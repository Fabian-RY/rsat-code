#!/usr/bin/perl -w
############################################################
#
# $Id: peak-quality,v 1.1 2012/07/02 18:07:04 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

peak-quality

=head1 VERSION

$program_version

=head1 DESCRIPTION

Evaluate the quality of a set of peaks by measuring its enrichment for
one or several reference motifs.


=head1 AUTHORS

Jacques.van-Helden@univ-amu.fr

=head1 CATEGORY

=over

=item NGS

=back

=head1 USAGE

peak-quality [-i inputfile] [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

The program requires three input files : 

=over

=item B<Peak coordinates>

A set of peaks coordinates sorted by decreasing score, in BED format.

=item B<Peak sequences>

A set of sequences for these peaks, in fasta format (must be in the
same order as the peak coordinates in the bed file).

=item B<Reference motifs>

A file containing one or several reference matrix (matrices), in
transfac format.

=back

=head1 OUTPUT FORMAT

Various statistics are computed on the peaks, and drawings are
generated to give an intuition of the data.


=head2 Score versus length

Peak score as a function of its length.

=head2 Peak score distribution

Histogram of peak score distribution. 

=head2 Peak score by rank

Decreasing curve of peak scores (score as a function of the rank).


=head1 SEE ALSO

=head1 WISH LIST

=over

=item B<convert-features>

Add option -from swembl to the command I<convert-features> in ordefr
to automatically produce a consistent bed file: score at the 5th
column and name at the 4th column. The name should be the same as the
one generated by I<fetch-sequences>.

=back

=cut

BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}
require "RSA.lib";
require "RSA.disco.lib";
require "footprint.lib.pl";
use RSAT::util;
use RSAT::MatrixReader;
use RSAT::SeqUtil;
use Data::Dumper;
use File::Basename;

################################################################
## Main package
package main;
{
  ## Check that the RSAT paths of the programs required for the script are specified
  $SCRIPTS = $ENV{RSAT}."/perl-scripts" unless ($SCRIPTS);

  ################################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.1 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  our %infile = ();
  our %outfile = ();
  our %dir = ();

  our $verbose = 0;
  our $in = STDIN;
  our $out = STDOUT;

  our @peaks = (); ## peak information
  our @peak_ids = ();
  our @peak_len = ();

  our %param = ();
  our @param_list = (); ## Parameters to print out in the report
  $param{nb_slices} = 5; push @param_list, "nb_slices"; ## Number of sequence slices
  $param{seq_per_slice} = 200; push @param_list, "seq_per_slice"; ## Number of sequences per slice
  $param{nb_peaks_from_bed} = 0; push @param_list, "nb_peaks_from_bed"; ## Number of peaks defined in the bed file
  $param{nb_peaks_from_seq} = 0; push @param_list, "nb_peaks_from_seq"; ## Number of peaks found in the sequence file
  $param{top_matrices} = 1; push @param_list, "top_matrices"; ## Number of top matrices taken in consideration in the reference matrix file
  $param{matrix_permutations} = 1; push @param_list, "matrix_permutations"; ## Number of matrix permutations for matrix-quality (negative control)
  $param{decimals} = 1; push @param_list, "decimals"; ## Number of decimals for matrix scanning

  my %task = ();
  $task{seq_len} = 1;
  $task{slices} = 1;
  $task{quality} = 1;

  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values

  ## Output directory
  if ($main::dir{output}) {
    &RSAT::util::CheckOutDir($main::dir{output}, "", 755);
  } else {
    &RSAT::error::FatalError("You must define the output directory (option -outdir)");
  }

  ## Prefix
  unless ($main::param{prefix}) {
    &RSAT::error::FatalError("You must define a prefix for the output files (option -prefix)");
  }

  ## Reference motif file
  unless ($main::infile{ref_motifs}) {
    &RSAT::error::FatalError("You must define a reference motif file (option -ref_motifs).");
  }

  ################################################################
  ## Define log file name
  $outfile{log} = &OutFileName("", ".txt", "log");

  ################################################################
  ## Open output stream
  $out = &OpenOutputFile($outfile{log});

  ################################################################
  ## Read bed coordinates
  &RSAT::message::TimeWarn("Reading bed file", $infile{bed});
  my $peak_nb = 0;
  my ($bed_handle) = &OpenInputFile($main::infile{bed});
  my $l = 0 ; ## Line counter
  my $bed_errors = 0;
  while (<$bed_handle>) {
    $l++; ## Increment line counter
    next if (/^#/); ## Skip header/comment rows
    next if (/^;/); ## Skip comment rows
    next unless (/\S/); ## Skip empty rows
    chomp();
    my ($chrom, $start, $end, $name, $score) = split(/\t/);

    ## Check score
    unless (&RSAT::util::IsReal($score)) {
      $bed_errors++;
      &RSAT::message::Warning("Line", $l, "skipped because of invalid score", $score);
      next;
    }

    ## Check coordinates
    unless (&RSAT::util::IsNatural($start)) {
      $bed_errors++;
      &RSAT::message::Warning("Line", $l, "skipped because of invalid start", $start);
      next;
    }
    unless (&RSAT::util::IsNatural($end)) {
      $bed_errors++;
      &RSAT::message::Warning("Line", $l, "skipped because of invalid end", $end);
      next;
    }

    my $len = $end - $start + 1;
    if ($len < 0) {
      $bed_errors++;
      &RSAT::message::Warning("Line", $l, "skipped because start (".$start.") smaller than end (".$end.")");
      next;
    }

    ## Check name
    unless ($name) {
      $name = join ("", $chrom, "_", $start, "_", $end, "+");
    }

    $peak_nb++; ## Increment feature counter

    $peaks[$peak_nb]->{chrom} = $chrom;
    $peaks[$peak_nb]->{start} = $start;
    $peaks[$peak_nb]->{end} = $end;
    $peaks[$peak_nb]->{name} = $name;
    $peaks[$peak_nb]->{score} = $score;
    $peaks[$peak_nb]->{len} = $len;
  }
  close $bed_handle;
  if ($main::verbose >= 1) {
    &RSAT::message::TimeWarn("Read ".$peak_nb." peaks");
    &RSAT::message::TimeWarn("Skipped ".$bed_errors." invalid rows.");
  }
  $main::param{nb_peaks_from_bed} = $peak_nb;

  ################################################################
  ## Sequence lengths
  &RSAT::message::TimeWarn("Computing sequence lengths");
  $outfile{seq_len} = &OutFileName("seq_stats", ".tab", "seq_len");
  if ($task{seq_len}) {
    my $cmd = $SCRIPTS."/sequence-lengths";
    $cmd .= " -i ".$infile{seq};
    $cmd .= " -o ".$outfile{seq_len};
    &one_command($cmd, 1);
  }

  ## Read sequence lengths and check that they are compatible with
  ## slice nb and size.
  ##
  ## We need to take this information from the sequence file rather
  ## than the peak file, because some peaks could correspond to no
  ## sequence (e.g. there are sometimes problem with peaks on the Mt
  ## chromosome).
  my ($len_handle) = &OpenInputFile($main::outfile{seq_len});
  while (<$len_handle>) {
    next if (/^;/); # Skip comment lines
    next if (/^#/); # Skip header line
    next unless (/\S/); # Skip empty lines
    chomp();
    my ($id, $len) = split ("\t");
    push @peak_ids, $id;
    push @peak_len, $len;
  }
  close ($len_handle);

  $param{nb_peaks_from_seq} = scalar(@peak_ids);
  if (scalar(@peak_ids) < $param{nb_slices} * $param{seq_per_slice}) {
    &RSAT::error::FatalError(join(" ",
				  "Number of peak sequences ($param{nb_peaks_from_seq}) is insuffient to extract",
				  $param{nb_slices}, "slices of",
				  $param{seq_per_slice}, "sequences."))
			   }

  ################################################################
  ## Prepare sequence slices
  $param{slice_spacing} = ($param{nb_peaks_from_seq} - $param{nb_slices}*$param{seq_per_slice}) / ($param{nb_slices}-1);
  push @param_list, "slice_spacing"; ## Number of sequences skipped between two successive slices
  foreach my $s (1..$param{nb_slices}) {
    my $first_seq = &RSAT::util::round(($s-1) * ($param{seq_per_slice} + $param{slice_spacing}))+1;
    my $last_seq = $first_seq + $param{seq_per_slice} -1;
    &RSAT::message::TimeWarn("Extracting slice",
			     $s."/".$param{nb_slices},
			     $first_seq." -> ".$last_seq,
			     $param{seq_per_slice}." sequences"
			    )
      if ($main::verbose >= 1);


    ## Compute slice statistics
    my %slice_stats = &RSAT::stats::summary(@peak_len[($first_seq-1)..($last_seq-1)]);
    $slice_stats[$s]->{s} = $s;
    $slice_stats[$s]->{L_n} = $slice_stats{n};
    $slice_stats[$s]->{L_sum} = $slice_stats{sum};
    $slice_stats[$s]->{L_mean} = sprintf("%.1f", $slice_stats{mean});
    $slice_stats[$s]->{L_med} = $slice_stats{median};
    $slice_stats[$s]->{L_sd} = sprintf("%.1f", $slice_stats{sd});
    $slice_stats[$s]->{L_min} = $slice_stats{min};
    $slice_stats[$s]->{L_max} = $slice_stats{max};
    $slice_stats[$s]->{first} = $first_seq;
    $slice_stats[$s]->{last} = $last_seq;
    $slice_stats[$s]->{seq_nb} = $last_seq - $first_seq + 1;
    $slice_stats[$s]->{id} = "slice".$s."_".$first_seq."-".$last_seq;

    ## Extract sequence slices from the input sequence file
    $outfile{"seq_slice_".$s} = &OutFileName("sequences", ".fasta", $slice_stats[$s]->{id}, "seq");
    if ($task{slices}) {
      my $skip_seq = $first_seq -1;
      my $cmd = $SCRIPTS."/convert-seq";
      $cmd .= " -i ".$infile{seq};
      $cmd .= " -from fasta -to fasta";
      $cmd .= " -dna";
      $cmd .= " -mask non-dna";
      $cmd .= " -skip ".$skip_seq;
      $cmd .= " -top ".$last_seq;
      $cmd .= " -o ".$outfile{"seq_slice_".$s};
      &one_command($cmd, 1);
    }

    if ($task{seq_len}) {
      ## Compute seq length distribution for each slice
      $outfile{"seq_len_distrib_slice_".$s} = &OutFileName("seq_stats", ".tab", "seq_len_distrib_slice_".$s);
      $cmd = $SCRIPTS."/sequence-lengths";
      $cmd .= " -i ".$outfile{"seq_slice_".$s};
      $cmd .= " | classfreq -v -ci 100";
      $cmd .= " -o ".$outfile{"seq_len_distrib_slice_".$s};
      &one_command($cmd, 1);
    }
  }


  ## Print out slice stats
  my @slice_stat_fields = qw(s
			     id
			     first
			     last
			     seq_nb
			     L_n
			     L_min
			     L_max
			     L_sum
			     L_mean
			     L_med
			     L_sd
			    );

  my %stat_descr = ();
  $stat_descr{s} = "Slice number";
  $stat_descr{id} = "Slice identifier";
  $stat_descr{first} = "Index of first sequence in the slice";
  $stat_descr{last} = "Index of last sequence in the slice";
  $stat_descr{seq_nb} = "Number of sequences in the slice";
  $stat_descr{L_n} = "Number of sequences in the slice";
  $stat_descr{L_min} = "Min sequence length in the slice";
  $stat_descr{L_max} = "Max sequence length in the slice";
  $stat_descr{L_sum} = "Sum of sequence lengths in the slice";
  $stat_descr{L_mean} = "Mean sequence length in the slice";
  $stat_descr{L_med} = "Median sequence length in the slice";
  $stat_descr{L_sd} = "Standard deviation of sequence length in the slice";
  $outfile{slice_stats} = &OutFileName("seq_stats", ".tab", "slice_statistics");
  my $slice_stat_hdl = &OpenOutputFile($main::outfile{slice_stats});
  my $s = 0;
  foreach my $stat (@slice_stat_fields) {
    $s++;
    print $slice_stat_hdl join ("\t", ";", $s, $stat, $stat_descr{$stat}), "\n";
  }
  print $slice_stat_hdl "#", join ("\t",  @slice_stat_fields), "\n";
  foreach my $s (1..$param{nb_slices}) {
    my @stats = ();
    foreach my $stat (@slice_stat_fields) {
      push @stats, $slice_stats[$s]->{$stat};
    }
    print $slice_stat_hdl join ("\t", @stats), "\n";
  }
  close $slice_stat_hdl;


  ################################################################
  ## Use matrix-quality to compute motif enrichment in the different
  ## slices
  if ($task{quality}) {
    &RSAT::message::TimeWarn("Running matrix-quality") if ($main::verbose >= 1);
    $outfile{"quality"} = &OutFileName("quality", ".fasta", "");

    my $cmd = $SCRIPTS."/matrix-quality";
    $cmd .= " -v ".$main::verbose;
    $cmd .= " -m ".$main::infile{ref_motifs};
    $cmd .= " -matrix_format transfac";
    $cmd .= " -top ".$param{top_matrices};
    $cmd .= " -seq all_peaks ".$infile{seq};
    $cmd .= " -perm all_peaks ".$param{matrix_permutations};
    $cmd .= " -decimals ".$param{decimals};
    foreach my $s (1..$param{nb_slices}) {
      $cmd .= " -seq ".$slice_stats[$s]->{id}." ".$outfile{"seq_slice_".$slice_stats[$s]->{s}};
    }
    &one_command($cmd, 1);
  }

  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose >= 1);

  ################################################################
  ## Report execution time and close output stream
  my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
  print $out $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified
  close $out if ($outfile{output});

  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }


=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();


=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();


=pod

=item B<-bed peak_coordinate_file>

Peak coordinates and score provided in bed format.
Each row corresponds to one peak.
Columns must be provided in the following order:
1. Chromosome
2. Start
3. End
4. Name
5. Score

=head2 Important remarks

=over

=item I<Name>: peak names of the bed files should be consistent with
those of the fasta file.

=item The score column is required, since it is used for computing
various statistics.

=item SWEMBL files must be converted in order to get the name and
score at the right position.

=back

=cut
    } elsif ($arg eq "-bed") {
      $main::infile{bed} = shift(@arguments);

=pod

=item B<-seq peak_sequence_file>

Name of the file containing the peak sequences (must be in fasta
format).

=head2 Important remarks

=over

=item Peak names of the sequence files should be consistent with
those of the bed file.

=item Sequences should be sorted in the same order as the bed file.

=back

=cut
    } elsif ($arg eq "-seq") {
      $main::infile{seq} = shift(@arguments);

=pod

=item B<-ref_motifs reference_motif>

Reference motifs (mandatory).

A file containing one or several reference motif(s)
(i.e. position-specific scoring matrices) for the peak sequences,
i.e. the motifs for which the enrichment will be assessed in the
different peak slices.

Must be in TRANSFAC format (use I<convert-matrix> to obtain
transfac-formatted matrices).

=cut
    } elsif ($arg eq "-ref_motifs") {
      $main::infile{ref_motifs} = shift(@arguments);

=pod

=item	B<-o output_directory>

Output directory. All result files will be stored in this directory.

=cut
    } elsif ($arg eq "-o") {
      $dir{output} = shift(@arguments);

=pod

=item	B<-prefix output_prefix>

Prefix for the output files.

=cut
    } elsif ($arg eq "-prefix") {
      $main::param{prefix} = shift(@arguments);


=pod

=item B<-slices nb_slices>

Number of "slices", i.e. subsets of the sorted peaks submitted to
enrichment analysis.

Default: 5

=cut
    } elsif ($arg eq "-slices") {
      $main::param{slices} = shift(@arguments);
      &RSAT::error::FatalError($main::param{slices}, "Invalid number of slices, must be a strictly positive Natural number")
	unless (&RSAT::util::IsNatural($main::param{slices}));

    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }

=pod

=back

=cut
  }

}

################################################################
## Verbose message
sub Verbose {
  print $out "; peak-quality ";
  &PrintArguments($out);
  printf $out "; %-22s\t%s\n", "Program version", $program_version;
  if (%main::infile) {
    print $out "; Input files\n";
    foreach my $key (sort keys (%main::infile)) {
      my $value = $main::infile{$key};
#    while (my ($key,$value) = each %main::infile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }
  if (%main::outfile) {
    print $out "; Output files\n";
    foreach my $key (sort keys (%main::outfile)) {
      my $value = $main::outfile{$key};
#    while (my ($key,$value) = each %main::outfile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }
  if (%main::dir) {
    print $out "; Directories\n";
    foreach my $key (sort keys (%main::dir)) {
      my $value = $main::dir{$key};
#    while (my ($key,$value) = each %main::dir) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  ## Parameter values
  print $out "; Parameter values\n";
  foreach my $param_name (@param_list) {
    print $out sprintf ";\t%-22s\t%s\n", $param_name, $param{$param_name};
  }
}


__END__
