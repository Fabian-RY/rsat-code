#!/usr/bin/perl -w
############################################################
#
# $Id: convert-background-model,v 1.10 2007/07/27 23:47:22 jvanheld Exp $
#
# Time-stamp: <2007-07-06 17:41:48 jturatsi>
#
############################################################

## use strict;

=pod

=head1 NAME

convert-backgound-model

=head1 DESCRIPTION

Interconversions between formats of background models supported by
different programs (oligo-analysis, matrix-scan, patser, consensus,
MotifLocator, MotifSampler, MEME, ...).

This is a temporary version, with only some formats supported. Additional
formats will be progressively added.

=head1 AUTHORS

=item Jacques van Helden jvanheld@scmbb.ulb.ac.be

=item Jean Valery Turatsinze jturatsi@scmbb.ulb.ac.be

=item Morgane Thomas-Chollier <morgane@scmbb.ulb.ac.be>

=head1 CATEGORY

util

=head1 USAGE

convert-backgound-model [-i inputfile] [-o outputfile] [-v]

=head1 BACKGROUND MODEL FORMATS

B<Note>: some formats are supported for both input and outpu, but some
formats are supported only for input or for output.


=over

=head2 oligos (input/output)

Oligonucleotide frequency table, as exported by the RSAT program
I<oligo-analysis>. The simplest format is a two-column file with the
oligonucleotide in the first column, and the frequency in the second
one.

An oligo file containing k-mers frequencies corresponds to a Markov
model of order I<m=k-1>. Frequencies are converted to transition
probabilities by calculating the relative frequencies of all oligomers
of size k having the same prefix (first m letters).

=head2 MotifSampler (input/output)

This format can be used by the various programs of the software suite
INCLUSive developed by Gert Thijs
(http://homes.esat.kuleuven.be/~thijs/download.html).

MotifSampler background files can be generated with the program
I<CreateBackgroundModel>, which creates a Markov model from a
background sequence.

=head2 MEME (input)

MEME (http://meme.sdsc.edu/meme/) is a matrix-based pattern discovery
program developed by Tim Bailey, and supporting Marckov chain
background models. 

MEME background files can be generated with the program
I<fasta-get-markov>, which creates a Markov model from a background
sequence.

=head2 patser (output)

Export the Markov model in patser format. I<patser> isa pattern
matching program developed by Jerry Hertz.

WARNING: patser only supports Bernoulli models ! If the Markov order is
superior to 0, this function issues a fatal error.


=back

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
use RSAT::MarkovModel;



################################################################
## Main package

package main;
{

    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();
    local $bg_model = new RSAT::MarkovModel();
    local $decimals = 5;
    local $bg_pseudo = 0;
    
    $input_format = "oligo-analysis";
    %supported_input_format = $bg_model->get_supported_input_formats();
    $supported_input_formats = join (",", keys %supported_input_format);


    $output_format = "tab";
    %supported_output_format = $bg_model->get_supported_output_formats();
    $supported_output_formats = join (",", keys %supported_output_format);
    

    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
#    $main::in = STDIN;
    $main::out = STDOUT;

    &ReadArguments();

    ################################################################
    #### check argument values
    unless ($input_format) {
	&RSAT::error::FatalError("You should define the input format");
    }

    unless ($output_format) {
	&RSAT::error::FatalError("You should define the output format");
    }

    $bg_model->set_attribute("bg_pseudo" => $bg_pseudo);


    ################################################################
    ### open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ##### Read input
    $bg_model->load_from_file($main::infile{input}, $input_format);
    
    ################################################################
    #### print verbose
    &Verbose() if ($main::verbose);
    
    ################################################################
    ###### print output
    print $out $bg_model->to_string($output_format, decimals=>$decimals);
    
    
    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ###### close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
#    foreach my $a (0..$#ARGV) {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();
	    

	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ## Input format
=pod

=item B<-from input_format>

Input format. Supported: oligo-analysis, MotifSampler, meme.

=cut
	} elsif ($arg eq "-from") {
	    $main::input_format = lc(shift(@arguments));
	    &RSAT::error::FatalError(join("\t", $main::input_format,
					  "Invalid input format.",
					  "Supported: ", $main::supported_input_formats))
		unless ($main::supported_input_format{$main::input_format});


	    ## Output format
=pod

=item B<-to output_format>

Output format. Supported: tab (default), patser, MotifSampler.

=cut
	} elsif ($arg eq "-to") {
	    $main::output_format = lc(shift(@arguments));
	    &RSAT::error::FatalError(join("\t", $main::output_format,
					  "Invalid output format.",
					  "Supported: ", $main::supported_output_formats))
		unless ($main::supported_output_format{$main::output_format});

	    ## Number of decimals
=pod

=item B<-bg_pseudo #>

Pseudo frequency for the background models. Value must be a real between 0 and 1 (default: 0.01)
If the training sequence length (L) is known, the value can be set to
square-root of L divided by L+squareroot of L

=cut
	} elsif ($arg eq "-bg_pseudo") {
	    $main::bg_pseudo = shift(@arguments);
	    &RSAT::error::FatalError(join("\t", $main::bg_pseudo,
					  "Invalid value for bg_pseudo, should be a Real number between 0 and 1."))
		unless ((&IsReal($main::bg_pseudo)) && (0 <= $main::bg_pseudo) && ($main::bg_pseudo <= 1));

	    ## Number of decimals
=pod

=item B<-decimals #>

Number of decimals to print or the transition probabilities. 

=cut
	    
	} elsif ($arg eq "-decimals") {
	    $main::decimals = shift(@arguments);
	    &RSAT::error::FatalError(join("\t", $main::decimals,
					  "Invalid format for decimals, should be a Natural number."))
		unless (&IsNatural($main::decimals));

	    
	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; convert-backgound-model ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
      }
    print $main::out "; Markov order\t", $bg_model->get_attribute("order"), "\n";
}


__END__

=pod

=head1 SEE ALSO

=over

=item B<seq-proba>

Calculate the probability of a sequence fiven a background model. 

=item B<matrix-scan>

Scan sequences with a PSSM, accepting various background models. 

=item B<patser>

Scan sequences with a PSSM. Program developed by Jerry Hertz.

=back

=cut
