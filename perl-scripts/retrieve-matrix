#!/usr/bin/perl

############################################################
#
# $Id: retrieve-matrix,v 1.0 2017/10/19 14:27:53 thnguyen $
#
# Time-stamp: <2003-08-05 10:24:33 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.seq.lib";

## Initialize parameters
local $start_time = &RSAT::util::StartScript();

my $outputfile = "";
my $collection_file = "";
my $id = "";
my $id_file = "";

&ReadArguments();

my @ids;
if($id ne ""){
    @ids = split(",", $id);
}elsif($id_file ne ""){
    open(my $fh, "<", $id_file) or die "Cannot open file $!";
    while(my $row = <$fh>){
        chomp $row;
        push @ids, $row;
    }
}

################################################################################
############################### check parameters ###############################
################################################################################

&RSAT::message::TimeWarn("Checking parameters") if ($main::verbose >= 2);

open(my $fh, "<", $collection_file) or die "Cannot open file $!";
my $result_matrix = "";
while(my $row = <$fh>){
    chomp $row;
    if($row =~ /^AC\s+/){
        @f = split(/\s+/, $row);
        if($f[1] ~~ @ids){
            $isprint = 1;
            $result_matrix .= $row . "\n";
        }else{
            $isprint = 0;
        }
    }elsif($isprint == 1) {
        $result_matrix .= $row . "\n";
    }
}

if($outputfile ne ""){
    open(my $fh, ">", $outputfile);
    print $fh $result_matrix;
}else{
    print $result_matrix;
}
exit(0);

################################################################
#### subroutine definitions
################################################################

################################################################
#### detailed help message
sub PrintHelp {
open(HELP, "| more");
print HELP<<End_help;
USAGE
retrieve-matrix -i collection file -id identifier(s) | -id_list identifiers file [-o outpufile]

DESCRIPTION
Returns matrix

CATEGORY
genomics
sequences

OPTIONS
-org organism
When an organism is specified, the program automatically
loads the appropriate genome sequence and feature table.

If this option is not used, the option -seq must be used
instead.

(type supported-organism to obtain the list of supported
organisms)

-seq	input sequence file
(alternative to organism)

Specify the input sequence file. See INPUT FORMAT
below.
-informat	input sequence format
-prefix
prefix for sequence identifier
-feattype
Feature type.
Supported: $supported_feature_types
-type	sequence type
Currently supported sequence types
upstream (default)
downstream
orf (warning: introns are not spliced out)
random (random fragments)
To implement in the future
introns
coding

The sub-option
-type random
requires to use the -n for specifying the number of sequences.
-n number of sequecnes (only with -type random)
-q query
The query should be an orf identifier (eg 'metR').
The query is case-insensitive.
Multiple queries can be entered by reiteratively using the -q
option.
-i     query file. The first word of each line is taken as a query.
This option is incompatible with -q.

-ids_only
Use this option if the queries are provided as a list
of IDs. This avoids to load the table of synonyms, in
order tos ave time.
-all	return all genomic upstream regions

-o	name of the output file

-oft	output features file
in addition to the sequences, export a feature file with the
chromosomal location of the retrieved sequences.

-from #1 -to #2
where #1 and #2 are numbers. #2 should be higher than #1.
limits of the region to extract, relative to orf start
(=position 0). Use negative values for upstream sequence.
example: -from -800 -to -1
will extract the 800 bp upstream the orf start.
(this is the default)

-format	allows to select different output formats, with the following
options:
IG	IntelliGenetics (default format)
WC	wconsensus format
raw	only the sequence is returned, without spaces, newlines
nor comments.
FastA

-lw ##	Line width. A newline character will be inserted in the
sequence every ## bases. Default is 60.
-lw 0 will prevent newline insertion.

-label label_fields
Field(s) to be used in the sequence label.
Default: name.
Supported: $supported_label_fields

Multiple fields can be specified, separated by commas
in the command line.

Example:
-label org,name,id

In this case, the sequence identifier will contain all
of these fields, separated by the separator specified
with the option -labelsep.

-labelsep
Separator between label fields. Default: $label_sep

-noorf	prevent overlap with neighbout genes.

When this option is active, the sequence size is
adapted to avoid including coding sequences of the
neighbour genes.

The reason for preventing overlap with upstream genes
is that (at least for microbial organisms, and in
large part for higher eukaryotes) most cis-acting
elements are located in the non-coding regions. Thus,
if the neighbour gene is closer than the selected
limit for collecting upstream sequences, the part of
coding sequences included it the result is likely to
add up to the noise, without bringing any additional
signal.

More importantly, coding and non-coding sequences
generally have very different background models. The
inclusion of coding sequences from neighbour genes may
thus lead to biases in motif discovery.

The weaknesses of using this option are that, in some
cases, predicted orf do not correspond to real genes,
This was particularly frequent in the early versions
of the yeast genome, but the annotations have been
improved since then.

For bacterial sequences, it is essential to prevent
overlap with upstream genes, because intergenic
distances are often very short, especially between
pairs of genes comprised in the same operon.


-rm     Use the repeat masked version of the genome.  Attention :
repeated regions are annotated for some genomes only.

-nocom	no comments. Only the identifier and the sequence are
returned. By default, the comment indicates the ORF and
upstream sequence coordinates.

-imp_pos
Admit imprecise positions.
In the annotation of some genomes, the limits of some genes
are imprecisely specified (e.g. <555245, >898098). By default,
these genes are not loaded. The option -imp_pos allows to
retrieve sequence for these genes as well, using the imprecise
coordinate as reference position.

-nowarn
Prevents warning when a gene cannot be identified.

-randsels #
Select a random set of # genes in the genome annotations.
This option ois obsolete, it has been replaced by a
separate command: random-genes. The option is
maintained for backward compatibility.

-lf	length file
(only with the option '-type random')
Allows to generate random sequences with the same
lengths as a set of reference sequences. The sequence
length file can be obtained with the command
sequence-lengths
The length file contains two columns :
- sequence ID (ignored)
- sequence length

-features
alternate feature table. This option allows to speify
an alternate file where the ORF locations are found.
See below for a description of the feature file format.

INPUT FORMATS
Input sequence file
Sequence file is of type filelist, i.e. this file
contains a list of other file names, each of which
contains a raw contig sequence (usually a whole
chromosome). The raw sequence files cannot contain any
space or carriage return : the character position in
the file must correspond to the nucleotide position on
the contig.

Feature file
The feature file contains one line per feature, with
tab-delimited columns providing the following information:
column	field   description
1	id	feature identifier
2	type	feature type (Supported: ${supported_feature_types})
3	name	feature name
4	ctg	chomosome.or contig
5	left	left end position
6	right	right end position
7	strand	D (direct) or R (reverse)
8	descr	short description (optional)

EXAMPLES
retrieve-seq -type upstream -org Escherichia_coli_K12 \\
-q metJ -q meta -q metb		      \\
-from +59 -to -200 -noorf

will return the sequence of 260 nucleotides, 200of which
extracted upstream the start codon, and the 60 following being
the beginning of the coding sequence.

End_help
close HELP;
exit;
}

################################################################
#### list of options
sub PrintShortHelp {
open(HELP, "| more");
print HELP<<End_short_help;
retrieve-matrix options
--------------------
-i		collection file path
-id		matrix identifier(s), can be a list of identifiers separated with commas
-id_file    matrix identifier(s) file which contains a list of identifiers (one per line)
-o		outputfile.
End_short_help
close HELP;
exit;
}

################################################################
## Read arguments
sub ReadArguments {
    foreach $a (0..$#ARGV) {
        ### output file name
        if ($ARGV[$a] eq "-o") {
            $outputfile = $ARGV[$a+1];
            
            ### input collection file
        } elsif ($ARGV[$a] eq "-i") {
            $collection_file = $ARGV[$a+1];
            
            ### help request
        } elsif ($ARGV[$a] eq "-h") {
            &PrintHelp;
        } elsif ($ARGV[$a] eq "-help") {
            &PrintShortHelp;
            
            ### input identifiers
        } elsif ($ARGV[$a] eq "-id") {
            $id = $ARGV[$a+1];
            
            ### input identifiers file
        } elsif ($ARGV[$a] eq "-id_file") {
            $id_file = $ARGV[$a+1];
            
            ### verbose
        } elsif ($ARGV[$a] eq "-v") {
            if (&IsNatural($ARGV[$a+1])) {
                $verbose = $ARGV[$a+1];
            } else {
                $verbose = 1;
            }
        }
    }
}


################################################################
#### verbose ####
sub Verbose {
    print $out "; retrieve-matrix";
    &PrintArguments($out);
    printf $out "; %-14s\t%s\n", "organism", $organism_name;
    printf $out "; %-14s\t%s\n", "sequence type", $sequence_type;
    printf $out "; %-14s\t%s\n", "feature type", join ",", $organism->get_attribute("feature_types");
    if ($input_sequence_file) {
        printf $out "; %-14s\t%s\n", "input sequence file", $input_sequence_file;
        printf $out "; %-14s\t%s\n", "input sequence format", $input_sequence_format;
    }
    printf $out "; %-14s\t%s\n", "feature table file", $annotation_table if ($annotation_table);
    printf $out "; %-14s\t%s\n", "Output format", $out_format;
    printf $out "; %-14s\t%s\n", "Line width", $line_width;
    printf $out "; %-14s\t%d\n", "Random selection", $random_orfs if ($random_orfs);
    print $out "; clipping to avoid overlap with neighbour ORFs\n" if ($noorf);
    print $out "; relative coordinates\n";
    print $out ";        from    $from\n";
    print $out ";        to      $to\n";
    print $out ";        size    ", abs($to - $from + 1), "\n";
    if (defined($query_file)) {
        printf $out "; %-14s\t%s\n", "Query file", $query_file;
    } else {
        printf $out "; %-14s\t%d\n", "Queries", scalar(@queries);
        unless ($return_all) {
            foreach $q (@queries) {
                print $out ";	$q\n";
            }
        }
    }
    print $out ";\n";
}
