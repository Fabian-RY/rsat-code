#!/usr/bin/perl 

=pod

=head1 NAME

roc-stats

=head1 DESCRIPTION

From a comparison (Predictions vs Annotations, or Query vs Reference), this
program calculates statistical parameters using different score thresholds.
The calculated False Positive Rate (X) and Sensitivity (Y) can be used in
order to make ROC curves.

=head1 AUTHOR

Rekin's Janky <rekins@scmbb.ulb.ac.be>

=head1 CATEGORY

evaluation statistics

=head1 USAGE

roc-stats -v 1 --input <file> [options]

=cut

#### Librairies
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
use Getopt::Long qw(:config bundling);
use Pod::Text;
require "RSA.lib";

 
# use OPTOOLS::util;
# use OPTOOLS::Valid;

#### package variables
$verbose = 0;

#### lexical variables
my $options ="";
my $help="";
my $input="";
my $output="";
my %col=(id=>3, # column with id
	 status=>5, # column with status
	 score=>0); # column with score
my %status=();
my %ci=();
my $score_format="score";
my %thr=();
my $param2return="TP,FP,FN,Sn,PPV,FPR,Acc,QnotR,notQR";
my $roc3D="";
my $nodie=0;

#### options
my %opt = ('opt|?'=>\$options,
	   'h|help'=>\$help,
	   'v|verbose=i'=> \$verbose,
	   'i|input=s'=> \$input,
	   'o|output=s'=> \$output,
	   'col=i%'=>\%col,
	   'status=s%'=> \%status,
	   'score_format=s'=> \%score_format,
	   't|threshold=s%'=> \%thr,
	   'ci=i%'=> \%ci,
	   'r|return=s'=>\$param2return,
	   '3D'=>\$roc3D,
	   'nodie'=>\$nodie
	   );
&GetOptions(%opt);

################################################################
## display help menu

&PrintHelp if ($help);
&PrintHelp if ($options);

################################################################
## Check all parameters

# Check status 
my %supported_status=("TP"=>"TP",
		      "FP"=>"FP",
		      "FN"=>"FN",
		      "TN"=>"TN"
		      );
foreach my $st (keys %status){
    &RSAT::message::Warning(join(" ","status",$st,"=>",$status{$st})) if ($main::verbose >= 0) ;
    next if ($supported_status{$status{$st}});
    &RSAT::message::Warning(join(" ","This status",$status{$st}," is not supported. Supported status :",join(",",keys %supported_status))) if ($main::verbose >= 0) ;; 
    die;
}
%supported_status=(%supported_status,%status);

# check class interval on scores
my %supported_scores=(score=>1, # class interval on all score
		      Q=>1, # class interval on Q score
		      R=>1, # class interval on R score
		  );
if (scalar (keys %ci) >=0){
    foreach my $c (keys %ci){
	&RSAT::message::Warning(join(" ","class interval",$c,"=>",$ci{$c})) if ($main::verbose >= 0) ;;
	next if ($supported_scores{$c});
	&RSAT::message::Warning(join(" ","This class interval",$c," is not supported. Supported class intervals :",join(",",keys %supported_scores))) if ($main::verbose >= 0) ; 
	die;
    }
}
# check threshold on scores
if(scalar (keys %thr) >=0){
    foreach my $t (keys %thr){
	&RSAT::message::Warning(join(" ","score threshold",$t,"=>",$thr{$t})) if ($main::verbose >= 0);
	next if ($supported_scores{$t});
	&RSAT::message::Warning(join(" ","This score threshold",$t," is not supported. Supported score thresholds :",join(",",keys %supported_scores))) if ($main::verbose >= 0) ; 
	die;
    }
} 

# check score format
my %supported_score_format=("score"=>1,
			    "Q::R"=>1,
#			    "Qscore"=>1,
#			    "Rscore"=>1
			    );
$score_format="Q::R" if ($roc3D);
unless ($supported_score_format{$score_format}){
    &RSAT::message::Warning(join(" ","This score format",$score_format," is not supported. Supported format :",join(",",keys %supported_score_format))) if ($main::verbose >= 0) ;; ; 
    die;    
}

# check statistical parameters to return
my %supported_param=(
		"TP"=>"True Positive",
		"TN"=>"True Negative",
		"FP"=>"False Positive",
		"FN"=>"False Negative",
		"Sn"=>"TP/TP+FN",
		"Sp"=>"TN/TN+FP",
		"PPV"=>"TP/TP+FP",
		"NPV"=>"TN/TN+FN",
		"FPR"=>"FP/TP+FP",
		"Acc"=>"sqrt(Sn*PPV)",
		"QnotR"=>"QnotR",
		"notQR"=>"RnotQ"
		);
my %param2return=();
foreach my $p (split /,/,$param2return){
    if ($supported_param{$p}){
	$param2return{$p}=1;
    } else {
	&RSAT::message::Warning(join(" ","This output parameter",$p," is not supported. Supported parameters :",join(",",keys %supported_param))); 
	die;
    }
}

################################################################
#                                                              #
#                         MAIN                                 #
#                                                              #
################################################################


#### Calculate comparative parameters (Sn, PPV , Sp, NPV, Accuracy)
my ($id2score)=&getId2score($input,\%col,$score_format,$nodie);

if  ($score_format eq "Q::R"){ # use two scores (ROC 3D)
    &getConfusionTableByAllScores($id2score,\%ci,\%thr,\%param2return,$output);
}else{ 
    #&getConfusionTable($id2score);
    &getConfusionTableByScore($id2score,'scores',$ci{scores},\%thr,\%param2return,$output);
}

&RSAT::message::Warning("Job done.") if ($main::verbose >= 0);
exit(0);

################################################################
#                                                              #
#                      SUBROUTINES                             #
#                                                              #
################################################################

################################################################
#### Read Input file and get a hash of status and score by id
################################################################

=pod
    
=head1 INPUT FORMAT
    
=item The format must be a tab-delimited file with one column for the
    id, one column for the status and one column for the score (optional).

=over

=item B<id>
    
    Each item from this column must be unique. 
    This can specify a link between two nodes (in the case of comparison of Query and Reference graphs).
    Or an element from the prediction and/or the annotation set.

=item B<status>
    
    This column define the status of item. 
    By default, the status can be :

=over

=item I<TP> for True Positive  

=item I<FP> for False Positive  

=item I<TN> for True Negative  

=item I<FN> for False Negative 

=back

=item B<score> (optional) 

Use --col score <column> in order to specify a score column.  This column will
contain scores (or weight) and "NA" when ther is no value.  If used with 
option --3D, two scores can be defined in the same field separated by a :: (score_format Q::R)
like Qscore::Rscore for Q.and.R element or Qscore::NA for Q.not.R element.

=back

=cut
    
sub getId2score{
  my ($file,$col, $score_format,$nodie) = @_;
  my @lines = &readfile("$file");
  my %id_score=();
  my %col=%{$col};
  # careful of unvalid columns
  my @fields = split (/\t/,$lines[0]);
  my $nb_fields=scalar(@fields);
  if (($col{id} > $nb_fields)||($col{score} > $nb_fields)||($col{status} > $nb_fields)){
      &RSAT::message::Warning(join(" ","Warning ! one column is improperly specified. Input file have only",scalar(@fields),"columns."));
      &RSAT::message::Warning("\n\t",
			      $col{id},"\t", "id column","\n\t",
			      $col{status},"\t", "status column","\n\t",
			      $col{score},"\t", "score column","\n",
			      );
      die;
  }
  
  foreach my $line (@lines){
      &RSAT::message::Warning("line : ",$line) if ($main::verbose >= 10);
      my @fields = split(/\t/,$line);

      # Careful of doublons
      my $id=$fields[$col{id}-1];
      if ($id_score{$id}){
	  &RSAT::message::Warning(join(" ","Warning ! This id", $id," is a doublon"))if ($main::verbose >= 0);;
	  die ;#unless ($nodie);
      }

      # get status
      if($col{status} != 0){
	  my $status = $fields[$col{status}-1];
	  if (!$supported_status{$status}){
	      &RSAT::message::Warning(join(" ","Warning ! This status",$status," is not supported. Supported status :",join(",",keys %supported_status))) if ($main::verbose >= 10);
	      die unless ($nodie);	      
	  }else {
	      $id_score{$id}->{status} = $supported_status{$status};
	  }
      }

      # associate the score to the id field
      if  ($col{score} != 0){
	  my $score = $fields[$col{score}-1];

	  if($score_format eq "score"){
	      $id_score{$id}->{score} = $score;

	  }elsif($score_format eq "Q::R"){ # check if two scores

	      # TEMPORARY IN COMMENT (TO UPDATE WITH COMPARE GRAPH UPDATE)
	      # REMOVE FOLLOWING PARAMS
# 	      my ($Qscore, $Rscore)= split /::/,$score;
# 	      $id_score{$id}->{Qscore} = $Qscore;
# 	      $id_score{$id}->{Rscore} = $Rscore;
# 	      &OPTOOLS::util::Warning(10,join("\t",
# 					      "id",$id,
# 					      "Qscore",$id_score{$id}->{Qscore},
# 					      "Rscore",$id_score{$id}->{Rscore},
# 					      "status",$id_score{$id}->{status})); 

	      if($id_score{$id}->{status} eq "TP"){ # Q.and.R
		  my ($Qscore, $Rscore)= split /::/,$score;
		  $id_score{$id}->{Qscore} = $Qscore;
		  $id_score{$id}->{Rscore} = $Rscore;
		  &RSAT::message::Warning(join("\t",
						 "id",$id,
						 "Qscore",$id_score{$id}->{Qscore},
						 "Rscore",$id_score{$id}->{Rscore},
						 "status",$id_score{$id}->{status})) if ($main::verbose >= 10); 
	      }elsif($id_score{$id}->{status} eq "FP"){ # Q.not.R
		  $id_score{$id}->{Qscore} = $score;
		  $id_score{$id}->{Rscore} = "NA";
		  &RSAT::message::Warning(join("\t",
						 "id",$id,
						 "Qscore",$id_score{$id}->{Qscore},
						 "status",$id_score{$id}->{status})) if ($main::verbose >= 10); 
	      }elsif($id_score{$id}->{status} eq "FN"){ # not.Q.R
		  $id_score{$id}->{Qscore} = "NA";
		  $id_score{$id}->{Rscore} = $score;
		  &RSAT::message::Warning(join("\t",
						 "id",$id,
						 "Rscore",$id_score{$id}->{Rscore},
						 "status",$id_score{$id}->{status})) if ($main::verbose >= 10); 
	      }
#	  }else{
#	      $id_score{$id}->{score} = $score;
	  }
      }
      
      &RSAT::message::Warning(join("\t","id",$id,"score",$id_score{$id}->{score},"status",$id_score{$id}->{status})) if ($main::verbose >= 10); 
  }
  return(\%id_score);
}

################################################################
#### Calculate and export results
################################################################

=pod

=head1 OUTPUT FORMAT

The output is a tab-delimited file.


=item B<Scores>

I<score> Column corresponding to a score threshold (if scores is specified in
the input file), and following columns correspond to calculated statistical
parameters (see below).

=item if option B<--3D> selected :

=over

I<Qscore> Threshold on the Q scores (Query)

I<Rscore> Threshold on the R scores (Reference)

I<QnotR> Number of elements which are in the Query set but not in the Reference set.

I<notQR> Number of elements which are in the Reference set but not in the Query set.

=back

=cut

#     &getConfusionTableByAllScores($id2score,\%ci,\%thr,\%param2return,$output);
# }else{ 
#     #&getConfusionTable($id2score);
#     &getConfusionTableByScore($id2score,'scores',$ci{scores},\%thr,\%param2return,$output);

################################################################
#### Calc stats by Qscore and Rscore
################################################################
sub getConfusionTableByAllScores{
    my ($id2score)=shift;
    my ($ci)=shift;
    my ($thr)=shift;
    my ($return_params)=shift;
    my $output=shift;

    my %id2score=%{$id2score};
    my %ci = %{$ci};
    my %thr= %{$thr};
    my %return_params=%{$return_params};

    my $Rscores = &getScores($id2score,"Rscore",$ci{R});
    my @Rscores = sort {$a<=>$b} keys %{$Rscores};
    &RSAT::message::Warning("Rscore min: ", $Rscores[0]) if ($main::verbose >= 0);
    &RSAT::message::Warning("Rscore max: ", $Rscores[$#Rscores])  if ($main::verbose >= 0);
    my $export =1;
    my @datas =();

    my $header = join("\t","#Rscore","Qscore");
    $header .="\tTP" if ($return_params{TP});
    $header .="\tFP" if ($return_params{FP});
    $header .="\tTN" if ($return_params{TN});
    $header .="\tFN" if ($return_params{FN});
    $header .="\tSn" if ($return_params{Sn});
    $header .="\tSp" if ($return_params{Sp});
    $header .="\tPPV" if ($return_params{PPV});
    $header .="\tNPV" if ($return_params{NPV});
    $header .="\tFPR" if ($return_params{FPR});
    $header .="\tAcc" if ($return_params{Acc});
    $header .="\tACP" if ($return_params{ACP});
    $header .="\tQnotR" if ($return_params{QnotR});
    $header .="\tnotQR" if ($return_params{notQR});

    if ($thr{R}){
	@Rscores =($thr{R});
    }

    foreach my $Rscore (@Rscores){
	&RSAT::message::Warning("Rscore threshold: ", $Rscore)  if ($main::verbose >= 0);;
	my ($Qscores,
	    $true_positives,
	    $false_positives,
	    $true_negatives,
	    $false_negatives,
	    $sensitivity,
	    $specificity,
	    $ppv,
	    $npv,
	    $fpr,
	    $accuracy_1,
	    $accuracy_2,
	    $accuracy_3,
	    $ACP,
	    $Query_not_Ref,
	    $NnotQR	    ) = &getConfusionTableByScore($id2score,"Qscore",$ci{Q},$Rscore);
	
	## Export
	if ($export){
	    my %Qscores=%{$Qscores};
	    my %true_positives=%{$true_positives};
	    my %false_positives=%{$false_positives};
	    my %true_negatives=%{$true_negatives};
	    my %false_negatives=%{$false_negatives};
	    my %sensitivity=%{$sensitivity};
	    my %specificity=%{$specificity};
	    my %ppv=%{$ppv};
	    my %npv=%{$npv};
	    my %fpr=%{$fpr};
	    my %accuracy_1=%{$accuracy_1};
	    my %accuracy_2=%{$accuracy_2};
	    my %accuracy_3=%{$accuracy_3};
	    my %ACP=%{$ACP};
	    my %Query_not_Ref=%{$Query_not_Ref};
	    &RSAT::message::Warning($header) if ($main::verbose >= 0);
	    foreach my $Qscore (sort {$b<=>$a} keys %Qscores){
		my $data .=join("\t",
				$Rscore,
				$Qscore);
		$data .="\t".$true_positives{$Qscore} if ($return_params{TP});
		$data .="\t".$false_positives{$Qscore} if ($return_params{FP});
		$data .="\t".$true_negatives{$Qscore} if ($return_params{TN});
		$data .="\t".$false_negatives{$Qscore} if ($return_params{FN});
		$data .="\t".$sensitivity{$Qscore} if ($return_params{Sn});
		$data .="\t".$specificity{$Qscore} if ($return_params{Sp});
		$data .="\t".$ppv{$Qscore} if ($return_params{PPV});
		$data .="\t".$npv{$Qscore} if ($return_params{NPV});
		$data .="\t".$fpr{$Qscore} if ($return_params{FPR});
		$data .="\t".$accuracy_3{$Qscore} if ($return_params{Acc});
		$data .="\t".$ACP{$Qscore} if ($return_params{ACP});
		$data .="\t".$Query_not_Ref{$Qscore} if ($return_params{QnotR});
		$data .="\t".$NnotQR if ($return_params{notQR});
#		$data .="\n" ;
		push @datas, $data;
		&RSAT::message::Warning($data);
	    }
	}
	# put datas in output file
	if ($output){
	    &write_file($output,$header,@datas);
	}
    }

    # put datas in output file
#    if ($output){
#	&OPTOOLS::util::write_file($output,$header,@datas);
#    }
}

################################################################
#### group scores by class intervals
sub getScores{
    my ($id2score)=shift;
    my $score_type=shift||"score";
    my $ci=shift;
    my %id2score=%{$id2score};
    my %scores=();
    foreach my $id (keys %id2score){
	$scores{$id2score{$id}->{$score_type}}=1;
    }
    my %scores_class=();
    if($ci){
	foreach my $sc (sort {$b<=>$a} keys %scores){ # decreasing scores
	    my ($class_min, $class_max, $class_mid) = &ClassRange($sc, $ci);
	    $scores_class{$class_min}=1;
	}
	%scores = %scores_class;
    }
    return(\%scores);
}

################################################################
#### Calc stats by score
################################################################
sub getConfusionTableByScore{
    my ($id2score)=shift;
    my ($score_type)=shift || "score";
    my ($class_interval)=shift;
    my ($Rscore_threshold)=shift;
    my %scores = ();
    my %id2score=%{$id2score};
    my (@ids) = sort keys (%id2score);
    my %tp=();
    my %tn=();
    my %fp=();
    my %fn=();
    my $Ntp=0;
    my $Ntn=0;
    my $Nfp=0;
    my $Nfn=0;
    my $NQnotR=0;
    my $NnotQR=0;

#    die if ($Rscore_threshold>500); # debug
    # $Rscore_threshold = 50;
    &RSAT::message::Warning("Rscore threshold: ", $Rscore_threshold) if ($main::verbose >= 5);

    ## Detect Total of True positives (TP), false positives (FP) and False negatives (FN) by score
    my $i=0;
    foreach my $id (@ids){
	$i++;
	my $status = $id2score{$id}->{status};
	&RSAT::message::Warning(join("\t",
				       $i,
				       $id,
				       $status)) if ($main::verbose >= 10);
	
	## If it is a False Negative
	if ($status eq "FN"){ # not.Q.R
	    my $Rscore=$id2score{$id}->{Rscore};
	    &RSAT::message::Warning(join("\t",
					    $i,
					    $id,
					    $status, 
					    $Rscore)) if ($main::verbose >= 10);
	    if ($Rscore >= $Rscore_threshold){
		$NnotQR++;
		$Nfn++;
	    }else{
		&RSAT::message::Warning(join("\t",
						$id,
						"Not included in the reference set",)) if ($main::verbose >= 10);
	    }	    
	}else{
	    ## Item has a score
	    my $score = $id2score{$id}->{$score_type};
#	    if (($score ne "NA")||($score ne "")){

	    &RSAT::message::Warning(join("\t",
					   $i,
					   $id,
					   $status, 
					   $score)) if ($main::verbose >= 10);
	    if ($status eq "TP"){ # Q.and.R
		my $Rscore=$id2score{$id}->{Rscore};
		if ($Rscore >= $Rscore_threshold){
		    $tp{$score}++;
		    $Ntp++;
		}else{
		    $fp{$score}++;
		    $Nfp++;
		}
		$scores{$score}=1 ; 
	    }elsif($status eq "FP"){ # Q.not.R
		$QnotR{$score}++;
		$Nfp++;
#		$NQnotR++;
		$scores{$score}=1 ; 
# 	    }else{
#  	       &OPTOOLS::util::Warning(5,join("\t","Warning ! Not well identified.",
#  					      $i,
#  					      $id,
#  					      $status, $Rscore));
#  	       die unless ($nodie);
 	   }	    
	}
	&RSAT::message::Warning(join("\t",
					"Total TP",$Ntp,
					"Total FP",$Nfp,
					"Q.not.R",$NQnotR,
					"not.Q.R",$NnotQR)) if ($main::verbose >= 5);        
    }	
    
# else{
# 	    ## using only the status
# 	    &OPTOOLS::util::Warning(8,join("\t",$id,
# 					   $status,
# 					 $score));
# 	  if ($status eq "TP"){
# 	      $tp{$score}++;
# 	      &OPTOOLS::util::Warning(8,join("\t",$id,"=> TP"));
# 	      $Ntp++;
# 	  }
# 	  elsif ($status eq "TN"){
# 	      $tn{$score}++;
# 	      &OPTOOLS::util::Warning(8,join("\t",$id,"=> TN"));
# 	      $Ntn++;
# 	  }elsif($status eq "FP"){
# 	      $fp{$score}++;
# 	      &OPTOOLS::util::Warning(8,join("\t",$id,"=> FP"));
# 	      $Nfp++;
# 	  }elsif($status eq "FN"){
# 	      $fn{$score}++;
# 	      &OPTOOLS::util::Warning(8,join("\t",$id,"=> FN"));
# 	      $Nfn++;
# 	  }else{
# 	      &OPTOOLS::util::Warning(0,join(" ","This status",$status," is not supported. Supported status :",join(",",keys %supported_status))); 
# 	      die;
# 	  }
#       }


    ## evaluation without any threshold
    if ($main::verbose>=10){
	&RSAT::message::Warning(join("\t","R>=$Rscore_threshold",$Ntp,"(total TP)")) if ($main::verbose >= 0);        
	&RSAT::message::Warning(join("\t","R<$Rscore_threshold",$Nfp,"(Total FP)"))  if ($main::verbose >= 0);        
	&RSAT::message::Warning(join("\t","not.Q.R",$NnotQR))  if ($main::verbose >= 0);               
	&confusionTable($Ntp,$Ntn,$Nfp,$Nfn);  
#      &stats($Ntp,$Ntn,$Nfp,$Nfn);
    }
        
    ################################################################
    #### group scores by class intervals
    if  ($class_interval){
	&RSAT::message::Warning("Grouping ",$score_type," by class interval of ",$class_interval)  if ($main::verbose >= 0);        ;
	my %tp_class=();
	my %tn_class=();
	my %fp_class=();
	my %fn_class=();
	my %QnotR_class=();
	my %scores_class=();
	foreach my $sc (sort {$b<=>$a} keys %scores){ # decreasing scores
#	    &OPTOOLS::util::Warning(1, "Group data of scores : ",$sc);
	    my ($class_min, $class_max, $class_mid) = &ClassRange($sc, $class_interval);
	    $tp_class{$class_min}+=$tp{$sc};
	    $tn_class{$class_min}+=$tn{$sc};
	    $fp_class{$class_min}+=$fp{$sc};
	    $fn_class{$class_min}+=$fn{$sc};
	    $QnotR_class{$class_min}+=$QnotR{$sc};
	    $scores_class{$class_min}=1;
	}
	# Fill gaps in classes
 	my @class_scores = sort {$a<=>$b} keys %scores_class;
#	&OPTOOLS::util::Warning(0,join("\t",@class_scores));
	my $cl_min = $class_scores[0];
	my $cl_max = $class_scores[$#class_scores];
	&RSAT::message::Warning(join("\t","class min",$cl_min,"class max",$cl_max)) if ($main::verbose >= 0) ;
	my $cl=$cl_max;
	my $prev_cl = $cl_max;
	for ($cl = $cl_max ; $cl >= $cl_min ; $cl = $cl-$class_interval){
	    &RSAT::message::Warning(join("\t","class",$cl)) if ($main::verbose >= 0);
	    unless ($scores_class{$cl}){
		$tp_class{$cl}=$tp_class{$prev_cl};
		$tn_class{$cl}=$tn_class{$prev_cl};
		$fp_class{$cl}=$fp_class{$prev_cl};
		$fn_class{$cl}=$fn_class{$prev_cl};
		$QnotR_class{$cl}=$QnotR_class{$prev_cl};
		$scores_class{$cl}=1;		
	    }
	    $prev_cl = $cl;
	}
	# update the results
	%tp = %tp_class;
	%fp = %fp_class;
	%tn = %tn_class;
	%fn = %fn_class;
	%QnotR = %QnotR_class;
	%scores = %scores_class;
    }
    
    ################################################################
    #### For each score , calculate the TP, TN, FP and FN
    #### calculate cumulative functions
    &RSAT::message::Warning("Calculating Statistical parameters :",join("\n",keys %desc_param)) if ($main::verbose >= 1);
    
    my $tp_cum=0;
    my $tn_cum=0;
    my $fp_cum=0;
    my $QnotR_cum=0;
    my $fn_cum=0;
    my %true_positives=();
    my %false_positives=();
    my %true_negatives=();
    my %false_positives=();
    my %Query_not_Ref=();

    foreach my $score (sort {$b<=>$a} keys %scores){ # decreasing scores
	
	#### true positives
	$tp_cum += $tp{$score};
	$true_positives{$score} = $tp_cum;
	#### false negatives
	$fn_cum += $fn{$score};
	$false_negatives{$score} = $Nfn + $Ntp - $tp_cum; #fn_cum;
	#### true negatives
	$tn_cum += $tn{$score};
	$true_negatives{$score} = $tn_cum;
	#### QnotR
	$QnotR_cum += $QnotR{$score};
	$Query_not_Ref{$score} = $QnotR_cum;
	#### false positives
	$fp_cum += $fp{$score};
	$false_positives{$score} = $fp_cum + $Query_not_Ref{$score} ;

	#### total references and total query
	my $total_ref = $true_positives{$score} + $false_negatives{$score};
	my $total_query = $true_positives{$score} + $false_positives{$score};
      
	&RSAT::message::Warning(join("\t",
				       $score_type,$score	,
				       "TP",$true_positives{$score},
				       "FP",$false_positives{$score},
				       "TN",$true_negatives{$score},
				       "FN",$false_negatives{$score},
				       "QnotR",$Query_not_Ref{$score},
				       "notQR",$NnotQR,
				       ),"\n") if ($main::verbose >= 5);
	
	################################################################
	#### For each score , calculate the Sn, Sp, PPV and NPV
	
	#### Calculate Sensitivity 
	#### (Sn = TP / (TP+FN))
	$sensitivity{$score} = "NA";
	if ($total_ref!=0){
	    $sensitivity{$score} = sprintf "%.2f",($true_positives{$score}/$total_ref);
	}
	
	#### Calculate Specificity 
	#### (Sp = TN / (TN+FP))
	$specificity{$score} = "NA";
	if ($true_negatives{$score}+$false_positives{$score}!=0){
	    $specificity{$score} = sprintf "%.2f",(($true_negatives{$score})/
						   ($true_negatives{$score}+$false_positives{$score}));
	}
	
	#### Calculate Positive Predictive Value
	#### (PPV = TP /(TP+FP))
	$ppv{$score}="NA";
	if ($total_query!=0){
	    $ppv{$score} = sprintf "%.2f",(($true_positives{$score})/
					   ($total_query));
	}
	
	#### Calculate Negative Predictive Value
	#### (NPV = TN /(TN+FN))
	$npv{$score} = "NA";
	if ($true_negatives{$score} + $false_negatives{$score}!=0){
	    $npv{$score} = sprintf "%.2f",(($true_negatives{$score})/
					   ($true_negatives{$score} + $false_negatives{$score}));
	}
	
	#### Calculate the False Positive Rate (FPR)
	#### (FPR = FP /(TP+FP))
	$fpr{$score}="NA";
	if ($total_query!=0){
	    $fpr{$score} = sprintf "%.2f",(($false_positives{$score})/
					   ($total_query));
	}
	
	&RSAT::message::Warning(join("\t",
				       $score_type,$score,
				       "Sn",$sensitivity{$score},
				       "Sp",$specificity{$score},
				       "PPV",$ppv{$score},
				       "FPR",$fpr{$score},
				       "NPV",$npv{$score},
				       ),"\n") if ($main::verbose >= 5);
	
	################################################################
	#### For each score , calculate the accuracies and ACP
	$accuracy_1{$score}="NA";
	$accuracy_2{$score}="NA";
	$accuracy_3{$score}="NA";
	$ACP{$score}="NA";
	
	if ($sensitivity{$score} ne "NA"){
	    if ($specificity{$score} ne "NA"){
		#### Calculate Accuracy (average of sensitivity and specificity)
	      $accuracy_1{$score}=  sprintf "%.2f",(sqrt($sensitivity{$score}*$specificity{$score}));
	  }
	    if ($ppv{$score} ne "NA"){
		#### Calculate Accuracy (average of PPV and Sn)
		$accuracy_3{$score}= sprintf "%.2f",(sqrt($ppv{$score}*$sensitivity{$score}));
	    }
	}
	if (($ppv{$score} ne "NA")&&($npv{$score} ne "NA")){
	    
	    #### Calculate Accuracy (average of PPV and NPV)
	    $accuracy_2{$score}= sprintf "%.2f",(sqrt($ppv{$score}*$npv{$score}));
	    
	    if (($sensitivity{$score} ne "NA")&&($specificity{$score} ne "NA")){
	      #### The ACP (Average Conditional Probability) can be used as a measure
		#### of the global prediction accuracy
		$ACP{$score} =  sprintf "%.2f",(($sensitivity{$score}+$specificity{$score}+$ppv{$score}+$npv{$score})/4);
	    }
	}
	
	################################################################
	#### OPTIMAL SCORES
	
	#### optimal score with accuracy 1
	if ($accuracy_1{$score} > $max_accuracy_1) {
	    $max_accuracy_1 = $accuracy_1{$score};
	    $optimal_score_1 = $score;
	}
	#### optimal score with accuracy 2
	if ($accuracy_2{$score} > $max_accuracy_2) {
	    $max_accuracy_2 = $accuracy_2{$score};
	    $optimal_score_2 = $score;
	}
	#### optimal score with accuracy 3
	if ($accuracy_3{$score} > $max_accuracy_3) {
	    $max_accuracy_3 = $accuracy_3{$score};
	    $optimal_score_3 = $score;
	}
	#### optimal score with accuracy 3
	if ($accuracy_3{$score} > $max_accuracy_3) {
	    $max_accuracy_3 = $accuracy_3{$score};
	    $optimal_score_3 = $score;
	}
	#### optimal score with accuracy 3
	if ($ACP{$score} > $max_ACP) {
	    $max_ACP = $ACP{$score};
	    $optimal_score_4 = $score;
	}
    }
        
    return(\%scores,
	   \%true_positives,
	   \%false_positives,
	   \%true_negatives,
	   \%false_negatives,
	   \%sensitivity,
	   \%specificity,
	   \%ppv,
	   \%npv,
	   \%fpr,
	   \%accuracy_1,
	   \%accuracy_2,
	   \%accuracy_3,
	   \%ACP,
	   \%Query_not_Ref,
	   $NnotQR
	 );
}

################################################################
#### Attribute type (TP,TN,FP,FN) to simple data (without score)
################################################################
sub getConfusionTable{
  my ($id2score)=@_;
  my %id2score=%{$id2score};
  my (@ids) = sort keys (%id2score);
  my %tp=();
  my %tn=();
  my %fp=();
  my %fn=();
  foreach my $id (@ids){
      my $score = $id2score{$id}->{status};
      if ($score eq "TP"){
	  $tp{$id}=1;
	  &RSAT::message::Warning(join("\t",$id,"=> TP")) if ($main::verbose >= 8);
      }
      elsif ($score eq "TN"){
	  $tn{$id}=1;
	  &RSAT::message::Warning(join("\t",$id,"=> TN")) if ($main::verbose >= 8);
      }elsif($score eq "FP"){
	  $fp{$id}=1;
	  &RSAT::message::Warning(join("\t",$id,"=> FP")) if ($main::verbose >= 8);
      }elsif($score eq "FN"){
	  $fn{$id}=1;
	    &RSAT::message::Warning(join("\t",$id,"=> FN")) if ($main::verbose >= 8);
      }else{
	  &RSAT::message::Warning(join(" ","This status",$score," is not supported. Supported status :",join(",",keys %supported_status))) if ($main::verbose >= 0); 
	  die;
      }
  }
  if ($main::verbose>=1){
      my $Ntp=scalar (keys %tp);
      my $Ntn=scalar (keys %tn);
      my $Nfp=scalar (keys %fp);
      my $Nfn=scalar (keys %fn);
      &confusionTable($Ntp,$Ntn,$Nfp,$Nfn);
      &stats($Ntp,$Ntn,$Nfp,$Nfn);
  }
  return(\%tp,\%tn,\%fp,\%fn);
}


################################################################
#### EVALUATION PARAMS
################################################################

=pod

=head1 B<STATISTICAL PARAMETERS>

=over
    
I<TP>    True Positive (cumulative)

I<FP>    False Positive (cumulative)

I<TN>    True Negative (cumulative)

I<FN>    False Negative (cumulative)

I<Sn>    Sensitivity 

I<Sp>    Specificity

I<PPV>   Positive Predictive Value

I<NPV>   Negative Predictive Value

I<FPR>   False Positive Rate

I<Acc>   Accuracy (geometric average between Sn and PPV)

I<ACP>   Average Conditional Probability

=back

=cut

my %desc_param=(
		"TP"=>"True Positive",
		"TN"=>"True Negative",
		"FP"=>"False Positive",
		"FN"=>"False Negative",
		"Sn"=>"TP/TP+FN",
		"Sp"=>"TN/TN+FP",
		"PPV"=>"TP/TP+FP",
		"NPV"=>"TN/TN+FN",
		"FPR"=>"FP/TP+FP",
		"accArit1"=>"(Sn+Sp)/2",
		"accGeom1"=>"sqrt(Sn*Sp)",
		"accArit2"=>"(PPV+NPV)/2",
		"accGeom2"=>"sqrt(PPV*NPV)",
		"accArit3"=>"(Sn+PPV)/2",
		"accGeom3"=>"sqrt(Sn*PPV)",
		);

my %param_fullname=(
		    "TP"=>"True Positive",
		    "TN"=>"True Negative",
		    "FP"=>"False Positive",
		    "FN"=>"False Negative",
		    "Sn"=>"Sensitivity",
		    "Sp"=>"Specificity",
		    "PPV"=>"Positive Predictive Value",
		    "NPV"=>"Negative Predictive Value",
		    "FPR"=>"False Positive Rate",
		    "accArit1"=>"Arithmetic Accuracy 1",
		    "accGeom1"=>"Geometric Accuracy 1",
		    "accArit2"=>"Arithmetic Accuracy 2",
		    "accGeom2"=>"Geometric Accuracy 2",
		    "accArit3"=>"Arithmetic Accuracy 3",
		    "accGeom3"=>"Geometric Accuracy 3"		  
		    );

################################################################
#### Make confusion table
################################################################
sub confusionTable{
  my ($Ntp,$Ntn,$Nfp,$Nfn)=@_;
  my $table="; Confusion Table\n";
  $table .= join("\t","","Ref.T","Ref.N","Total")."\n";
  $table .= join("\t","Pred.T",$Ntp,$Nfp,$Ntp+$Nfp)."\n";
  $table .= join("\t","Pred.N",$Nfn,$Ntn,$Nfn+$Ntn)."\n";
  $table .= join("\t","Total",$Nfn+$Ntp,$Ntn+$Nfp,$Nfn+$Ntn+$Ntp+$Nfp)."\n";
  print $table;
  return ($table);
}

################################################################
#### Calculate statistics
################################################################
sub stats{
  my ($Ntp,$Ntn,$Nfp,$Nfn)=@_;
  if (!$Ntn){
    &RSAT::message::Warning(join("\t","Warning ! No value for true negative (TN). Will affect Sn, NPV, accArit1, accArit2, accGeom1, accGeom2")) if ($main::verbose >= 1);
  }
  my %param=();
  $param{Sn}=sprintf("%.2f",$Ntp/($Nfn+$Ntp));
  $param{PPV}=sprintf("%.2f",$Ntp/($Nfp+$Ntp));
  $param{Sp}=sprintf("%.2f",$Ntn/($Nfp+$Ntn));
  $param{NPV}=sprintf("%.2f",$Ntn/($Nfn+$Ntn));
  $param{accArit1}=sprintf("%.2f",($param{Sn}+$param{Sp})/2);
  $param{accGeom1}=sprintf("%.2f",sqrt($param{Sp}*$param{Sn}));
  $param{accArit2}=sprintf("%.2f",($param{PPV}+$param{NPV})/2);
  $param{accGeom2}=sprintf("%.2f",sqrt($param{PPV}*$param{NPV}));
  $param{accArit3}=sprintf("%.2f",($param{PPV}+$param{Sn})/2);
  $param{accGeom3}=sprintf("%.2f",sqrt($param{PPV}*$param{Sn}));
  if ($main::verbose >= 1){
    foreach my $p ("Sn","Sp","PPV","NPV","accArit1","accArit2","accArit3","accGeom1","accGeom2","accGeom3"){
      &RSAT::message::Warning(0,join("\t",$param{$p},$p,$desc_param{$p})) if ($main::verbose >= 5);
    }
  }

  return (%param);
}

################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help 
sub PrintOptions {
    &PrintHelp();
}

################################################################
####                 OPTOOLS FUNCTIONS                  ########
################################################################

################################################################
#### Read a file
################################################################
sub readfile{
  my ($file,$noskip)=@_;
  &RSAT::message::Warning(join("\t","Reading file",$file)) if ($main::verbose >= 2);
  # get the data from file
  my @datas=();
  open (FILE,"<$file")||die("Cannot open $file");
  while (<FILE>){
    chomp;
    if ($noskip){ # don't skip comments
      &RSAT::message::Warning($_) if ($main::verbose >= 10);
      push (@datas, $_);
    }else{
	next if ($_ =~ /^;/ );    # skip comments
	next if ($_ =~ /^#/ );    # skip comments
	&RSAT::message::Warning($_) if ($main::verbose >= 10);
	push (@datas, $_);
    }
  }
  close (FILE);
  &RSAT::message::Warning(join("\nread line: ",@datas)) if ($main::verbose > 4);
  return(@datas);
}

################################################################
#### WRITE A FILE
################################################################
sub write_file{
  my ($output_file,@data) = @_;
  &RSAT::message::Warning(2,"Writing file : $output_file") if ($main::verbose >= 2);
  # now open it to write
  open (OUTPUT, ">$output_file");# || die ("Cannot open $output_file\n");
  flock(OUTPUT, 2);         # and lock it
  my $i = 0;
  for ($i=0;$i<=$#data;$i++){
    my $l = $i+1;
    &RSAT::message::Warning("Writing line $l : $data[$i]\n") if ($main::verbose >= 5);
    print OUTPUT "$data[$i]\n";  # write the unchanged line out to the file
  }
  flock(OUTPUT, 8);    # unlock the file
  close(OUTPUT);       # and close it
}

################################################################
#### Return the min, max and mid of a class
################################################################
sub ClassRange {
    my ($d, $class_interval) = @_;
    my $class_min = &ClassMin($d, $class_interval);
#    die join "\t", $d, $class_interval, $class_min;
    my $class_max = $class_min + $class_interval;
    my $class_mid = $class_min + $class_interval/2;
    return ($class_min, $class_max, $class_mid);
}
################################################################
#### Calculate the minimum of a class
################################################################

sub ClassMin {
    my ($d, $class_interval) = @_;
    my $class_min;
    if ($d >= 0) {
	$class_min  = $class_interval*(int($d/$class_interval));
    } else {
	$class_min  = $class_interval*(int(($d+1)/$class_interval) - 1);	
    }
    return $class_min;
}
__END__


=pod

=over

=head1 OPTIONS

=over

=item -h|--help

Prints this help message

=item -v|--verbosity [integer]

Level of verbosity (information displayed on the screen to indicate
the processing).

=item --opt

Print option values.

=item -i|--input <file>

Input file.

=item -o|--output <file>

Output file.

=item --col [id|status|score]=<col_number> (default:id=1,status=2,score=3)

Specify the column for the id, status or score.(e.g. --col id=3)

=item --score_format [score|Q|R|Q::R] (default:score or Q::R with --3D)

Specify the score format: "score" when using one score and "Q::R" with 3D.

=item -t|--threshold [Q|R|score] 

Put a threshold on one score.

=item -s|--status <status>=[TP|FP|FN|TN]

You can specify here other terms to assign to supported status.
(e.g. --status R.and.Q=TP --status not.Q.R=FN --status Q.not.R=FP)

=item --ci (score|Q|R)=<integer>

Class interval for scores. 
Use --ci Q <number> and --ci R <number> with --3D option.

=item -r|--return [TN,FP,FN,Sn,PPV,FPR,Acc,...]

Statistical parameters to return in the output file. See Previous section for
description of these parameters. (By default: TN,FP,FN,Sn,PPV,FPR,Acc,QnotR,notQR)

=item --3D

This option allows to consider the comparison of two data sets (Query and
Reference) having both scores (or weight). For a given threshold on the
Reference score (Rscore), all statistical parameters are returned considering
only elements of the reference set with a Rscore >= threshold. Thus, for
different thresholds on the Rscore (see --ci R), one can build several ROC
curves. Graphically, this is like adding a Z axis for the Rscore threshold to the
usual ROC representation (Sn=f(FPR)), leading to a "ROC 3D" representation.

=item --nodie

This option avoids the program to die when status is not supported. This is
particularly useful with --3D if you want to calculate the statistics only on
"Q.and.R" elements for different thresholds.

=back

=head1 SEE ALSO

=item B<compare-graphs>

=item B<XYgraph>

Use XYgraph in order to draw the ROC curve (Options to be implemented in parenthesis):

C<XYgraph -i ROC-table.tab -xcol 6 -ycol 5 (-labelcol 1)>
 
C<XY(Z)graph -i ROC-cube.tab -xcol 6 -ycol 5 (-zcol 9 -labelcol 1)>

=back





