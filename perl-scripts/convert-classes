#!/usr/bin/perl -w
############################################################
#
# $Id: convert-classes,v 1.3 2006/03/13 23:43:42 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

## use strict;

=pod

=head1 NAME

convert-classes

=head1 DESCRIPTION

Interconversions between different formats of cluster files.

=head1 AUTHORS

jvanheld@scmbb.ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE
    
convert-classes [-i inputfile] [-o outputfile] [-v]

=head1 INPUT/OUTPUT FORMATS


=head2 mcl

The output format of the MCL algorithm. MCL is a graph-based
clustering algorithm developed by Stijn Van Dongen
(http://micans.org/mcl/).

The output format has one row per cluster, each row giving a list of
elements, separated by tabulations.

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
use RSAT::Family;
use RSAT::Classification;


################################################################
## Main package
package main;
{

    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();


    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
#    $main::in = STDIN;
    $main::out = STDOUT;
    
    $input_format = "mcl";
    $output_format = "tab";
    my $classification = new RSAT::Classification;

    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	mcl=>1,
	tab=>1,
	profiles=>1,
    );
    $supported_input_formats = join (",", keys %supported_input_format);

    ## Output formats
    local $output_format = "dot";
    %supported_output_format =(
	mcl=>1,
	tab=>1,
	profiles=>1,
    );
    $supported_output_formats = join (",", keys %supported_output_format);

    %args = ();

    &ReadArguments();

    ################################################################
    #### check argument values


    ################################################################
    ##### Read input
    $classification->read_from_file($main::infile{input}, $input_format, %args);
    
    ################################################################
    ### open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    #### print verbose
    &Verbose() if ($main::verbose);

    ################################################################
    ###### print output
    print $out $classification->to_text($output_format);
    
    
    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ###### close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
#    foreach my $a (0..$#ARGV) {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();
	    

	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    

	    ### Input format  
=pod

=item B<-from input_format>

Input format. Supported: tab, mcl, profiles

=cut
	} elsif ($arg eq "-from") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});

	    ## Member column
=pod

=item B<-mcol>

Member column. Column containing the member names in the tab format (default 1). 

=cut
	} elsif ($arg eq "-mcol") {
	    $args{member_column} = shift (@arguments);
	    unless (&IsNatural($args{member_column}) && ($args{member_column} > 0)) {
		&RSAT::error::FatalError(join("\t", $args{member_column}, "Invalid value for the member column. Must be a strictly positive natural number"));
	    }

	    ## Class column
=pod

=item B<-ccol>

Class column. Column containing the class names in the tab format (default 1). 

=cut
	} elsif ($arg eq "-ccol") {
	    $args{class_column} = shift (@arguments);
	    unless (&IsNatural($args{class_column}) && ($args{class_column} > 0)) {
		&RSAT::error::FatalError(join("\t", $args{class_column}, "Invalid value for the class column. Must be a strictly positive natural number"));
	    }

	    ## Score column
=pod

=item B<-scol>

Score column. Column containing the scores in tab format. If not
specified, scores are not defined.

=cut
	} elsif ($arg eq "-scol") {
	    $args{score_column} = shift (@arguments);
	    unless (&IsNatural($args{score_column}) && ($args{score_column} > 0)) {
		&RSAT::error::FatalError(join("\t", $args{score_column}, "Invalid value for the score column. Must be a strictly positive natural number"));
	    }


	    ### Output format  
=cut

=item B<-to output_format>

Output format. Supported: tab, mcl,profiles

=cut 
	} elsif ($arg eq "-to") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});



	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; convert-classes ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=cut
