#!/usr/bin/perl
use CGI;

package main;


################################################################
## Load the default parameters for get-orthologs`
sub LoadGetOrthoDefault {
  $default{organism} = "Escherichia_coli_K12";
  $default{taxon} = "Gammaproteobacteria";
  $default{queries} = '';
  $default{full} = '';
  $default{match_description} = '';
  $default{feattype} = "CDS";
  $default{ortho_lth_ali_len} = 50;
  $default{ortho_uth_e_value} = 1e-5;
  $default{ortho_uth_rank} = 1;
  #$default{ortho_uth_s_rank} = 1;
  $default{return_ident} = "checked";
  $default{return_ali_len} = "";
  $default{return_mismat} = "";
  $default{return_gap_open} = "";
  $default{return_e_value} = "checked";
  $default{return_bit_sc} = "";
  $default{return_rank} = "";
  #$default{return_s_rank} = "";
}

################################################################
## Print the options for selecting ortholofs:
## - query organism
## - query genes
## - reference taxon
sub PrintOrthoSelectionSection {


  ################################################################
  ## List of organisms for which ortholog search is supported
  ## This is temporary, we need to find a way to provide orhtologs for all organisms
  my @supported_orthologs = qw(
			       Bacillus_subtilis
			       Brucella_melitensis
			       Escherichia_coli_K12
			       Saccharomyces_cerevisiae
			       Salmonella_typhimurium_LT2
			       Salmonella_typhi
			      );

  #### choice of the organism
  print "<b>Query </b>";
 &OrganismPopUp(@supported_orthologs);

  ################################################################
  ### gene queries
  print "<B><A HREF='help.retrieve-seq.html#genes'>Query genes</A></B>&nbsp;";
  print "<BR>\n";
  print $query->textarea(-name=>'queries',
			 -default=>$default{queries},
			 -rows=>3,
			 -columns=>40);
  ### option to upload a file with the gene list from the client machine 
  print "<BR>Upload gene list from file<BR>\n";
  print $query->filefield(-name=>'uploaded_file',
			  -default=>'',
			  -size=>45,
			  -maxlength=>200);
  print "<p>\n";

  ## Taxon of interest
#  &TaxonPopUp("node");
  &TaxonPopUp("all");
}


################################################################
## For debugging: if the echo level is >= 2, display the parameters
## transmitted to the CGI query.
## This method should be called from the cgi scripts
sub ListParameters {
  my($cgi_query) = $_[0];
  @param = $query->param;
  print "<H3>CGI query parameters</H3>";
  print "<ul><table>\n";
  foreach my $key (@param) {
    print "<tr>";
    print "<td valign=top><b>$key</b></td>";
    my $value = $query->param($key);
    $value =~ s/\n/<br>/g;
    print "<td valign=top>$value</td>";
    print "</tr>\n";
  }
  print "</table></ul>\n";
}

################################################################
## List the default parameter values for a CGI script
## This method should be called from the *_form.cgi scripts
sub ListDefaultParameters {
  @param = $query->param;
  print "<b>Default parameter values</b>";
  print "<ul><table>\n";
  foreach my $key (sort keys %main::default) {
    print "<tr>";
    print "<td valign=top><b>$key</b></td>";
    my $value = $default{$key};
    $value =~ s/\n/<br>/g;
    print "<td valign=top>$value</td>";
    print "</tr>\n";
  }
  print "</table></ul>\n";
}

################################################################
## returns all the fields of the %input hash
## TO CHECK: IS THIS METHOD STILL USED ? LOOKS LIKE AN OLD VERSION OF &LISTPARAMETERS()
sub Print_CGI_Input {
    print "<PRE>";
    foreach $key (sort keys %input) {
	print "$key\t$input{$key}\n";
    }
    print "</PRE>";

    print "Parameters: $parameters<P><P>\n";
}


## ##############################################################
## Start a new HTML page and write the header of a RSAT query form or result
## page usage &RSA_header($program_name)
sub RSA_header {
  my $css_body_class = "form";
  my ($title) = shift;
  $title =~ s/\"//g;
  $title =~ s/\'//g;
  if (scalar @_ > 0) {
    $css_body_class = shift;
  }


#  print &html_header();
  print $query->header();
  print sorttable_script();
  ### print the header of the result page
  print $query->start_html(-title=>"RSA-tools : $title",
			   -class => "$css_body_class",
			   -author=>'jvanheld@scmbb.ulb.ac.be',
			   -style => { 	-src => "$ENV{rsat_www}/main.css",
                             	       	-type => 'text/css',
                             		-media => 'screen' });
  print "<H3 ALIGN='center'><A HREF='$ENV{rsat_www}/RSAT_home.cgi'>RSA-tools</A> - $title</H3>";
}


## ##############################################################
## send results by e-mail or display on the browser
sub SelectOutput {
    my ($default_output, %args) = @_;
    $default_output = "display" unless ($default_output);
    my @values = ();
    if ($args{email_only}) {
      push @values, 'email';
      $default{output} = 'email';
    } else {
      if ($default_output eq 'server') {
	push @values, 'server'
      }
      push @values, ('display','email');
    }
    print "<B>Output</B>&nbsp;";
    print $query->radio_group(-name=>'output',
			      -values=>[@values],
			      -default=>$default_output);
    print $query->textfield(-name=>'user_email',
			    -size=>30);
    print "<BR>\n";
    print "<BR>\n";
}


################################################################
### print a selection between diferent modes of sequence entry 
### in a HTML form
### - sequences copy-pasted in a textarea
### - sequences uploaded from a file on the client side
### - sequences piped from a previous script, and stored on the server
###   (typically  in a temporary dir)
sub DisplaySequenceChoice {
    print &SequenceChoice();
}

sub SequenceChoice {
    my $sequenceChoiceString = "";
    $sequenceChoiceString .=  "<B>Sequence</B>";
    #$sequenceChoiceString .=  "<UL>\n";
    
    if ($sequence_file = $query->param(sequence_file)) {
	### sequence file is already on the server machine 
	### (piped from a previous script)
	$sequence_url = $sequence_file;
	$sequence_url =~ s|$ENV{RSAT}/public_html|$ENV{rsat_www}|;
	$sequenceChoiceString .=  "<a href=$sequence_url>";
	$sequenceChoiceString .=  " transferred from previous query<BR>\n";
	$sequenceChoiceString .=  "</a>";
	$sequence_format = $query->param(sequence_format);
	$sequenceChoiceString .=  "<INPUT type='hidden' NAME='sequence_format' VALUE='$sequence_format'>\n";
	$sequenceChoiceString .=  "<INPUT type='hidden' NAME='sequence_file' VALUE='$sequence_file'>\n";
    } else {

	#### sequence format (pop-up menu)
	$sequenceChoiceString .=  "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n";
	$sequenceChoiceString .=  "<B><A HREF='help.formats.html'>Format</A></B>&nbsp;";
	$sequenceChoiceString .=  $query->popup_menu(-name=>'sequence_format',
						    -Values=>['fasta', 
							      'ig',
							      'wconsensus',
							      'raw',
							      'ncbi',
							      "tab",
							      'multi'],
						    -default=>$sequence_format);
	#### Mask option
	$sequenceChoiceString .=  "<B><A HREF='help.formats.html'>Mask</A></B>&nbsp;";
	$sequenceChoiceString .=  $query->popup_menu(-name=>'mask',
						    -Values=>['none', 
							      'upper',
							      'lower'],
						    -default=>"none");
	$sequenceChoiceString .=  "<BR>\n";

	### text area to copy-paste the sequence
	$sequenceChoiceString .=  "Paste your sequence in the box below<BR>\n";
	$sequenceChoiceString .=  $query->textarea(-name=>'sequence',
						  -default=>$default{sequence},
						  -rows=>4,
						  -columns=>55);
	$sequenceChoiceString .=  "<BR>\n";

	### option to upload the sequence file from the client machine 
	$sequenceChoiceString .=  "Or select a file to upload<BR>\n";
	$sequenceChoiceString .=  $query->filefield(-name=>'uploaded_file',
						    -default=>'',
						    -size=>45,
						    -maxlength=>200);
	$sequenceChoiceString .=  "<BR>\n";

    }
    $sequenceChoiceString .=  "<BR>\n";
    
    
    #$sequenceChoiceString .=  "</UL>\n";
    return $sequenceChoiceString;
}


################################################################
## Treat input sequence for the RSAT web server
## The seqence can be specified in 3 ways :
## - as a file to upload from the client to the server $query->param('uploaded_file')
## - as a text in the textarea $query->param('sequence')
## - as a sequence file already on the server $query->param('sequence_file')
##
## Usage:
##    ($sequence_file,$sequence_format) = &GetSequenceFile();
##    ($sequence_file,$sequence_format) = &GetSequenceFile($required_format,
##                                                         add_rc=>1,
##                                                         skip_short=>30);
sub GetSequenceFile {
  my ($required_format, %args) = @_;
  my $add_rc = $args{add_rc} || 0;
  my $no_format = $args{no_format} || 0;
  my $skip_short = $args{skip_short} || 0;

  ### sequence file format
  my $sequence_format = lc($query->param("sequence_format"));
  unless ($accepted_input_seq{$sequence_format}) {
    &cgiError("Invalid sequence format : '$sequence_format'.");
  }

  unless ($sequence_file = $query->param('sequence_file')) { 
    ### sequence file already on the server side
    ### create a new temporary sequence file
    $sequence_file = "$TMP/$tmp_file_name.seq"; 

    ### upload sequence file from the client side
    $upload_file = $query->param('uploaded_file');
    if ($upload_file) {
      if ($upload_file =~ /\.gz$/) {
	$sequence_file .= ".gz";
      }
      $type = $query->uploadInfo($upload_file)->{'Content-Type'};
      open SEQ, ">$sequence_file" ||
	&cgiError("Cannot store sequence file in temp dir.");
      while (<$upload_file>) {
	print SEQ;
      }
      close SEQ;

      ### read sequence from the textarea "sequence"
    } elsif ($query->param('sequence') =~ /\S/) {
      if (open SEQ, ">$sequence_file") {
	print SEQ $query->param('sequence');
	close SEQ;
      }
    } else {
      &cgiError("The sequence box should not be empty.");
    }

    #### sequence file will be deleted
    &DelayedRemoval($sequence_file);
  }

  ## Mask option
  my $mask = "";
  if ($query->param('mask')) {
    unless ($query->param('mask') eq "none") {
      $mask = $query->param('mask');
      &CheckMask($mask);
    }
  }

  #### convert-seq
  if (($add_rc) ||
      ($mask) ||
      ($skip_short) ||
      ((defined($required_format)) && (lc($sequence_format) ne lc($required_format)))
     ) {

    ## Check required format
    unless ($required_format) {
      $required_format = $sequence_format;
    }
    unless ($accepted_output_seq{$required_format}) { 
      &cgiError("Invalid sequence format : ${required_format}.");
    }
    my $converted_seq_file = $sequence_file.".".$required_format;
    my $convert_seq_command = "$SCRIPTS/convert-seq ";
    $convert_seq_command .= " -i $sequence_file -o $converted_seq_file ";
    $convert_seq_command .= " -from  $sequence_format -to $required_format ";

    ## Add reverse complement
    if ($add_rc) {
      $convert_seq_command .= " -addrc ";
    }

    ## Mask
    if ($mask) {
      $convert_seq_command .= " -mask ".$mask;
    }

    ## Skip short sequences
    if ($skip_short) {
      $convert_seq_command .= " -skip_short ".$skip_short;
    }

    ## Execute the sequence conversion
    system($convert_seq_command);

    #print "<PRE>$convert_seq_command</PRE>\n";
    &DelayedRemoval($converted_seq_file);
    $sequence_file = $converted_seq_file;
    $sequence_format = $required_format;
  }

  return($sequence_file, $sequence_format);
}


#### warn the users to wait for complete result before clicking on piping buttons
sub PipingWarning {
    my $message = "One or several button(s) will appear at the bottom of this page, ";
    $message .= "allowing you to send the result as input for a subsequent query."; 
    &cgiMessage($message, "Information");
}


### display a pop-up menu with a selection of organism
### on the basis of the configuration found in RSA.config
sub OrganismPopUp {
    print &OrganismPopUpString(@_);
}
sub OrganismPopUpString {
    my (@selected_organisms) = @_;
    if (scalar(@selected_organisms) <= 0) {
	@selected_organisms = &ListSupportedOrganisms("keys");
    }
    my $organismPopup = "";
    $organismPopup .=  "<B>Organism</B>&nbsp;";
    $organismPopup .=  "<SELECT NAME='organism'>\n";
    foreach my $org (@selected_organisms) {
	$name = $supported_organism{$org}->{'name'};
	if ((lc($org) eq lc($default{organism})) ||
	    (lc($name) eq lc($default{organism}))) {
	    $organismPopup .=  "<OPTION SELECTED VALUE='$org'>$name\n";
	} else {
	    $organismPopup .=  "<OPTION VALUE='$org'>$name\n";
	}
    }
    $organismPopup .=  "</SELECT>";
    $organismPopup .=  "<BR>\n";
    return $organismPopup;
}



################################################################
### display a pop-up menu with the supported taxonomy
### on the basis of the configuration found in RSA.config
sub TaxonPopUp {
    print &TaxonPopUpString(@_);
}
sub TaxonPopUpStringIndented {
    require RSAT::Tree;
    my $tree = new RSAT::Tree();
    $tree->LoadSupportedTaxonomy(undef, \%supported_organism, 1);
#    $tree->LoadSupportedTaxonomy(1);
    my @supported_taxons = $tree->node_names();
    my $indent_char = ":-";

    my %indented_taxa = ($tree->as_indented_hash($indent_char,"Bacteria"),
			 $tree->as_indented_hash($indent_char,"Fungi"));
    my $taxonomyPopup = "";
    $taxonomyPopup .=  "<B>Taxon</B>&nbsp;";
    $taxonomyPopup .=  "<SELECT NAME='taxon'>\n";
    foreach my $taxon (@supported_taxons) {
      if ($indented_taxa{$taxon}){
	$name = $indented_taxa{$taxon};
	if ((lc($taxon) eq lc($main::default{taxon})) ||
	    (lc($name) eq lc($main::default{taxon}))) {
	    $taxonomyPopup .=  "<OPTION SELECTED VALUE='$taxon'>$name\n";
	  } else {
	    $taxonomyPopup .=  "<OPTION VALUE='$taxon'>$name\n";
	  }
      }
    }
    $taxonomyPopup .=  "</SELECT>";
    $taxonomyPopup .=  "<BR>\n";
    return $taxonomyPopup;
}

sub TaxonPopUpString {
  my ($node_type) =  @_;
  $node_type = "node" unless ($node_type);
  require RSAT::Tree;
  my $tree = new RSAT::Tree();
  $tree->LoadSupportedTaxonomy(undef, \%supported_organism, 1);

  my @taxa = $tree->get_node_descendents_names("Bacteria",undef,$node_type);
  push @taxa, $tree->get_node_descendents_names("Fungi",undef,$node_type);
  @taxa = sort @taxa;

  my $taxonomyPopup = "";
  if ($node_type eq "all") {
    $taxonomyPopup .=  "<B>Taxon/Organism</B>&nbsp;";
  } else {
    $taxonomyPopup .=  "<B>Taxon</B>&nbsp;";
  }
  $taxonomyPopup .=  "<SELECT NAME='taxon'>\n";
  foreach my $taxon (@taxa) {
    my $name = $taxon;
    $label =~ s/_/ /g;
    if ((lc($taxon) eq lc($main::default{taxon})) ||
	(lc($name) eq lc($main::default{taxon}))) {
      $taxonomyPopup .=  "<OPTION SELECTED VALUE='$taxon'>$name\n";
    } else {
      $taxonomyPopup .=  "<OPTION VALUE='$taxon'>$name\n";
    }
  }
  $taxonomyPopup .=  "</SELECT>";
  $taxonomyPopup .=  "<BR>\n";
  return $taxonomyPopup;
}




################################################################
## MATRICES
sub GetMatrix {
my $consensus = shift;
print "<B>Matrix (or matrices)</B>\n";
print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n";
print "<A HREF='help.matrix-scan.html'><B>Format</B></a>&nbsp;";

#### matrix format 
print $query->popup_menu(-name=>'matrix_format',
			 -Values=>[
				   'tab',
				   'meme',
				   'MotifSampler',
				   'consensus',
				   'gibbs',
				   'transfac',
				   'alignace',
				   'clustal',
				   'assembly',
				   'cluster-buster',
				   'feature',
				   'infogibbs'
				  ],
			 -default=>$default{matrix_format});

if ($consensus) {
print $query->checkbox(-name=>'consensus_as_name',
		       -checked=>$default{consensus_as_name},
		       -label=>' use motif consensus as matrix name ');
}
#### text area to enter the matrix
print "<BR>\n";
print $query->textarea(-name=>'matrix',
		       -default=>$default{matrix},
		       -rows=>4,
		       -columns=>60);


#### pseudo-counts
print "<BR>\n";
print "<B><A HREF='help.matrix-scan.html'>Pseudo-counts</A></b>\n";
print $query->textfield(-name=>'pseudo_counts',
			-default=>$default{pseudo_counts},
			-size=>2);

print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='equi_pseudo' $checked{'equi_pseudo'}>","<b>distributed in an equiprobable way</b>");
print ("<INPUT TYPE='radio' NAME='pseudo_distribution' VALUE='pseudo_prior' $checked{'pseudo_prior'}>","<b>distributed proportionally to residues priors</b>");

}


################################################################
## BACKGROUND MODEL for matrix-based programs
sub GetBackgroundModel {

my $params_ref = shift;
my %params = %$params_ref;


my $title = "Background model";
if ($params{title}){
	$title=$params{title};
}

if ($params{title_choose}){
	print ("<br><INPUT TYPE='radio' NAME='bg_choose' VALUE='rsat' $checked{'rsat'}>");
	print "<b>$title</b><br/>";
} else {
	print "<p><B>$title</B><br>";
	}

if ($params{markov}) {
#### Markov order
print ("<b><a href=help.matrix-scan.html#markov_order>Markov Chain order</a></b> &nbsp;");
print $query->popup_menu(-name=>'markov_order',
			 -Values=>[0..7],
			 -default=>$default{markov_order});
if ($params{markov_message}) {
	print ("&nbsp;&nbsp;&nbsp;<font color=red>High orders can be time-comsuming.</font>");
	}
}
print "<p>";
## Method to estimate the bg model

print ("<b><a href=help.matrix-scan.html#bg_method>Estimation method</a></b>");

if ($params{from_matrix}){
	print ("<br><INPUT TYPE='radio' NAME='bg_method' VALUE='from_matrix' $checked{'from_matrix'}>", 
       "<b>Estimate from input matrix</b>");
}

if ($params{bg_input}) {
#### Input sequences
print ("<br><INPUT TYPE='radio' NAME='bg_method' VALUE='bginput' $checked{'bginput'}>", 
       "<b>Estimate from input sequences</b>");
}

if ($params{bg_window}) {
 ## Sliding window
 print ("<br><INPUT TYPE='radio' NAME='bg_method' VALUE='window' $checked{'window'}>",
        "<b>Sliding window</b> &nbsp;");
 print $query->textfield(-name=>'window_size',
 			-default=>$default{window_size},
 			-size=>5);
}

#### Pre-defined background frequencies
print "<br/>";
unless ($params{title_choose}) {
	print ("<INPUT TYPE='radio' NAME='bg_method' VALUE='bgfile' $checked{bgfile}>");
	}
print ("<b>Genome subset</b> &nbsp; ", 
       $query->popup_menu(-name=>'background',
			  -Values=>["upstream-noorf","upstream","intergenic"],
			  -default=>$default{background}));
if ($params{taxon}){
	print "<br/>";
	print  "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
	print "<INPUT TYPE='radio' NAME='bg_taxo' VALUE='organism' $checked{organism}>";
	print &OrganismPopUpString();
	print  "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
	print "<INPUT TYPE='radio' NAME='bg_taxo' VALUE='taxon' $checked{taxon}>";
	&TaxonPopUp();
} else {
	print  &OrganismPopUpString();
	}

if ($params{strands}) {
	print "<B><A HREF='help.convert-background-model.html#item__2d1str'>Count on</A></b>\n";
	print $query->popup_menu(-name=>'strands',
			 -Values=>[
				   'single strand',
				   'both strands',
				  ],
			 -default=>$default{strands});
	print "&nbsp;&nbsp";
}
if ($params{noov}) {
	print ($query->checkbox(-name=>'noov',
			   -checked=>$default{noov},
			   -label=>''));
	print "<B><A HREF='help.convert-background-model.html#item__2dnoov'>prevent overlapping matches (noov)</A></b>\n";
	print "<br/>";
}

if ($params{title2}){
	if ($params{title_choose}) {
		print "<p><b> OR <b></p>";
		print ("<p/><INPUT TYPE='radio' NAME='bg_choose' VALUE='file_upload' $checked{'file_upload'}>");
	}
	print "<B>$params{title2}</B><br>";
}

#### custom background model
unless ($params{title_choose}) {
	print "<INPUT TYPE='radio' NAME='bg_method' VALUE='file_upload' $checked{file_upload}>";
}
print "<a href='help.matrix-scan.html#bg_file'>Upload your own file for the background model</a>", "&nbsp;"x5;
print "<br/><b>&nbsp;&nbsp;&nbsp;&nbsp;Format</b>&nbsp;";
#### bg format 
print $query->popup_menu(-name=>'bg_format',
			 -Values=>[
				   'oligo-analysis',
				   'MotifSampler',
				   'meme'
				  ],
			 -default=>$default{bg_format});

print $query->filefield(-name=>'upload_bgfile',
			-default=>'starting value',
			-size=>30,
			-maxlength=>200);

if ($params{sep_bg_pseudo}){
	print "<hr/>";
	}		
#### pseudo-counts
print "<p/>\n";
print "<B><A HREF='help.matrix-scan.html'>Pseudo-frequencies</A></b>\n";
print $query->textfield(-name=>'bg_pseudo',
			-default=>$default{bg_pseudo},
			-size=>5);
}

################################################################
## Print HTML header
sub html_header {
  my $header = "";
  $header .=  "<html>\n";
  $header .=  "<header>\n";
  $header .=  "<title>$infile{input}</title>\n";
  $header .= &sorttable_script();
  $header .=  "<header>\n";
  $header .=  "<body bgcolor='#ffffff'>\n";
  return $header;
}

################################################################
## Close HTML table
sub close_table_html {
  my $string = "";
  $string .=  "</BODY>";
  $string .=  "</HTML>";
  return $string;
}


################################################################
## Print a little java script produce a sortable HTML table
sub sorttable_script {
  my $script = $ENV{RSAT}."/perl-scripts/lib/sorttable.js";
  return `cat $script`;
}


################################################################
#### Print a text table in html format
##
## usage
##   PrintHtmlTable(FILE_HANDLE,$mirror_file)
## reads the content of FILEHANDLE and displays 
## it in the form of a HTML table.
## if $mirror_file is specified, a copy of the input text (without HTML formatting)  
## is saved on the hard drive
##
## global variables
## ================
## The fixed font type can be switched off 
## by specifiying a global variable 
##       $font{variable} = 1;
sub PrintHtmlTable {
    my ($FILE, $mirror_file, $mirror_verbose, $chunk, $out, $border) = @_;
    $out = STDOUT unless ($out);
    $chunk = 1000 unless (&IsNatural($chunk));
    my $line_count = 0;
    my $last_line = "";
    my $header_line = "";
    unless ($border) {
	$border=0;
    }

    $TABLE="<TABLE  class=\"sortable\"  CELLSPACING=1 CELLPADDING=3 BORDER=$border>";
    unless ($main::font{variable}) {
	$font_spec_start = "<TT>";
	$font_spec_end = "</TT>";
    }
    
    if ($mirror_file) {
	if (open MIRROR, ">$mirror_file") {
	    $mirror = 1;
	    &DelayedRemoval($mirror_file);
	} else {
	    &Warning("Could not open the mirror file $mirror_file<P>\n");
	}
    }

    print $out "<PRE>";
    while (<$FILE>) {
	s|$ENV{RSAT}/(public_html/)*||g; #### avoid exposing the full path through the web interface
	if ($mirror) {
	  print MIRROR $_
	    unless ((/^;/) && !($mirror_verbose)); 
	}
	if (/^\s*$/) {		#nothing on the line
	} elsif (/^;WARNING/) {		# warning
	  push @warnings, $_;
	} elsif ((/^;/) ||
		 (/^\-\-/) ||
		 (/^\#/) ||
		 (/^\/\//)) {		# comment line
	  if ($table_opened) {
	    print $out "<\/TABLE><PRE>\n";
	    $table_opened = 0;
	  }
	  $last_line =~ s/^;//;
	  $last_line =~ s/^#//;
	  $last_line =~ s/^--//;
	  print $out $last_line;
	  $last_line = $_;

	} elsif (!($table_opened)) { # first line of the table
	    $table_opened = 1;
	    $line_count = 0;
	    print $out "</PRE>\n\n$TABLE\n";

	    # print the header line
	    chomp($last_line);
	    $last_line =~ s/^;//;
	    $last_line =~ s/^#//;
	    $last_line =~ s/^--//;
	    $last_line =~ s/\t/ <\/TT><\/TH>\n<TH ALIGN=LEFT>$font_spec_start/g;
	    $header_line = "<TR VALIGN=top>\n<TH ALIGN=LEFT >".$font_spec_start.$last_line.$font_spec_end."</TH>\n</TR>\n\n";
	    print $out $header_line;
	    $last_line = "";
	    
	    ### print the first result line
	    chomp;
	    s/\t/ <\/TT><\/TD>\n<TD>$font_spec_start/g;
	    print $out "<TR VALIGN=top>\n<TD>".$font_spec_start;
	    print $out $_;
	    print $out $font_spec_end."</TD>\n</TR>\n\n";
	    
	} else {			# other line of the table
	    $line_count++;
	    if ($line_count%$chunk == 0) {
		### avoid HTML tables with too many rows
		print $out "</TABLE>\n\n$TABLE";
		print $out $header_line;
	    }
	    chomp;
	    s/\t/ <\/TT><\/TD>\n<TD>$font_spec_start/g;
	    print $out "<TR VALIGN=top>\n<TD>".$font_spec_start.$_.$font_spec_end."</TD>\n</TR>\n\n";
	}
    }
    if ($table_opened) {
	print $out "</TABLE>\n\n";
	print $out @warnings;
	print $out "<PRE>\n";
	$table_opened = 0;
    }
    print $out $last_line;
    print $out "</PRE>\n";
    if ($mirror_file ne "") {
	close MIRROR;
    }
}



################################################################
## Save the command string in a temporary file for debugging
sub SaveCommand {
    my ($command, $tmp_file_name) = @_;

    #### temporary file for storing the result
    unless ($tmp_file_name) {
	$tmp_file_name = sprintf "command.%s", &AlphaDate.".txt";
    }
    open CMD, ">${tmp_file_name}_command.txt";
    print CMD $command, "\n";
    close CMD;

}


################################################################
## Save the result in a temporary file on the server this file will be
## deleted after some delay
sub ServerOutput {
    #### redirect the task to email output
    &EmailTheResult(@_);

}

#### send e-mail with the result of a command
sub EmailTheResult {
    my ($command, $email_address, $tmp_file_name, %args) = @_;
    my $delay = "72 hours";
    my $mail_title = $args{title};
    unless ($mail_title) {
      $mail_title = join " ", "[RSAT]", $script_name, &AlphaDate();
    }
    $mail_command = "mail -s \'".$mail_title."\'";

    #### check the email address
    &CheckEmailAddress($email_address);

    #### temporary file for storing the result
    unless ($tmp_file_name) {
	$tmp_file_name = sprintf "result.%s", &AlphaDate.".txt";
    }
    my $result_URL = "$ENV{rsat_www}/tmp/$tmp_file_name";

    #### debugging: report the command
    print "<pre>$command > $TMP/$tmp_file_name</pre>" if ($ECHO >= 1);

    #### Indicate the URL of the future result file
    my $message = "The server is now processing your request.\n"; 
    $message .= "Once it will be finished, the result will become available at the following URL\n";
    $message .= "\t${result_URL}\n";
    $message .= "When the result will be ready, you will be warned at your email address ($email_address).\n";
    $message .= "The result file will remain on the server for $delay.\n";
    $html_message = $message;
    $html_message =~ s|(http://\S+)|<a href=$1>$1</a>|gm;

    &Info($html_message);

    #### concatenate the command with the email notification
    my $email_message = "Your result is available at the following URL:\n\t${result_URL}";
    $email_message .= "\nThe result file will remain there for $delay.";
    $email_command =  "$command | perl -pe 's|$ENV{RSAT}/(public_html/)*||g' > $TMP/$tmp_file_name; ";
    $email_command .= "echo \"$email_message\" | $mail_command $email_address &"; 
    print "<PRE>$email_command</PRE>" if ($ECHO >= 1);
    system $email_command;


    #### prepare removal of the temporary file
    &DelayedRemoval("$TMP/$tmp_file_name", $delay);
}

#### check email address format
sub CheckEmailAddress {
    my ($email_address) = @_;
    if ($email_address eq "") {
	&RSAT::error::FatalError ("You did not enter your e-mail address");
    } elsif ($email_address !~ /(\S+\@\S+)/) {
	&RSAT::error::FatalError ("The e-mail address you entered is not valid: $email_address");
    }
}


sub SelectFormat {
    my($in_format) = lc($_[0]);

    #### update the sequence format in a web form
    $form =~  s/ selected>Wconsensus/>Wconsensus/i; 
    $form =~  s/ selected>Fasta/>Fasta/i; 
    $form =~  s/ selected>NCBI/>NCBI/i; 
    $form =~  s/ selected>IG/>IG/i; 
    $form =~  s/ selected>raw/>raw/i; 
    $form =~  s/ selected>multi/>multi/i; 
    if ($in_format =~ /fasta/i) {
	$form =~  s/\>Fasta/ SELECTED\>Fasta/i; 
    } elsif ($in_format =~ /multi/i) {
	$form =~  s/\>multi/ SELECTED\>multi/i; 
    } elsif ($in_format =~ /raw/i) {
	$form =~  s/\>raw/ SELECTED\>raw/i; 
    } elsif ($in_format =~ /^wc/i) {
	$form =~  s/\>Wconsensus/ SELECTED\>Wconsensus/i; 
    } elsif ($in_format =~ /ig/i) {
	$form =~  s/\>IG/ SELECTED\>IG/i; 
    }    
}



################################################################
#
# Pipe the result to another command
#
sub PipingFormForSequence {

    ## Choose organism-specific or alternative background
    if ($query->param('single_multi_org') eq 'multi') {

#	$oligo_background_model = "<INPUT type=\"hidden\" NAME=\"freq_estimate\" VALUE=\"Residue frequencies from input sequence\">";
#	$dyad_background_model = "<INPUT type=\"hidden\" NAME=\"freq_estimate\" VALUE=\"monads\">";
      $oligo_background_model = "<INPUT type=\"hidden\" NAME=\"freq_estimate\" VALUE=\"background\">";
      $oligo_background_model .= "<INPUT type=\"hidden\" NAME=\"bg_level\" VALUE=\"taxon\">";
      $oligo_background_model .= "<INPUT type=\"hidden\" NAME=\"taxon\" VALUE=".$query->param('taxon').">";
      $dyad_background_model = "<INPUT type=\"hidden\" NAME=\"freq_estimate\" VALUE=\"background\">";
      $dyad_background_model .= "<INPUT type=\"hidden\" NAME=\"bg_level\" VALUE=\"taxon\">";
      $dyad_background_model .= "<INPUT type=\"hidden\" NAME=\"taxon\" VALUE=".$query->param('taxon').">";
    } else {

      #### choose background model for oligo-analysis
      if ($seq_type =~ /upstream/) {
	if ($noorf) {
	  $background = "upstream-noorf";
	} else {
	  $background = "upstream";
	}
      } elsif ($seq_type =~ /protein/) {
	$background = "protein";
      } else {
	$background = "upstream-noorf";
      }
      $oligo_background_model = "\n<INPUT type=\"hidden\" NAME=\"background\" VALUE=\"$background\">";
      $dyad_background_model = $oligo_background_model;
    }


  print qq|;
<HR SIZE = 3>
<table class = "nextstep">
<tr><td colspan = 5><h3>next step</h3></td></tr>


<tr valign="top" align="center">

    <th align=center>
      	<font size=-1>
	String-based<br>
	Pattern Discovery<br>
	(unknown patterns)
	</font>
    </th>

    <td align=center>
	<FORM METHOD="POST" ACTION="oligo-analysis_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
        <INPUT type="hidden" NAME="sequence_type" VALUE="$seq_type">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="background" VALUE="$background">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	$oligo_background_model
	<INPUT type="submit" value="oligo-analysis">
	</FORM>
	Over- or under-represented words
    </td>
|;
    if ($seq_type eq "protein") {
      print "</tr>";
    } else {
    print <<End_of_form;
    <td align=center>
	<FORM METHOD="POST" ACTION="dyad-analysis_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	$dyad_background_model
	<INPUT type="submit" value="dyad analysis">
	</FORM>
	Overrepresented spaced pairs
    </td>

    <td align=center>
	<FORM METHOD="POST" ACTION="position-analysis_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	<INPUT type="hidden" NAME="background" VALUE="$background">
	<INPUT type="submit" value="position analysis">
	</FORM>
	Positionally biased words
    </td>

    <td align=center>
	<FORM METHOD="POST" ACTION="ORM_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	$oligo_background_model
	<INPUT type="submit" value="ORM">
	</FORM>
	<b><font color=red>New !</font></b>
	Windows of word over-representation
    </td>

</tr>

<tr valign="top" align="center">

    <th align=center>
      	<font size=-1>
	<B>Matrix-based<br>
	 Pattern Discovery</B><BR>
	(unknown patterns)
	</font>
    </th>

    <td align=center>
	<FORM METHOD="POST" ACTION="consensus_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	<INPUT type="submit" value="consensus">
	</FORM>
	Greedy algorithm
    </td>

    <td align=center>
	<FORM METHOD="POST" ACTION="gibbs_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	<INPUT type="submit" value="gibbs sampler">
	</FORM>
	Gibbs sampling (1995 version)
    </td>

</tr>

<tr valign="top" align="center">

    <th align=center>
      	<font size=-1>
	<B>Pattern matching</B><BR>
	(known patterns)
	</font>
    </td>


    <td align=center>
	<FORM METHOD="POST" ACTION="dna-pattern_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	<INPUT type="submit" value="dna-pattern">
	</FORM>
	Regular expressions and IUPAC search.
    </td>

    <td align=center>
        <FORM METHOD="POST" ACTION="matrix-scan_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	<INPUT type="submit" value="matrix-scan (matrices)">
	</FORM>
	<b><font color=red>New !</font></b>
	Position-specific scoring matrices
    </td>

    <td align=center>
	<FORM METHOD="POST" ACTION="patser_form.cgi">
	<INPUT type="hidden" NAME="organism" VALUE="$organism_name">
        <INPUT type="hidden" NAME="taxon" VALUE="$taxon">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	<INPUT type="submit" value="patser (matrices)">
	</FORM>
	Position-specific scoring matrices
    </td>


    <td align=center>
    &nbsp;
    </td>

    <td align=center>
    &nbsp;
    </td>

</tr>


<tr valign="top" align="center">

    <th align=center>
      	<font size=-1>
	<B>Utilities</B>
	</font>
    </th>

    <td align=center>
	<FORM METHOD="POST" ACTION="purge-sequence_form.cgi">
	<INPUT type="hidden" NAME="sequence_file" VALUE="$sequence_file">
	<INPUT type="hidden" NAME="sequence_format" VALUE="$out_format">
	<INPUT type="submit" value="purge sequence">
	</FORM>
	Mask redundant fragments. 
    </td>

    <td align=center>
    &nbsp;
    </td>

    <td align=center>
    &nbsp;
    </td>
</tr>


</table>
End_of_form
    }
}


################################################################
## Background models based on a genome subset
sub PrintGenomeSubsetBgOptions {
  $checked{$default{bg_level}} = "CHECKED";
  $checked{$default{freq_estimate}} = "CHECKED";

  #### Calibrated on genome subsets
  print( "<br><input type='radio' NAME='freq_estimate' VALUE='background' $checked{background}>");
  print ("<b>Genome subset</b>");
#  print "<ul>";
  print ( "&nbsp;&nbsp;<a href='help.oligo-analysis.html#background'>Sequence type</a> &nbsp;&nbsp;&nbsp;&nbsp;", 
	  $query->popup_menu(-name=>'background',
			     -Values=>["upstream","upstream-noorf","protein"],
			     -default=>$default{background}));


  print ("<ul>");
  print( "<input type='radio' NAME='bg_level' VALUE='organism' $checked{organism}>", &OrganismPopUpString());
  print( "<br><input type='radio' NAME='bg_level' VALUE='taxon' $checked{taxon}>", &TaxonPopUpString("node"));
  print ("</ul>");
#  print "</ul>";


  print "<p>";
}

################################################################
## Background model options for oligo-analysis + ORM
sub PrintOligoBackgroundOptions {
  $checked{$default{freq_estimate}} = "CHECKED";
  print "<a href='help.oligo-analysis.html#exp_freq'><B>Background model</b></a>&nbsp;";
  &PrintGenomeSubsetBgOptions();

  #### Estimated from the input sequence set

  print ("<br><b>Estimate from input sequence</b>");

  ## Markov chain model
  print ("<br><input type='radio' NAME='freq_estimate' VALUE='Markov Chain (higher order dependencies)' $checked{'Markov Chain (higher order dependencies)'}>", 
	 "Markov Chain (higher order dependencies)");

  print "&nbsp;&nbsp;order &nbsp;";
  print $query->textfield(-name=>'markov_order',
			  -default=>$default{markov_order},
			  -size=>5);

  #### Lexicon partitioning
  #print "<br><input type='radio' NAME='freq_estimate' VALUE='Lexicon partitioning' $checked{'Lexicon partitioning'}>Lexicon partitioning<p>";

  #### Bernouilli model
  #print "<br><input type='radio' NAME='freq_estimate' VALUE='Residue frequencies from input sequence' $checked{'Residue frequencies from input sequence'}>Residue frequencies from input sequence<p>";

  #### equiprobable residues
  print "<br><input type='radio' NAME='freq_estimate' VALUE='Equiprobable residues' $checked{'Equiprobable residues'}>Equiprobable residues (<A HREF='help.oligo-analysis.html#equiprobable'>usually NOT recommended</a>)<p>";

  #### custom expected frequency file
  print ("<a href='help.oligo-analysis.html#upload_freq_file'><b>Upload your own expected frequency file</b></a><BR>");
  print ("<br><input type='radio' NAME='freq_estimate' VALUE='file_upload' $checked{'file_upload'}>");
  print ($query->filefield(-name=>'upload_freq_file',
			   -default=>'starting value',
			   -size=>30,
			   -maxlength=>200));
  print "<p>";
}


################################################################
## Load default prameters for dyad-analysis form
sub LoadDyadDefault {
  ### default values for filling the form
  $default{organism} = "Saccharomyces cerevisiae";
  $default{freq_estimate} = "background";
  $default{background} = "upstream-noorf";
  $default{bg_level} = "organism";
  #$default{title} = "";
  $default{sequence} = "";
  $default{sequence_format} = "fasta";
  $default{sequence_file} = "";
  $default{upload_file} = "";
  $default{oligo_size} = 3;
  $default{spacing_from} = 0;
  $default{spacing_to} = 20;
  $default{strand} = "both strands";
  $default{noov} = 'checked';
  $default{purge} = 'checked';
  $default{dyad_type} = "any dyad";
  $default{exp_freq} = "background";
  $default{upload_freq_file} = "";
  #$default{lth_occ_sig} = "0";
  $default{to_matrix} = 0;

  ## Return values and thresholds
  $default{zscore} = '';
  $default{lth_zscore} = 'none';
  $default{uth_zscore} = 'none';

  $default{rank} = 'checked';
  $default{lth_rank} = "none";
  $default{uth_rank} = "none";

  $default{ratio} = '';
  $default{lth_ratio} = "none";
  $default{uth_ratio} = "none";

  $default{occ} = 'checked';
  $default{lth_occ} = "1";
  $default{uth_occ} = "none";

  $default{proba} = 'checked';
  $default{lth_occ_P} = "none";
  $default{uth_occ_P} = "none";

  $default{eval} = 'checked';
  $default{lth_occ_E} = "none";
  $default{uth_occ_E} = "none";

  $default{lth_occ_sig} = "0";
  $default{uth_occ_sig} = "none";

  $default{freq} = '';
  $default{lth_observed_freq} = "none";
  $default{uth_observed_freq} = "none";
}

################################################################
## Print background model optiosn for dyad-analysis
sub PrintDyadBackgroundOptions {
  $checked{$default{freq_estimate}} = "CHECKED";
  print "<A HREF='help.oligo-analysis.html#exp_freq'><B>Background model</B></A>&nbsp;<p>";

  &PrintGenomeSubsetBgOptions();

  print ( "<INPUT TYPE='radio' NAME='freq_estimate' VALUE='monads' $checked{monads}>",
	  "<b>Monad frequencies from the input sequence</b>");

  print "<BR>\n";

  print ("<a href='help.dyad-analysis.html#upload_freq_file'><b>Upload your own expected frequency file</b></a><BR>");
  print ("<br><input type='radio' NAME='freq_estimate' VALUE='file_upload' $checked{'file_upload'}>");
  print ($query->filefield(-name=>'upload_freq_file',
			   -default=>'starting value',
			   -size=>30,
			   -maxlength=>200));
  print "<p>";

}


################################################################
## Table with all the return fields and thresholds for dyad-analysis
sub PrintDyadReturnFields {
  my (%args) = @_;
#  print "<p><br>\n";

  print $query->table({-border=>0,-cellpadding=>2,-cellspacing=>0, -bgcolor=>'#FFFFFF'},
		      $query->Tr({-align=>left,-valign=>TOP},
				 [
				  $query->th(["<a href='help.oligo-analysis.html#return_fields'><b>Return fields</b></a>",
					      " <a href='help.oligo-analysis.html#thresholds'>Lower<br>Threshold</a> ",
					      " <a href='help.oligo-analysis.html#thresholds'>Upper<br>Threshold</a> "]),

				  ### occurrences
				  $query->td([$query->checkbox(-name=>'occ',
							       -checked=>$default{occ},
							       -label=>' Occurrences '),
					      $query->textfield(-name=>'lth_occ',
								-default=>$default{lth_occ},
								-size=>5),
					      $query->textfield(-name=>'uth_occ',
								-default=>$default{uth_occ},
								-size=>5)
					     ]),

				  ### binomial proba
				  $query->td([$query->checkbox(-name=>'proba',
							       -checked=>$default{proba},
							       -label=>' Binomial proba '),
					      $query->textfield(-name=>'lth_occ_P',
								-default=>$default{lth_occ_P},
								-size=>5),
					      $query->textfield(-name=>'uth_occ_P',
								-default=>$default{uth_occ_P},
								-size=>5)]),
				  ### binomial E-value
				  $query->td([$query->checkbox(-name=>'eval',
							       -checked=>$default{eval},
							       -label=>' Binomial E-value '),
					      $query->textfield(-name=>'lth_occ_E',
								-default=>$default{lth_occ_E},
								-size=>5),
					      $query->textfield(-name=>'uth_occ_E',
								-default=>$default{uth_occ_E},
								-size=>5),
					     ]),

				  ### significance index
				  $query->td([$query->checkbox(-name=>'proba',
							       -checked=>$default{proba},
							       -label=>' Significance '),
					      $query->textfield(-name=>'lth_occ_sig',
								-default=>$default{lth_occ_sig},
								-size=>5),
					      $query->textfield(-name=>'uth_occ_sig',
								-default=>$default{uth_occ_sig},
								-size=>5)
					     ]),

				  ### Z-scores
				  $query->td([$query->checkbox(-name=>'zscore',
							       -checked=>$default{zscore},
							       -label=>' Z-scores '),
					      $query->textfield(-name=>'lth_zscore',
								-default=>$default{lth_zscore},
								-size=>5),
					      $query->textfield(-name=>'uth_zscore',
								-default=>$default{uth_zscore},
								-size=>5)
					     ]),

				  ### frequencies
				  $query->td([$query->checkbox(-name=>'freq',
							       -checked=>$default{freq},
							       -label=>' Frequencies '),
					      $query->textfield(-name=>'lth_observed_freq',
								-default=>$default{lth_observed_freq},
								-size=>5),
					      $query->textfield(-name=>'uth_observed_freq',
								-default=>$default{uth_observed_freq},
								-size=>5)
					     ]),


				  ### ratio
				  $query->td([$query->checkbox(-name=>'ratio',
							       -checked=>$default{ratio},
							       -label=>' Obs/exp ratio '),
					      $query->textfield(-name=>'lth_ratio',
								-default=>$default{lth_ratio},
								-size=>5),
					      $query->textfield(-name=>'uth_ratio',
								-default=>$default{uth_ratio},
								-size=>5)
					     ]),

				  ### rank
				  $query->td([$query->checkbox(-name=>'rank',
							       -checked=>$default{rank},
							       -label=>' Rank '),
					      $query->textfield(-name=>'lth_rank',
								-default=>$default{lth_rank},
								-size=>5),
					      $query->textfield(-name=>'uth_rank',
								-default=>$default{uth_rank},
								-size=>5)
					     ]),

				 ]
				)
		     );

  #### Convert patterns to matrix
  unless ($args{no_matrix}) {
    print $query->checkbox(-name=>'to_matrix',
			   -checked=>$default{to_matrix},
			   -label=>'');
    print "&nbsp;Convert assembled patterns to Position-Specific Scoring Matrices (<font color=red>Can be time-consuming</font>)";
    print "<BR>";
  }
}




1; # return true

