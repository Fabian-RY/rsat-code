#!/usr/bin/perl -w

############################################################
#
# $Id: download-ensembl-variations,v 1.10 2013/06/24 14:44:36 rsat Exp $
#
############################################################

use warnings;

=pod

=head1 NAME

download-ensembl-variations

=head1 VERSION

$program_version

=head1 DESCRIPTION

Download gvf file of variations from ensembl, decompress the file,
remove variations that fail the quality check.

Create "super-variations" from sets of overlapping variations.  Write
new variation file with one file per chromosome plus a separate file
for the removed variations.

 /!\

Sequences need to be installed in raw format for the species of
interest before using download-ensembl-variations.

=head1 AUTHORS

Jeremy.Delerce@univ-amu.fr

=head1 CATEGORY

=over

=item util

=back

=head1 USAGE

 download-ensembl-variations -species # [-genomesdir #] [-available_species] [-v #]

=head2 Example

	Get variation for a given species
		download-ensembl-variations -species Homo_sapiens

=head1 OUTPUT FORMAT

A tab delimited file with the following column content.

=head 2 GOOD VARIATION

=over

=item 1. chrom

The name of the chromosome (e.g. 1, X, 8...)

=item 2. chromStart

The starting position of the feature in the chromosome

=item 3. chromEnd

The ending position of the feature in the chromosome

=item 4. chromStrand

The strand of the feature in the chromosome

=item 5. varId

The id of the variation(s)

=item 6. refSeq

Reference sequence of the variation

=item 7. varSeq

Sequence of all the variant

=item 8. type

Type of the variation

=item 9. validate

If the variation is validate.
Go to the following link to see all validation state :
http://www.ncbi.nlm.nih.gov/projects/SNP/snp_legend.cgi?legend=validation

=item 10. isSpVar

If the variation is a super-variation

=item 11. inSpVar

If the variation is in a super-variation

=back

=head 2 Failed VARIATION

=over

=item 1. chrom

The name of the chromosome (e.g. 1, X, 8...)

=item 2. chromStart

The starting position of the feature in the chromosome

=item 3. chromEnd

The ending position of the feature in the chromosome

=item 4. chromStrand

The strand of the feature in the chromosome

=item 5. varId

The id of the variation(s)

=item 6. description

Why the variation is remove

=back

=head1 SEE ALSO

=head2 download-ensembl-genome

I<download-ensembl-variations> uses the sequences downloaded
from Ensembl using the tool I<download-ensembl-genome>.

=head2 retrieve-variation-seq

I<retrieve-variation-seq> uses files product by I<download-ensembl-variations>
to make all the sequence of a variation.

=head2 variation-scan

Scan SNP sequences with one or several position-specific scoring
matrices.

=head1 WISH LIST

=cut

BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
  push (@INC, "../rsa-tools/perl-scripts/lib");
}

require "RSA.lib";
require "RSAT_to_ensembl.lib.pl";
use File::Path qw( mkpath );

################################################################
## Main package
package	main;
{

  ###############################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.10 $ =~ /\d+/g); sprintf"%d."."%02d" x $#r, @r };

  our %outfile = ();

  our $verbose = 2;
  our $out = STDOUT;
  our $genomes_dir = "$ENV{'RSAT'}/data/genomes/";

  our $species = "";
  our $available = 0;
  our $ref_seq = "";
  our $ensembl_version = "safe";


  ################################################################
  ## Read argument values
  &ReadArguments();

  if ($ensembl_version eq "safe") {
    $ensembl_version = &Get_ensembl_version_safe();
  } elsif ($ensembl_version eq "latest") {
    $ensembl_version = &Get_ensembl_version();
  } else {
      &RSAT::error::FatalError("$ensembl_version not supported. Minimun version is 60.") if ($ensembl_version < 60);
  }

  ################################################################
  ##Print available species
  my $variation_rsync = &Get_variation_rsync($ensembl_version);

  if ($available) {
    my @available_species = qx{rsync -navP $variation_rsync "."};
    foreach (@available_species) {
      next if (/\./);
      next unless (/\/\n/);
      my ($species) = split("\/");
      print ucfirst($species),"\n";
    }
    exit(0);	
  }

  ################################################################
  ## Check argument values
  
  unless ($species) {
    &RSAT::error::FatalError("No species indicate. Use -species");
  }

  # Check if variation available on Ensembl
  my @available_species = qx{rsync -navP $variation_rsync "."};

  unless ( grep($_ = $species."\/\n", @available_species )) {
    &RSAT::error::FatalError("No variation avalaible for $species on Ensembl");
  }


  # Get url
  my $species_fasta_rsync = &Get_species_rsync(&Get_fasta_rsync($ensembl_version),$species,'fasta',$ensembl_version);
  my $species_variation_rsync = &Get_species_rsync($variation_rsync,$species,'variation',$ensembl_version);
  my $species_gvf_rsync = &Get_gvf_rsync($species_variation_rsync,$species,$ensembl_version);
  &RSAT::message::Info("Species dna URL", $species_fasta_rsync) if ($main::verbose >= 1);
  &RSAT::message::Info("Species variation URL", $species_variation_rsync) if ($main::verbose >= 1);
  &RSAT::message::Info("Species gvf URL", $species_gvf_rsync) if ($main::verbose >= 1);

  # Get genome version
  my $assembly_version = &Get_assembly_version($species_fasta_rsync, ucfirst($species));


  # Check if genome version install
  my $species_dir = &Get_species_dir(ucfirst($species),$assembly_version);
  my $genome_dir = &Get_genome_dir($species, $assembly_version);

  &RSAT::error::FatalError("$species $assembly_version not find in supported_organisms_ensembl.tab. Use download-ensembl-genome before download-ensembl-variations.") unless ($species_dir);
  &RSAT::error::FatalError("$genome_dir don't exist. Use download-ensembl-genome before download-ensembl-variations.") unless (-d $genome_dir);

  # Check if sequence file are not missing
  my %chr_file = &Get_file_seq_name($genome_dir);

  foreach my $file (keys(%chr_file)) {
    unless (-f $genome_dir.$chr_file{$file}) {
      &RSAT::error::FatalError($genome_dir.$chr_file{$file}, " is missing.");
    }
  }


  ################################################################
  ###Dowload variation file
  &RSAT::message::TimeWarn("Download gvf file") if ($main::verbose >= 2);
  my $variation_dir = &Get_variation_dir($species_dir);

  &RSAT::util::CheckOutDir($variation_dir);
  system("rsync -avP $species_gvf_rsync $variation_dir");


  ################################################################
  ## Decompress variation file
  &RSAT::message::TimeWarn("Decompress gvf file") if ($main::verbose >= 2);
  system ("gzip -dv $variation_dir/*.gz");

  ################################################################
  ## Execute the command
  &RSAT::message::TimeWarn("Filter variation and make super-variation") if ($main::verbose >= 2);
  my $out_rm = &OpenOutputFile($variation_dir."/Failed.tab");

  my $last_chr = "";
  my $last_end = 0;
  my $last_rs = "";
  my @super_variation = ();

  my ($file) = &OpenInputFile($variation_dir."/".ucfirst($species).".gvf");
  while (<$file>) {
    next if (/^#/);

    chomp();

    ##Get variation info
    my ($chr,$db,$type,$start,$end,$score,$strand,$phase,$attributes) = split("\t");
    my %info = ();
    foreach my $token (split(";",$attributes)) {
      my ($cle,$value) = split("=",$token);
      $info{$cle} = $value;
    }

    ##Change validation_state format
    if ($info{'validation_status'} || $info{'validation_states'}) {
      $info{'validation_status'} = 1;
    } else {
      $info{'validation_status'} = 0;
    }

    ##Get reference sequence
    if ($last_chr ne $chr) {

      &SVariation($last_chr, $last_end,@super_variation) unless ( scalar(@super_variation) == 0);

      $last_chr = $chr;
      $last_end = 0;
      @super_variation = ();

      close $out unless ($out eq STDOUT);

      my $raw_file = $species_dir."/genome/".$chr_file{$chr};
      $ref_seq = qx($ENV{'RSAT'}/perl-scripts/sub-sequence -i $raw_file -from 1 -to 500000000 -format raw);

      $out = &OpenOutputFile("$variation_dir/$chr.tab");
      &RSAT::message::TimeWarn("Analyse variation on chromosome : $chr") if ($main::verbose >= 2);
    }

    ################################################################
    ##Remove bug line

    ##Ensembl 71
    unless ($info{'Dbxref'}) {
      next;
    }

    if ($end < $last_end) {
      next;
    }

    ##Ensembl 70
    my ($version,$rs) = split(":",$info{'Dbxref'});
    if ( $last_rs eq $rs) {
      next;
    }

    ################################################################
    ##Remove non-analysable variation
    if ( $info{'Reference_seq'} =~ /[^ACGT\-]/) {
      print $out_rm $chr."\t".$start."\t".$end."\t".$strand."\t".$rs;
      print $out_rm "\tReference variant $info{'Reference_seq'} does not only contain A,C,G,T,-\n";
      next;
    }

    if ( $info{'Variant_seq'} =~ /[^ACGT\-,]/) {
      print $out_rm $chr."\t".$start."\t".$end."\t".$strand."\t".$rs;
      print $out_rm "\tAlternative variant $info{'Variant_seq'} does not only contain A,C,G,T,-\n";
      next;
    }

    if ( $end-$start+1 != length($info{'Reference_seq'}) ) {
      print $out_rm $chr."\t".$start."\t".$end."\t".$strand."\t".$rs;
      print $out_rm "\tLength of the variation ".($end-$start+1)." ($start-$end) not identical to the length of reference seq ".(length($info{'Reference_seq'}))." ($info{'Reference_seq'})\n";
      next;
    }

    if ( $info{'Reference_seq'} ne "-" && ($info{'Reference_seq'} ne substr($ref_seq,$start-1,$end-$start+1))) {
      print $out_rm $chr."\t".$start."\t".$end."\t".$strand."\t".$rs;
      print $out_rm "\tReference sequence $info{'Reference_seq'} do not match Sequence file ".substr($ref_seq,$start-1,$end-$start+1)."\n";
      next;
    }

    ########################
    #Check if the variation is not a part of a super_variation
    if ( $start <= $last_end ) {
      $last_end=$end if ($last_end < $end);	  	
    } else {
      &SVariation($chr, $last_end,@super_variation) unless ( scalar(@super_variation) == 0);
      $last_end=$end;
      @super_variation = ();
    }

    $last_rs = $rs;
    push (@super_variation,$chr."\t".$start."\t".$end."\t".$strand."\t".$rs."\t".$info{'Reference_seq'}."\t".$info{'Variant_seq'}."\t".$type."\t".$info{'validation_status'});
  }

  &SVariation($last_end,@super_variation);


  close $file;
  unlink($variation_dir."/".ucfirst($species).".gvf");

  &RSAT::message::Info("Variations installed in dir", $variation_dir) if ($main::verbose >= 1);

  ################################################################
  ## Report execution time and close output stream
  my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
  print $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified
  close $out;

  exit(0);
}


################################################################
################### SUBROUTINE DEFINITION ######################
################################################################

################################################################
## Display full help message
sub PrintHelp {
  system "pod2text -c $0";
  exit(0);
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
sub SVariation {
  my ($chr, $last_end, @super_variation) = @_;

  ##Make super-var list
  my @super_variation_validates = ();
  my @super_variation_validate = ();
  my @outside_insert_validate = ();
  my @outside_insert = ();
  my $super_validate_end = 0;
  my $ii = 0;

  if ( scalar(@super_variation) >1 ) {
    for (my $i=0; $i<scalar(@super_variation) ; $i++) {
      my @var_info = split("\t",$super_variation[$i]);

      #Remove insertion outside super_variation
      if ( $var_info[5] eq "-" && $var_info[1]+1 > $last_end) {
	push (@outside_insert, $super_variation[$i]);
	splice(@super_variation, $i, 1);
	$i--

	  #Make super-var with only validate variation
      } elsif ($var_info[8] == 1) {

	if ( scalar(@super_variation_validate) == 0) {
	  @super_variation_validate = ($super_variation[$i]);
	  $super_validate_end = $var_info[2];

	} elsif ( $var_info[1] < $super_validate_end ) {
	  push (@super_variation_validate, $super_variation[$i]);
	  $super_validate_end = $var_info[2] if ($super_validate_end < $var_info[2]);

	} else {
	  push(@{$super_variation_validates[$ii]}, @super_variation_validate);
	  @super_variation_validate = ($super_variation[$i]);
	  $ii++;
	}
      }
    }
    push(@{$super_variation_validates[$ii]}, @super_variation_validate) unless ( scalar(@super_variation_validate) == 0);
  }

  #Check if insertion not form a super variation.
  foreach (@outside_insert) {
    my @var_info = split("\t");
    push (@outside_insert_validate, $_) if ($var_info[8]==1);
  }


  ####################
  ##Make print line
  %line_to_print = ();

  if ( scalar(@super_variation) > 1) {

    #Variation in the super variation
    foreach my $line (@super_variation) {
      my @info = split("\t",$line);
      $info[1]++ if ($info[5] eq '-');
      push (@{$line_to_print{$info[1]}{$info[2]}}, join("\t",@info)."\t0\t1\n");
    }

    #Super variation
    if ( scalar(@super_variation_validates) == 1) {

      if ( scalar(@{$super_variation_validates[0]}) == scalar(@super_variation)) {
	my @info = split("\t", &MakeSuperVar(@{$super_variation_validates[0]} ));
	push (@{$line_to_print{$info[0]}{$info[1]}}, "$chr\t".join("\t",@info)."\t1\t1\t0\n");

      } else {
	my @info = split("\t",&MakeSuperVar(@super_variation));
	push (@{$line_to_print{$info[0]}{$info[1]}}, "$chr\t".join("\t",@info)."\t0\t1\t0\n");
      }

    } else {

      if ( scalar(@super_variation_validates) >= 1) {

	foreach (@super_variation_validates) {
	  if ( scalar(@{$_}) > 1) {
	    my @info = split("\t", &MakeSuperVar(@{$_} ));
	    push (@{$line_to_print{$info[0]}{$info[1]}}, "$chr\t".join("\t",@info)."\t1\t1\t1\n");
	  }
	}
      }

      my @info = split("\t",&MakeSuperVar(@super_variation));
      push (@{$line_to_print{$info[0]}{$info[1]}}, "$chr\t".join("\t",@info)."\t0\t1\t0\n");
    }

  } elsif ( scalar(@super_variation) == 1) {
    my @info = split("\t",$super_variation[0]);
    $info[1]++ if ($info[5] eq '-');
    push (@{$line_to_print{$info[1]}{$info[2]}}, join("\t",@info)."\t0\t0\n");
  }

  #Outside insert
  if ( scalar(@outside_insert) >= 1) {

    if ( scalar(@outside_insert) == 1) {
      my @info = split("\t",$outside_insert[0]);
      $info[1]++;
      push (@{$line_to_print{$info[1]}{$info[2]}}, join("\t",@info)."\t0\t0\n");

    } else {

      foreach (@outside_insert) {
	my @info = split("\t");
	$info[1]++;
	push (@{$line_to_print{$info[1]}{$info[2]}}, join("\t",@info)."\t0\t1\n");
      }

      if (scalar(@outside_insert) > scalar(@outside_insert_validate)) {
	my @info = split("\t",&MakeSuperVar(@outside_insert));
	push (@{$line_to_print{$info[0]}{$info[1]}}, "$chr\t".join("\t",@info)."\t0\t1\t0\n");

      } elsif (scalar(@outside_insert_validate) > 1) {
	my @info = split("\t",&MakeSuperVar(@outside_insert_validate));
	push (@{$line_to_print{$info[0]}{$info[1]}}, "$chr\t".join("\t",@info)."\t1\t1\t0\n");
      }
    }
  }

  ### Print
  my @sorted_start = sort{$a<=>$b} ( keys( %line_to_print ) );
  foreach my $start ( @sorted_start ) {
    my @sorted_end = sort{$a<=>$b} ( keys( %{$line_to_print{$start}} ) );

    foreach my $end ( @sorted_end ) {
      print $out @{$line_to_print{$start}{$end}};
    }
  }
}

################################################################
##Create Super-variation
sub MakeSuperVar {
  my $super_start=0;
  my $super_end=0;
  my @super_strand = ();
  my @super_rs = ();
  my @super_types =();

  foreach my $line (@_) {
    my @var_info = split("\t",$line);
    $var_info[1] ++ if ($var_info[5] eq "-");

    ##Get coord
    $super_end = $var_info[2] if ($var_info[2] > $super_end);
    $super_start = $var_info[1] if ($var_info[1] < $super_start || $super_start == 0);

    ##Get strand
    push (@super_strand,$var_info[3]) unless (grep ($_ eq $var_info[3], @super_strand));

    ##Get rs
    push (@super_rs,$var_info[4]);

    ##Get type
    push (@super_types,$var_info[7]) unless (grep ($_ eq $var_info[7], @super_types));
  }

  ##Get ref seq
  my $super_ref = substr($ref_seq,$super_start-1,$super_end-$super_start+1);

  ##Get variants
  my @list_variants = ();
  @list_variants = GetAlternate($super_ref,$super_start-2,$super_start,$super_end,\@_,\@list_variants);

  ##Get type
  my $super_type = 'subsitution';

  if (scalar(@super_types) == 1) {
    $super_type = $super_types[0];

  } else {
    foreach (@list_variants) {
      my $len = length($_);
      $len -- if ($_ eq "-");

      unless (length($super_ref) == length($_)) {
	$super_type = 'sequence_alteration';
	last;
      }
    }
  }

  $super_ref = "-" if (length($super_ref) == 0);

  return $super_start."\t".$super_end."\t".join('/',@super_strand)."\t".join(',',@super_rs)."\t".$super_ref."\t".join(',',@list_variants)."\t".$super_type;
}

################################################################
## Get Alternatif Variant
sub GetAlternate {
  my ($ref_variant,$last_end,$super_start,$super_end,$list_variations,$list_variants) = @_;

  @list_variations = @{$list_variations};
  @list_variants = @{$list_variants};

  for (my $i = 0; $i < scalar(@list_variations);$i++ ) {
    my @var_info = split("\t",$list_variations[$i]);

    if ( $var_info[1] > $last_end) {
      $var_info[1] ++ if ($var_info[5] eq "-");

      foreach my $variant (split(",", $var_info[6])) {
	$var = substr($ref_variant,0, length($ref_variant) - ($super_end-$var_info[1]+1) ).$variant.substr( $ref_variant, length($ref_variant) - ($super_end-$var_info[2]) );
	$var =~ s/\-//g if (length($var)>1);

	push (@list_variants, $var ) unless (grep ($_ eq $var, @list_variants));
	@list_variants = GetAlternate($var,$var_info[2],$super_start,$super_end,\@list_variations,\@list_variants);
      }

      @list_variants = GetAlternate($ref_variant,$var_info[2],$super_start,$super_end,\@list_variations,\@list_variants);
    }
  }
  return (@list_variants);
}


################################################################
## Read arguments
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();

=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-species species_name>

Species that you want download variation (Homo_sapiens, Mus_musculus).

Help : Use I<> to get avalaible species

=cut
    } elsif ($arg eq "-species") {
      $main::species = lc(shift(@arguments));

=pod

=item B<-genomesdir #>

The directory in wich genomes are install.

Default : $RSAT/data/genomes/

=cut
    } elsif ($arg eq "-genomesdir") {
      $main::genomes_dir = shift(@arguments);

=pod

=item B<-available_species>

Get all available species on Ensembl

=cut
    } elsif ($arg eq "-available_species") {
      $main::available = 1;

=pod

=item B<-version #>

The release version of ensEMBL.

Supported versions: 70 to 72, safe, latest

Default : I<safe>

=over

=item I<safe>

The file locations and/or formats of the Ensembl rsync distribution
may change between two Ensembl release.

For this reason, we defined the "safe" version, which corresponds to
the latest version of ensembl which has been checked to work with this
script.

=item latest

This corresponds to the lastest version of Ensembl. Beware: this
version is not guaranteed to be compatible with RSAT, in case Ensembl
would change their file formats or locations.

=cut
    } elsif ($arg eq "-version") {
      my $version = shift(@arguments);
      if ( &IsNatural($version) || $version eq "safe" || $version eq "latest" ) {
        $main::ensembl_version = $version;
      } else {
        &RSAT::error::FatalError($version,"is not supported");
      }

    } else {
      &FatalError(join("\t", "Invalid option", $arg));
    }
  }

=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
  print "; download-ensembl-variations ";
  &PrintArguments($out);

  if (%main::outfile) {
    print "; Output files\n";
    while (my ($key,$value) = each %main::outfile) {
      printf ";\t%-13s\t%s\n", $key, $value;
    }
  }

}
