#!/usr/bin/perl -w
############################################################
#
# $Id: footprint-scan,v 1.2 2008/06/13 00:11:21 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

footprint-scan

=head1 DESCRIPTION

Scan promoters of orthologous genes with one or several
position-specific scoring matrices (PSSM) in order to detect conserved
hits.

=head1 AUTHORS

Jacques.van.Helden@ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE

footprint-scan [-i inputfile] [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=head1 SEE ALSO

=head1 WISH LIST

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "footprint.lib.pl";

################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  my $start_time = &AlphaDate();
  $program_version = do { my @r = (q$Revision: 1.2 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  %main::infile = ();
  %main::outfile = ();

  $main::verbose = 0;
  $main::in = STDIN;
  $main::out = STDOUT;

  ## Parameters for promoter retrieval
  local $taxon;			## Reference taxon
  local $organism_name;		## Query organism
  local @query_genes = ();	## list of query genes
  local $infer_operons = 0;     ## Infer operon leader genes
  local $dist_thr = 55;	        ## Distance threshold for operon inference
  local $all_genes = 0;         ## Analyze all the genes of the query organism
  local $sep_genes = 0;	        ## Analyze each gene separately
  local $max_genes = undef;     ## Analyze a restricted number of genes
  local $query_prefix;

  ## Matrix scanning parameters
  local @matrix_files = ();
  local $strands = "-2str"; ## Strands for pattern matching
  $supported_task{scan} = 1;
  $supported_task{map} = 1;
  local $pseudo = 1;
  local $bg_pseudo = 0.05;
  local $strands = "-2str"; ## Strands for pattern discovery and pattern matching
  local $matrix_dir="data/matrices";
  local $matrix_file = $matrix_dir."/PHO4_matrix.tab";
  local $matrix_format = "tab";
  local $markov = 1;
  local $img_format = "png";
  local %lth = ();
  $lth{score} = 5;
  local %uth = ();
  $uth{Pval} = "1e-3";

  ## DEBUG ## 
#  $task{scan} = 1;
#  $task{map} = 1;

  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values

  ## Check parameters for footprint analysis
  &CheckFootprintParameters();
  
  ################################################################
  ## Check parameters for matrix-scan
  local $ms_parameters = " -v 1";
  if (defined($main::infile{bg})) {
    $ms_parameters .= " -bgfile ".$main::infile{bg};
  } elsif ($bg_method eq "input") {
    $ms_parameters .= " -bginput ";
    if (defined($markov)) {
      $ms_parameters .= " -markov ".$markov;
    } else {
      &RSAT::error::FatalError("The option -bginput requires o specify a Markov model (option -markov)");
    }
  } else {
    &RSAT::error::FatalError("You must define a background model using either -bgfile or -bginput ");
  }

  ## Matrix file and format
  &RSAT::error::FatalError("You must specify a matrix file (option -m)") unless (scalar(@matrix_files) > 0);
  foreach my $file (@matrix_files) {
    $ms_parameters .= " -m ".$file;
  }
  &RSAT::error::FatalError("You must specify the matrix format (option -matrix_format)") unless (defined($matrix_format));
  $ms_parameters .= " -matrix_format ".$matrix_format;

  ## Sequence format
  $ms_parameters .= " -seq_format fasta";

  ## Thresholds
  foreach my $key (keys(%lth)) {
    $ms_parameters .= " -lth ".$key." ".$lth{$key};
  }
  foreach my $key (keys(%uth)) {
    $ms_parameters .= " -uth ".$key." ".$uth{$key};
  }

  ## Return fields
  $ms_parameters .= " -return limits,sites,rank";

  ## Strands
  $ms_parameters .= " ".$strands;

  ## Origin for the positions
  $ms_parameters .= " -origin -0";

  ## Pseudo-count for the matrix
  $ms_parameters .= " -pseudo ".$pseudo;

  ## Pseudo-frequency for the background model
  $ms_parameters .= " -bg_pseudo ".$bg_pseudo;


  ################################################################
  ## Analyze query genes separately or altogether
  if ($sep_genes) {
    foreach my $current_gene (@query_genes) {
      &RunFootprintScan($current_gene);
    }
  } else {
    &RunFootprintScan(@query_genes);
  }

  ################################################################
  ## Open output stream
  $main::out = &OpenOutputFile($main::outfile{output});

  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose);

  ################################################################
  ## Execute the command

  ################################################################
  ## Print output


  ################################################################
  ## Finish verbose
  if ($main::verbose >= 1) {
    my $done_time = &AlphaDate();
    print $main::out "; Job started $start_time\n";
    print $main::out "; Job done    $done_time\n";
  }


  ################################################################
  ## Close output stream
  close $main::out if ($main::outfile{output});


  ################################################################
  ## Report the index files
  if ($create_index) {
    if ($main::verbose >= 2) {
      print ("; Index files\n");
      foreach my $key (sort keys %index_list) {
	print join ("\t", ";", $key, $index_list{$key}), "\n";
      }
    }
  }

  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
#    system "pod2text -c $0";
    system "cat $0 $ENV{RSAT}/perl-scripts/lib/footprint.lib.pl | pod2text -c";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  local $arg;
  local @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

=pod

=head1 OPTIONS

=cut

    ## Read the options that are common to all footprint-detection programs
    if (&ReadFootprintOptions()) {
      next;

	    ## Matrix file

=pod

=over 4

=item B<-m matrixfile>

Matrix file. 

This argument can be used iteratively to scan the sequence with
multiple matrices.

=cut
    } elsif ($arg eq "-m") {
      push @matrix_files, shift(@arguments);


	    ## Matrix format
=pod

=item B<-matrix_format matrix_format>

Matrix format. Default is tab.

=cut
	} elsif ($arg eq "-matrix_format") {
	    $main::matrix_format = lc(shift(@arguments));

	    ## Pseudo-count for the PSSM
=pod

=item B<-pseudo #>

Pseudo-count for the matrix (default: 1). See matrix-scan for details.

=cut
	} elsif ($arg eq "-pseudo") {
	    $main::pseudo = shift(@arguments);
	    &RSAT::error::FatalError(join("\t", $main::pseudo,
					  "Invalid value for pseudo count. Must be a real value."))
		unless (&IsReal($main::pseudo));

		##bg file
=pod

=item B<-bgfile background_file>

 Background model file.

=cut
	} elsif ($arg eq "-bgfile") {
	    $main::infile{bg} = shift(@arguments);

	  ## Background calculated from the input sequence set
=pod

=item B<-bginput>

Calculate background model from the input sequence set.

=cut
	} elsif ($arg eq "-bginput") {
	  &RSAT::error::FatalError("Options -bgfile and -bginput  are mutually exclusive") if (defined($infile{bg}));
	  $main::bg_method = "input";
	  &RSAT::error::FatalError("The options -bginput and -bgfile are mutually exclusive.")
		if defined($main::infile{bg});

	  ## Calculate background model from the input sequence
=pod

=item B<-markov>

Order of the markov chain for the background model. 

This option is incompatible with the option -bgfile. 

=cut
	} elsif ($arg eq "-markov") {
	    $main::markov = shift(@arguments);
	    &RSAT::error::FatalError("Markov order must be a natural number.") 
		unless &RSAT::util::IsNatural($main::markov);
	    &RSAT::error::FatalError("The options -markov and -bgfile are mutually exclusive.") 
		if defined($infile{bg});


=item B<-bg_pseudo #>

Pseudo frequency for the background model. Value must be a real
between 0 and 1.

If this option is not specified, the pseudo-frequency value depends on
the background calculation.

For -bginput and -window, the pseudo frequency is automatically
calculated from the length (L) of the sequence following this formula:

  sqrt(L)/(L+sqrt(L))

For -bgfile, default value is 0.01. 

In other cases, if the length (L) of the training sequence is known
(e.g. all promoters for the considered organism), the value can be set
manually by using the option -bg_pseudo. In such case, the background
pseudo-frequency might be set, as suggested by Thijs et al., to the
following value:

  sqrt(L)/(L+sqrt(L))


=cut
	} elsif ($arg eq "-bg_pseudo") {
	    $main::bg_pseudo = shift(@arguments);
	    &RSAT::error::FatalError(join("\t", $main::bg_pseudo,
					  "Invalid format for bg_pseudo, should be a Real number between 0 and 1."))
		unless ((&IsReal($main::bg_pseudo)) && (0 <= $main::bg_pseudo) && ($main::bg_pseudo <= 1));
		$main::bg_pseudo_user_specified = 1;


    } else {
      &FatalError(join("\t", "Invalid option", $arg));
    }
  }


}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; footprint-scan ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
}



################################################################
## Run footprint scan flow chart for one or several query genes
sub RunFootprintScan {
  local (@current_query_genes) = @_;

  local $start_time = &AlphaDate();
  local $batch_cmd = "";
  local $out = "";
  local $genes = "";


  ################################################################
  ## Initialize output directory + output files
  local $query_prefix = &GetQueryPrefix();
  $outfile{prefix} = &GetOutfilePrefix();
  &InitOutput();

  ## Output files for matrix-scan
  $outfile{sites} = $outfile{prefix}."_sites";
  $outfile{occ_hits} = $outfile{prefix}."_over";

  ################################################################
  ## Open file to the HTML index
  &OpenIndex() if ($create_index);

  ################################################################
  ## Print query genes in the gene file
  foreach my $gene (@current_query_genes) {
    print $genes $gene, "\t", $organism_name, "\n";
  }
  &IndexOneFile("genes", $outfile{genes}) if ($create_index);

  ################################################################
  ## Print verbose
  &Verbose() if ($verbose);

  ################################################################
  ## Identify ortholog genes
  &GetOrthologs();

  ################################################################
  ## Predict operon leader genes for the orthologous genes
  &InferOrthoOperons() if ($infer_operons);

  ################################################################
  ## Retrieve sequences from orthologs
  &RetrieveOrthoSeq();

  ################################################################
  ## Purge sequences
  &PurgeOrthoSeq();

  ################################################################
  ## Send the command to a batch queue (e.g. PC cluster)
  if ($batch) {
    &doit($batch_cmd, $dry, $die_on_error, $verbose, 1, $job_prefix);
  }

  ################################################################
  ## Scan the promoters of one group of orhtologous genes with one
  ## position-specific scoring matrix

  ################################################################
  ## Scan sequences with PSSM to locate sites
  &CheckDependency("scan", "seq");
  my $scan_cmd = "matrix-scan";
  $scan_cmd .= $ms_parameters;
  $scan_cmd .= " -i ".$outfile{seq};
  $scan_cmd .= " -o ".$outfile{sites}.".tab";
  &one_command($scan_cmd) if ($task{scan});

  ################################################################
  ## Draw a feature map with the detected sites
  &CheckDependency("map", "sites");
  my $map_cmd = "feature-map -i ".$outfile{sites}.".tab";
  $map_cmd .= " -scalebar -legend";
  $map_cmd .= " -xsize 800 -scorethick";
  $map_cmd .= " -title 'matrix hits in ".$taxon." promoters'";
  $map_cmd .= " -format ".$img_format;
  $map_cmd .= " -o ".$outfile{sites}.".".$img_format;
  &one_command($map_cmd) if ($task{map});


  ################################################################
  ## Finish verbose
  if ($verbose >= 1) {
    my $done_time = &AlphaDate();
    print $out "; Job started $start_time\n";
    print $out "; Job done    $done_time\n";
  }

  ################################################################
  ## Close output stream
  close $out if ($outfile{log});
  close $genes if ($outfile{genes});
  if ($create_index) {
    print $index "</table>\n";
    print $index "</blockquote>";
    print $index "<hr size=2 color='#000088'>";
    print $index "</body>";
    print $index "</html>";
    close $index;
  }


  ################################################################
  ## Add one file to the index file
  sub IndexOneFile {
    my ($name, $file, %args) = @_;
    $short_file = `basename $file`;
    print $index "<tr valign=top>\n";
    print $index "<td>", $name, "</td>\n<td><a href=".$short_file.">".$short_file."</a></td>\n";
    if ($args{image}) {
      #    print $index "<td><a href=".$short_file."><img width=100 src=".$short_file."></a></td>\n";
      print $index "</tr><tr><td colspan=\"2\">(Click on image below)</td></tr><tr><td colspan=\"2\"><a href=".$short_file."><img width=\"100%\" src=".$short_file."></a></td>\n";
    }
    print $index ("</tr>\n\n");
  }
}

__END__
