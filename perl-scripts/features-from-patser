#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib.pl";



if ($ARGV[0] eq "-h") {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	features-from-patser

        1998 by Jacques van Helden (jacques\@ucmb.ulb.ac.be)
	
USAGE
        features-from-patser [-i inputfile] [-o outputfile] [-v]

DESCRIPTION
	converts the output from the program patser into a file
	that can be used as input for the program feature-map.

OPTIONS
        -h      (must be first argument) display full help message
        -help   (must be first argument) display options
	-v	verbose
	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-id	feature identifier
		the same identifier is used for all features
	-mlen #	matrix length
	-strand	D, R or DR. Strand on which to draw the feature.
	-orig	origin
		each position is recalculated using this value as reference.
	-origfile	origin file	
		each line indicates the specific origin for one of the 
		sequences. It must contain 2 words separate by a tab.
		The first word is the sequence identifier (= the map name),
		the second word is the origin for that sequence.
	-seq seq_file
		indicates the sequence file which had been used as 
		input for patser. This file must be in wconsensus format.
		
INPUT FORMAT
	
	
OUTPUT FORMAT
	
	
EXAMPLES
       features-from-patser -v -i mydata -o myresult
	
End_of_help
  close HELP;
  exit;
}

if ($ARGV[0] eq "-help") {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
features-from-patser options
----------------
-h      (must be first argument) display full help message
-help   (must be first argument) display options
-i      input file
-o      output file
-v      verbose
-id	feature identifier
-mlen #	matrix length
-strand	D, R or DR. Strand on which to draw the feature
-orig	origin
-origfile	origin file
-seq	sequencefile
End_short_help
  close HELP;
  exit;
}

$start_time = $date = `date '+%d/%m/%y %H:%M:%S %Z'`;

#### initialise parameters ####
$type="site";
$id = "patser";
$matrix_length = 1;
$seq_format = "wconsensus";

#### read arguments ####
foreach $a (0..$#ARGV) {
    ### verbose ###
    if ($ARGV[$a] eq "-v") {
	$verbose = 1;
    ### input file ###
    } elsif ($ARGV[$a] eq "-i") {
	$inputfile = $ARGV[$a+1];
    ### output file ###
    } elsif ($ARGV[$a] eq "-o") {
	$outputfile = $ARGV[$a+1];

    } elsif ($ARGV[$a] eq "-strand") {
	$strand = $ARGV[$a+1];
	$force_strand = 1;

    } elsif ($ARGV[$a] eq "-id") {
	$id = $ARGV[$a+1];

    } elsif (($ARGV[$a] =~ /^-orig$/i) &&(&IsInteger($ARGV[$a+1]))) {
	$fixed_origin = 1;
        $origin = $ARGV[$a+1];

    } elsif ($ARGV[$a] =~ /^-origfile/i) {
	$origin_file = $ARGV[$a+1];

    } elsif (($ARGV[$a] =~ /^-mlen/i) && (&IsNatural($ARGV[$a+1]))) {
	$matrix_length = $ARGV[$a+1];

    ### sequence file ###
    } elsif ($ARGV[$a] =~ /^-seq/) {
	$sequence_file = $ARGV[$a+1];

    }
}

### origin file
if ($origin_file ne "") {
    unless (open ORIG, $origin_file) {
	print "Error: could not open the oirigin file\n";
	exit;
    }
    while (<ORIG>) {
	if (/^\s*(\S+)\s*(\S+)/) {
	    $origin{$1} = $2;
	}
    }
    close ORIG;
}



##### read the sequences #####
if ($sequence_file ne "") {
    unless (open SEQ, $sequence_file) {
	print "Error: cannot open sequence file\n";
	print "type features-from-patser -h for the manual\n";
	exit;
    }

    $in = SEQ;
    while ((($current_seq, $current_id) = &ReadNextSequence($in, $seq_format)) &&
	   (($current_seq ne "") || ($current_id ne ""))) {
	$current_seq =~s/\s//g;
	$sequence{$current_id} = $current_seq;

    }
    close SEQ;
}


### open input file ###
$in = &OpenInputFile($inputfile);

### open output file ###
$out = &OpenOutputFile($outputfile);

#### verbose ####
if ($verbose) {
    print $out ";features-from-patser ";
    &PrintArguments;
    print $out "\n";
    print $out ";Input file	$inputfile\n" unless ($inputfile eq "");
    print $out ";Output file	$outputfile\n" unless ($outputfile eq "");
    if ($sequence_file ne "") {
	print $out ";Sequence file\t$sequence_file\n";
	print $out ";\tsequence id\tlength\n";
	foreach $id (sort keys %sequence) {
	    $length = length($sequence{$id});
	    print $out ";\t$id\t$length\n";
	}
    }
    print $out ";map";
    print $out "\ttype";
    print $out "\tid";
    print $out "\tstrand";
    print $out "\tstart";
    print $out "\tend";
    print $out "\tdescr";
    print $out "\tscore";
    print $out "\n";
}

###### execute the command #########

while (<$in>) {
    if (($matrix_length == 1) && (/width of the alignment matrix\:\s+(\d+)/)) {
         $matrix_length = $1;

    } elsif (/^\s*(\S+)\s+position=\s+(\d+)([c\s])\s+score=\s+(\S+)/i) {
	$map = $1;
	$score = $4;
        $sub_sequence = substr($sequence{$map}, $2 -1, $matrix_length);
	if ($3 eq "C") {
	    $sub_sequence = &ReverseComplement($sub_sequence);
	}

	if ($fixed_origin) {
	    $start = $2 - $origin;
	} else {
	    $start = $2 - $origin{$1};
	}
	$end = $start + $matrix_length -1;

	unless ($force_strand) {
	    if  ($3 =~ /^c$/i) {
		$strand = "R";
	    } else {
		$strand = "D";
	    }
	}

	$descr = "${sub_sequence}";

	&PrintFeature;
    }
}

###### verbose ######
if ($verbose) {
    $done_time = $date = `date '+%d/%m/%y %H:%M:%S %Z'`;
    print $out ";Job started $start_time";
    print $out ";Job done    $done_time";
}


###### close input file ######
close $in unless ($inputfile eq "");

###### close output file ######
close $out unless ($outputfile eq "");


exit(0);


########################## subroutine definition ############################

sub PrintFeature {
    print $out $map;
    print $out "\t$type";
    print $out "\t$id";
    print $out "\t$strand";
    print $out "\t$start";
    print $out "\t$end";
    print $out "\t$descr";
    print $out "\t$score";
    print $out "\t";
    print $out "\n";
}
