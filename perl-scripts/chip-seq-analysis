#!/usr/bin/perl -w
############################################################
#
# $Id: chip-seq-analysis,v 1.18 2010/03/17 00:34:11 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

chip-seq-analysis

=head1 VERSION

$program_version

=head1 DESCRIPTION

Pipeline for discoering motifs from ChIP-seq (or ChIP-chip) peak
sequences.

=head1 AUTHORS

=over

=item Jacques van Helden <Jacques.van.Helden@ulb.ac.be>

=item Morgane Thomas-Chollier <thomas-c@molgen.mpg.de>

=item Matthieu Defrance <defrance@ccg.unam.mx>

=item Olivier Sand <oly@bigre.ulb.ac.be> for the Web services

=back


=head1 CATEGORY

Pattern discovery

=head1 USAGE

chip-seq-analysis [-i inputfile] [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

The program takes as input either one (test) or two sequence files
(test versus control).

All input sequences formats supported by convert-sequences are
supported.

=head1 OUTPUT FORMAT

The pipeline runs a series of programs generating each one or several
result file. An HTML index is generated in order to synthesize the
results and give access to the individual result files. 

The index file is formed from the output directory (option -outdir)
and the file prefix (option -prefix).

  [output_dir]/[prefix]_synthesis.html

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "footprint.lib.pl";
use RSAT::util;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();
    $program_version = do { my @r = (q$Revision: 1.18 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
#    $program_version = "0.00";

    %main::param = ();
    @main::param_list = ();

    %main::dir = ();
    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::out = STDOUT;

    ################################################################
    ## Supported tasks
    @supported_tasks = qw (
			   all
			   seqlen
			   purge
			   oligos
			   dyads
			   positions
			   orm
			   profiles
			   synthesis
			   clean_seq
			  );

    my @future_tasks = qw(
			  oligo-diff
			  tomtom
			  to_bed
		      );
    $supported_tasks = join ",", @supported_tasks;
    %supported_task = ();
    foreach my $task (@supported_tasks) {
      $supported_task{$task} = 1;
    }
    %task = (); ## List of tasks to be executed


    ################################################################
    ## Set default parameters
    &DefaultParameters();

    ################################################################
    ## Read argument values
    &ReadArguments();

    &CheckArguments();

    &SetOutFileNames();

    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{log});

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    if ($task{purge}) {
      &PurgeOneSeq($infile{test_seq}, "test");
      if ($infile{control_seq}) {
	&PurgeOneSeq($infile{control_seq}, "control");
      }
    }

    &SequenceLengths if ($task{seqlen});

    &CompositionProfiles if ($task{profiles});

    &OligoAnalysis if ($task{oligos});

    &DyadAnalysis if ($task{dyads});

    &PositionAnalysis if ($task{positions});

    &ORM if ($task{orm});

    &Synthesis if ($task{synthesis});

    &CleanSequences() if ($task{clean_seq});

    if ($main::verbose >= 1) {
      &TimeWarn("Log file", $outfile{log});
    }

    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }


    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}


################################################################
## Set parameter values for all the programs
sub DefaultParameters {
  &RSAT::message::TimeWarn("Setting default parameter values") if ($main::verbose >= 1);

  ## Formats
  $main::param{seq_format} = "fasta"; push(@main::param_list, "seq_format");
  $main::param{img_format} = "png"; push(@main::param_list, "img_format");

  ## Purge-seq
  $main::param{purge_match_length} = 30; push(@main::param_list, "purge_match_length");
  $main::param{purge_mismatches} = 0; push(@main::param_list, "purge_mismatches");

  ## residue profiles (position-analysis)
  $main::param{profiles_ci} = 10; push(@main::param_list, "profiles_ci");
  $main::param{profiles_max_graphs} = 20; push(@main::param_list, "profiles_ci");
  $main::param{profiles_strand} = "-2str"; push(@main::param_list, "profiles_strand");
  @main::profiles_oligo_lengths = (1,2);
  $main::param{profiles_oligo_lengths} = join(',',@profiles_oligo_lengths); push(@main::param_list, "profiles_oligo_lengths");

  ## Pattern discovery options
  $main::param{min_sig} = 0; push(@main::param_list, "strand");
  $main::param{strand} = "-2str"; push(@main::param_list, "strand");
  $main::param{noov} = "-noov"; push(@main::param_list, "noov");
  $main::param{oligo_min_len} = 6; push(@main::param_list, "oligo_min_len");
  $main::param{oligo_max_len} = 7; push(@main::param_list, "oligo_max_len");
  $main::param{patterns_max_rank} = 25; push(@main::param_list, "patterns_max_rank");

  ## oligo-analysis
  $main::param{oligo_markov} = -2; push(@main::param_list, "oligo_markov");

  ## dyad-analysis

  ## position-analysis
  $main::param{positions_ci} = 20; ## Class interval for position-analysis

  ## orm
  $main::param{orm_ci} = 20; ## Class interval for ORM

  ## matrix-from-patterns
  $main::param{matrix_nmotifs} = 3; push(@main::param_list, "matrix_nmotifs");


}


################################################################
## Define one output file name by concatenating arguments
sub OutFileName {
    my ($extension, @name_elements) = @_;
    my $out_file_name = $dir{output}."/".$main::param{prefix};
    $out_file_name .= join ("_", @name_elements);
    $out_file_name .= $extension;
    return($out_file_name);
}



################################################################
## Set output file names
sub SetOutFileNames {
    ## Purged sequences
    $main::outfile{"purged_test"} = &OutFileName(".fasta", 
						 "test",
						 "purged",
						 "ml".$main::param{purge_match_length},
						 "mis".$main::param{purge_mismatches});
    if ($infile{control_seq}) {
	$main::outfile{"purged_control"} = &OutFileName(".fasta", 
						     "control",
						     "purged",
						     "ml".$main::param{purge_match_length},
						     "mis".$main::param{purge_mismatches});
    }

    ## Sequence lengths
    $main::outfile{"test_seqlen"} = &OutFileName(".tab", "test_seqlen");
    $main::outfile{"test_seqlen_distrib"} = &OutFileName(".tab", "test_seqlen_distrib");
    $main::outfile{"test_seqlen_distrib_graph"} = &OutFileName(".".$param{img_format}, "test_seqlen_distrib");
    if ($infile{control_seq}) {
	$main::outfile{"control_seqlen"} = &OutFileName(".tab", "control_seqlen");
	$main::outfile{"control_seqlen_distrib"} = &OutFileName(".tab", "control_seqlen_distrib");
	$main::outfile{"control_seqlen_distrib_graph"} = &OutFileName($param{img_format}, "control_seqlen_distrib");
    }

    ################################################################
    ## Pattern discovery result

    @pattern_types = ();

    for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
      ## oligo-analysis
      $main::outfile{'oligos_'.$len.'nt'} = &OutFileName(".tab", "oligos".$main::param{strand}.$main::param{noov},
							 $len."nt",
							 "mkv".$main::param{oligo_markov});
      push @pattern_types, 'oligos_'.$len.'nt';

      ## orm
      $main::outfile{'orm_'.$len.'nt'} = &OutFileName(".tab", "orm".$main::param{strand}.$main::param{noov},
						      $len."nt", "ci".$main::param{orm_ci},
						      "mkv".$main::param{oligo_markov});
      push @pattern_types, 'orm_'.$len.'nt';

      ## position-analysis
      $main::outfile{'positions_'.$len.'nt'} = &OutFileName(".tab", "positions".$main::param{strand}.$main::param{noov},
							    $len."nt", "ci".$main::param{positions_ci});
      push @pattern_types, 'positions_'.$len.'nt';
    }

    ## dyad-analysis
    $main::outfile{dyads} = &OutFileName(".tab", "dyads".$main::param{strand}.$main::param{noov},
					 "3nt_sp0-20_bg_monads");
    push @pattern_types, "dyads";

    ## Converstion from patterns to matrices + logos
    foreach my $pattern_type (@pattern_types) {
      $main::outfile{$pattern_type.'_pssm'} = $main::outfile{$pattern_type};
      $main::outfile{$pattern_type.'_pssm'} =~ s/\.tab$//;
      $main::outfile{$pattern_type.'_pssm'} .= "_pssm";
      $main::outfile{$pattern_type.'_asmb'} = $main::outfile{$pattern_type.'_pssm'}.".asmb";
      $main::outfile{$pattern_type.'_pssm_sig'} = $main::outfile{$pattern_type.'_pssm'}."_sig_matrices.txt";
      $main::outfile{$pattern_type.'_pssm_gibbs'} = $main::outfile{$pattern_type.'_pssm'}."_gibbs_matrices.txt";
      $main::outfile{$pattern_type.'_pssm_counts'} = $main::outfile{$pattern_type.'_pssm'}."_count_matrices.txt";
      foreach my $logo_nb (1..$main::param{matrix_nmotifs}) {
	$main::outfile{$pattern_type.'_pssm_logo'.$logo_nb} = $main::outfile{$pattern_type.'_pssm'}."_gibbs_matrices_m".$logo_nb."_logo.".$main::param{img_format};
	$main::outfile{$pattern_type.'_pssm_logo_rc'.$logo_nb} = $main::outfile{$pattern_type.'_pssm'}."_gibbs_matrices_m".$logo_nb."_logo_rc.".$main::param{img_format};
      }
    }

#     ## dyad-analysis result
#     $main::outfile{dyads} = &OutFileName(".tab", "dyads".$main::param{strand}.$main::param{noov}, 
# 					  "3nt_sp0-20_bg_monads");
#     $main::outfile{dyads_pssm} = $main::outfile{dyads};
#     $main::outfile{dyads_pssm} =~ s/\.tab$//;
#     $main::outfile{dyads_pssm} .= "_pssm";

    ## Position-analysis
    for my $ol (@profiles_oligo_lengths) {
      $main::outfile{$ol."nt_profiles"} = &OutFileName(".tab", "profiles".$main::param{profiles_strand}.$main::param{noov},$ol."nt",
						       "ci".$main::param{profiles_ci});

      ## HTML index to the individual oligonucleotide profiles
      $main::outfile{$ol."nt_profiles_index"} = $main::outfile{$ol."nt_profiles"};
      $main::outfile{$ol."nt_profiles_index"} =~ s/\.tab$//;
      $main::outfile{$ol."nt_profiles_index"} .= "_graph_index.html";
    }

    ## Compositional profiles
    for my $ol (1,2) {
      $outfile{$ol."nt_profiles_graph"} = $main::outfile{$ol."nt_profiles"};
      $outfile{$ol."nt_profiles_graph"} =~ s/\.tab$//;
      $outfile{$ol."nt_profiles_graph"} .= ".".$main::param{img_format};
    }
  }

################################################################
## Purge sequences
sub PurgeOneSeq {
  my ($seq_file, $seq_type) = @_;
  &RSAT::message::TimeWarn("Purging sequences") if ($main::verbose >= 1);
  my $cmd = "convert-seq";
  $cmd .= " -i ".$seq_file;
  $cmd .= " -from ".$main::param{seq_format};
  $cmd .= " -to fasta";
  $cmd .= " -mask non-dna";
  $cmd .= "| purge-sequence -dna";
  $cmd .= " -ml ".$main::param{purge_match_length};
  $cmd .= " -mis ".$main::param{purge_mismatches};
  $cmd .= " -o ".$main::outfile{"purged_".$seq_type};
  &one_command($cmd);
}


################################################################
## Compute sequence lengths
sub SequenceLengths {
  &RSAT::message::TimeWarn("Computing sequence lengths") if ($main::verbose >= 1);
  my $cmd = "sequence-lengths";
  $cmd .= " -i ".$main::infile{test_seq};
  $cmd .= " -o ".$main::outfile{test_seqlen};
  $cmd .= " ; cut -f 2 ".$main::outfile{test_seqlen};
  $cmd .= " | classfreq -v 1 -ci 10 -o ".$main::outfile{test_seqlen_distrib};
  $cmd .= " ; XYgraph -lines -legend";
  $cmd .= " -format ".$main::param{img_format};
  my $title = "Sequence lengths";
  $title .= "; ".$main::param{title} if ($main::param{title});
  $cmd .= " -title '".$title."'";
  $cmd .= " -ysize 200 -ycol 4 -yleg1 'Number of peaks'";
  $cmd .= " -xsize 800 -xcol 3 -xleg1 'Peak length'";
  $cmd .= " -i ".$main::outfile{test_seqlen_distrib};
  $cmd .= " -o ".$main::outfile{test_seqlen_distrib_graph};
  &one_command($cmd);
}

################################################################
## Run position-analysis to compute composition profiles (residues,
## dinucleotides)
sub CompositionProfiles {
  for my $ol (@profiles_oligo_lengths) {
    &RSAT::message::TimeWarn("Computing composition profiles", $ol."nt") if ($main::verbose >= 1);
    my $cmd = "position-analysis -v 1";
    $cmd .= " -i ".$main::outfile{"purged_test"};
    $cmd .= " -format fasta";
    $cmd .= " -sort ";
    $cmd .= " -return chi,sig,distrib,graphs,rank";
#    $cmd .= " -max_graphs ".$main::param{profiles_max_graphs};
    $cmd .= " ".$main::param{profiles_strand};
    $cmd .= " ".$main::param{noov};
    $cmd .= " -seqtype dna";
    $cmd .= " -l ".$ol;
    $cmd .= " -ci ".$main::param{profiles_ci};
    $cmd .= " -img_format ".$main::param{img_format};
    $cmd .= " -title '".$main::param{title}."'";
    $cmd .= " -origin center ";
    $cmd .= " -o ".$outfile{$ol."nt_profiles"};
    &one_command($cmd);

    ## Draw the XY graph with composition profiles
    my $col_nb = 4**$ol + 1;
    $cmd = 'grep -v ";" '.$outfile{$ol."nt_profiles"}.' | transpose-table | grep -P \'(^id)|(^\-?\d+)\'';
    $cmd .= " | XYgraph -xcol 1 -ycol 2-".$col_nb;
    $cmd .= " -lines -legend -header";
#    $cmd .= " -symbols "; ## THIS OPTION IS NOT WORKING ANYMORE : THE LEGEND DISPLAYS SYMBOLS BUT NOT THE GRAPH. THIS HAS TO BE FIXED
    my $title = "Peak composition profiles : ".$ol."nt";
    $title .= "; ".$main::param{title} if ($main::param{title});
    $cmd .= " -title '".$title."'";
    $cmd .= " -xleg1 'Position' -xsize 800";
    $cmd .= " -yleg1 'Occurrences' -ysize 300";
    $cmd .= " -o ".$outfile{$ol."nt_profiles_graph"};
    &one_command($cmd);
  }
}


################################################################
## Run oligo-analysis on the test set
sub OligoAnalysis {
  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    my $pattern_type = 'oligos_'.$len.'nt';
    &RSAT::message::TimeWarn("Running oligo-analysis", $len."nt") if ($main::verbose >= 1);
    my $cmd = "oligo-analysis -v 1";
    $cmd .= " -i ".$main::outfile{"purged_test"};
    $cmd .= " -format fasta";
    $cmd .= " -sort -lth occ_sig ".$main::param{min_sig};
    $cmd .= " -uth rank ".$main::param{patterns_max_rank};
    $cmd .= " -return occ,proba,rank";
    $cmd .= " ".$main::param{strand};
    $cmd .= " ".$main::param{noov};
    $cmd .= " -seqtype dna";
    $cmd .= " -l ".$len;
    $cmd .= " -markov ".$main::param{oligo_markov};
    $cmd .= " -pseudo 0.01";
    $cmd .= " -o ".$outfile{$pattern_type};
    &one_command($cmd);
    &MatrixFromPatterns($outfile{$pattern_type}, $outfile{$pattern_type.'_pssm'}, $pattern_type);
  }
}


################################################################
## Run dyad-analysis on the test set
sub DyadAnalysis {
  &RSAT::message::TimeWarn("Running dyad-analysis") if ($main::verbose >= 1);
  my $cmd = "dyad-analysis -v 1";
  $cmd .= " -i ".$main::outfile{"purged_test"};
  $cmd .= " -format fasta";
  $cmd .= " -sort -lth occ_sig ".$main::param{min_sig};
  $cmd .= " -uth rank ".$main::param{patterns_max_rank}." -return occ,proba,rank";
  $cmd .= " ".$main::param{strand};
  $cmd .= " ".$main::param{noov};
  $cmd .= " -seqtype dna";
  $cmd .= " -l 3 -sp 0-20 ";
  $cmd .= " -bg monads";
  $cmd .= " -pseudo 0.01";
  $cmd .= " -o ".$outfile{dyads};
  &one_command($cmd);
  &MatrixFromPatterns($outfile{dyads}, $outfile{dyads_pssm}, "dyads");
}


################################################################
## Run position-analysis to discover oligonucleotides with positional
## biases
sub PositionAnalysis {
  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    my $pattern_type = 'positions_'.$len.'nt';
    &RSAT::message::TimeWarn("Running position-analysis", $len."nt") if ($main::verbose >= 1);
    my $cmd = "position-analysis -v 1";
    $cmd .= " -i ".$main::outfile{"purged_test"};
    $cmd .= " -format fasta";
    $cmd .= " -sort ";
    $cmd .= " -return chi,sig,distrib,graphs,rank";
    $cmd .= " -rth ".$main::param{patterns_max_rank};
    $cmd .= " -lth_sig ".$main::param{min_sig};
    $cmd .= " -max_graphs ".$main::param{patterns_max_rank};
    $cmd .= " ".$main::param{strand};
    $cmd .= " ".$main::param{noov};
    $cmd .= " -seqtype dna";
    $cmd .= " -l ".$len;
    $cmd .= " -ci ".$main::param{profiles_ci};
    $cmd .= " -img_format ".$main::param{img_format};
    $cmd .= " -title '".$main::param{title}."'";
    $cmd .= " -origin center ";
    $cmd .= " -o ".$outfile{$pattern_type};
    &one_command($cmd);
    &MatrixFromPatterns($outfile{$pattern_type}, $outfile{$pattern_type."_pssm"}, $pattern_type);
  }
}


################################################################
## Run orm on the test set
sub ORM {
  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    my $pattern_type = 'orm_'.$len.'nt';
    &RSAT::message::TimeWarn("Running orm", $len."nt") if ($main::verbose >= 1);
    my $cmd = "orm -v 3";
    $cmd .= " -i ".$main::outfile{"purged_test"};
    #  $cmd .= " -format fasta";
    $cmd .= " --center=0";
    $cmd .= " --min=occ_sig ".$main::param{min_sig};
    $cmd .= " --sort=-occ_sig";
    $cmd .= " --max=rank ".$main::param{patterns_max_rank};
    $cmd .= " --max=w_rank ".1; ## Only return the most significant window for each word
    # " -return occ,proba,rank";
    if ($main::param{strand} eq "-1str") {
      $cmd .= " +";
    } else {
      $cmd .= " +-";
    }
    $cmd .= " --overlap" if ($main::param{noov} eq "ovlp");
    $cmd .= " --window=".$main::param{orm_ci};
    #  $cmd .= " -seqtype dna";
    $cmd .= " -l ".$len;
    $cmd .= " -m ".$main::param{oligo_markov};
    #  $cmd .= " -pseudo 0.01";
    $cmd .= " -o ".$outfile{$pattern_type};
    &one_command($cmd);
    &MatrixFromPatterns($outfile{$pattern_type}, $outfile{$pattern_type.'_pssm'}, $pattern_type);
  }
}


################################################################
## Convert a list of patterns into PSSMs
sub MatrixFromPatterns {
  my ($pattern_file, $pssm_file, $type) = @_;
  &RSAT::message::TimeWarn("\tMatrix from patterns", $type) if ($verbose >= 1);
  my $cmd = "matrix-from-patterns -v 1 ";
  $cmd .= " -seq ".$infile{test_seq};
  $cmd .= " -pl ".$pattern_file;
  $cmd .= " -bginput -markov 1 ";
  $cmd .= " -max_asmb_nb ".$main::param{matrix_nmotifs};
  $cmd .= " -gibbs_flanks 2";
  $cmd .= " -gibbs_iter 2";
  $cmd .= " -gibbs_msps 0.5";
  $cmd .= " -logo";
#  $cmd .= " -links";
  $cmd .= " -o ".$pssm_file;
  &one_command($cmd);
}



################################################################
## Generate a synthetic table summarizing the main results with links
## to the iriginal result files.
sub Synthesis {
  local $syn = &OpenOutputFile($main::outfile{synthesis});
  local $synthesis_path = `dirname $main::outfile{synthesis}`;
  chomp($synthesis_path);

  ## HTML Header and title
  print $syn "<html>\n";
  print $syn "<head>\n";
  print $syn "<title>chip-seq-analysis ".$main::param{title}."</title>\n";

  ## Page styles
  print $syn "<style type='text/css'>\n";
  print $syn `cat $ENV{RSAT}/perl-scripts/lib/results.css`;
  print $syn "</style>\n";
#  print $syn "<link rel='stylesheet' type='text/css' href='".$ENV{RSAT}."/public_html/main.css'/>\n";

  print $syn "</head>\n";
  print $syn "<body>\n";
  print $syn "<h1>Result: chip-seq-analysis ".$main::param{title}."</h1>\n";


  ## Header of the synthetic table
  print $syn "<h2>Synthetic report</h2>";
  print $syn "<p><table class='sortable'>\n";

  &SynthesisSequenceComposition();


  ## Header line
  &SyntheticTableAddHeaderRow("Pattern discovery");

  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    &SynthesisPatternDisco('oligos_'.$len.'nt');
  }

  &SynthesisPatternDisco("dyads");

  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    &SynthesisPatternDisco('positions_'.$len.'nt');
  }

  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    &SynthesisPatternDisco('orm_'.$len.'nt');
  }

  ## Log file
  &SyntheticTableAddRow("Log file",
			"",
 			"txt"=>$main::outfile{"log"},
 		       );


  ## Close the synthetic table
  print $syn "</table></p>\n";

  ## Log file
  print $syn "<h2>Log</h2>";
  print $syn "<pre>";
  print $syn `cat $main::outfile{log}`;
  print $syn "</pre>";

  ## End of the HTML file
  print $syn "</body>\n";
  print $syn "</html>\n";
  close $syn;
  &RSAT::message::TimeWarn("Synthetic report", $main::outfile{synthesis}) if ($main::verbose >= 1);
}

################################################################
## Compute a file path relative to the synthesis file
sub RelativePath {
  my ($file) = @_;
  $file =~ s|${synthesis_path}/||;
  return ($file);
}

################################################################
## Add a row to the syhnthetic table
sub SyntheticTableAddRow {
  my ($type, $summary, @files) = @_;
  print $syn "<tr>\n";
  print $syn "<td>$type</td>\n";
  print $syn "<td>$summary</td>\n";
  print $syn "<td>\n";
  my $key;
  my $file;
  while ($key = shift (@files)){
    last unless $key;
    $file = shift(@files);
    &RSAT::message::Debug($key, $file) if ($main::verbose >= 5);
    $file = &RelativePath($file);
    print $syn "<a href='".$file."'>[".$key."]</a><br>\n";
  }
  print $syn "</td>\n";
  print $syn "</tr>\n";
}


################################################################
## Add a header row to the synthetic table
sub SyntheticTableAddHeaderRow {
  my ($header) = @_;
  print $syn "<tr>\n";
  print $syn "<th colspan=3>\n";
  print $syn $header;
  print $syn "</th>\n";
  print $syn "</tr>\n";
}

################################################################
## Add sequence composition on the synthetic report
sub SynthesisSequenceComposition {

  ## Header line
  &SyntheticTableAddHeaderRow("Sequence composition");

  ## Get number of peaks from sequence length distribution
  my $peak_nb = `grep ';count:' $main::outfile{"test_seqlen_distrib"}`;
  chomp($peak_nb);
  $peak_nb =~ s/.*count:\s*//;

  ## Get total sequence size from sequence length distribution
  my $seq_size = `grep ';sum:' $main::outfile{"test_seqlen_distrib"}`;
  chomp($seq_size);
  $seq_size =~ s/.*sum:\s*//;
  $seq_size = round($seq_size/1000);

  ## Sequence lengths
  my $img = &RelativePath($main::outfile{"test_seqlen_distrib_graph"});
  &SyntheticTableAddRow("Nb of peaks: ".$peak_nb."<br>\nTotal seq. size: ".$seq_size." kb",
			"<a  href='".$img."'><img height=150 src='".$img."'></a>",
			"lengths",$main::outfile{"test_seqlen"},
			"distrib",$main::outfile{"test_seqlen_distrib"},
			"plot",$main::outfile{"test_seqlen_distrib_graph"},
		       );


  ## Residue composition
  $img = &RelativePath($outfile{"1nt_profiles_graph"});
  &SyntheticTableAddRow("Residue composition",
			"<a  href='".$img."'><img height=150 src='".$img."'></a>",
			"table",$outfile{"1nt_profiles"},
			"individual profiles",$main::outfile{"1nt_profiles_index"},
		       );

  ## Dinucleotide composition
  $img = &RelativePath($outfile{"2nt_profiles_graph"});
  &SyntheticTableAddRow("Dinucleotide composition",
			"<a  href='".$img."'><img height=150 src='".$img."'></a>",
			"table",$outfile{"2nt_profiles"},
			"individual profiles",$main::outfile{"2nt_profiles_index"},
		       );
}

################################################################
## Synthesis for one pattern discovery algorithm
## Usage:
##   &SynthesisPatternDisco($pattern_type);
## Where pattern type can be oligos, dyads, ORM, oligo-diff
sub SynthesisPatternDisco {
  my ($pattern_type) = @_;

  ## Dinucleotide composition
  my $logo_table = "<table cellpadding=0 cellspacing=0 align=center border=0>";
  foreach my $logo_nb (1..$main::param{matrix_nmotifs}) {
    $logo_table .= "<tr>\n";
    my $logo_file = $main::outfile{$pattern_type.'_pssm_logo'.$logo_nb};
    my $logo_file_rc = $main::outfile{$pattern_type.'_pssm_logo_rc'.$logo_nb};
    &RSAT::message::Debug("Logo", $logo_nb, $logo_file) if ($main::verbose >= 5);
    if (-e $logo_file) {
      my $img = &RelativePath($logo_file);
      $logo_table .= "<td align='right'><a  href='".$img."'><img height=70 src='".$img."'></a></td>\n";
    } elsif ($main::verbose >= 0) {
      &RSAT::message::Warning("Cannot find logo", $logo_file);
    }
    if (-e $logo_file_rc) {
      my $img = &RelativePath($logo_file_rc);
      $logo_table .= "<td align='left'><a  href='".$img."'><img height=70 src='".$img."'></a></td>\n";
    } elsif ($main::verbose >= 0) {
      &RSAT::message::Warning("Cannot find reverse complementary logo", $logo_file_rc);
    }
    $logo_table .= "</tr>\n";
  }
  $logo_table .= "</table>\n";
  &SyntheticTableAddRow($pattern_type,
			$logo_table,
			$pattern_type,$main::outfile{$pattern_type},
			"assembly",$main::outfile{$pattern_type.'_asmb'},
			"sig matrix",$main::outfile{$pattern_type.'_pssm_sig'},
			"info-gibbs",$main::outfile{$pattern_type.'_pssm_gibbs'},
			"count matrix",$main::outfile{$pattern_type.'_pssm_counts'},
		       );
}

################################################################
## Delete purged sequence files after analysis has been completed.
sub CleanSequences {
  &RSAT::message::TimeWarn("Cleaning sequences") if ($main::verbose >= 1);
  &one_command("rm -f ".$main::outfile{"purged_test"});
  if ($infile{control_seq}) {
    &one_command("rm -f ".$main::outfile{"purged_control"});
  }
}


################################################################
## Read arguments 
sub ReadArguments {
  &RSAT::message::TimeWarn("Reading arguments") if ($main::verbose >= 1);
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();

=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-i test_seq_file>

Test peak sequence file (mandatory).

For single-set analysis, this file contains the peak seuences of the
unique set.  For test versus control analysis, it contains the test
sequences.

=cut
    } elsif ($arg eq "-i") {
      $main::infile{test_seq} = shift(@arguments);

=pod

=item B<-ctl control_seq_file>

Control peak sequence file (optional).

This option is used only for the test versus control analysis.

=cut
    } elsif ($arg eq "-ctl") {
      $main::infile{control_seq} = shift(@arguments);

=pod

=item	B<-outdir output_directory>

Output directory (mandatory).

The result files and index files produced by the different programs
will be stored in this directory.



=cut
    } elsif ($arg eq "-outdir") {
      $main::dir{output} = shift(@arguments);


=pod

=item	B<-prefix output_prefix>

Prefix for the output files

=cut
    } elsif ($arg eq "-prefix") {
      $main::param{prefix} = shift(@arguments);

=pod

=item	B<-title graph_title>

Title displayed on top of the graphs.

=cut
    } elsif ($arg eq "-title") {
      $main::param{title} = shift(@arguments);

=pod

=item	B<-img_format img_format>

Image format. 

All the formats supported by XYgraph can be used.

=cut
    } elsif ($arg eq "-img_format") {
      $main::param{img_format} = shift(@arguments);

=pod

=item B<-task>

Specify a subset of tasks to be executed.

By default, the program runs all necessary tasks. However, in some
cases, it can be useful to select one or several tasks to be executed
separately.

Beware: task selection requires expertise, because most tasks depends
on the prior execution of some other tasks in the workflow. Selecting
tasks before their prerequisite tasks have been completed will provoke
fatal errors.

I<Avilable Tasks.>

=over

=item I<all> (default)

Run all supported tasks.

=item I<purge>

Purge input sequences (test set and, if specified, control set) to
mask redundant fragments before applying pattern discovey
algorithms. Sequence purging is necessary because redundant fragments
would violate the hypothesis of independence underlying the binomial
significance test, resulting in a large number of false positive
patterns.

=item I<seqlen>

Compute sequence lengths and their distribution. 

Sequence lengths are useful for the negative control (selection of
random genome fragments).

Sequence length distribution is informative to get an idea about the
variability of peak lengths.

=item I<profiles>

Compute compositional profiles, i.e. distributions of residues and
dinucleotide frequencies per position (using I<position-analysis>).

Residue profiles may reveal composition biases in the neighborhood of
the peak sequences. Dinucleotide profiles can reveal (for example) an
enrichment in CpG island.

Note that I<chip-seq-analysis> also runs I<position-analysis> with
larger oligonucleotide length (see option -l) to detect motifs on the
basis of positionally biased oligonucleotides (see task B<positions>).

=item I<oligos>

Run I<oligo-analysis> to detect over-represented oligonucleotides of a
given length (k, specified with option -l) in the test set (van Helden
et al., 1998). Prior frequencies of oligonucleotides are taken from
Markov model of order m (see option -markov) estimated from the test
set sequences themselves.

=item I<dyads>

Run I<dyad-analysis> to detect over-represented dyads, i.e. pairs of
short oligonucleotides (monads) spaced by a region of fixed width but
variable content (van Helden et al., 2000). Spaced motifs are typical
of certain classes of transcription factors forming homo- or
heterodimers.

By default, chip-seq-analysis analyzes pairs of trinucleotides with
any spacing between 0 and 20.

The expected frequency of each dyad is estimated as the product of its
monad frequencies in the input sequences (option -bg monads of
dyad-analysis).

=item I<positions>

Run I<position-analysis> to detect oligonucleotides showing a
positional bias, i.e. have a non-homogeneous distribution in the peak
sequence set.

This method was initially developed to analyze termination and
poly-adenylation signals in downstream sequences (van Helden et al.,
2001), and it turns out to be very efficient for detecting motifs
centred on the ChIP-seq peaks. For ChIP-seq analysis, the reference
position is the center of each sequence.

Note that I<chip-seq-analysis> also uses I<position-analysis> for the
task B<profiles>, in order to detect compositional biases (residues,
dinucleotides) in the test sequence set.


=item I<synthesis>

Generate the HTML file providing a synthesis of the results and
pointing towards the individual result files.

=item I<clean_seq>

Delete the purged sequence files after the analysis, in order to save
space.

This task is executed only when it is called explicitly. It is not
part of the tasks running with the option "-task all".

=back

=cut
    } elsif ($arg eq "-task") {
      my @requested_tasks = split ",", shift (@arguments);
      foreach my $task (@requested_tasks) {
	next unless $task;
	if ($supported_task{$task}) {
	  $task{$task} = 1;
	} else {
	  &RSAT::error::FatalError("Task '$task' is not supported. \n\tSupported: $supported_tasks");
	}
      }

=pod

=item B<-nmotifs max_motif_number>

Maximal number of motifs (matrices) to return for pattern discovery
algorithms. Note the distinction between the maximal number of motifs
(matrices) and the maximum number of patterns (words, dyads): a motif
generally corresponds to mutually overlapping several patterns (dyads,
words).

=cut

    } elsif ($arg eq "-nmotifs") {
      $main::param{matrix_nmotifs} = shift (@arguments);

=pod

=item B<-minol oligo_min_len>

=item B<-maxol oligo_max_len>

Minimal (-minol) and maximal (-maxol) oligonucleotide lengths for
word-counting approaches (oligo-analysis, position-analysis, ORM,
oligo-diff).

In our experience, optimal results are obtained with hexanucleotides
and heptanucleotides.

Note: the monad length used for dyad-analysis is not affected by those
options. Instead it is fixed to to 3. Indeed, dyad-analysis can detect
larger motifs by sampling various spacings between the two
trinucleotide monads.

=cut
    } elsif ($arg eq "-minol") {
      $main::param{oligo__min_len} = shift (@arguments);
    } elsif ($arg eq "-maxol") {
      $main::param{oligo__max_len} = shift (@arguments);

=pod

=item B<-markov markov_order>

Order of the Markov model used to estimatd expected oligonucleotide
frequencies for I<oligo-analysis> and I<orm>.

Higher order Markov models are more stringent, lower order are more
sensitive, but tend to return a large number of false positives. 

The markov model can be specified with either a positive or a negative
value. Positive value indicate the length of the prefix in the
transition matrix. Negative value indicate the order of the Markov
model relative to the oligonucleotide length. For example, the option
-markov -2 gives a model of order m=k-2 (thus, an order 5 for
heptanucleotides, an order 4 for hexanucleotides).

The optimal Markov order depends on the number of sequences in the
test set. Since ChIP-seq data typically contain hundreds to thoursands
of peaks, high Markov orders are generally good, because they are
stringent and still sensitive enough.  In our experience, motifs are
well detected with the most stringent Markov order (-markov -2).

=cut
    } elsif ($arg eq "-markov") {
      $main::param{oligo_markov} = shift (@arguments);

=pod

=item B<-1str | -2str>

Single-strand (-1str) or double-strand (-2str) analysis.

The default is double-strand analysis, since ChIP-seq results have no
particular strand orientation.

=cut
    } elsif ($arg eq "-1str") {
      $main::param{strand} = "-1str";
    } elsif ($arg eq "-2str") {
      $main::param{strand} = "-2str";

=pod

=item B<-noov | -ovlp>

Treatment of self-overlapping words: count (-ovlp) or do not count
(-noov) overlapping occurrences. In -noov mode, only renewing
occurrences are counted.

It is recommended to use the -noov mode (default) to avoid the effect
of self-overlap, which violates the hypothesis of independence of
successive occurrences underlying the binomial significance test
(oligo-analysis, dyad-analysis).

=cut
    } elsif ($arg eq "-noov") {
      $main::param{noov} = "-noov";
    } elsif ($arg eq "-ovlp") {
      $main::param{noov} = "-ovlp";

=pod

=item B<-ci class_interval>

Class interval for I<position-analysis>.

=cut

    } elsif ($arg eq "-ci") {
      $main::param{profiles_ci} = shift(@arguments);
      &RSAT::error::FatalError($main::param{profiles_ci}, "is not a valid value for class interval. Should be a strictly positive Natural number.")
	unless ((&IsNatural($main::param{profiles_ci})) && ($main::param{profiles_ci} > 0));

      ## Other parameters are not accepted
    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}

################################################################
## Check arguments
sub CheckArguments {
  &RSAT::message::TimeWarn("Checking arguments") if ($main::verbose >= 1);
  if ($infile{test_seq}) {
    unless (-e $infile{test_seq}) {
      &FatalError("Test sequence file does not exist", $infile{test_seq});
    }
  } else {
    &FatalError("You must define the test sequence set (option -i)");
  }

  if ($infile{control_seq}) {
    unless (-e $infile{control_seq}) {
      &FatalError("Control sequence file does not exist", $infile{control_seq});
    }
  }

  ## output directory
  if ($main::dir{output}) {
    &RSAT::util::CheckOutDir($main::dir{output});
  } else {
    &FatalError("You must define the output directory (option -outdir)");
  }

  ## Log file 
  $main::outfile{log} = &OutFileName(".txt", "log");

  ## Synthesis file 
  $main::outfile{synthesis} = &OutFileName(".html", "synthesis");

  ## If all tasks are requested or if no task is defined, execute all
  ## tasks.
  if ((scalar(keys(%task)) == 0) || ($task{all})) {
    %task = %supported_task;
    delete($task{all});
    delete($task{orm}); ## TEMPORARILY, ORM HAS TO BE CALLED MANUALLY BECAUSE IT TAKES TOO MUCH TIME
    delete($task{clean_seq});
  }
  foreach my $task (@supported_tasks) {
   push (@tasks, $task) if $task{$task};
  }
  &RSAT::message::Info("Tasks: ", join (",", @tasks)) if ($main::verbose >= 1);
}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; chip-seq-analysis ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;

    ## Parameter values
    print $main::out "; Parameter values\n";
    foreach my $param_name (@param_list) {
	print $main::out sprintf ";\t%-22s\t%s\n", $param_name, $param{$param_name};
    }

    ## Input file(s)
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-22s\t%s\n", $key, $value;
	}
    }

    ## Output files
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	foreach my $key (sort keys  %main::outfile) {
	  $value = $main::outfile{$key};
	  printf $main::out ";\t%-22s\t%s\n", $key, $value;
	}
    }
}

=pod

=head1 REFERENCES

The program I<chip-seq-analysis> combines a series of tried-and-tested
programs which have been detailed in the following publications.

=over

=item I<oligo-analysis>

van Helden, J., Andre, B. and Collado-Vides, J. (1998). Extracting
regulatory sites from the upstream region of yeast genes by
computational analysis of oligonucleotide frequencies. J Mol Biol 281,
827-42.

=item I<dyad-analysis>

van Helden, J., Rios, A. F. and Collado-Vides, J. (2000). Discovering
regulatory elements in non-coding sequences by analysis of spaced
dyads. Nucleic Acids Res 28, 1808-18.

=item I<position-analysis>

van Helden, J., del Olmo, M. and Perez-Ortin,
J. E. (2000). Statistical analysis of yeast genomic downstream
sequences reveals putative polyadenylation signals. Nucleic Acids Res
28, 1000-10.

=item I<matrix-scan>

Turatsinze, J. V., Thomas-Chollier, M., Defrance, M. and van Helden,
J. (2008). Using RSAT to scan genome sequences for transcription
factor binding sites and cis-regulatory modules. Nat Protoc 3,
1578-88.

=back

=head1 SEE ALSO

=over

=item I<oligo-analysis>

=item I<dyad-analysis>

=item I<position-analysis>

=item I<matrix-scan>


=back

=head1 WISH LIST

=cut

__END__
