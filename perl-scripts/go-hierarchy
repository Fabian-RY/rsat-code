#!/usr/bin/perl -w
############################################################
#
# $Id: go-hierarchy,v 1.2 2007/02/01 12:15:13 rsat Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

go-hierarchy

=head1 DESCRIPTION

After reading an obo file, able to retrieve the ancesters of one or more go classes.
This program also allows to annotate a file of gene and go ids.

=head1 AUTHORS

sylvain@scmbb.ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE
    
go-hierarchy [-i inputfile] [-o outputfile] [-v #] [-q go_class1] [-q go_class2] [-classfile classfile] 

go-hierarchy [-i inputfile] [-o outputfile] [-v #] [-genefile genefile] 

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::go;



################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();
     @class_names = ();
     @known_classes = ();
     @unknown_classes = ();
     $class = 0;
     $gene = 0;
     #$format_name = 0;
     %required_output_fields = ("name" => 1);
     %available_return_option = ("id" => 1, 
    				   "name" => 1, 
    				   "def" => 1,
    				   "namespace" => 1 );
    
    
     
    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
#    $main::in = STDIN;
    $main::out = STDOUT;

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values
    if ($gene && $class) {
      &FatalError(join("\t", "You cannot specify both a list of genes to annotate and a query go-class"));
    }

    
    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    
    ################################################################
    ## Initialize gene ontology object
    $go = new RSAT::go();
    $go->read_from_obo($infile{inputfile}); 
    

    ################################################################
    ## Determine the go classes for which the hierarchy is searched
    if ($class) {
      if ($infile{class_file}) {
        my $l = 0;
        &RSAT::message::TimeWarn("Reading classes from file", $infile{class_file}) if ($main::verbose >= 2);
        my ($class_file_handle) = &OpenInputFile($infile{class_file});
        while (my $line = <$class_file_handle>) {
          $l++;
          next if ($line =~ /^\#/); ## Skip header lines
          next if ($line =~ /^--/); ## Skip comment lines
          next if ($line =~ /^;/); ## Skip comment lines
          next unless ($line =~ /\S/); ## Skip empty lines
          chomp($line);
          my @fields = split /\s+/, $line;
          my $name =  $fields[0];
          if ($name) {
          
            push @class_names, $name;
          } else {
	    &RSAT::message::Warning("Line", $l, "starts with space. Skipped.");
          }
        }
        close $class_file_handle;
      }
      ## Identify class in the go object
      &RSAT::message::TimeWarn("Identifying",scalar(@class_names), "seed nodes in the graph") if ($main::verbose >= 2);
      foreach my $goid (@class_names) {
	my $exists = $go->exists($goid);

	if ($exists) {
	  push @known_classes, $goid;
	  &RSAT::message::Info("Identified class with id", $goid) if ($main::verbose >= 3);
        } else {
	  push @unknown_classes, $goid;
	  &RSAT::message::Warning("The GO obo file you submitted does not contain any class with id", $goid);
	}
      }
    }

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);
    
    ################################################################
    ## Retrieve the ancesters for the queried classes
    if ($class) {
      ## Header output
      print $out "#query_class_name";
      if (exists($required_output_fields{"name"})) {
        print $out "\tancester_class_name";
      }
      if (exists($required_output_fields{"namespace"})) {
        print $out "\tnamespace";
      }  
      if (exists($required_output_fields{"id"})) {
        print $out "\tgo_id";
      }
      if (exists($required_output_fields{"def"})) {
        print $out "\tdefinition";
      }
      print $out "\n";
      ## Ancesters search
      foreach my $goid (@known_classes) {
        print @class_names."\n";
        my $goclassesRef = $go->get_parents($goid);
        @goclasses = @{$goclassesRef};
        my $goid_name = $go->get_name($goid);
        foreach my $goclass (@goclasses) {
          print $out "$goid_name";
          if (exists($required_output_fields{"name"})) {
            print $out "\t".$go->get_name($goclass);
          }
          if (exists($required_output_fields{"namespace"})) {
            print $out "\t".$go->get_namespace($goclass);
          }  
          if (exists($required_output_fields{"id"})) {
            print $out "\t".$goclass;
          }
          if (exists($required_output_fields{"def"})) {
            print $out "\t".$go->get_definition($goclass);
          }
          print $out "\n";
        }
      }
    } 
    
    ################################################################
    ## Annotate the gene file by adding the ancesters. Output may be use
    ## in the compare-classes program
    
    if ($gene) {
      ## Header output
      print $out "#gene_name\tgo_class_name";
      if (exists($required_output_fields{"namespace"})) {
        print $out "\tnamespace";
      }  
      if (exists($required_output_fields{"id"})) {
        print $out "\tgo_id";
      }
      if (exists($required_output_fields{"def"})) {
        print $out "\tdefinition";
      }
      print $out "\n";
      ## Ancesters search
      
      if ($infile{gene_file}) {
	my $l = 0;
	&RSAT::message::TimeWarn("Reading genes from file", $infile{gene_file}) if ($main::verbose >= 2);
	my ($gene_file_handle) = &OpenInputFile($infile{gene_file});
	while (my $line = <$gene_file_handle>) {
	  $l++;
	  next if ($line =~ /^\#/); ## Skip header lines
	  next if ($line =~ /^--/); ## Skip comment lines
	  next if ($line =~ /^;/); ## Skip comment lines
	  next unless ($line =~ /\S/); ## Skip empty lines
	  chomp($line);
	  my @fields = split /\t/, $line;
	  my $gene =  $fields[0];
	  my $goid = $fields[1];
	  if ($gene && $goid) {
	    if ($go->exists($goid)) {
	      my $goclassesRef = $go->get_parents($goid);
              @goclasses = @{$goclassesRef};
              my $goid_name = $go->get_name($goid);
              foreach my $goclass (@goclasses) {
                print $out "$gene";
                if (exists($required_output_fields{"name"})) {
                  print $out "\t".$go->get_name($goclass);
                }
                if (exists($required_output_fields{"namespace"})) {
                  print $out "\t".$go->get_namespace($goclass);
                }  
                if (exists($required_output_fields{"id"})) {
                  print $out "\t".$goclass;
                }
                if (exists($required_output_fields{"def"})) {
                  print $out "\t".$go->get_definition($goclass);
                }
                print $out "\n";
              }
	    } else {
	      &RSAT::message::Warning("Class $goid unknown at line", $l, ". Skipped.");
	    }
	  } else {
	    &RSAT::message::Warning("Format error at line", $l, ". Skipped.");
	  }
	}
	close $gene_file_handle;
      }
    }
    
    
    
    
    
    ################################################################
    ## Print output
    
    
    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Input file
=pod

=item B<-i inputfile>

This file must be in the obo format. 
If no input file is specified, the standard input is used. 
This allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{inputfile} = shift(@arguments);

	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);

=pod

=item	B<-q query_go_class>
Specify one GO class for which you want to know the ancesters. This option can be used iteratively to specify
several query classes.

=cut
	} elsif ($arg eq "-q") {
	       push @class_names, shift(@arguments);
	       $class = 1;
=pod

=item	B<-classf query_file>

Query file. This file specifies a list of go classes.
The first word of each row specifies one class. The
rest of the row is ignored.

=cut
	} elsif ($arg eq "-classf") {
	    $main::infile{class_file} = shift(@arguments);
	    $class = 1;
=pod	    
=item	B<-genef gene_file>

Gene file. This two-columns tab-delimited file specifies a list 
of genes and the GO to which the gene belongs.
	First column  : gene name
	Second column : gene ontology ID

=cut
	} elsif ($arg eq "-genef") {
	    $main::infile{gene_file} = shift(@arguments);
	    $gene = 1;	    
=pod

=item	B<-return fields>

List of fields to return : goid,name,def,namespace,all (default : name)

=cut
	} elsif ($arg eq "-return") {
	    my $fields = shift(@arguments);
	    my @all_fields = split(/,/, $fields);
	    foreach my $field (@all_fields) {
	      if (exists($available_return_option{$field})) {
  	        $required_output_fields{$field} = 1;
  	      } elsif ($field eq 'all') {
  	        %required_output_fields = %available_return_option;
  	      } else {
  	        &FatalError(join("\t", "Invalid return option", $field,"\n","Allowed options are : ",join(keys(%available_return_option))));
  	      } 
	    }
	        
	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; go-hierarchy ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=cut
