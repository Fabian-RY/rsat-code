#!/usr/bin/perl -w
############################################################
#
# $Id: random-genome-fragments,v 1.17 2010/03/15 14:50:49 morgane Exp $
#
############################################################

use strict;


=pod

=head1 NAME

random-genome-fragments

=head1 DESCRIPTION

Randomly calculates genomic coordinates, for a given organism  (installed in RSAT or from Ensembl).
Makes use of EnsEMBL API (www.ensembl.org) for EnsEMBL genomes.

=head1 AUTHORS

morgane@bigre.ulb.ac.be

=head1 CATEGORY

sequences

=head1 USAGE
    
random-genome-fragments -org organism -l length -r repetitions [-o outputfile] [-v # -rm -lf length_file] [..]

=head1 OUTPUT FORMATS

The program outputs a file containing the coordinates.

The default format is ft. Use I<convert-features -h> to
convert to another format.

Sequences can also be directly exported for genomes installed in RSAT.

To obtain the sequences for Ensembl organisms, use the coordinate file as input to I<retrieve-ensembl-seq.pl> with the options 
-ftfile YourFeaturefile -ftfileformat ft

For very big files, you might consider using the output format 'bed' and use the tools of sequence providers (Galaxy, UCSC, Ensembl) to efficently extract the sequences.




=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
push (@INC, $ENV{bioperl});
push (@INC, $ENV{ensembl});


## EnsEMBL libraries
use DBI();
require Bio::EnsEMBL::Registry;

require RSAT::organism;
require RSAT::feature;
use Data::Dumper;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();

    %main::outfile = ();
    %main::infile = ();

    $main::verbose = 0;
    #$main::out = STDOUT;
    $main::out_format = "ft";
    $main::rm = 0;
    @main::lengths =();
    @main::contig_names = ();
    @main::files2remove =();
    $main::null = "";
    $main::assembly_version = "";


    ################################################################
    ## Read argument values
    &ReadArguments();
    
    ################################################################
	## File with the specification of sequence lengths
	if ($main::infile{length_file}) {
    	my ($len_handle, $input_dir) = &OpenInputFile($main::infile{length_file});

		 while (my $line = <$len_handle>) {
    		chomp($line);
			next if ($line =~ /^;/);
			next if ($line =~ /^--/);
			next if ($line =~ /^#/);
			next unless ($line =~ /\S/);
			my @fields = split ("\t",$line);
			my $length = $fields[1];
			if (&IsNatural($length)) {
			  push @main::lengths, $length;
			}
    	}
    	close $len_handle;
    	$main::nb_fragment = $#main::lengths +1;
	} else {

    	#### check sequence lengths and repetitions
    	unless (&IsNatural($main::length_fragment)) {
		&RSAT::error::FatalError ("You should specify the sequence length");
    	} 
    
    	unless ($main::nb_fragment >=1) {
		&RSAT::error::FatalError( "Number of repetitions should be >=1");
    	}
	}

    ################################################################
    ## Check argument values 
    
    ## fasta output is not compatible with an Ensembl organism
    if ($main::organism_ens) {
    	if ($main::out_format eq "fasta"){
    		&RSAT::error::FatalError( "Returning sequences is not compatible with Ensembl genomes. Use gft output format, followed by retrieve-ensembl-seq.pl");
    	}
    }

	#################################################################
	## RSAT organism
	if ($main::organism_name) {
		our $organism = new RSAT::organism();
		$organism->check_name($main::organism_name);
		$organism->set_attribute("name", $main::organism_name);
	
		## Repeat masked version
		if ($main::rm) {
			my %args = ('rm' => 1);
			$organism->OpenContigs($main::organism_name,"","","",%args);
	
		} else {
			$organism->OpenContigs($main::organism_name);
		}
	
		## get all contigs name 
		%main::contigs= $organism->get_contigs();

		foreach my $contig_name (keys(%main::contigs)) {
			unless ($contig_name =~ /:MT:/) { #Do not take into account mitochondrial genome.		
				## store contig name
				push (@main::contig_names, $contig_name);
			}
		}
	}
	
	#################################################################
	## Ensembl organism
	elsif ($main::organism_ens) {
		
		my $ensembl = Ensembl_genome->new($main::organism_ens);
		$ensembl->get_connect_param;
		$ensembl->get_db_name;
		my $db =$ensembl->ens_connect;
		%main::ens_chroms =();
			
		my $slice_adaptor = $db->get_sliceAdaptor();
		$main::slices_ref = $slice_adaptor->fetch_all('chromosome');
		foreach my $slice (@{$main::slices_ref}) {
			my $slice_name = $slice->name();
			if ($slice_name =~ /chromosome:([\w\.]*?):/){
				$main::assembly_version = $1;
			}
			unless ($slice_name =~ /:MT:/) { #Do not take into account mitochondrial genome.	
				&RSAT::message::Info(join ("\t", "Chromosome name", $slice_name) )
				if ($main::verbose >= 2);
					push (@main::contig_names, $slice_name);
					$main::ens_chroms{$slice_name} = $slice;
				}
			}
	} else {
    	&RSAT::error::FatalError("You should select an organism.");
	}

	################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    
    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);
	my $header = &RSAT::feature::header($main::out_format);
	print $main::out $header if ($header);
	
	################################################################	
	## get random positions
	
	for (my $i=1; $i<=$main::nb_fragment; $i++) {
		
		## 1- get a random contig
		my $rand_contig = int(rand ($#main::contig_names+1));
		my $rand_contig_name = $main::contig_names[$rand_contig];
		
		## 2 - get contig length, and calculate last possible position to have
		## a fragment of the desired length
		my $contig_length;
		if ($main::organism_name) {
			$contig_length = $main::contigs{$rand_contig_name}->get_length();
		} elsif ($main::organism_ens) {
			$contig_length = $main::ens_chroms{$rand_contig_name}->length();
		}
		&RSAT::message::Info(join ("\t", "Random chrom", $rand_contig_name, "length",$contig_length) )
				if ($main::verbose >= 2);
		
		my $rand_fragment_size;
		if ($main::length_fragment) {
			$rand_fragment_size = $main::length_fragment;
		}	else {
			$rand_fragment_size = $main::lengths[$i-1];
		}
		my $contig_last_rand_pos = $contig_length - $rand_fragment_size;
		
		## 3 - get a random start position
		my $rand_start = int(rand ($contig_last_rand_pos));
		## check that the fragment is not in negative coord
		my $count = 0;
		while ($rand_start < 1) {
			$rand_start = int(rand ($contig_last_rand_pos));
			last if ($rand_start > 0);
			$count ++;
			last if ($count == 5); ##
			&RSAT::message::Info(join ("\t", "Negative start value for contig", $rand_contig_name, "value",$rand_start) )
				if ($main::verbose >= 2);
		}
		##exclude the contig from the analysis, if it is too difficult to get a fragment of the correct size.
		if ($rand_start < 1) {
			&RSAT::message::Info(join ("\t", "Excluding", $rand_contig_name, "from contigs due to repetitive negative starts. Contig length:",$contig_length," fragment size:",$main::length_fragment) )
			if ($main::verbose >= 2);
			splice(@main::contig_names, $rand_contig, 1);
			$i--;
			next;
		}
		
		## calculate end position
		my $rand_end = $rand_start + $rand_fragment_size -1;
		
		## 4- rand strand
		my @strands = ("D","R");
		my $rand_strand = $strands[rand @strands];
		
		my $seq_id = "rand_".$i;
		
		&RSAT::message::Info(join ("\t", "Random fragment", $seq_id, $rand_contig_name,$rand_start,$rand_end,$rand_strand) )
		if ($main::verbose >= 2);
  
    	################################################################
   		## Print sequences
   		if (($main::organism_name)&&(($main::out_format eq "fasta"))) {
			my $current_seq = $main::contigs{$rand_contig_name}->get_sequence($rand_start,$rand_end,$rand_strand);
			my @comments = join("; ",
								"random sequence $i of $main::nb_fragment",
								"length: $rand_fragment_size",
								"$rand_contig_name",
								"$rand_start:$rand_end:$rand_strand"
								);
		
			&PrintNextSequence($main::out, $main::out_format,0, $current_seq, $seq_id, @comments);
			
   		} else  {
   		################################################################	
		## print the coordinates		
			my $feature = new RSAT::feature(); 
			$feature->set_attribute("ft_id", $seq_id);	 
			$feature->set_attribute("ft_type","random_fragment");
			$feature->set_attribute("feature_name",$seq_id);
			if ($main::out_format eq "bed"){
				# adapt the chromosome name for UCSC ChrXXX
				$rand_contig_name =~ s/chromosome:[\w\.]*?://;
      			$rand_contig_name =~ s/:.*//;
				$rand_contig_name = "chr".$rand_contig_name ;
				## in UCSC BED files are zero-based
				$feature->set_attribute("start",$rand_start-1);
				$feature->set_attribute("end",$rand_end); ## not -1, otherwise the tools Galaxy or UCSC do not work properly
			} else {
				$feature->set_attribute("start",$rand_start);
				$feature->set_attribute("end",$rand_end);
			}
			$feature->set_attribute("seq_name",$rand_contig_name);	
			$feature->set_attribute("strand",$rand_strand);
			
			print $main::out $feature->to_text($main::out_format, $main::null);
   		}
	}


    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    
    ################################################################
	## clean
	if (scalar(@main::files2remove)>0) {
		foreach my $file (@main::files2remove){
			system("rm -f $file");
		}
	}
     
    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
=pod

=item B<-oformat output_format>

Output format. Default is ft. To convert to another supported feature 
format, type the following command: I<convert-features -h>

For RSAT organisms, the outpout format can also be set to 'fasta' to retrieve
sequences. For Ensembl organisms, use the coordinate file as input to
I<retrieve-ensembl-seq.pl> with the options 

-ftfile YourFeaturefile -ftfileformat ft.

For very big files, you might consider using the output format BED, which is adapted to UCSC database. 
You can thus use the tools of sequence providers (UCSC, Galaxy, Ensembl) to efficently extract the sequences.
The genomic intervals in this BED file are 0-based, to be compliant with UCSC, and related programs to retrieve sequences (Galaxy). 
Chromosome thus start at position 0 (not 1).

=cut
	} elsif ($arg eq "-oformat") {
	    $main::out_format = shift(@arguments);

		    ### repeat_masked
=pod

=item	B<-rm>

Will use the version of genome with repeat masked


=cut
	} elsif ($arg eq "-rm") {
	    $main::rm = 1;
	    
	
		    ### organism
=pod

=item B<-org organism_name>

Specifies an organism, installed in RSAT.
To have the list of supported organism in RSAT, type the following
command: I<supported-organism>

=cut
	} elsif ($arg eq "-org") {
	    $main::organism_name = shift(@arguments);

		    ### organism_ensembl
=pod

=item B<-org_ens ensembl_organism_name>

Specifies an organism, from EnsEMBL database.
No caps, underscore between words (eg 'homo_sapiens')

=cut
	} elsif ($arg eq "-org_ens") {
	    $main::organism_ens = shift(@arguments);

		    ### ensembl server
=pod

=item B<-ensemblhost mysql_server_name>

Uses a local EnsEMBL server. (Advanced users)

=cut
	} elsif ($arg eq "-ensemblhost") {
	    $main::local_server = shift(@arguments);


	    
		    ### nb of fragments
=pod

=item	B<-r repetitions>

Allows to generate a set r of sequences, each of length l.


=cut
	} elsif ($arg eq "-r") {
	    $main::nb_fragment = shift(@arguments);

		    ### length of fragments
=pod

=item	B<-l sequence_length>

Sequence length of random genomic fragments.

=cut
	} elsif ($arg eq "-l") {
	    $main::length_fragment = shift(@arguments);

=pod

=item	B<-lf length file>

Allows to generate random sequences with the same
lengths as a set of reference sequences. The sequence
length file can be obtained with the command I<sequence-lengths>
		
The length file contains two columns : 

=over

=item -sequence ID (ignored)

=item -sequence length

=back

=cut
	} elsif ($arg eq "-lf") {
	    $main::infile{length_file} = shift(@arguments);

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; random-genome-fragments ";
    &PrintArguments($main::out);
    print $main::out "; Number of random fragments $main::nb_fragment\n";
    if ($main::organism_ens){
    	print $main::out "; Data from Ensembl org:$main::organism_ens assembly:$main::assembly_version \n";
    }
    if ($main::out_format eq "bed"){
    	print $main::out "; Warning: the genomic intervals in this BED file are 0-based, to be compliant with UCSC, and related programs to retrieve sequences (Galaxy). Chromosome thus start at position 0 (not 1).\n";
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}

#########################################
## CLASSES
#########################################

package Ensembl_genome;
{
 
 sub new {
  my $class = shift;
  my $species = shift;
  my $self = {
	      org => $species,
	     };
  bless $self, $class;
}

sub get_connect_param {
	my $self = shift;
	## Connection to the EnsEMBL MYSQL database
	if ($main::local_server){
  		$self->{ensembl_host} = $main::local_server; # ie 'xserve2.bigre.ulb.ac.be'  # Local db (use inside BIGRE)
	} else {
  		$self->{ensembl_host} = $ENV{ensembl_host};  
	}
	$self->{ensembl_user} = "anonymous";
}

sub get_db_name {
	my $self = shift;
	my $dbname;
	my $dbh = DBI->connect("DBI:mysql:host=".$self->{ensembl_host}.":port=5306", "$self->{ensembl_user}", "", {'RaiseError' => 1});
	
    my $sth = $dbh->prepare("SHOW DATABASES");
    $sth->execute();
    while (my $ref = $sth->fetchrow_hashref()) {
      if ($ref->{'Database'} =~ /($self->{org})_core_\d+/) {
		$dbname = $ref->{'Database'};
      }
    }
    &RSAT::message::Info (join("\t", "dbname = ", $dbname)) if ($main::verbose >= 2);
    $sth->finish();
    $dbh->disconnect();
     if ($dbname) {
     	$self->{dbname} = $dbname;
	   } else {
	   	&RSAT::error::FatalError( "there is no organism named $self->{org} in the EnsEMBL database. Use the command supported-organisms-ensembl to obtain a full list of supported organisms.");
      }
}

sub ens_connect {
	my $self = shift;
	
	 my $registry = "Bio::EnsEMBL::Registry";

 	 $registry->load_registry_from_db(
				   -host => $self->{ensembl_host},
				   -user => $self->{ensembl_user},
                   -port => "5306",
				   -verbose => "0" );
	
	my $org = $self->{dbname};
    $org =~s/_core_.+//;
  	my $db = Bio::EnsEMBL::Registry->get_DBAdaptor($org, "core");

	return $db;
}

 1;
 }


__END__

=pod

=back

=head1 SEE ALSO

=over

=item random-genes


=cut


