#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";

$start_time = $date = `date '+%d/%m/%y %H:%M:%S %Z'`;

#### initialise parameters ####
$type="site";
$id = "patser";
$matrix_length = 1;
$seq_format = "wconsensus";
$flank_len = 0;

%supported= ();
$supported{table} = 1;
$supported{matches} = 1;

#### read arguments ####
&ReadArguments();

unless (defined(%return)) {
    $return{matches} = 1;
}

#### origin file
if ($origin_file) {
    unless (open ORIG, $origin_file) {
	print "Error: could not open the oirigin file\n";
	exit;
    }
    while (<ORIG>) {
	if (/^\s*(\S+)\s*(\S+)/) {
	    $origin{$1} = $2;
	}
    }
    close ORIG;
}



#### read the sequences
if ($sequence_file) {
    ($seq, $seq_dir) = &OpenInputFile($sequence_file);
    while ((($current_seq, $current_id) = &ReadNextSequence($seq, $seq_format, $seq_dir)) &&
	   (($current_seq) || ($current_id))) {
	$current_seq =~s/\s//g;
	$sequence{$current_id} = $current_seq;
    }
    close $seq;
}


### open input file ###
($in, $input_dir) = &OpenInputFile($inputfile);

### open output file ###
$out = &OpenOutputFile($outputfile);

#### verbose ####
if ($verbose) {
    print $out ";features-from-patser ";
    &PrintArguments();
    print $out "\n";
    print $out ";Input file	$inputfile\n" if ($inputfile);
    print $out ";Output file	$outputfile\n" if ($outputfile);
    if ($sequence_file) {
	print $out ";Sequence file\t$sequence_file\n";
	print $out ";\tsequence id\tlength\n";
	foreach $id (sort keys %sequence) {
	    $length = length($sequence{$id});
	    print $out ";\t$id\t$length\n";
	}
    }
}

#### read and parse patser file
$header_printed=0;
while (<$in>) {
    if (($matrix_length == 1) && (/width of the alignment matrix\:\s+(\d+)/)) {
	$matrix_length = $1;
	print $out "; $_";

    } elsif (/^\s*(\S+)\s+position=\s+(\d+)([c\s])\s+score=\s+(\S+)(.*)/i) {
	
	#### parse the match
	$map = $1;
	$position = $2;
	$strand = $3;
	$score = $4;
	
	#### P-value
	if ($5 =~ /ln\(p-value\)=\s+(\S+)/) {
	    $lnP = $1;
	}

	
	
	#### adapt coordinates to the selected origin
	unless ($fixed_origin) {
	    $origin = $origin{$1};
	}
	if ($origin eq "-0") {
	    $start = $position - length($sequence{$map}) - 1;
	} else {
	    $start = $position - $origin;
	}
	$end = $start + $matrix_length -1;
	
	#### strand
	unless ($force_strand) {
	    if  ($strand =~ /^c$/i) {
		$strand = "R";
	    } else {
		$strand = "D";
	    }
	}
	
	#### parse information about the match
	if ($return{matches}) {

	    #### get the sub sequence
	    if ($sequence_file) {
		my $sub_sequence = uc(sub_sequence($sequence{$map}, $position -1, $matrix_length));
		my $left_flank =  lc(sub_sequence($sequence{$map}, $position -1 - $flank_len, $flank_len));
		my $right_flank =  lc(sub_sequence($sequence{$map}, $position + $matrix_length -1, $flank_len));
		if ($strand eq "C") {
		    $sub_sequence = &ReverseComplement($sub_sequence);
		    $left_flank = lc(&ReverseComplement($left_flank));
		    $right_flank = lc(&ReverseComplement($right_flank));
		    $sub_sequence = $right_flank.$sub_sequence.$left_flank;
		} else {
		    $sub_sequence = $left_flank.$sub_sequence.$right_flank;
		}
		

		#### description
		$descr = "${sub_sequence}";
	    }



	    ################################################################
	    ### print the header line if it has not yet been done
	    unless ($header_printed) {
		print $out join ("\t", 
				 "; map", 
				 "type", 
				 "id", 
				 "strand", 
				 "start", 
				 "end", 
				 "sequence", 
				 "score",
				 "ln(P)",
				 ), "\n";
		$header_printed=1;
	    }

	    #### print the match
	    &PrintFeature();
	}

	#### store scores for the score table
	if ($return{table}) {
	    push @{$scores{$map}}, $score;
	    push @{$starts{$map}},  $start;
	    push @{$strands{$map}},  $strand;
	    push @{$positions{$map}},  join ("", $start,"..",$end,$strand); #$position;
	    $max_scores_per_map = &max($max_scores_per_map, $#{$scores{$map}}+1);
	}
	

    } else {
	print $out "; $_";
    }
}

#### print score table
if ($return{table}) {
    print $out "; Score table\n" if ($verbose >= 1);

    #### header
#    print $out join ("\t", "; seq_id", 1..$max_scores_per_map), "\n";
    print $out "; seq_id";
    for my $i (1..$max_scores_per_map) {
	print $out "\tscore.${i}";
    }
    for my $i (1..$max_scores_per_map) {
	print $out "\tstart.${i}";
    }
    for my $i (1..$max_scores_per_map) {
	print $out "\tstrand.${i}";
    }
    for my $i (1..$max_scores_per_map) {
	print $out "\tposition.${i}";
    }
    print $out "\n";

    #### print matche and positions
    foreach my $map (sort keys %scores) {

	for my $i ($#{$scores{$map}}..$max_scores_per_map-2) {
	    push @{$scores{$map}}, "";
	    push @{$starts{$map}}, "";
	    push @{$strands{$map}}, "";
	    push @{$positions{$map}}, "";
	}
	print $out join ("\t", $map, 
			 (sort {$b <=> $a} @{$scores{$map}}), 
			 (sort {$scores{$b} <=> $scores{$a}} @{$starts{$map}}),
			 (sort {$scores{$b} <=> $scores{$a}} @{$strands{$map}}),
			 (sort {$scores{$b} <=> $scores{$a}} @{$positions{$map}})
			 );
	print $out "\n";
    }
}

###### verbose ######
if ($verbose) {
    $done_time = $date = `date '+%d/%m/%y %H:%M:%S %Z'`;
    print $out ";Job started $start_time";
    print $out ";Job done    $done_time";
}


###### close input file ######
close $in unless ($inputfile eq "");

###### close output file ######
close $out unless ($outputfile eq "");


exit(0);


########################## subroutine definition ############################

sub PrintFeature {
    print $out join ("\t",  
		     $map, 
		     $type, 
		     $id, 
		     $strand, 
		     $start, 
		     $end, 
		     $descr, 
		     $score,
		     $lnP), "\n";
}

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	features-from-patser

        1998 by Jacques van Helden (jacques\@ucmb.ulb.ac.be)
	
USAGE
        features-from-patser [-i inputfile] [-o outputfile] [-v]

DESCRIPTION
	converts the output from the program patser into a file
	that can be used as input for the program feature-map.

CATEGORY
	util
	conversion
	drawing

OPTIONS
        -h      (must be first argument) display full help message
        -help   (must be first argument) display options
	-v	verbose
	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-id	feature identifier
		the same identifier is used for all features
	-mlen #	
		matrix length
	-strand	D, R or DR. Strand on which to draw the feature.
	-origin	#
		each position is recalculated using this value as reference.
	-origfile	origin file	
		each line indicates the specific origin for one of the 
		sequences. It must contain 2 words separate by a tab.
		The first word is the sequence identifier (= the map name),
		the second word is the origin for that sequence.
	-seq seq_file
		indicates the sequence file which had been used as 
		input for patser. This file must be in wconsensus format.
	-N #	return matching sequences with # flanking nucleotides
		(only valid with the -seq option)
	-return
		Information to return. Supported: matches,table

		matches (Default) the output file contains one row per
		match, with the same information as in the patser
		file.

	        table: the program returns a table with one row per
		sequence and one column per match. Matches are sorted
		by significance. Beware: this format is not supported
		by feature-map.
		
INPUT FORMAT
	The input file should be the result of patser.
	
	
OUTPUT FORMAT
	By default, the program returns a table with one row per
	match, in feature-map format.

	The option -table motifies the behaviour, and a table is
	returned with one row per sequence and one column per match. 
	
EXAMPLES

       features-from-patser -v -i mydata -o myresult \
	    -return matches,table

End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
features-from-patser options
----------------
-h      	(must be first argument) display full help message
-help   	(must be first argument) display options
-i      	input file
-o      	output file
-v      	verbose
-id		feature identifier
-mlen #		matrix length
-strand		D, R or DR. Strand on which to draw the feature
-origin #	origin
-N #		return matching sequences with # flanking nucleotides
-origfile	origin file
-seq		sequencefile
-return		information to return (Supported: matches,table)
End_short_help
  close HELP;
  exit;
}



sub ReadArguments {
#### read arguments ####
    foreach $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions;
	    
	    ### input file ###
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    ### output file ###
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];

	} elsif ($ARGV[$a] eq "-strand") {
	    $strand = $ARGV[$a+1];
	    $force_strand = 1;

	} elsif ($ARGV[$a] eq "-id") {
	    $id = $ARGV[$a+1];

	    #### neighborhood (return flanking residues)
	} elsif (($ARGV[$a] eq "-N") && (&IsNatural($ARGV[$a+1]))) {
	    $flank_len = $ARGV[$a+1];

	} elsif (($ARGV[$a] =~ /^-orig/i) &&
		 ((&IsInteger($ARGV[$a+1]) || ($ARGV[$a+1] eq "-0")))) {
	    $fixed_origin = 1;
	    $origin = $ARGV[$a+1];

	} elsif ($ARGV[$a] =~ /^-origfile/i) {
	    $origin_file = $ARGV[$a+1];

	} elsif (($ARGV[$a] =~ /^-mlen/i) && (&IsNatural($ARGV[$a+1]))) {
	    $matrix_length = $ARGV[$a+1];

	    ### sequence file 
	} elsif ($ARGV[$a] =~ /^-seq/) {
	    $sequence_file = $ARGV[$a+1];

	    ### return a table
	} elsif ($ARGV[$a] eq "-return") {
	    @to_return = split ",", $ARGV[$a+1];
	    foreach $format (@to_return) {
		unless ($supported{$format}) {
		    &FatalError("$format is not a supported return format");
		}
		$return{$format} = 1;
	    }

	}
    }
}
