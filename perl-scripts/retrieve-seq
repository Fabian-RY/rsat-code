#!/usr/bin/perl
############################################################
#
# $Id: retrieve-seq,v 1.4 2000/08/02 16:42:07 jvanheld Exp $
#
# Time-stamp: <2000-08-02 18:39:32 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib.pl";
require "RSA.classes.pl";
require "RSA.seq.lib.pl";

############# help ###########
if ($ARGV[0] eq "-h") {
  &PrintHelp;
}

if ($ARGV[0] eq "-help") {
  &PrintShortHelp;
}

#### initialize parameters
my $start_time = &AlphaDate;

#  my %col = ();
#  $col{'id'} = 0;
#  $col{'kind'} = 1;
#  $col{'name'} = 2;
#  $col{'chrom'} = 3;
#  $col{'left'} = 4;
#  $col{'right'} = 5;
#  $col{'strand'} = 6;
#  $col{'descr'} = 8;

my %chomosome = ();
my $chrom = "";

$seq_label = "full";  
$sequence_type = "up";
@queries = ();
$out_format = "fasta";
$line_width = 60;


&ReadArguments;


################################################################################
############################### check parameters ###############################
################################################################################


### organism ###
if ($organism eq "") {
  die "Error: you should specify an organism\n$supported_organisms\n";  
} elsif ($organism eq "yeast") {
  $args = join " ", @ARGV;
  if ($sequence_type eq "up") {
    system "$SCRIPTS/upstream-region-yeast $args";
  } elsif ($sequence_type eq "down") {
    system "$SCRIPTS/downstream-region-yeast $args";
  }
  exit(0);
} elsif ($supported_organism{$organism}) {
  $feature_table_file = $supported_organism{$organism}->{'features'};
  $genome_file = $supported_organism{$organism}->{'genome'};
  $genome_seq_format = $supported_organism{$organism}->{'seq_format'};
  
  ### open a direct read access to the genome file
  $chrom = "genome";
  $genome_file =~ s/\.fna$/\.raw/;
  $chromosome{$chrom} = new RSA::SequenceOnDisk (filename=>  $genome_file,
						 id=>        $chrom,
						 circular=>  1, ### for bacterial genomes
						 organism=>  $organism);

} else {
  die "Error: unsupported organism $organism\n";
}

#### check output format ####
&CheckOutputSeqFormat($out_format);

#### check limits ####
$from = $default{from} unless (defined($from));
$to = $default{to} unless (defined($to));

if ($to < $from) {
  $tmp = $to;
  $to = $from;
  $from = $tmp;
}

#### queries ####
if ($return_all) {
  $query_file = $feature_table_file;
} 
if (@queries == ()) {
  ### open query file ###
  if ($query_file ne "") {
    open(QUERIES, $query_file) || 
	die "\tcannot open query file $query_file\n";
    $in = QUERIES;
  } else {
    $in = STDIN;
  }
  while (<$in>) {
    next if (/^;/);
    if ((/(\S+)/) && !(/^;/)) {
      push @queries, $1;
    }
  }
  close $in;
}
if ($#queries <0) {
  print "Error: you should enter at least one valid query\n";
  print "type retrieve-seq -help for info\n";
  exit;
}

#### output file ####
$out = &OpenOutputFile($outputfile);


#### temporary: inactivation of the -noorf option
if ($no_orf) {
  undef $no_orf;
  print $out ";\n;\tWARNING: -noorf is currently not supported due to a bug\n;\n";
}

#### verbose ####
if ($warn_level) {
  print $out "; retrieve-seq\n";
  printf $out "; %-14s\t%s\n", "organism", $organism;
  printf $out "; %-14s\t%s\n", "sequence type", $sequence_type;
  printf $out "; %-14s\t%s\n", "Output format", $out_format;
  printf $out "; %-14s\t%s\n", "Line width", $line_width;
  print $out "; clipping to avoid overlap with neighbour ORFs\n" if ($no_orf);
  print $out "; relative coordinates\n";
  print $out ";        from    $from\n";
  print $out ";        to      $to\n";
  print $out ";        size    ", abs($to - $from + 1), "\n";
  if (defined($query_file)) {
    printf $out "; %-14s\t%s\n", "Query file", $query_file;
  } else {
    print $out "; Queries:\n";
    foreach $q (@queries) {
      print $out ";	$q\n";
    }
  }
  print $out ";\n";
}

#### read data
#&ReadCDSPositions;
&ReadOrfPositions($organism);
&ReadSynonyms($organism);
#&ReadGenomeSequence;

#### retrieve the sequences ####
QUERYLOOP: foreach $query (@queries) {


  unless (defined($orf_id{uc($query)})) {
    print $out ";WARNING\tinvalid query $query\n";
    next;
  }

  $orf_id = $orf_id{uc($query)};
  if ($name{$orf_id}) {
    $name = $name{$orf_id}; 
  } else {
    $name = $orf_id;
  }
  $orf_left = $left{$orf_id};
  $orf_right = $right{$orf_id};
  $orf_strand = $strand{$orf_id};
  

  $current_from = $from;
  $current_to = $to;
  
  ### upstream region
  if ($sequence_type eq "up") {
    if ($no_orf) {
      $current_from = &max(-$up_dist{$orf_id} + 1, $from);
    } 

    if ($orf_strand eq "D") {
      $reg_left = $orf_left + $current_from;
      $reg_right = $orf_left + $current_to;
    } else {
      $reg_right = $orf_right - $current_from;
      $reg_left = $orf_right - $current_to;
    }
    
    ### downstream region
  } elsif ($sequence_type eq "down") {
    if ($no_orf) {
      $current_to = &min($down_dist{$orf_id} - 1, $to);
    } 

    if ($orf_strand eq "D") {
      $reg_left = $orf_right + $current_from;
      $reg_right = $orf_right + $current_to;
    } else {
      $reg_right = $orf_left - $current_from;
      $reg_left = $orf_left - $current_to;
    }
  }

  $reg_size =  $reg_right - $reg_left + 1;
  if ($reg_size <= 0) {
    $reg_size = 0;
  }
  
  
  ### upstream region ID and comments ####
  if ($seq_label eq "orf") {
    $current_id = $orf_id;
  } elsif ($seq_label eq "gene") {
    $current_id = $name;
  } else {
    $current_id = join("_", 
		       $orf_id,
		       $name,
		       $sequence_type,
		       $current_from,
		       $current_to
		       );
  }
  
  unless ($no_comments) {
    @comments = ("$query upstream sequence, from $current_from to $current_to, size $reg_size");
    @comments = (@comments, "upstream region size: $reg_size; upstream region location: $reg_left $reg_right $orf_strand");
    @comments = (@comments, "Gene: $name; ID: $orf_id; gene location: $orf_left $orf_right $orf_strand");
  }
  
  ### substring retrieval
  ### beware! DNA is circular
  warn (join "\t", 
	";",
	$query, 
	$orf_id, 
	$orf_left, 
	$orf_right, 
	$orf_strand,
	$current_from,
	$current_to,
	$reg_left,
	$reg_right,
	$reg_size,
	"\n"
	)
      if ($warn_level >= 2); 
 
  
  $current_seq = $chromosome{$chrom}->get_sequence($reg_left,$reg_right,$orf_strand);
  
  

### print result sequence
  &PrintNextSequence($out,$out_format,$line_width,$current_seq,$current_id, @comments);
}

close $out;

###### verbose ######
if ($warn_level) {
  my $done_time = &AlphaDate;
  print $out "; Job started $start_time\n";
  print $out "; Job done    $done_time\n";
}



exit(0);




sub PrintHelp {
    open(HELP, "| more");
    print HELP<<End_help;
USAGE
	retrieve-seq -type type -org organism	
			[-from] [-to] [-format seqformat] [-lw line_width] 
			[-o outpufile] -q query_orf | -i query file | -all
	
	returns the DNA sequence of a region located upstream from a query orf.
	
OPTIONS
	-org organism
	     supported organisms : 
$supported_organisms
	-type	sequence type
		Currently supported sequence types
			upstream (default)
		To implement in the future
			downstream
			introns
			coding
	-q query
		The query should be an orf identifier (eg 'metR').
		The query is case-insensitive.
		Multiple queries can be entered by reiteratively using the -q 
		option.
        -i     query file. The first word of each line is taken as a query.
                This option is incompatible with -q.
	-all	return all genomic upstream regions
	-o	followed by the name of the outputfile. 
        -from #1 -to #2 
                where #1 and #2 are numbers. #2 should be higher than #1.
                limits of the region to extract, relative to orf start 
                (=position 0). Use negative values for upstream sequence.
                        example: -from -800 -to -1 
                        will extract the 800 bp upstream the orf start.
			 (this is the default)
	-format	allows to select different output formats, with the following 
		options:
		IG	IntelliGenetics (default format)
		WC	wconsensus format
		raw	only the sequence is returned, without spaces, newlines
			nor comments.
                FastA
	-lw ##	Line width. A newline character will be inserted in the 
		sequence every ## bases. Default is 60. 
		-lw 0 will prevent newline insertion.
        -label label_type
		rule for naming sequences
		supported label types
			orf	ORF identifier
			gene	gene name
				(if the gene has no name, ORF identifier is used instead).
			full	label is a concatenation of ORF identifier,
				gene name, sequence type and limits

	-noorf	the upstream sequence can only contain non-coding sequence.
		i.e. the -from values is modified if a predicted orf
		is encountered within its range. 
		The weaknesses of using this option are that
		- all predicted orf do not correspond to real orf,
		- there is no a priori reason to exclude a regulatory site
		  which would overlap the upstream coding sequence.
	-nocom	no comments. Only the identifier and the sequence are
		returned. By default, the comment indicates the orf and
		upstream sequence coordinates.

INPUT FORMAT
	Sequence file
		Sequence file can adopt any format supported by RSA 
		(currently : fasta, IG, raw, multi, filelist)

	Feature file
		The feature file contains one line per feature, with
		tab-delimited columns providing the following information:
		column	field
		1	id	feature identifier
		2	kind	orf for coding sequence
		3	name	feature name
		4	chrom	chomosome. 
				For bacteria, use the organism abbrev
		5	left	left end position
		6	right	right end position
		7	strand	D (direct) or R (reverse)
		8	descr	short description (optional)

EXAMPLES
	retrieve-seq -type upstream -org coli -q metJ -from +59 -to -200
	
	will return the sequence of 260 nucleotides, 200of which 
	extracted upstream the start codon, and the 60 following being 
	the beginning of the coding sequence.

WEB VERSION
	http://www.ucmb.ulb.ac.be/bioinformatics/rsa-tools

End_help
    close HELP;
    exit;
}

sub PrintShortHelp {
  open(HELP, "| more");
  print HELP<<End_short_help;
retrieve-seq options
--------------------
-org		organism
$supported_organisms
-type		upstream
-i		query file. This option is incompatible with -q.
-q		query
-all		returns all genomic upstream regions
-o		followed by the name of the outputfile. 
-from #1 -to #2	limits of the region to extract, relative to orf start 
-format		output sequence format. accepted: IG, raw, WC
-lw ##		Line width. -lw 0 will prevent newline insertion.
-label orf|gene|full	rule for naming sequences
-noorf		the upstream sequence can only contain non-coding sequence.
-nocom		do not print related information (start, end position, ...)
End_short_help
  close HELP;
  exit;
}


#### read arguments
sub ReadArguments {
  foreach $a (0..$#ARGV) {
    ### output file name
    if ($ARGV[$a] eq "-o") {
      $outputfile = $ARGV[$a+1];
      
      ### help request
    } elsif ($ARGV[$a] eq "-h") {
      &PrintHelp;
    } elsif ($ARGV[$a] eq "-help") {
      &PrintShortHelp;
      
      ### output sequence format
    } elsif ($ARGV[$a] eq "-format") {
      $out_format = lc($ARGV[$a+1]);
      
      ### limits of the region to retrieve
    } elsif (($ARGV[$a] eq "-from") && ($ARGV[$a+1] =~ /^[+-]{0,1}(\d+)$/)) {
      $from = $ARGV[$a+1];
    } elsif (($ARGV[$a] eq "-to") && ($ARGV[$a+1] =~ /^[+-]{0,1}(\d+)$/)) {
      $to = $ARGV[$a+1];
      
      ### verbose
    } elsif ($ARGV[$a] eq "-v") {
      $warn_level = 1;
      
      ### warn_level
    } elsif (($ARGV[$a] eq "-w") &&
	     (&IsNatural($ARGV[$a+1]))){
      $warn_level = $ARGV[$a+1];
      
      #### new query
    } elsif ($ARGV[$a] eq "-q") {
      @queries = (@queries, $ARGV[$a+1]);
      
      #### input file (one query per line)
    } elsif ($ARGV[$a] eq "-i") {
      $query_file =$ARGV[$a+1];
      
      ### return all genomic  upstream regions	
    } elsif ($ARGV[$a] eq "-all") {
      $return_all = 1;;
      
      #### organism
    } elsif ($ARGV[$a] eq "-org") {
      $organism =$ARGV[$a+1];
      
      #### type
    } elsif ($ARGV[$a] eq "-type") {
      if ($ARGV[$a+1] =~ /^up/) {
	$sequence_type = "up";
	$default{from} = -400;
	$default{to} = -1;

      } elsif ($ARGV[$a+1] =~ /^down/) {
	$sequence_type = "down";
	$default{from} = 1;
	$default{to} = 200;

      } else {
	die "Error: unsupported sequence type: '$ARGV[$a+1]'\n";
      }
      
      
      #### line width
    } elsif (($ARGV[$a] eq "-lw") && ($ARGV[$a+1] >= 0)) {
      $line_width = $ARGV[$a+1];
      
      #### use identifiers rather than gene names
    } elsif ($ARGV[$a] eq "-label") {
      if ((lc($ARGV[$a+1]) eq "orf")) {
	$seq_label = "orf";
      } elsif ((lc($ARGV[$a+1]) eq "gene")) {
	$seq_label = "gene";
      } elsif ((lc($ARGV[$a+1]) eq "full")) {
	$seq_label = "gene";
      } else {
	die "Error: invalid sequence label";
      }
      
      #### do not allow overlapping coding sequences
    } elsif (($ARGV[$a] =~ /^-nocds/i) || 
	     ($ARGV[$a] =~ /^-noorf/i)) {
      $no_orf = 1;

      #### do not print the comments field
    } elsif ($ARGV[$a] =~ /^-nocom/i) {
      $no_comments = 1;
      
    }
  }
}
