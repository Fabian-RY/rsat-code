#!/usr/bin/perl
use CGI;
#require "cgi-lib.pl";
require "RSA.seq.lib";
require "RSA.stat.lib";
umask 0022;


############################################################################
############################################################################
############################################################################
############################################################################
############################################################################
####                                                                    ####
####                            RSAlib.perl                             ####
####                                                                    ####
############################################################################
############################################################################
############################################################################
############################################################################
############################################################################

#### Regulatory Sequence Analysis Tools (RSA-tools)
####  Project started in 1997 by Jacques van Helden (jvanheld@ucmb.ulb.ac.be)
####  a Perl library with diverse procedures
####  used by rsa-tools perl scripts


############################################################################
########################## PATH DEFINITION ##############################
############################################################################


#### read config files #####
if ($0 =~ /([^(\/)]+)$/) {
    $config_file = "$`../RSA.config";
    require $config_file;
    if ($ENV{'RSA_LOCAL_CONFIG'}) {
	if (-e $ENV{'RSA_LOCAL_CONFIG'}) {
	    if (-r $ENV{'RSA_LOCAL_CONFIG'}) {
		require $ENV{'RSA_LOCAL_CONFIG'};
	    } else {
		warn (";WARNING: cannot read local config file ", 
		      $ENV{'RSA_LOCAL_CONFIG'}, 
		      "\n"), 
	    }
	} else {
	    warn (";WARNING: local config file ", 
		  $ENV{'RSA_LOCAL_CONFIG'}, 
		  " does not exist\n"), 
	}
    }
} else {
    print "Error: problem when opening config file\n";
    print "Please contact jvanheld\@ucmb.ulb.ac.be\n";
    exit;
}



$BIN = "$RSA/bin";
$LIB = "$RSA/lib";
$TMP = "$RSA/public_html/tmp";
$LOGS = "$RSA/logs";
$SCRIPTS = "$RSA/perl-scripts";

my $login = getlogin;
#### redirect queries to a remote server
if ($REMOTE_SERVER) {
    if (($login eq "webserv") || !($login)) {
	$NICE = "nice +5";
	$RSH = "rsh -l jvanheld ${REMOTE_SERVER} $NICE";
	$SCRIPTS = "$RSH /home/rsa/rsa-tools/perl-scripts";
	$BIN = "$RSH /home/rsa/rsa-tools/bin";
    }
}


$HTML = "$RSA/public_html"; 
$WWW_TMP = "$WWW_RSA/tmp";
$ENV{SERVER_ADMIN} = "jvanheld\@ucmb.ulb.ac.be";

$counter_file = "$LOGS/count-file";
($sec, $min, $hour,$day,$month,$year) = localtime(time);
$log_file = sprintf "$LOGS/log-file_${config_site}_%04d_%02d", $year+1900,$month+1;

$script_name = &ShortFileName($0);

$date = &AlphaDate();

############################################################################
############################ GLOBAL VARIABLES ##############################
############################################################################


############################################################################
##################### PERL SUBROUTINE DEFINITION ###########################
############################################################################

################################################################
## echo a command and send it to the system
sub doit {
    my ($command, $dry, $die_on_error, $verbose) = @_;
    warn "\n", &AlphaDate(), "\t", $command, "\n" if ($verbose >= 1);
    my $error = system $command unless ($dry);
    if ($die_on_error) {
	if ($error == -1) {
	    &FatalError("Could not execute the command\n\t$command");
	} elsif ($error) {
	    &FatalError("Error $error occurred during execution of the command\n\t$command");
	}
    } else {
	return ($error);
    }
}


################################################################
#### Open an input stream
#### If a file name is specified, open this file. If not, read input from the STDIN
#### if the input file has extension .gz, or .Z, it is decopmpressed on the flight. 
#### usage 
####    ($in,$input_dir) = &OpenInputFile($filename);
#### returns a file handle
sub OpenInputFile {
    my ($filename) = @_;
#    warn "BOUM $filename";
    my $input_stream;
#    my ($short_file_name, $input_dir) = &ShortFileName($filename);
    warn join ("\t", "; Opening input stream", $filename, $short_file_name, $input_dir), "\n" 
	if ($verbose >= 2);
    my $input_dir = "";
    my $short_file_name = "";
    if ($filename) {
	($input_dir, $short_file_name) = &SplitFileName($filename);
	unless (-e $filename) {
	    if (-e "${filename}.gz") {
		$filename .= ".gz";
	    } elsif (-e "${filename}.Z") {
		$filename .= ".Z";
	    } else {
		&FatalError("OpenInputFile: File $filename does not exist.");
	    }
	}
	if ($filename =~ /\.gz$/) { ### gzip file -> decompress it on the fly
	    warn "; Uncompressing .gz file\n" if ($verbose >= 2);
	    $filename = "gunzip -c $filename |";
	} elsif ($filename =~ /\.Z$/) { ### gzip file -> decompress it on the fly
	    warn "; Uncompressing .Z file\n" if ($verbose >= 2);
	    $filename = "uncompress -c $filename |";
	}
	unless (open(INPUT, $filename)) {
	    print "\tError : cannot read input file $filename\n";
	    exit;
	}
	$input_stream = INPUT;
    } else {
	$input_stream = STDIN; ### default is standard input

    }
   return ($input_stream, $input_dir);
}

### open output file ###
sub OpenOutputFile {
    ### usage $output_stream = &OpenOutputFile($filename);
    my ($filename) = @_;
    my $to_open = "";
    
    if ($filename) {
	if ($filename =~ /\.gz$/) { ### gzip file -> decompress it on the fly
	    $to_open = "| gzip -c > $filename";
	} else {
	    $to_open = ">$filename";
	}
	unless (open OUTPUT, "$to_open") {
	    &FatalError ("\tError : cannot write output file $filename\n");
	}
	$output_stream = OUTPUT;
    } else {
	$output_stream = STDOUT;
    }
    return $output_stream;
}

################################################################
## Check for the existence of an output directory, and, if it does not
## exist, create it
sub CheckOutDir {
    my ($output_dir, $umask) = @_;

    next unless $output_dir;

    $umask = 0002 unless ($umask);
    umask($umask);

    if ($output_dir) {
	unless (-d $output_dir) {
	    warn "Creating directory $output_dir\n" if ($main::verbose >= 1);
	}
	mkdir ($output_dir, 0755);
	unless (-d $output_dir) {
	    warn "Creating directory with all parents $output_dir\n" if ($main::verbose >= 1);
	    system "mkdir -p $output_dir"; ## create output directory with all parents
	}
	unless (-d $output_dir) {
	    &FatalError("Cannot create output directory $output_dir");
	}
    } else {
	$output_dir = ".";
    }
}

################################################################
## Name of the expected frequency file, 
## given the organism, oligo length and background model
##
sub ExpectedFreqFile {
    my ($organism_name, $oligo_length, $background, %args) = @_;
    my $exp_freq_file = "";
    my $str = $args{str} || "-2str";
    my $noov = $args{noov} || "-noov";
    
    #### organism
    &CheckOrganism($organism_name);
    
    #### check oligo length
    unless (&IsNatural($oligo_length)) {
	&FatalError("Invalid oligonucleotide length : must be a natural number");
    }
    
    if ($oligo_length < 1) {
	&FatalError("Invalid oligonucleotide length : must be >= 1");
    }
    if ($oligo_length > 8) {
	&FatalError("Invalid oligonucleotide length : must be <= 8");
    }

    
    $exp_freq_file = $data_dir."/oligo-frequencies/";
    if ($background eq "upstreamL") {
	$exp_freq_file .= "_".$organism_name;
	$exp_freq_file .= "_allup500";
	$exp_freq_file .= $oligo_length."nt";
	$exp_freq_file .= $str;
	$exp_freq_file .= $noov;
	$exp_freq_file .= "_freq.tab";
    } else {
	$exp_freq_file .= $oligo_length."nt";
	$exp_freq_file .= "_".$background;
	$exp_freq_file .= "_".$organism_name;
	#### build the name of the expected frequency file 
#	if ((-e $exp_freq_file."-1str.freq") || 
#	    (-e $exp_freq_file."-1str.freq.gz")) {
	    $exp_freq_file .= "-1str.freq";
#	} else {
#	    #### TEMPORARY the previous format is still supported
#	    $exp_freq_file .= ".freq";
#	}
    }

    ## Check the existence of the exp freq file
    unless ((-e $exp_freq_file) || 
	    (-e $exp_freq_file.".gz")) {
	&FatalError("Cannot find expected frequency file $exp_freq_file");
    }

    warn "; Expected frequency file\t", $exp_freq_file, "\n" if ($main::verbose >= 0);
    return $exp_freq_file;
}


################################################################
# Read expected occurrences and variance from a calibration file
sub ReadCalibration {
    my ($calibration_file, $sum_rc) = @_;
    
    my ($cal) = &OpenInputFile($calibration_file);
    my $l=0;
    while (<$cal>) {
	$l++;
	chomp();
	next if (/^;/);
	next unless (/\S/);
	my @fields =  split /\s+/;
	my $pattern_seq = lc(shift(@fields));
	my $pattern_id = $pattern_seq;

	## Check if the 1st field contains a pair of reverse complements
	if ($pattern_seq =~ /(\S+)\|/) {
	    $pattern_seq = $1;
	}
	
	## Check if the second field contains the ID
	if ($fields[0] =~ /(\S+)\|/) {
	    $pattern_id = shift(@fields);
	}

	## Expected occurrences
	my $exp_occ = $fields[0];
	&FatalError("Invalid expected occurrences\t${exp_occ}") unless ((&IsReal($exp_occ)) && ($exp_occ >= 0));
	$patterns{$pattern_seq}->{exp_occ} = $exp_occ;

	## Expected variance
	my $exp_var = $fields[2];
	&FatalError("Invalid expected variance") unless ((&IsReal($exp_var)) && ($exp_ocvar >= 0));
	$patterns{$pattern_seq}->{exp_var} = $exp_var;

	warn join("\t", "; calibration", $pattern_seq, 
		  $patterns{$pattern_seq}->{exp_occ},
		  $patterns{$pattern_seq}->{exp_var}), "\n" if ($main::verbose >= 5);

    }
    close $cal if ($calibration_file);
    
    #### check if reverse complements were included in the expected freq file;
    #### if not, infer them from the direct strand 
    foreach my $pattern_seq (sort keys %patterns) {
  	my $rc = lc(&SmartRC($pattern_seq));
  	if (($patterns{$rc}->{exp_occ} <= 0) &&
  	    ($patterns{$pattern_seq}->{exp_occ})) {
  	    $patterns{$rc}->{exp_occ} = $patterns{$pattern_seq}->{exp_occ};
  	    $patterns{$rc}->{exp_var} = $patterns{$pattern_seq}->{exp_var};
	    #print STDERR join "\t", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n";
  	}
    }
}


################################################################
# Read pattern expected frequencies from a file
#
sub ReadExpectedFrequencies {
    my ($exp_freq_file, $sum_rc, $rescale_freq) = @_;
    
    ($exp) = &OpenInputFile($exp_freq_file);
    my $l=0;
    while (<$exp>) {
	$l++;
	chomp();
	next if (/^;/);
	next unless (/\S/);

	my @fields =  split /\s+/;
	$pattern_seq = lc($fields[0]);

#	warn join "\t", "fields", $fields[0], "\n";

	#### check the format and extract expected frequency
	if (&IsReal($fields[1])) {
	    ### second field contains the expected frequency (old format)
	    $patterns{$pattern_seq}->{exp_freq} = $fields[1];
	    $file_type="undef";

  	} elsif (($fields[1] =~ /(\S+)\|(\S+)/) && (&IsReal($fields[2]))) {
	    #### second field contains the ID as a pair of reverse complements
	    $file_type = "2str";
  	    $fw = lc($1);
  	    $rc = lc($2);
  	    $patterns{$rc}->{exp_freq} = $fields[2];
  	    $patterns{$fw}->{exp_freq} = $fields[2];

  	} elsif	(($fields[1] eq $fields[0]) &&(&IsReal($fields[2]))) {
	    #### second field contains the ID which is identical to the pattern (single strand pattern)
	    $file_type = "1str";
  	    $patterns{$fields[0]}->{exp_freq} = $fields[2];

	} else {
	    ### unrecognized format
	    &FatalError("Invalid expected frequency in file $exp_freq_file at line $l\n");
	}
	
	if ($patterns{$pattern_seq}->{exp_freq} < 0) {
	    &FatalError("Expected frequency cannot be negative\t$pattern_seq\t".$patterns{$pattern_seq}->{exp_freq});
	}
    }
    close $exp if ($exp_freq_file);
    
    #### check if reverse complements were included in the expected freq file;
    #### if not, infer them from the direct strand 
    foreach my $pattern_seq (sort keys %patterns) {
  	my $rc = lc(&SmartRC($pattern_seq));
  	if (($patterns{$rc}->{exp_freq} <= 0) &&
  	    ($patterns{$pattern_seq}->{exp_freq})) {
  	    $patterns{$rc}->{exp_freq} = $patterns{$pattern_seq}->{exp_freq};
	    #print STDERR join "\t", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n";
  	}
    }

    #### sum expected frequencies by reverse complements
    if (($sum_rc) && ($file_type eq "1str")) {
	&SumExpectedFrequencies(%patterns);
    }

    #### make sure that the sum of frequencies is positive
    my $freq_sum = 0;
    foreach my $pattern_seq (keys %patterns) {
	$freq_sum += $patterns{$pattern_seq}->{exp_freq};
    }
    if ($freq_sum <= 0) {
	&FatalError("Error with the expected frequency file : the sum must be strictly positive\t$freq_sum");
    }
    
    #### rescale expected frequencies to have a sum of 1
    if ($rescale_freq) {
	print $out "; Rescaling expected frequencies\n" if ($verbose >=1);
	foreach my $pattern_seq (keys %patterns) {
	    $patterns{$pattern_seq}->{exp_freq} /= $freq_sum;
	}
    }
    
}


################################################################
## Sum expected frequencies
##
sub SumExpectedFrequencies {
    %patterns = @_;
    foreach my $pattern_seq (sort keys %patterns) {
	my $rc = lc(&SmartRC($pattern_seq));
	if ($rc eq $pattern_seq) {
	    #### palindromic sequence
	    $freq_2str{$pattern_seq} =   $patterns{$pattern_seq}->{exp_freq};
	} else {
	    #### non-palindromic sequence : the expected frequency is the sum of the sequence + its reverse complement 
	    $freq_2str{$pattern_seq} =  $freq_2str{$rc} = $patterns{$rc}->{exp_freq} + $patterns{$pattern_seq}->{exp_freq};
	}
	warn join ("\t", 
		   $pattern_seq,  
		   $patterns{$pattern_seq}->{exp_freq}, 
		   $freq_2str{$pattern_seq},
		   $rc, 
		   $patterns{$rc}->{exp_freq}, 
		   $freq_2str{$rc},
		   ), "\n" if ($verbose >= 5);
    }
    
    foreach my $pattern_seq (sort keys %patterns) {
	$patterns{$pattern_seq}->{exp_freq} = $patterns{$rc}->{exp_freq} = $freq_2str{$pattern_seq};
    }
}


################################################################
# Calculate conditional residue probabilities on the basis of specified
# oligonucleotide frequencies
sub CalcConditionalProbabilities {
    my ($exp_freq_file) = @_;

    &ReadExpectedFrequencies($exp_freq_file) ;
    
    warn "; Calculating conditional probabilities\n" if ($main::verbose >= 2);
    
    foreach my $pattern_seq (keys %patterns) {
	$expected_freq{$pattern_seq} = $patterns{$pattern_seq}->{exp_freq};
    }

    #### calculate alphabet from expected frequency keys
    foreach my $pattern_seq (keys %patterns) {
	my @residues = split "|", $pattern_seq;
	foreach my $r (@residues) {
	    $letter{$r} = 1;
	}
    }
    @letters = keys (%letter);

    #### calculate subword frequencies
    %subword_freq = ();
    foreach my $oligo_seq (keys %expected_freq) {
	my $subword = substr($oligo_seq,0,-1);
	$subword_freq{$subword} += $expected_freq{$oligo_seq};
    }

    foreach $subword (keys %subword_freq) {
	for $l (0..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    if ($subword_freq{$subword} > 0) {
		$conditional_proba{$subword}[$l] =  $expected_freq{$word}/$subword_freq{$subword};
	    } else {
		$conditional_proba{$subword}[$l] =  "NA";
	    }
	}
    }

    #### calculate cumulative conditional residue probabilities
    foreach $subword (keys %subword_freq) {
	$word = lc($subword.$letters[0]);
	$cum_letter_freq{$subword}[0] = $expected_freq{$word};
	$cum_letter_freq{$subword}[0]/=$subword_freq{$subword} if $expected_freq{$word};
# 	warn (join ("\t", 
# 		    $subword, 
# 		    $subword_freq{$subword},
# 		    $word, 
# 		    $expected_freq{$word},
# 		    $cum_letter_freq{$subword}[0]
# 		    ), "\n");
	for $l (1..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    $cum_letter_freq{$subword}[$l] = $cum_letter_freq{$subword}[$l-1];
	    $cum_letter_freq{$subword}[$l] += $expected_freq{$word}/$subword_freq{$subword} if $expected_freq{$word};
#	    warn (join ("\t", 
#			$subword, 
#			$subword_freq{$subword},
#			$word, 
#			$expected_freq{$word},
#			$cum_letter_freq{$subword}[$l]
#			), "\n");
	}
    }
    @subword_keys = sort keys %subword_freq;
}

################################################################
### returns current time
### usage
### $time = &CurrentTime;
sub CurrentTime {
    my $current_time = `date '+%H:%M:%S'`;
    $current_time =~ chomp $current_time;
    return $current_time;
}

################################################################
### returns 1 if the first argument is a natural number,
###         0 otherwise
### usage
### if (IsNatural($my_number) { 
sub IsNatural {
    if ($_[0] =~ /^ *\d+ *$/) {
	return 1;
    } else {
	return 0;
    }
}

################################################################
### returns 1 if the first argument is an integer number,
###         0 otherwise
### usage
### if (IsInteger($my_number) { 
sub IsInteger {
    if ($_[0] =~ /^ *[\+\-]{0,1}\d+ *$/) {
	return 1;
    } else {
	return 0;
    }
}

################################################################
### returns 1 if the first argument is a real number,
###         0 otherwise
### usage
### if (number($my_number) { 
sub IsReal {
    my ($value) = @_;
    return if ($#_ < 0);
    return 0 unless defined($value);

    if (($value =~ /^ *[\+\-]{0,1}\d+(\.\d*){0,1} *$/) || 
        ($value =~ /^ *[\+\-]{0,1}\d+(\.\d*){0,1}e[\+\-]{0,1}\d+ *$/i)) {
	return 1;
    } else {
	return 0;
    }
}


################################################################
#### returns the closest integer value from a real number
#### usage:
#### $my_int = &round($my_real);
sub round {
    my $my_real = $_[0];
    my $my_int;
    if (abs(($my_real - int($my_real))) < 0.5) {
	return int($my_real);
    } elsif ($my_real < 0) {
	return int($my_real) - 1;
    } else {
	return int($my_real) + 1;
    }
}

################################################################
#### suppress space characters at the start and the end of a string
sub trim {
    my ($string) = @_;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}



################################################################
### returns a date in the inverted form, so that 
### the choromological and alphabetical sorting ar identical.
### Usage:
###      $alpha_date = &AlphaDate;
sub AlphaDate {
    my $my_date = "";
    my ($sec, $min, $hour,$day,$month,$year) = localtime(time);

    ###$my_date = sprintf("%02d%02d%02d.%02d%02d%02d", $year,$month+1,$day,$hour, $min, $sec);
    $my_date = `date +%Y_%m_%d.%H%M%S`;
    chomp $my_date;
    return $my_date;
}

################################################################
#### increment the counter file for monitoring web access
sub UpdateCounterFile {
    my $nb_visitors = 1;

    ### read previous counter value
    if (-e $counter_file) {
	open(COUNTER, "<$counter_file");
	#flock(COUNTER, 2);
	$nb_visitors = <COUNTER>;
	#flock(COUNTER,8);
	close(COUNTER);
	$nb_visitors++;
    }
    
    ### save new counter value
    open(COUNTER, ">$counter_file");
    #flock(COUNTER,2);
    print COUNTER $nb_visitors;
    #flock(COUNTER,8);
    close(COUNTER);
    
    return $nb_visitors;
}


################################################################
### store info into a log file in a conveninent way for 
### subsequent login statistics
### Usage:
###     &UpdateLogFile;
sub UpdateLogFile {
  if (open LOG, ">>$log_file") {
    #flock(LOG,2);
    $date = &AlphaDate;
    #$date = `date '+%y%m%d.%H%M%S'`;
    $date =~ s/\n//;
    print LOG join ("\t", 
		    $date,
		    $config_site, 
		    "$ENV{'REMOTE_USER'}\@$ENV{'REMOTE_ADDR'} ($ENV{'REMOTE_HOST'})",
		    $script_name,
		    $query->param('user_email')
		    ), "\n";
    #flock(LOG,8);
    close LOG;
  }
  chmod 0777, $log_file;
}

################################################################
#### splits a full file name into directory and short file name
#### usage:
####     my ($dir, $short_file_name) = &SplitFileName($full_file_name);
sub SplitFileName {
    my ($full_file_name) = @_;
    my $short_file_name = $full_file_name;
    my $dir = "";
    if ($full_file_name =~ /[^(\/)]+$/) {
	$dir = $`;
	$short_file_name = $&;
#	$dir =~ s|/$||; #### suppress the trailing /
    }
    return ($dir, $short_file_name);
}

################################################################
#### removes the directory from a full file name, and returns the short file name
#### usage:
#### $file_name = &ShortFileName($full_file_name);
sub ShortFileName {
    my $full_file_name = $_[0];
    my ($dir, $short_file_name) = &SplitFileName($full_file_name);
    return $short_file_name;
}


################################################################
### returns the path from a file name
### usage 
### path = &ExtractPath($long_file_name);
###
sub ExtractPath {
    my $l_file_name = $_[0];
    my $l_path = "";
    while ($l_file_name =~ /\/(.*)/) {
	$l_path .= "$`\/";
	$l_file_name = $1;
    }
    return $l_path;
}


################################################################
#### send a unix command to remove a file the next day
#### Usage:
#### &DelayedRemoval($file_to_remove, $delay);
####
sub DelayedRemoval {
    my ($file_to_remove, $delay) = @_;
    $delay = "12 hours" unless ($delay);

    unless (-e $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove does not exist");
	return();
    }
    unless (-r $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove is not readable");
	return();
    }
    unless (-w $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove is not writable");
	return();
    }

    &MessageToAdmin("DelayedRemoval: file $file_to_remove will be removed in $delay") if ($ECHO >= 2);

    #### TEMPORARILY INACTIVATED BECAUSE IT MOBILIZES A LOT OF MEMORY
    return();

    open REMOVE, "| at now + $delay";
    print REMOVE "rm -f $file_to_remove \n";
    close REMOVE;
}


################################################################
### prints a list of elements, one per line
sub PrintList {
    my $spacer = "\n";
    foreach $element (@_) {
	print $element;
	print $spacer;
    }

}

################################################################
#### print the command-line arguments
sub PrintArguments {
    my $local_out = $_[0];
#    unless ($local_out)  {
#	$local_out = STDOUT;
#    }
    my $argument_string = "";

    foreach my $a (@main::ARGV) {
	if (($a =~ /\s+/)  ||
	    ($a !~ /\S+/) ||
	    ($a =~ /[\(\)\>\<\&]/)) {
	    $argument_string .= " '$a'";
	} else {
	    $argument_string .= " $a";
	}
    }
    print $local_out $argument_string, "\n" if ($local_out);
    return $argument_string;
}


############################################################
###############  Genome data ###############################
############################################################

@supported_feature_types = qw (CDS mRNA tRNA rRNA);
%supported_feature_types = ();
foreach my $type (@supported_feature_types) {
    $supported_feature_types{lc($type)} = 1;
}
$supported_feature_types = join ",", @supported_feature_types;



sub CheckOrganismName {
    my ($organism_name) = @_;
     unless ($supported_organism{$organism_name}) {
	&FatalError("Organism $organism_name is not supported.",
		    "Supported on this site : \n".&ListSupportedOrganisms());
    }
}


################################################################
#### Check if an organism is supported on the current installation,
#### and open streams to read its genome sequence.
####
#### Usage
#### -----
#### Automatic selection of genome and feature file : 
####    &CheckOrganism($organism_name); 
####
#### Manual specification of input files :
#### &CheckOrganism($organism_name, 
####                $feature_table_file, 
####                $input_sequence_file,  
####                $input_sequence_format);

sub CheckOrganism {
    my ($organism_name, $feature_table_file, $input_sequence_file, $input_sequence_format) = @_;
    my $organism_object = new RSA::Organism;

#    die $organism_name;

    #### check input sequence file and format
    if ($input_sequence_file) {
	$genome_file = $input_sequence_file;
	$genome_seq_format = $input_sequence_format;  
	
    } else {
	&CheckOrganismName($organism_name);
	$genome_file = $supported_organism{$organism_name}->{'genome'};
	$genome_seq_format = $supported_organism{$organism_name}->{'seq_format'};
	&Warning("checking organism\t$organism_name") if ($verbose >= 2);
	&FatalError("You should specify an organism.", 
		    "Supported organisms\n".&ListSupportedOrganisms)
	    unless ($organism_name);
    }


#    die join( "\t", $organism_name, $feature_table_file, $genome_file, $genome_seq_format), "\n";
    
    #### check feature file
    unless ($feature_table_file) {
	$feature_table_file = $supported_organism{$organism_name}->{'features'};
    }	
    &Warning("Feature table\t$feature_table_file") if ($verbose >= 2);
    
    if ($genome_seq_format eq "raw") {
	### open a direct read access to the genome file
	$chr = $organism_name;
	$genome_file =~ s/\.fna$/\.raw/;
	$chromosome_seq{$chr} = new RSA::SequenceOnDisk (filename=>  $genome_file,
							 id=>        $chr,
							 circular=>  1, ### for bacterial genomes
							 organism=>  $organism_name);
	$chromosome{$chr} = new RSA::Chromosome();
	$chromosome{$chr}->push_attribute("names", $chr);
	$chromosome{$chr}->set_sequence($chromosome_seq{$chr});
	$chromosome{$chr}->set_organism($organism_name);
	$organism_object->add_chromosome($chromosome{$chr});

    } elsif ($genome_seq_format eq "filelist") {
	my ($seq_dir, $seq_list) = &SplitFileName($genome_file);
	
	&Warning("Genome file\t$genome_file") if ($verbose >= 2);

	unless (-e $genome_file) {
	    &FatalError("Genome file $genome_file does not exist.");
	}
	open FILES, $genome_file || 
	    &Fatalrror("Cannot open genome file $genome_file for reading.");
	while (<FILES>) {
	    chomp;
	    ($seq_file, $chr, $type) = split "\t";
	    if ($type eq "circular") {
		$circular = 1;
	    } else {
		$circular = 0;
	    }
	    $chr = $seq_file unless ($chr);

#	    warn join ("\t", "dir:$seq_dir", "file:$seq_file", "chr:$chr", "circular:$circular", "org:$organism_name"), "\n";

	    $chromosome_seq{$chr} = new RSA::SequenceOnDisk (filename=>  $seq_dir.$seq_file,
							     id=>        $chr,
							     circular=>  $circular, 
							     organism=>  $organism_name);	    
	    $chromosome{$chr} = new RSA::Chromosome();
	    $chromosome{$chr}->push_attribute("names",$chr);
	    $chromosome{$chr}->set_sequence($chromosome_seq{$chr});
	    $chromosome{$chr}->set_organism($organism_name);
	    $organism_object->add_chromosome($chromosome{$chr});

# 	    warn join ("\t","CHROMOSOME", 
# 		       $seq_file,
# 		       $chr, 
# 		       $chromosome{$chr},
# 		       $chromosome{$chr}->get_attribute("sequence"),
# 		       $chromosome{$chr}->get_attribute("sequence")->get_length()
# 		       ), "\n";
	    
# 	    warn join ("\t", "SEQUENCE", 
# 		       $chromosome_seq{$chr},
# 		       $chromosome_seq{$chr}->get_attribute("filename"),
# 		       $chromosome_seq{$chr}->get_length(),
# 		       $chromosome_seq{$chr}->get_attribute("circular"),
# 		       $chromosome_seq{$chr}->get_sequence(1,12,"D")
# 		       ), "\n";

	}
	close FILES;
	
    } elsif ($accepted_input_seq{$genome_seq_format}) {
	unless (-e $genome_file) {
	    &FatalError("Genome file $genome_file does not exist.");
	}
	my ($in, $input_dir) = &OpenInputFile($genome_file, $genome_seq_format);

	while ((($current_seq, $current_id, @comments) = &ReadNextSequence($in, $genome_seq_format, $input_dir)) &&
	       (($current_seq) || ($current_id))) {
	    $chr = $current_id;
	    $chromosome_seq{$chr} = new RSA::Sequence (
						       id=>        $chr,
						       sequence=>  $current_seq,
						       organism=>  $organism_name);
	    $chromosome{$chr} = new RSA::Chromosome();
	    $chromosome{$chr}->push_attribute("names",$chr);
	    $chromosome{$chr}->set_sequence($chromosome_seq{$chr});
	    $chromosome{$chr}->set_organism($organism_name);
	    $organism_object->add_chromosome($chromosome{$chr});
#	    warn join ("\t", $current_id, $chr), "\n";

	}
    } else {
	&FatalError("Sequence format $genome_seq_format is not supported for genomes.");
    }
    return $organism_object;
}


################################################################
#### return a random ORF selection
#### usage 
####      @random_orfs = &SelectRandomORFs($n, $replace);
#### requires prior loading of an organism [see &ReadFeatures()]
sub SelectRandomORFs {  
  my ($rand_orf_nb, $replace, $init, $seed) = @_;
  my @random_orfs = ();

  #### initalize the random generator
  if ($init) {
      if ($seed) { ### defined seed
	  srand($seed);
      } else {
	  srand (time); ### current time
      }
  }

  my @orfs = keys %chr;
  for my $i (1..$rand_orf_nb) {
    my $remaining_orfs = $#orfs+1;
    my $selected = int(rand($remaining_orfs));
    warn ";", join ("\t", "Selected ORF", $selected, $remaining_orfs), "\n" if ($verbose >= 2);
    if ($replace) {
	push @random_orfs, $orfs[$selected];
    } else {
	push @random_orfs, splice(@orfs, $selected, 1);
    }
  }
  return @random_orfs;
}


################################################################
#### convert different strand formats into
#### "D" (direct) and "R" (reverse)
sub ConvertStrand {
    my ($strand_to_convert) = @_;
    ### Heli's notation: F (forward) or R (reverse)
    $strand_to_convert =~ s/F/D/;
    $strand_to_convert =~ s/R/R/;
    
    ### > OR <
    $strand_to_convert =~ s/>/D/;
    $strand_to_convert =~ s/</R/;
    
    ### Yeast notation: W (Watson) or C (Crick)
    $strand_to_convert =~ s/W/D/;
    $strand_to_convert =~ s/C/R/;
    return $strand_to_convert;
}

################################################################
#### read ORF positions for a given organism
#### usage: &ReadFeatures($organism_name, $feature_table_name, $feature_types)
sub ReadFeatures {
    my ($organism_name, 
	$feature_table_file,
	$feature_types)= @_;

#      my @feature_types = ();
#      my %accepted_feature_types = ();
#      if ($feature_types) {
#  	@feature_types = split ",", $feature_types;
#      } else {
#  	@feature_types = qw (cds);
#      }
#      foreach my $feature_type (@feature_types) {
#  	$accepted_feature_type{$features_type}++;
#      }

    unless (defined (%accepted_feature_types)) {
	%accepted_feature_types = (cds=>1,
#				   mrna=>1,
#				   trna=>1,
#				   rrna=>1,
				   );
    }
    

    unless ($feature_table_file) {
	$feature_table_file = $supported_organism{$organism_name}->{'features'};
    }
    $col{'orf_id'} = 0;
    $col{'type'} = 1;
    $col{'name'} = 2;
    $col{'chr'} = 3;
    $col{'left'} = 4;
    $col{'right'} = 5;
    $col{'strand'} = 6;
    $col{'descr'} = 7;
    $col{'location'} = 8;
    
    
    ### read ORF positions
    my ($orfs) = &OpenInputFile($feature_table_file);
    my $linenb = 0;
    while (<$orfs>) {
	$linenb++;
	next unless (/\S/);
	next if ((/^;/) || (/^\#/) || (/^--/));
	next if (/^--/);
	chomp;
	@fields = split "\t";

	if ($organism_name eq "yeast") {
	    $orf_id = uc($fields[0]);
	    $name = uc($fields[2]);
	    $chr = $fields[3];
	    $start = $fields[4];
	    $end = $fields[5];
	    $descr = $fields[8];
	    
	    $orf_id{uc($orf_id)} = $orf_id;
	    $orf_id{uc($name)} = $orf_id if ($name =~ /\S/);

	    if ($name eq "") {
		$name{$orf_id} = $orf_id;
	    } else {
		$name{$orf_id} = $name;
	    }
	    $left = &min($start,$end);
	    $right = &max($start,$end);
	    
	    if ($end > $start) {
		$strand = "W";
	    } else {
		$strand = "C";
	    }
	    $strand = &ConvertStrand($strand);
	} else {
	    
	    foreach $f (keys %col) {
		$$f = $fields[$col{$f}];
	    }


#	    print join "\t", "HELLO", $name, $type, "\n";
	    next unless ($accepted_feature_types{lc($type)});
	}
	
	#### check mandatory attributes
	unless ($orf_id) {
	    warn "; WARNING: invalid orf identifier specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
	    next;
	}
	unless ($chr) {
	    warn "; WARNING: invalid chromosome specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
	    next;
	}
	unless ($left) {
	    warn "; WARNING: left position not specified in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
	    next;
	}
	unless ($right) {
	    warn "; WARNING:right position not specified in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
	    next;
	}
	
	unless (&IsNatural($left) ) {
	    warn "; WARNING: invalid left position specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
	    next;
	}
	unless (&IsNatural($right) ) {
	    warn "; WARNING: invalid right position specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
	    next;
	}
	
	unless ($strand) {
	    warn "; WARNING: invalid strand specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
	    next;
	}
	unless ($left < $right) {
	    warn "; WARNING: left should be smaller than right position specification in in  feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
	    next;
	}
	
	#### make sure the strand format is correct
	$strand = &ConvertStrand($strand);
	
	### assign attributes to the gene
	$left{$orf_id} = $left;
	$right{$orf_id} = $right;
	$strand{$orf_id} = $strand;
	$chr{$orf_id} = $chr;
	$type{$orf_id} = $type;
	$descr{$orf_id} = $descr;
	$orf_id{uc($orf_id)} = $orf_id;
	$orf_id{uc($name)} = $orf_id if ($name =~ /\S/);
	$orf_info{$orf_id} = $_;
	#$name{$orf_id} = $name;
	if ($name eq "") {
	    $name{$orf_id} = $orf_id;
	} else {
	    $name{$orf_id} = $name;
	}
	unless (defined($chromosome{$chr})) {
	    $chromosome{$chr} = new RSA::Chromosome(id=>$chr);
	    $chromosome{$chr}->set_organism($organism_name);
	}
	$chromosome{$chr}->add_gene($orf_id);
# 	warn join( "\t",
# 		   $orf_id,
# 		   $chr,
# 		   $strand,
# 		   $left,
# 		   $right,
# 		   $descr{$orf_id},
# 		   $chromosome{$chr}->count_genes()), "\n";
    }
    close $orfs if ($feature_table_file);
}


################################################################
#### read a list of synonyms for gene names, given an organism name
sub ReadSynonyms {  
    #### read synonym file ###
    ### usage : &ReadSynonyms($organism_name);
    my ($organism_name) = @_;

    unless ( $supported_organism{$organism_name}->{'synonyms'}) {
	return;
    }

    ($syn) = &OpenInputFile( $supported_organism{$organism_name}->{'synonyms'});
    if (($organism_name eq "") || 
	($organism_name eq "yeast")
	){
	while(<$syn>) {
	    chomp;
	    tr/a-z/A-Z/;
	    @fields = split;
	    if ((defined($orf_id{$fields[0]})) &&
		($orf_info{$orf_id{$fields[0]}})) {
		$orf_id = $orf_id{$fields[0]};
		unless (($fields[1] eq  $orf_id) || ($orf_info{$fields[1]})) {
		    $orf_id{$fields[1]} = $orf_id;
		    push @{$synonyms{$orf_id}}, $fields[1] if ($fields[1] =~ /\S/);
		}
	    } elsif ((defined($orf_id{$fields[1]})) &&
		     ($orf_info{$orf_id{$fields[1]}})) {
		$orf_id = $orf_id{$fields[1]};
		unless (($fields[0] eq  $orf_id) ||($orf_info{$fields[0]})) {
		    $orf_id{$fields[0]} = $orf_id;
		    push @{$synonyms{$orf_id}}, $fields[0] if ($fields[0] =~ /\S/);
		}
	    }
	}
    } else {
	while(<$syn>) {
	    next if ((/^;/) || (/^\#/) || (/^--/));
	    next unless (/\S/);
	    chomp;
	    @fields = split "\t";
	    my $id = uc($fields[0]);
	    my $name = $fields[1];
#	    print join "\t", $id, $name, $fields[0], $fields[1], "\n"; 
	    if (defined($orf_id{$id})) {
		$orf_id{uc($name)} = $orf_id{$id};
		push @{$synonyms{$orf_id{$id}}}, $name;
	    }
	}
    }
    close $syn if ($supported_organism{$organism_name}->{'synonyms'});
} ### ReadSynonyms


################################################################
#### Calculate the limits of the non-coding region on both sides of
#### each gene
sub CalcNeighbourLimits {
    foreach my $chr (sort keys %chromosome) {
	my @genes = sort { $left{$a} <=> $left{$b} } $chromosome{$chr}->get_genes();
	@chrom_lefts = sort {$a <=> $b} @left{@genes};
	@chrom_rights = sort {$a <=> $b} @right{@genes};
	

	for my $g (0..$#genes) {
	    my $gene = $genes[$g];
	    my $ln = $g -1; ### first guess for left neighbour
	    my $rn = $g +1; ### first guess for right neighbour
	    my $found = 0;

	    #### calculate left upstream limit 
	    do {
		if ($chrom_rights[$ln] > $left{$gene}) {
		    $ln--;
		} elsif ($chrom_rights[$ln+1] < $left{$gene}) {
		    $ln++;
		} else {
		    $found = 1;
		}
	    } until (($found) || ($ln < 0) || ($ln > $#chrom_rights));
	    if ($found) {
		$neighb_left_limit{$gene} = $chrom_rights[$ln]; 
	    } elsif ($ln < 0) {
		$neighb_left_limit{$gene} = 0; 
	    } elsif ($ln > $#chrom_rights) {
		$neighb_left_limit{$gene} = undef; 
	    }
	    $neighb_left_size{$gene} = $left{$gene} - $neighb_left_limit{$gene} -1;
	    


	    #### calculate right upstream limit 
	    $found = 0;
	    do {
		if ($chrom_lefts[$rn] < $right{$gene}) {
		    $rn++;
		} elsif ($chrom_lefts[$rn-1] > $right{$gene}) {
		    $rn--;
		} else {
		    $found = 1;
		}
	    } until (($found) || ($rn < 0) || ($rn > $#chrom_lefts));
	    if ($found) {
		$neighb_right_limit{$gene} = $chrom_lefts[$rn];
	    } elsif ($rn < 0) {
		$neighb_right_limit{$gene} = undef; 
	    } elsif ($rn > $#chrom_lefts) {
		$neighb_right_limit{$gene} = $chromosome_seq{$chr}->get_length() + 1; 
	    }
	    $neighb_right_size{$gene} = $neighb_right_limit{$gene} - $right{$gene} -1;
	    
	    if ($strand{$gene} eq "R") {
		$upstr_limit{$gene} = $neighb_right_limit{$gene};
		$upstr_size{$gene} = $neighb_right_size{$gene};
		$downstr_limit{$gene} = $neighb_left_limit{$gene};
		$downstr_size{$gene} = $neighb_left_size{$gene};
	    } else {
		$upstr_limit{$gene} = $neighb_left_limit{$gene};
		$upstr_size{$gene} = $neighb_left_size{$gene};
		$downstr_limit{$gene} = $neighb_right_limit{$gene};
		$downstr_size{$gene} = $neighb_right_size{$gene};
	    }    

#  	print join ("\t", "HELLO", $g, $gene, 
#  		    $left{$gene},$right{$gene}, 
#  		    "ln", $ln, $chrom_lefts[$ln],$chrom_rights[$ln], 
#  		    "rn", $rn, $chrom_lefts[$rn],$chrom_rights[$rn], 
#  		    "left", $neighb_left_limit{$gene}, $neighb_left_size{$gene},
#  		    "right", $neighb_right_limit{$gene}, $neighb_right_size{$gene},
#  		    "upstr", $upstr_limit{$gene}, $upstr_size{$gene},
#  		    "down", $downstr_limit{$gene}, $downstr_size{$gene},
#  		    "\n");
	}
#    die "HELLO";
	
    }

}

sub ListSupportedOrganisms {
  ### usage : &ListSupportedOrganisms($format);
  ### $supp =  &ListSupportedOrganisms("text");
  ### $supp =  &ListSupportedOrganisms("html_list");
  ### $supp =  &ListSupportedOrganisms("html_table");
  ### @keys =  &ListSupportedOrganisms("keys");
  ### @names =  &ListSupportedOrganisms("names");
  ### %organisms =  &ListSupportedOrganisms("hash");
  my $out_format = $_[0] || "text";

  foreach my $key (keys %main::supported_organism) {
      $names{$key} = $main::supported_organism{$key}->{'name'};
#      print "HELLO $key\t",$main::supported_organism{$key}->{'name'}, "\t", $names{$key}, "\n";;
  }
  @sorted_names = sort values %names;
  @sorted_keys = sort keys %supported_organism;

  if ($out_format eq "html_list") {
      my $result = "<UL>\n";
      foreach my $name (@sorted_names) {
	  $result .= "<LI>";
	  $result .= $name;
	  $result .= "\n";
      }
      $result .= "</UL>\n";
      return $result;
  } elsif ($out_format eq "html_table") {
      my $result = "<TABLE>\n";
      foreach my $key (@sorted_keys) {
	  $result .= "<TR>\n";
	  $result .= "<TD>$key</TD>\n";
	  $result .= "<TD>";
	  $result .= $names{$key};
	  $result .= "</TD>\n";
	  $result .= "</TR>\n";
      }
      $result .= "</TABLE>\n";
      return $result;
  } elsif (($out_format eq "names") ||
	   ($out_format eq "array")) {
      return @sorted_names;
  } elsif ($out_format eq "keys") {
      return @sorted_keys;
  } elsif ($out_format eq "hash") {
      my %result = ();
      foreach my $ket (@sorted_keys) {
	  $result{$key} = $main::supported_organism{$key}->{name};
      }
      return %result;
  } elsif ($out_format eq "sizes") {
      #### collect the default limits for each organism
      my $result = sprintf ";\t%-35s\t%7s\t%7s\t%s\n", "Organism", "upstream from", "upstream to", "taxonomy";
      foreach my $key (sort @sorted_keys) {
	  $result .= sprintf ("\t%-35s\t%7s\t%7s\t%s\n", 
			      $key, 
			      $supported_organism{$key}->{'up_from'},
			      $supported_organism{$key}->{'up_to'}
			      );
      }
      return $result;
  } elsif ($out_format eq "full") {
      #### collect the default limits for each organism
      my $result = join ("\t", 
			 "; organism",
			 "taxonomy", 
			 "last update", 
			 "upstream from", 
			 "upstream to")."\n";
      foreach my $key (sort @sorted_keys) {
	  $result .= join ("\t", 
			   $key,  
			   $supported_organism{$key}->{'taxonomy'},
			   $supported_organism{$key}->{'last_update'},
			   $supported_organism{$key}->{'up_from'},
			   $supported_organism{$key}->{'up_to'}
			   )."\n";
      }
      return $result;
  } else {
      my $result = "";
      foreach $key (@sorted_keys) {
	  $result .= sprintf "\t\t%-30s", $key;
	  $result .= "\t";
	  $result .= $names{$key};
	  $result .= "\n";
      }
      return $result;
  }
}

$supported_organisms = &ListSupportedOrganisms();


#foreach $key (sort keys %supported_organism) {
#  $supported_organisms .= sprintf "\t\t%-12s\t", $key;
#  $supported_organisms .= $supported_organism{$key}->{'name'};
#  $supported_organisms .= "\n";
#}




################################################################
#### Treatment of warnings and  errors
################################################################

### warn with time 
sub TimeWarn {
    my $message = join "\t", &AlphaDate(), @_;
    chomp($message);
    $message .= "\n";
    warn ($message);
}


################################################################
#### report an error by sending an email to RSAT administrator
sub MessageToAdmin {
    my ($message) = @_;
    $mail_command = "mail -s \'RSA-tools - $script_name - $date\'";
    system "echo \"$message\" | $mail_command $ENV{SERVER_ADMIN} &"; 
}


### report fatal errors 
sub FatalError {
    my @error_message = @_;
    my $message = join "\n\t", @error_message;
    $ENV{RSA_ERROR} = "1";
    my $context = $ENV{RSA_OUTPUT_CONTEXT} || "screen";
    if ($context eq "cgi") {
	$message =~ s/\n\t/ /g;
	$message =~ s/\t/ /g;
	&cgiError($message);
    } else {
	die("Error\n\t", $message, "\n");
    }
}

sub cgiError {
    my $error_message = join "", @_;
    my $error_color = "#FF0000";
    &cgiMessage($error_message, "Error", $error_color);
    print "</body></html>\n";
    exit(1);
}


### report a warning
sub Warning {
    my @warning_message = @_;
    my $message = join "\n\t", @warning_message;
    if ((defined($ENV{RSA_OUTPUT_CONTEXT})) &&
	($ENV{RSA_OUTPUT_CONTEXT} eq "cgi")) {
	$message =~ s/\n/<br>\n/g;
	&cgiWarning($message);
    } else {
	warn("; WARNING\t", $message, "\n");
    }
}

sub cgiWarning {
    my $warning_message = join "<P>", @_;
    my $warning_color = "#aa0000";
    &cgiMessage($warning_message, "Warning", $warning_color);
}

### information message
sub Info {
    my @info_message = @_;
    my $message = join "\n\t", @info_message;
    if ($ENV{RSA_OUTPUT_CONTEXT} eq "cgi") {
	$message =~ s/\n/<br>\n/g;
	&cgiMessage($message);
    } else {
	warn("Info\n\t", $message, "\n");
    }
}

#### report a message in HTML format
sub cgiMessage {
    my ($message, $message_type, $color) = @_;
    $color = "#00BB00" unless ($color);
    print  "<h3>$message_type</h3>",
	    "<blockquote>",
	    "<FONT SIZE=+1 color=$color><B>",
	    $message,
	    "</B></FONT>",
	    "</blockquote>",
	    "<BR><HR SIZE=3>";
}


################################################################
#### read classification file
#### The file is supposed to contain at least two columns 
#### - element (e.g. a gene ID)
#### - class (e.g. a functional class, or a regulon, or a clustering result)
#### additional columns are allowed, but they are ignored
sub ReadFamilies {
    my ($family_file, $get_orf_id) = @_;
    warn "; Reading family file\t$family_file\n" 
	if ($verbose >=2);

    my %family = ();
    my ($fam) = &OpenInputFile($family_file);

    my $line = 0;
    while (<$fam>) {
	$line++;
	next if (/^;/);
	next if (/^\#/);
	next unless (/\S/);
	chomp;
	s/\r$//;
##	my @fields = split /\s+/;
	my @fields = split /\t/;
	
	### family member
	$member_name = &trim(uc($fields[0]));
	unless ($member_name =~ /\S/) {
	    warn ("Error family file $family_file line $line\t",
		  "gene not specified\n");
	    next;
	}
	### family name
	$family_name = &trim($fields[1]);
	$family_name =~ s/ +/_/g;
	unless ($family_name =~ /\S/) {
	    warn ("Error family file $family_file line $line\t",
		  "family not specified\n");
	    next;
	}

	#### create a new family if required
	unless ($family{$family_name}) {
	    $family{$family_name} = new RSA::family(name=>$family_name);
	}

	
	my $member_key = "";
	if ($get_orf_id) {
	    ### identify the gene on the basis of its name
	    $member_key = $orf_id{$member_name};
	} else {
	    $member_key = $member_name;
	}
	if ($member_key) {
#	    push @{$family{$family_name}->{members}}, $member_key;
	    $family{$family_name}->new_member($member_key);
#	    warn join ("\t",  "; \t$family_name","$member_name","$member_key","$name{$id}"), "\n" 
#		if ($verbose >= 0);
	} else {
	    &Warning ("$member_name unknown gene name");
	}
	
    }
    close $fam if ($family_file);
    return %family;
}

sub ReadClasses {
    ReadFamilies(@_);
}


#### end of the library #####

1; # return true



