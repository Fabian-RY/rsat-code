#!/usr/bin/perl -w
############################################################
#
# $Id: matrix-clustering,v 1.5 2013/02/19 05:35:16 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

matrix-clustering

=head1 VERSION

$program_version

=head1 DESCRIPTION

Taking as input a set of position-specific scoring matrices, identify
clusters of similar matrices and build consensus motifs by merging the
matrices that belong to the same cluster.

=head1 DEPENDENCIES

The clustering step relies on I<MCL>, the graph-based clustering
algorithm developed by Stijn Van Dongen. MCL must be installed and its
path indicated in the RSAT configuration file
($RSAT/RSAT_config.props). The installation of MCL can be done with a
RSAT makefile:

  cd $RSAT
  make -f makefiles/install_software.mk install_mcl


Various R packages are required in I<matrix-clustering> to convert the 
hierarchical tree into different output formats and to manipulate the
dendrogram which is exported.

  RJSONIO : http://cran.r-project.org/web/packages/RJSONIO/index.html
  ctc : http://www.bioconductor.org/packages/release/bioc/html/ctc.html
  dendextend : http://cran.r-project.org/web/packages/dendextend/index.html


For visualize the logo forest it is required the JavaScript I<D3> 
(Data Driven Documents) library, the user can select an option to connect
 directly with the server to load the functions of this library (see option I<-d3_base>). 

   D3 : http://d3js.org/

=head1 AUTHORS

=head2 Implementation

=over

=item Jacques.van-Helden@univ-amu.fr

=item Jaime Castro <jcastro@lcg.unam.mx>

=back

=head2 Conception

=over

=item Jacques van Helden

The following collaborator contributed to the definition of
requirements for this program.

=item Carl Herrmann

=item Denis Thieffry

=item Morgane Thomas-Chollier

=back

=head1 CATEGORY

util

=head1 USAGE

matrix-clustering [-i inputfile] [-o outputfile] [-v ] [...]


=head1 OUTPUT FORMAT

=head1 SEE ALSO

=over

=item I<compare-matrices>

The program I<compare-matrices> is used by I<cluster-matrices> to
measure pairwise similarities and define the best alignment (offset,
strand) between each pair of matrices.

=back

=head1 WISH LIST

=cut

BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}
require "RSA.lib";
require "RSA2.cgi.lib";
use RSAT::util;
use RSAT::matrix;
use RSAT::MatrixReader;
use RSAT::SeqUtil;


require "RSA.disco.lib";
require "footprint.lib.pl";
use Data::Dumper;
use File::Basename;


################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  local $start_time = &RSAT::util::StartScript();
  $program_version = do { my @r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };

  ## Input / output files
  %main::infile = ();
  %main::outfile = ();
  %main::dir = ();
  %main::param = ();
  @dirs = ();

  $main::verbose = 0;
  $main::out = STDOUT;

  local @tab_to_convert = (); ## Tables to convert to html

  ## Input formats: only accept formats supporting multiple matrices
  local @supported_matrix_formats = qw(transfac tf tab clusterbuster cb infogibbs meme stamp uniprobe);
  local %supported_matrix_format = ();
  foreach my $format (@supported_matrix_formats) {
    $supported_matrix_format{$format} = 1;
  }
  local $supported_matrix_formats = join ",", @supported_matrix_formats;

  ## Output formats for hclust
  local @supported_tree_formats = qw (json newick);
  local %supported_tree_formats = ();
  foreach my $format (@supported_tree_formats) {
    $supported_tree_formats{$format} = 1;
  }
  local $supported_tree_formats = join ",", @supported_tree_formats;
  local $export_tree_format = "";



  ## Javascript (D3 + JQuery) base
  local $js_base;
  if (defined($ENV{RSA_OUTPUT_CONTEXT}) && ($ENV{RSA_OUTPUT_CONTEXT} eq "cgi")) {
    $js_base = $ENV{rsat_www}."/lib/js";
  } else {
    $js_base = $ENV{RSAT}."/public_html/lib/js";
  }
  local $d3_base= $js_base."/d3.v3.min.js";
  local $jquery_base = $js_base."/DataTables-1.10.4/media/js/jquery.js";
  local $datatable_base= $js_base."/DataTables-1.10.4/media/js/jquery.dataTables.min.js";
  local $datatable_css_base = $js_base."/DataTables-1.10.4/media/css/jquery.dataTables.min.css";

  ## Supported label fields
  local @supported_label_fields = qw (id name consensus);
  local %supported_label_fields = ();
  foreach my $field (@supported_label_fields) {
    $supported_label_fields{$field} = 1;
  }
  local $supported_label_fields = join ",", @supported_label_fields;
#    local $label_fields_to_return = "";
  local %label_fields_to_return = ();
  local @label_fields_to_return = ();

  ## Supported hclust methods
  local @supported_hclust_methods = qw (average complete single);
  local %supported_hclust_methods = ();
  foreach my $method (@supported_hclust_methods) {
    $supported_hclust_methods{$method} = 1;
  }
  local $supported_hclust_methods = join ",", @supported_hclust_methods;
  local $hclust_method = "complete";


  ## Threshold parameters
  local %lth = ();		# lower threshold values
  local %uth = ();		# upper threshold values
  local @supported_thresholds = qw(
				     cor
                                     Ncor
                                     w
				   );
  local $supported_thresholds = join ",", @supported_thresholds;
  local %supported_threshold = ();
  foreach my $thr (@supported_thresholds) {
    $supported_threshold{lc($thr)} = 1;
  }


  ## Metric parameters
  local @supported_metrics = qw(
			         cor
                                 Ncor
                                 w
			     );
  local $supported_metrics = join ",", @supported_metrics;
  local %supported_metrics = ();
  foreach my $met (@supported_metrics) {
    $supported_metrics{lc($met)} = 1;
  }



  ## Consensuses alignment labels
  local @supported_consensuses_alignment_labels = qw(
			         consensus
                                 id
                                 strand
                                 number
			     );
  local $supported_consensuses_alignment_labels = join(",", @supported_consensuses_alignment_labels);
  local %supported_consensuses_alignment_labels = ();
  foreach my $lab (@supported_consensuses_alignment_labels) {
    $supported_consensuses_alignment_labels{lc($lab)} = 1;
  }
  local @cons_labels = @supported_consensuses_alignment_labels;


  ## Matrices
  local @matrices = ();
  local $draw_heatmap = 0;


  ## Unrecognized arguments are passed to compare-matrices
  local @args_to_pass = ();
  local $args_to_pass = "";
  
  ## Hash with the path to tha aligned logos
  local %aligned_logos_path = ();
  local %alignment_info = ();

  ## Hash with the cluster information
  ## required to the HTML tree
  local %clusters_info = ();
  local %cluster_nodes = (); 
  local %clusters_to_HTML = (); 

  ## Lower and upper threshold on matrix comparison scores
  local %lth = ();
  local %uth = ();

  ## Merged consensuses logos
  local %merged_consensuses_files = ();
  local @levels_JSON = ();

  ## Supported taks
  local @supported_tasks = qw(
			all
		        cluster
                     );
  local @task = qw (all);
  local $supported_tasks = join ",", @supported_tasks;
  local %supported_tasks = ();
  foreach my $task (@supported_tasks) {
    $supported_tasks{$task} = 1;
  }
  %selected_tasks = ();
  $selected_tasks{all} = 1;

  ## Use compare-matrices-quick
  local $quick_flag = 0;

  ## display title in trees and alignment table
  local $display_title_flag = 0;

  ## Limit the number of input motifs
  local $mat_nb_flag = 0;
  local $mat_nb = 0;
  
  ## To export in the results the input file
  local $clone_input_flag = 0;

  ## A hash to save the name of the clusters and their corresponding hexa code
  local %hexa_code = ();

  ## List of files to delete
  %to_delete = ();

  ################################################################
  ## Options used for motif comparison
  local %param = ();
  $param{matrix_compa_min_w} = 5; ## min number of aligned columns
  $param{matrix_compa_min_Wr} = 0.3; ## min relative width
  #$param{matrix_compa_min_cor} = 0.7; ## min correlation
  #$param{matrix_compa_min_Ncor} = 0.4; ## min normalizd correlation
  $param{matrix_compa_sort_field} = "Ncor"; ## sorting field
  #$param{matrix_compa_metrics} = "Ncor";
  $param{matrix_compa_metrics} = "cor,Ncor,logoDP,NIcor,NSW,match_rank";
  $param{matrix_compa_score} = "Ncor"; ## The score must be a similarity score for MCL
  $param{archive_format} = "zip";
  $param{progressive_synthesis} = 1;
  $param{title} = "matrix-clustering";


  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values

  &RSAT::message::TimeWarn("Checking parameter values") if ($main::verbose >= 2);


  ## Non-recognized parameters are passed to compare-matrices
  if (scalar(@args_to_pass)) {
    $args_to_pass = join (" ", @args_to_pass);
    &RSAT::message::Info("Unrecognized arguments passed to compare-matrices", $args_to_pass) if ($main::verbose >= 2);
  }

  ## Check that the  input file has been specified
  unless ($infile{matrices}) {
    &RSAT::error::FatalError("You must define the input file (option -i).");
  }

  ## Check that the  input format has been specified
  unless ($matrix_format) {
    &RSAT::error::FatalError("You must define the input matrix format (option -matrix_format).");
  }


  ## Check that the output prefix has been specified
  unless ($outfile{prefix}) {
    &RSAT::error::FatalError("You must define the output prefix (option -o).");
  }

  ## Check that at least one field is selected for the option
  ## "-label".
  if (scalar(@label_fields_to_return) == 0) {
    @label_fields_to_return = qw(id name);
    for my $field (@label_fields_to_return) {
      $label_fields_to_return{$field} = 1;
    }
  }
  $label_fields_to_return = join ",", @label_fields_to_return;
  &RSAT::message::Info("Label fields", $label_fields_to_return) if ($main::verbose >= 5);


  ################################################################
  ## Check output directories and define file names
  &set_output_file_names();

  &OpenSynthesis() if ($main::param{progressive_synthesis}); ## Already open the HTML report summary, for the Web site

  ################################################################
  ## Read input matrices
  if ($infile{matrices}){
      @matrices = &RSAT::MatrixReader::readFromFile($infile{matrices}, $matrix_format);
      &RSAT::message::TimeWarn(scalar(@matrices), "Matrices loaded from file", $infile{matrices})
	  if ($main::verbose >= 2);

      if($mat_nb_flag == 1){
	  if(scalar(@matrices) > $mat_nb){
	  &RSAT::error::FatalError($mat_nb, "Matrices loaded from file", $infile{matrices}, "The number of input matrices is limted to", $mat_nb);
	  }
      }
  }

  # ## According to the task selected by the user, execute or skip some functions
  if($selected_tasks{all}){

      if($quick_flag == 0){

  	  ################################################################
  	  ## Compare the matrices with compare-matrices
  	  &CompareMatrices();

      } elsif ($quick_flag == 1){
  	  ################################################################
  	  ## Compare the matrices with compare-matrices-quick
  	  &CompareMatricesQuick();
      }
  }

  if($selected_tasks{all} || $selected_tasks{cluster}){
      
      #####################################################
      ## Create temporary files with the single matrices
      %alignment_info = &create_single_matrix_files();

      ################################################################
      ## Cluster the matrices
      &Hclustering();

      ################################################################
      ## Read the motif to cluster assignation, which will be required for
      ## several functions below.
      &ReadClusterComposition();
      
      ################################################################
      ## Create the merged matrices and consensuses
      &Merge_matrices();

      ################################################################
      ## Read the table with the hexadecimal code 
      ## for the colors assigned to each cluster
      %hexa_code = &Read_cluster_colors();
      
      ################################################################
      ## Parse the JSON file
      &Add_attributes_to_JSON();
      
      ################################################################
      ## Creates the body of html to display
      ## each cluster separately
      &Add_div_to_HTML();
            
      ################################################################
      ## Convert tab files to HTML files
      &ConvertTabToHTML(@tab_to_convert);

      ###################################
      ## Delete .tf files
      &Delete_temporal_files();

      ######################
      ## Clone input file
      if($clone_input_flag == 1){
      	  &Clone_input();
      }

      ################################################################
      ## Creates the website
      &Synthesis();

      ################################################################
      ## Create an archive with all result files
      &Archive(1);
  }

  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose);
  
  ################################################################
  ## Generate the HMTL index of input/output files
  &IndexFiles() if ($main::outfile{html_index});

  ################################################################
  ## Close output stream
  my $exec_time = &RSAT::util::ReportExecutionTime($start_time); print $main::out $exec_time if ($main::verbose >= 1);
  close $main::out if ($main::outfile{prefix});

  ## Close the HTML index file
  if ($main::outfile{html_index}) {
    print $main::html_index "<hr>";
    print $main::html_index "</body>";
    print $main::html_index "</html>";
    close $main::html_index;
  }

  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();


=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-i input matrix file>

The input file contains a set of position-specific scoring
matrices.

=cut
    } elsif ($arg eq "-i") {
      $main::infile{matrices} = shift(@arguments);
      
=pod

=item B<-matrix_format matrix_format>

Specify the input matrix format.


B<Supported matrix formats>

Since the program takes several matrices as input, it only accepts
matrices in formats supporting several matrices per file (transfac,
tf, tab, clusterbuster, cb, infogibbs, meme, stamp, uniprobe).

For a description of these formats, see the help of I<convert-matrix>.

=cut
    } elsif ($arg eq "-matrix_format") {
      $main::matrix_format = shift(@arguments);
      unless ($supported_matrix_format{$matrix_format}) {
	&RSAT::error::FatalError($matrix_format, "Invalid format for input matrices\tSupported: ".$main::supported_matrix_formats);
      }

=pod

=item	B<-title graph_title>

Title displayed on top of the report page.

=cut
     } elsif ($arg eq "-title") {
      $main::param{title} = shift(@arguments);
      $main::param{title} =~ s/\s+/_/g;

=pod

=item	B<-display_title>

If it is selected. The title is displayed in the trees and in the result table.
This is ideal when the user wants to compare motifs from different sources (files).

=cut
     } elsif ($arg eq "-display_title") {
      $display_title_flag = 1;

=pod

=item	B<-o output_prefix>

Prefix for the output files.

Mandatory option: since the program I<cluster-matrices> returns a
list of output files (pairwise matrix comparisons, matrix clusters).

=cut
    } elsif ($arg eq "-o") {
      $main::outfile{prefix} = shift(@arguments);

=pod

=item B<-heatmap>

Display consensus of merged matrices on the internal branches of the
tree.

=cut
    } elsif ($arg eq "-heatmap"){
      $draw_heatmap = 1;

  
=pod

=item B<-export format>

Specify format for the output tree.

The hierarchical tree in JSON format is always exported, since it is required to display
the logo tree with the d3 library. Additional formats are proposed in
option to enable visualization with classical phylogeny analysis
tools.

B<Supported trees formats>

(JSON, newick)

=over

=item I<JSON> (default)

File format used for D3 library to visualize the logo forest in HTML.

=item I<newick> (optional)

Widely used textual format to describe phylogenetic trees.

=back

=cut
      
    } elsif ($arg eq "-export") {
      $export_tree_format = shift(@arguments);
      unless($supported_tree_formats{$export_tree_format}) {
	&RSAT::error::FatalError($export_tree_format, "Invalid format for input matrices\tSupported: ".$main::supported_tree_formats);
      }

=pod

=item B<-task tasks>

Specify one or several tasks to be run. If this option is not
specified, all the tasks are run.

Note that some tasks depend on other ones. This option should thus be
used with caution, by experimented users only.

Supported tasks: (all, comparison, clustering)

=over

=item B<all>

Execute all the parts of the program (default)

=item B<clustering>

Skip the matrix comparison step and only executes the clustering step.

Assumes the users already have the description table and comparison table 
exported from the program I<compare-matrices>.

This option is ideal to saving time once all comparison beteen the input motifs had been done. 

=back

=cut

       } elsif ($arg eq "-task") {
	 $arg = shift (@arguments);
	 chomp($arg);
	 my @tasks = split ",", $arg;
         %selected_tasks = ();
	 foreach my $task (@tasks) {
	   $task = lc($task);
	   if ($supported_tasks{$task}) {
	     $selected_tasks{$task} = 1;
	   } else {
	     &RSAT::error::FatalError(join("\t", $task, "Invalid tasks. Supported:", $supported_tasks));
	   }
	 }

=pod

=item	B<-label>

Option to select the matrix label fields displayed in the html tree
    
B<Supported labels>
    
 (name, consensus, id)
 
=cut
    } elsif ($arg eq "-label") {
      my $label_fields_to_return = shift(@arguments);
      my @new_label_fields_to_return = split (",", $label_fields_to_return);
      foreach $field (@new_label_fields_to_return) {
	if ($supported_label_fields{$field}) {
	  $label_fields_to_return{$field} = 1;
	  push @label_fields_to_return, $field;
	} else {
	  &RSAT::error::FatalError(join("\t", $field, "Invalid return field. Supported:", $supported_label_fields));
	}
      }


=pod

=item	B<-quick>

With this option the motif comparison step is done with  the program I<compare-matrices-quick> 
(implemented in C) rather than the classic version compare-matrices (implemented in Perl).
The quick version runs x100 times faster, but has not all implemented options as in the Perl version.

We suggest use this option for a big set of input motifs > 300 motifs. 

B<NOTE:> By the moment the only threshold used in quick version is Ncor. 

=cut
    } elsif ($arg eq "-quick") {
    $quick_flag = 1;


=pod

=item	B<-clone_input>

If this option is selected, the input motif database is exported
in the results folder.

NOTE: take into account the input file size. 

=cut
    } elsif ($arg eq "-clone_input") {
    $clone_input_flag = 1;

=pod

=item	B<-max_matrix>

This option specify how many matrices can be clustered in the same analysis. If there are more matrices than
the specified number, the program reports an error.

This parameter can be useful when the user analyse a big dataset of matrices.

=cut
    } elsif ($arg eq "-max_matrix") {
    $mat_nb_flag = 1;
    $mat_nb = shift(@arguments);
    
      
=pod

=item	B<-hclust_method>

Option to select the agglomeration rule for hierarchical clustering.


Supported agglomeration rules:
 
=over

=item I<complete> (default)

Compute inter-cluster distances based on the two most distant nodes.

=item I<average>

Compute inter-cluster distances as the average distance between nodes
belonging to the relative clusters.

=item I<single>

Compute inter-cluster distances based on the closest nodes.

=back

=cut
    
    } elsif ($arg eq "-hclust_method") {
      $hclust_method = shift(@arguments);
      unless(exists($supported_hclust_methods{$hclust_method})){
	&RSAT::error::FatalError($hclust_method, "Invalid hclust method. Supported:", $supported_hclust_methods);
      }


=pod

=item B<-top X>

Only analyze the first X motifs of the input file. This options is
convenient for quick testing before starting the full analysis.

=cut

=pod

=item B<-skip X>

Skip the first X motifs of the input file. This options is convenient
for testing the program on a subset of the motifs before starting the
full analysis.

=cut

=pod

=item	B<-consensus_labels>

Option to select the labels displayed in the consensus
alignment picture

Default: consensus, id, strand

B<Supported labels>
    
 (consensus, id, strand, number)

=cut

    } elsif ($arg eq "-consensus_labels") {

	$cons_labels = shift(@arguments);
	my @new_cons_labels = split (",", $cons_labels);
	foreach $field (@new_cons_labels) {
	    if ($supported_consensuses_alignment_labels{$field}) {
		$supported_consensuses_alignment_labels{$field} = 1;
	    } else {
		&RSAT::error::FatalError(join("\t", $field, "Invalid consensus alignment label. Supported:", $supported_consensuses_alignment_labels));
	    }
	}
	@cons_labels =  @new_cons_labels;	

	
=pod

=item	B<-lth param lower_threshold>

=item	B<-uth param upper_threshold>

Threshold on some parameter (-lth: lower, -uth: upper threshold).

Threshold parameters are passed to compare-classes. 

In addition, if a threshold is defined in the (unique) metrics used as
clustering score (option I<-score>), this threshold will be used to
decide whether motifs should be aligned or not. If two motifs have a
similarity score lower (or distance score higher) than the selected
threshold, their aligment will be skipped. The status of each motif
 (Aligned or Non-aligned) is reported in the file
prefix_matrix_alignment_table.tab

Suggested thresholds:

    cor >= 0.7

    Ncor >= 0.4

=cut

    } elsif ($arg eq "-lth") {
      my $thr_field = shift(@arguments);
      my $thr_value =  lc(shift(@arguments));
      unless ($supported_threshold{lc($thr_field)}) {
	&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
      }
      &RSAT::error::FatalError($thr_value, "Invalid value for a lower threshold. Should be a real number. ")
	  unless (&RSAT::util::IsReal($thr_value));
      $lth{$thr_field} = $thr_value;

      
      ### Upper threshold
    } elsif ($arg eq "-uth") {
      my $thr_field = shift(@arguments);
      my $thr_value = shift(@arguments);
      unless ($supported_threshold{lc($thr_field)}) {
	&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
      }
      &RSAT::error::FatalError($thr_value, "Invalid value for an upper threshold. Should be a real number. ")
	  unless (&RSAT::util::IsReal($thr_value));
      $uth{$thr_field} = $thr_value;

      ## TEMPORARILY INACTIVATE PASSING THRESHOLDS TO compare-matrices
#      push @args_to_pass, join(" ", "-uth", $thr_field, $thr_value);

=pod

=item	B<-score metric>

Select the metric which will be used to cluster the motifs.

Supported metrics : cor, Ncor

Default: Ncor 

=cut

    }elsif ($arg eq "-score") {
      my $metric = shift(@arguments);
      unless ($supported_metrics{lc($metric)}) {
	&RSAT::error::FatalError("Invalid metric field $metric. Supported: $supported_metrics");	
      }
      $main::param{matrix_compa_score} = $metric;
      $main::param{matrix_compa_sort_field} = $metric;

    ## Additional arguments are passed to compare-matrices
    }else {
        if ($arg =~ /\s/) {
	    push @args_to_pass, "'".$arg."'";
        } else {
	    push @args_to_pass, $arg;
        }
    }
  }
=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
  print $main::out "; cluster-matrices ";
  &PrintArguments($main::out);
  printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
  if (%main::infile) {
    print $main::out "; Input files\n";
    while (my ($key,$value) = each %main::infile) {
      printf $main::out ";\t%-28s\t%s\n", $key, $value;
    }
  }
  printf $main::out  "; %-28s\t%s\n", "Number of matrices", scalar(@matrices);

  if (%main::outfile) {
    print $main::out "; Output files\n";
    while (my ($key,$value) = each %main::outfile) {
      printf $main::out ";\t%-28s\t%s\n", $key, $value;
    }
  }
}

################################################################
## Compare each discovered motifs to each other.
sub CompareMatrices {
  ## Pariwise comparisons between discovered matrices.  We don't
  ## the option "distinct" in order to ensure that all the motifs are
  ## in the output graph even if they are not related to any other
  ## motif.
  $matrix_compa_verbose = &RSAT::stats::max(($main::verbose-1), 1);

  &RSAT::message::TimeWarn("Pairwise matrix comparison.") if ($main::verbose >= 2);
  my $cmd = $SCRIPTS."/compare-matrices -v ".$matrix_compa_verbose; 
  $cmd .= " -mode scores";
  $cmd .= " -format ".$main::matrix_format;
  $cmd .=  " -file ".$main::infile{matrices};
  $cmd .= " -DR";
  $cmd .= " -sort ".$main::param{matrix_compa_sort_field};
  $cmd .= " -return matrix_id,matrix_label,strand,offset,".$main::param{matrix_compa_metrics}.",consensus,width,matrix_desc";
  $cmd .= " -labels ".$label_fields_to_return;
  $cmd .= " ".$args_to_pass;
  $cmd .= " -o ".$main::outfile{pairwise_compa};
  $cmd .= "; ".$SCRIPTS."/text-to-html -i ".$main::outfile{pairwise_compa};
  $cmd .= " -o ".$main::outfile{pairwise_compa_html};
  &RSAT::util::one_command($cmd, 1,"");

  &RSAT::message::TimeWarn("Matrix comparison table", $main::outfile{pairwise_compa}) if ($main::verbose >= 2);

  ## Parse compare-matrix result file to read score columns
  my ($compa) = &OpenInputFile($main::outfile{pairwise_compa});
  $main::param{score_column} = 0;
  while (<$compa>) {
    if (/;\t(\d+)\t$param{matrix_compa_score}/) {
      $main::param{score_column} = $1;
      &RSAT::message::Info("Score", $param{matrix_compa_score}, 
			   "column", $main::param{score_column}, 
			   "file", $main::outfile{pairwise_compa}) 
	  if ($main::verbose >= 2);
      last;
    }
  }
  close $compa;

  if ($main::param{score_column} == 0) {
    &RSAT::error::FatalError("Cannot identify score column (".$param{matrix_compa_score}.") in matrix comparison file (".$main::outfile{pairwise_compa}.").");
  }

  return();
}


################################################################
## Compare each discovered motifs to each other.
sub CompareMatricesQuick {

  ## Pariwise comparisons between discovered matrices.  We don't
  ## the option "distinct" in order to ensure that all the motifs are
  ## in the output graph even if they are not related to any other
  ## motif.
  ## This is the faster C implemented version of compare-matrices

  $matrix_compa_verbose = &RSAT::stats::max(($main::verbose-1), 1);
  my $BIN=$ENV{RSAT}."/bin";

  if($args_to_pass =~ /(-top \d+)/){

      $args_to_pass = $1;
      my $top = "convert-matrix ".$args_to_pass." -i ".$main::infile{matrices}." -from ".$main::matrix_format." -to tf -o ".$main::outfile{prefix}."_matrices.tf"; 
      &RSAT::util::one_command($top, 1,"");
      $main::infile{matrices} = $main::outfile{prefix}."_matrices.tf";
  }else{
      $args_to_pass = "";
  }

  ## Create the description table
  $cmd = $SCRIPTS."/compare-matrices -file ".$main::infile{matrices}." -format ".$main::matrix_format." -return matrix_desc ".$args_to_pass." -o ".$main::outfile{prefix}."_tables";
  &RSAT::util::one_command($cmd, 1, "");
  &RSAT::message::TimeWarn("Matrix description table", $main::outfile{matrix_descriptions}) if ($main::verbose >= 2);
  $cmd = $SCRIPTS."/text-to-html -i ".$main::outfile{matrix_descriptions};
  $cmd .= " -o ".$main::outfile{matrix_descriptions_html};
  &RSAT::util::one_command($cmd, 1,"");

  &RSAT::message::TimeWarn("Pairwise matrix comparison. Quick version.") if ($main::verbose >= 2);
  my $cmd = $BIN."/compare-matrices-quick -v ".$matrix_compa_verbose; 
  $cmd .=  " -file1 ".$main::infile{matrices};
  $cmd .=  " -file2 ".$main::infile{matrices};
  $cmd .= " -lth_ncor1 -1";
  $cmd .= " -lth_ncor2 -1";
  $cmd .= " -lth_ncor -1";
  $cmd .= " -lth_cor -1";
  $cmd .= " -lth_w 0";
  $cmd .= " -mode matches";
  $cmd .= " -o ".$main::outfile{pairwise_compa};
  $cmd .= "; ".$SCRIPTS."/text-to-html -i ".$main::outfile{pairwise_compa};
  $cmd .= " -o ".$main::outfile{pairwise_compa_html};
  &RSAT::util::one_command($cmd, 1,"");
  &RSAT::message::TimeWarn("Matrix comparison table", $main::outfile{pairwise_compa}) if ($main::verbose >= 2);

  return();
}


###############################################################
## Run the R script "matrix-clustering.R" 
##
## This script takes as input a matrix comparison file
## (generated by compare-matrices), performs hierarchical
## clustering.
##
## It returns the resulting tree in json format
## 
sub Hclustering {
    
    &RSAT::message::TimeWarn("Clustering matrices on the basis of the selected parameter.") if ($main::verbose >= 2);


    ##################################
    ### Identify the path of the R executable
    my $r_path = &RSAT::server::GetProgramPath("R");

    my $cluster_motifs_script  = $ENV{RSAT}."/R-scripts/matrix-clustering.R";
    &RSAT::error::FatalError("Cannot read cluster motifs script", $cluster_motifs_script) unless (-r $cluster_motifs_script);
    
    ## Create the string with the labels
    ## It will be passed to R as command-line argument
    my @temp_consensus_fields = @cons_labels;
    unshift(@temp_consensus_fields, "consensus");
    foreach (@temp_consensus_fields){
	$_ = "'".$_."'";
    }
    my $arg_labels = "c(";
    my $join_labels = join(",", @temp_consensus_fields);
    $arg_labels .= $join_labels." )"; 

    $r_verbosity = &RSAT::stats::max(($main::verbose-1), 0);


    ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ## FROM JVH TO JAIME: 
    ##
    ## I think we should better write all parameters in a file, and
    ## call this file with Rscript (or R). This would avoid to create
    ## a very long command line with all parameters, and it would
    ## leave a persistent trace of the complete analysis.
    ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    my $pos_drawing_offset = 0;
    my  $cluster_motifs_cmd = "cat ".$cluster_motifs_script;
    $cluster_motifs_cmd .= " | ".$r_path;
    $cluster_motifs_cmd .= " --slave --no-save --no-restore --no-environ";
    $cluster_motifs_cmd .= " --args \"";
    $cluster_motifs_cmd .= " infile = '".$main::outfile{pairwise_compa}."'";
    $cluster_motifs_cmd .= "; hclust.method = '".$hclust_method."'";
    $cluster_motifs_cmd .= "; description.file = '".$main::outfile{matrix_descriptions}."'";
    $cluster_motifs_cmd .= "; distance.table = '".$main::outfile{distance_table}."'";
    $cluster_motifs_cmd .= "; alignment.file = '".$main::outfile{alignment_table}."'";
    $cluster_motifs_cmd .= "; title = '".$main::param{title}."'";
    $cluster_motifs_cmd .= "; labels = ".$arg_labels;
    $cluster_motifs_cmd .= "; draw.heatmap = ".$draw_heatmap;
    $cluster_motifs_cmd .= "; verbosity = ".$r_verbosity;
    $cluster_motifs_cmd .= "; score = '".$param{matrix_compa_score}."'";

    if($quick_flag == 1){
	my %lth2 = ();
	my @param = qw (Ncor cor);
	foreach my $p (@param){
	    my $val = $lth{$p};
	    $lth2{$p} = $val;
	}
	%lth = %lth2;
    }
    
    ## Pass the thresholds on the score to R for clustering
    if (defined($lth{$param{matrix_compa_score}})) {
	my $lthsp = "";
	foreach my $par (keys %lth){
	    $lthsp.= $par."_".$lth{$par}."_";
	}
	$cluster_motifs_cmd .= "; lthsp = '".$lthsp."'";
    }
    if (defined($uth{$param{matrix_compa_score}})) {
      $cluster_motifs_cmd .= "; uth = '".$uth{$param{matrix_compa_score}}."'";
    }
    $cluster_motifs_cmd .= "; out.prefix = '".$main::outfile{prefix}."'";
    if ($export_tree_format eq "newick"){
      $cluster_motifs_cmd .= "; export = '".$export_tree_format."'";
      $cluster_motifs_cmd .= "; export_newick = '".$main::outfile{consensus_phylogram_newick}."'";
    }
    $cluster_motifs_cmd .= "; \"";
    #$cluster_motifs_cmd .= " >& ".$main::outfile{Rlog};

    if ($r_path) {
        &doit($cluster_motifs_cmd, 0, 1, $verbose);
    } else {
        &RSAT::message::Warning("Could not run motif clustering because the program R is not available") if ($main::verbose >= 1);
    }
    return();
}


################################################################
## Read the cluster composition, which will be required for several
## methods
##
## Results are stored in global variables of the main memory space.
sub ReadClusterComposition {

  ## Read cluster composition, and store it in a hash table where 
  ##   keys = cluster names
  ##   values = lists of nodes per cluster
  &RSAT::message::TimeWarn("Reading cluster sizes from alignment table", $outfile{alignment_table}) if ($main::verbose >= 2);
  my ($cluster_handle) = &RSAT::util::OpenInputFile($outfile{alignment_table});
  while (<$cluster_handle>) {
    next if (/^#/); ## Skip header line
    next if (/^;/); ## Skip comment lines
    next unless (/\S/); ## Skip empty lines
    my ($node, $name, $cluster) = split ("\t");
    push @{$cluster_nodes{$cluster}}, $node;
  }
  @clusters_to_HTML = sort keys %cluster_nodes;

  &RSAT::message::Debug("Cluster names", join ";", @clusters_to_HTML) if ($main::verbose >= 3);
  
  ## Index the number of nodes per cluster
  my %clusters_info = (); 
  foreach my $cluster (@clusters_to_HTML){
    my @nodes = @{$cluster_nodes{$cluster}};
    $clusters_info{$cluster} = scalar(@nodes);
    &RSAT::message::Debug("Cluster:", $cluster, 'nb of nodes:', $clusters_info{$cluster}) if ($main::verbose >= 4);
  }
  close $cluster_handle;
}

################################################################
## Identify clusters of similar motifs using MCL ("Markov clustering",
## an algorithm partitioning a network into clusters), and build
## consensus motifs.
sub ClusterMotifs {

  ## Generate a GML graph with the matrix comparison result (can be opened with CytoScape or Yed)
  $cmd = $SCRIPTS."/convert-graph -i ".$main::outfile{pairwise_compa};
  $cmd .= " -ewidth -ecolors fire";
  $cmd .= " -layout spring_new";
  $cmd .= " -from tab -to gml -scol 1 -tcol 2 -wcol ".$main::param{score_column};
  $cmd .= " -o ".$main::outfile{matrix_network_gml};
  &RSAT::util::one_command($cmd, 1);

  ## Generate a figure of the motif comparison graph
  $cmd = $SCRIPTS."/display-graph";
  $cmd .= " -in_format gml -i ".$main::outfile{matrix_network_gml};
  $cmd .= " -ewidth";
  $cmd .= " -layout none";
  $cmd .= " -out_format png -o ".$main::outfile{compa_png};
  &RSAT::util::one_command($cmd, 1);

  ## Use MCL to partition the motif graph into clusters
  &RSAT::message::TimeWarn("Matrix clustering by running MCL on th matrix-to-matrix network.") if ($main::verbose >= 2);
  my $mcl = &RSAT::server::GetProgramPath("mcl");  
  # my $mcl_dir = $ENV{mcl_dir};
  # unless ($mcl_dir) {
  #   &RSAT::error::FatalError("Motif comparison requires to install MCL and indicate its path in the file $ENV{RSAT}/RSAT_config.props");
  # }
  # my $mcl = $mcl_dir."/mcl";
  $cmd = "grep -v '^;' ".$main::outfile{pairwise_compa}.">".$main::outfile{pairwise_compa}.".mcl";
  $cmd .= "; ".$mcl."/mcl ".$main::outfile{pairwise_compa}.".mcl";
  $cmd .= " -I 1.8 --abc -V all ";
  $cmd .= " -o ".$main::outfile{clusters_mcl};
  $cmd .= " >& /dev/null";
  $cmd .= " ; ".${SCRIPTS}."/convert-classes -i ".$main::outfile{clusters_mcl};
  $cmd .= " -from mcl -to tab ";
  $cmd .= " -o ".$main::outfile{clusters_tab};
  &RSAT::util::one_command($cmd, 1);

  ## Split the motif graph into clusters as defined by MCL, and
  ## compute the intra-cluster degree (k) and weighted degree (wk) of
  ## each node
  $cmd = $SCRIPTS."/graph-get-clusters -i ".$main::outfile{pairwise_compa};
  $cmd .= " -in_format tab -scol 1 -tcol 2 -wcol ".$main::param{score_column};
  $cmd .= " -return clusters ";
  $cmd .= " -clusters ".$main::outfile{clusters_tab};
  $cmd .= " -out_format tab -o ".$main::outfile{clusters_subgraph};
  &RSAT::util::one_command($cmd, 1);


  ## Identify graph components and count the intra-component degree of
  ## each node. Most connected nodes will serve as seeds for motif
  ## clustering.
  $cmd = $SCRIPTS."/graph-connex-components -v 1";
  $cmd .= " -i ".$main::outfile{clusters_subgraph};
  $cmd .= " -wcol ".$main::param{score_column};
  $cmd .= " -o ".$main::outfile{intra_cluster_degree};
  &RSAT::util::one_command($cmd, 1);

  ## Generate a GML graph with the matrix comparison result (can be opened with CytoScape or Yed)
  $cmd = $SCRIPTS."/convert-graph -i ".$main::outfile{clusters_subgraph};
  $cmd .= " -ewidth -ecolors fire";
  $cmd .= " -layout spring_new";
  $cmd .= " -from tab -to gml -scol 1 -tcol 2 -wcol 3";
  $cmd .= " -o ".$main::outfile{clusters_subgraph_gml};
  &RSAT::util::one_command($cmd, 1);

  ## Generate a figure of the motif comparison graph
  $cmd = $SCRIPTS."/display-graph";
  $cmd .= " -in_format gml -i ".$main::outfile{clusters_subgraph_gml};
  $cmd .= " -ewidth";
  $cmd .= " -layout none";
  $cmd .= " -out_format png -o ".$main::outfile{clusters_subgraph_png};
  &RSAT::util::one_command($cmd, 1);


  return();
}


################################################################
## Add attributes to JSON file, like links to pictures and other
## attributes
sub Add_attributes_to_JSON(){
  my (%matrix_info) = ();


  ## Create the logos with the empty columns, which will be displayed
  ## in the HTML5 file
  &Add_empty_columns_to_logos();

  #############################################
  ## Create a hash with the attribute data:
  ##	key :  name
  ##	values : attribute (link, etc)

  ## Open the file with the picture's data
  open(DATA, $main::outfile{matrix_descriptions}) || &RSAT::error::FatalError( "Cannot open DATA file", $main::outfile{matrix_descriptions});
  while(<DATA>){
      next unless (/\S/); ## Skip empty rows
      next if (/^;/); ## Skip comment rows
      next if (/^#/); ## Skip header rows
      chomp();
      @split_line = split(/\s+/, $_);
      my $matrix_label = $split_line[6];

      $matrix_info{$split_line[1]}{id} = $split_line[1];
      $matrix_info{$split_line[1]}{name} = $split_line[2];
      $matrix_info{$split_line[1]}{width} = $alignment_info{$matrix_info{$split_line[1]}{id}}{width};
      $matrix_info{$split_line[1]}{consensus} = $split_line[4];
      $matrix_info{$split_line[1]}{consensus_rc} = $split_line[5];
      $matrix_info{$split_line[1]}{label} = $split_line[6];
      $matrix_info{$split_line[1]}{logo_file} = $split_line[7];
      $matrix_info{$split_line[1]}{logo_file_rc} = $split_line[8];
      #$matrix_info{$matrix_label}{logo_file_rc} = $split_line[8];

      ## The path of the aligned logo (in D or R) that will be displayed 
      if($aligned_logos_path{$split_line[1]}{strand} eq "D"){
	  $matrix_info{$split_line[1]}{logo_aligned_file} = $aligned_logos_path{$split_line[1]}{logo};
	  $matrix_info{$split_line[1]}{logo_aligned_file_rc} = $aligned_logos_path{$split_line[1]}{logo_rc};
      }else{
	  $matrix_info{$split_line[1]}{logo_aligned_file} = $aligned_logos_path{$split_line[1]}{logo}; 
	  $matrix_info{$split_line[1]}{logo_aligned_file_rc} = $aligned_logos_path{$split_line[1]}{logo_rc};
      }
  }
  close(DATA);


  ############################################################
  ## Read the JSON file and add the link data to each node
  &RSAT::message::TimeWarn("Linking data to nodes in JSON files") if ($main::verbose >= 2);
  foreach my $cluster(@clusters_to_HTML){
      my $line = "";
      my $children = 0;
      my ($M1, $M2, $Add_this, $Flag);
      my (@Split_line, @Parsed_JSON) = ();
      my $file = $main::outfile{prefix}."_clusters_information/".$cluster."/levels_JSON_".$cluster."_table.tab";
      chomp(@levels_JSON = `more $file | grep -v ';' | cut -f3`);
      my @merged_cons_folders = keys(%merged_consensuses_files);

      ## Open the JSON file produced by R   
      my $JSON = $main::outfile{prefix}."_trees/tree_".$cluster.".json";
      &RSAT::message::TimeWarn("JSON file", $JSON, $cluster ) if ($main::verbose >= 2);
      open(JSON, $JSON) || &RSAT::error::FatalError($JSON, "Cannot open the JSON file");
      while(<JSON>){
	  
	  chomp;
	  $Flag = 0;
	  $line = $_;
	  
	  # Add the consensus to the json file to be displayed in the tree
#	  if ($line =~ /(\s*\"children\":\s*\[)/){
	  if ($line =~ /children/){	  
	      $children++;
	      $Add_this = "";
	      if ($children >= 2){
		  my $folder = $levels_JSON[$children-2];

		  if(grep( /^$folder$/, @merged_cons_folders)){	      
		      my $branch = $folder;
		      $branch =~ s/\D+//g;
		      my $consensus_link = &RSAT::util::RelativePath($JSON, $merged_consensuses_files{$folder}{$cluster}{logo}); 
		      $Add_this .= " \"name\" : \"".$merged_consensuses_files{$folder}{$cluster}{consensus}."\",\n";
		      $Add_this .= " \"branch\" : ".$branch.",\n";
		      $Add_this .= " \"id\" : \"".$cluster."_".$folder."\",\n";
		      $Add_this .= " \"url\" : \"".$consensus_link."\",\n";
		      push(@Parsed_JSON, $Add_this."\n");
		  }
	      }
	  }
	  
	  ### Search the pattern separating the matrices names
	  if ($line =~ /\s*\"label\":\s*\"(.+)\",/){
	      $Flag = 1;
	      $Add_this = "";
	      $M1 = $1;
	      
	      ## Define te URL of the logo file, relative to the location of the json file
	      my $aligned_logo_link = &RSAT::util::RelativePath($JSON, $matrix_info{$M1}{logo_aligned_file});
	      $aligned_logo_link =~ s/^\.\.\///g;

	      my $aligned_logo_url = $aligned_logo_link.".png";

	      ## Define te URL of the logo file, relative to the location of the json file
	      my $aligned_rc_logo_link = &RSAT::util::RelativePath($JSON, $matrix_info{$M1}{logo_aligned_file_rc});
	      $aligned_rc_logo_link =~ s/^\.\.\///g;
	      my $aligned_rc_logo_url = $aligned_logo_link.".png";
	      
	      ### Create the line that will be added to JSON file
	      $Add_this .= "\n \"image\" : \"${aligned_logo_link}\"";
	      $Add_this .= ",\n \"image_rc\" : \"${aligned_rc_logo_link}\"";
	      $Add_this .= ",\n \"url\" : \"${aligned_logo_link}\"";
	      
	      foreach my $field (@supported_label_fields) {
		  if ($label_fields_to_return{$field}) {
		      $Add_this .= ",\n \"".$field."\" : \"".$matrix_info{$M1}{$field}."\"";
		  }
	      }
	      $Add_this .= ",\n \"size\" : ".$matrix_info{$M1}{width};
	      $Add_this .= ",\n \"consensus_rc\" : \"".$matrix_info{$M1}{consensus_rc}."\"";
	  }
	  push(@Parsed_JSON, $line."\n");
	  
	  ### Add the new line
	  if ($Flag) {
	      push(@Parsed_JSON, $Add_this."\n");
	  }
      }
      close(JSON);
  
      ### Create the JSON parsed FILE
      open(PARSED_JSON, ">".$main::outfile{prefix}."_trees/parsed_tree_".$cluster.".json") || &RSAT::error::FatalError("Cannot create the PARSED JSON file", $main::outfile{prefix}."_trees/parsed_tree_".$cluster.".json");
      print PARSED_JSON @Parsed_JSON;
      close(PARSED_JSON);
      unlink($JSON);
  }

  my $cmd = "rm -r ".$main::outfile{prefix}."_pairwise_compa_logos";
  &doit($cmd, 0, $die_on_error, $verbose);

  return();
}


###################################
## Create the html file to 
## display the tree
sub create_html_tree_file(){

    ## Values to change in the D3 tree
    my $svg_width = 25;
    my $svg_height = 80;
    my $svg_x1 = 15 * $nb_char;
    my $svg_y1 = -33;
    my $svg_x2 = '25 + '.$svg_x1.' + 25';;
    my $add_this = "";
    my $labels_num = 0;
    my $cluster_nb = 0;
    my $main_label = 	        
	"\tnode.append(\"a\")
	\t\t.attr(\"xlink:href\", function(d) { return d.url; })
	\t\t.append(\"text\")
	\t\t.text(function(d) { return d.children ? \"\" : d.; })
	\t\t.attr(\"dx\", function(d) { return d.children ? 0 : 20; })
	\t\t.attr(\"dy\", function(d) { return d.children ? 0 : 3; })
	\t\t.attr(\"text-anchor\", function(d) { return d.children ? \"end\" : \"start\"; });\n";

    my $new_label = 
	"\tnode.append(\"text\")
	\t\t.text(function(d){ return d.children ? \"\" : d.; })
	\t\t.attr(\"x\", function(d){ return d.children ? 0 : 20; })
	\t\t.attr(\"dy\", function(d){ return d.children ? 0 : #; })
	\t\t.attr(\"text-anchor\", function(d){ return d.children ? \"end\" : \"start\"; });";

    my $display_consensus_d3 =
	"		node.append(\"a\")
		.attr(\"xlink:href\", function(d) { return d.children ? d.url : \"\"; })
		.append(\"text\")
		.text(function(d) { return d.children ? d.name : \"\"; })
		.attr(\"dx\", function(d) { return d.children ? -20 : 0; })
		.attr(\"dy\", function(d) { return d.children ? -6 : 0; })
		.attr(\"fill\", function(d) { return d.children ? \"blue\" : \"\"; })
		.attr(\"text-anchor\", function(d) { return d.children ? \"end\" : \"start\"; });";

    
    my $display_title_lab .= '
        node.append("text")
	.text(function(d){ return d.children ? "" : "'.$main::param{title}.'"; })
	.attr("x", function(d){ return d.children ? 0 : 20; })
	.attr("dy", function(d){ return d.children ? 0 : 27; })
        .attr("fill", "blue")
	.attr("font-size", "17px")
	.attr("text-anchor", function(d){ return d.children ? "end" : "start"; })
        ';


    open(TREE, $main::outfile{logo_cladogram_html}) || &RSAT::error::FatalError($main::outfile{logo_cladogram_html}, "Cannot open HTML file");
    open(TEMP, ">".$main::outfile{temp}) || &RSAT::error::FatalError($main::outfile{temp}, "Cannot create temporary file");

    while(<TREE>){
	chomp;	

	if(/\(function\(\)\{/){
	    $cluster_nb++;
	}

	if ((defined($ENV{RSA_OUTPUT_CONTEXT})) &&
	    (($ENV{RSA_OUTPUT_CONTEXT}eq "cgi") || ($ENV{RSA_OUTPUT_CONTEXT} eq "RSATWS"))) {
	  $_ =~ s|$ENV{RSAT}/public_html/|$ENV{rsat_www}|g;
	}
	
	### Fix the d3 library path
	if(/--d3--/){;
	    $_ =~ s/--d3--/$d3_base/g;
	}

	### Set the height 
	if(/--height--/){
	    my $clust = "cluster_".$cluster_nb;
	    my $mat_number = $clusters_info{$clust} + 2;
	    $_ =~ s/--height--/100 + 85 * $mat_number/;
	}

	### Set the height 
	if(/--widthtree--/){;
	    $_ =~ s/--widthtree--/3500/;
	}

	### Set the tree size
	if(/--size--/){;
	    $_ =~ s/--size--/1000/;
	}

	### Add the JSON file name
	if(/--jsonfile--/){
	    my $j_file = $main::outfile{prefix}."_trees/parsed_tree_cluster_".$cluster_nb.".json";
	    $json_file_name = &RSAT::util::RelativePath($main::outfile{logo_cladogram_html}, $j_file);
	    $_ =~ s/--jsonfile--/$json_file_name/;
	}

	if(/--cl_id--/){
	    my $c = "cluster_".$cluster_nb;
	    $_ =~ s/--cl_id--/$c/;
	}

	## Add the color of the cluster
	if(/--stroke--/){
	    my $clust = "cluster_".$cluster_nb;
	    $_ =~ s/--stroke--/$hexa_code{$clust}/;
	}

	if(/--radius--/){
	    $_ =~ s/--radius--/6/;
	}

	if(/--insert--/){
	    $_ =~ s/--insert--//;
	}

	if(/--svgwidth--/){
	    $_ =~ s/--svgwidth--/$svg_width/g;
	}

	if(/--svgheight--/){
	    $_ =~ s/--svgheight--/$svg_height/g;
	}

	if(/--x1--/){
	    $_ =~ s/--x1--/$svg_x1/g;
	}

	if(/--y1--/){
	    $_ =~ s/--y1--/$svg_y1/g;
	}

	if(/--x2--/){
	    $_ =~ s/--x2--/$svg_x2/g;
	}

	if(/--lab--/){
	    $_ =~ s/--lab--//g;
	}

	if ($_ =~ /Insert labels/){
	    $add_this = "";
	    $labels_num = 0;
	    ################################################################
	    ## Insert in the html script the labels selected by the user
	    foreach my $field (@label_fields_to_return) {
		if ($label_fields_to_return{$field}) {
		    $labels_num++;
		    
		    ### Add the first label with the the link to the logo
		    if($labels_num == 1){
			$add_this = $main_label;
			$up = uc($field);
			$add_this =~ s/d\.;/ d\.$field;/;
		    }

		    if($display_title_flag == 1){
			$add_this .= "\n".$display_title_lab."\n";	
		    }
		    
		    ### Add the new labels, set the distances among the labels in the tree
		    if($labels_num > 1){
			my $copy = $new_label;
			$up = uc($field);
			$copy =~ s/d\.;/ d\.$field;/;
			my $y_displacement = 3 + (($labels_num -1) * 20);
			$copy =~ s/#/$y_displacement/;
			$add_this .= "\n\n".$copy."\n";
		    }
		}
	    }
	    print TEMP $add_this."\n";
	}

	if ($_ =~ /Insert consensus/){
	    $add_this = "";
	    $add_this .= "\n\n".$display_consensus_d3."\n\n";
	    print TEMP $add_this."\n";
	}

	print TEMP $_."\n";
    }
    close(TEMP);
    unlink($main::outfile{logo_cladogram_html});
    my $cmd = "mv -f ".$main::outfile{temp}." ".$main::outfile{logo_cladogram_html};
    &doit($cmd, 0, $die_on_error, $verbose);
    return();
}

################################################################
## Index a table to convert to HTML
sub AddTabToConvert {
  my ($key) = @_;
  my $tab = $main::outfile{$key};
  my $html_key = $key."_html";
  my $html = $tab."_html";
  $html =~ s/\.tab.html$/\.html/;
  $html =~ s/\.txt.html$/\.html/;
  $main::outfile{$html_key} = $html; push @outfiles, $html_key; 
  push @tab_to_convert, $key; ## Add the key to the list to be converted
}

################################################################
## Convert tab-delimited files in HTML
sub ConvertTabToHTML {
  my @tab_to_convert = @_;
  &RSAT::message::TimeWarn("Converting tab-delimited to HTML files") if ($main::verbose >= 2);
  for my $key (@tab_to_convert) {
    my $tab = $main::outfile{$key};
    my $html_key = $key."_html";
    my $html = $main::outfile{$html_key};
    my $cmd = $SCRIPTS."/text-to-html ";
    $cmd .= " -i ".$tab;
    $cmd .= " -o ".$html;
    &doit($cmd, 0, $die_on_error, $verbose);
  }
}

################################################################
## Add the empty columns to the logos that will be displayed, in order
## to get multiple alignment on the logo cladogram.
sub Add_empty_columns_to_logos(){

  ## Open the alignment_table data
  open(ALIGNMENT_TABLE, $main::outfile{alignment_table}) || &RSAT::error::FatalError( "Cannot open ALIGNMENT_TABLE file", $main::outfile{alignment_table});

  while(<ALIGNMENT_TABLE>){
    next unless (/\S/); ## Skip empty rows
    next if (/^;/); ## Skip comment rows
    next if (/^#/); ## Skip header rows
    chomp();
    
    my @split_line = split(/\s+/, $_);
    $split_line[0] =~ s/\s+//g;
    ## Store the ID, strand and offset of each aligned motif
    $alignment_info{$split_line[0]}{name} =  $split_line[1];
    $alignment_info{$split_line[0]}{strand} =  $split_line[4];
    $alignment_info{$split_line[0]}{offset_left} =  $split_line[5];
    $alignment_info{$split_line[0]}{offset_right} =  $split_line[6];
    $alignment_info{$split_line[0]}{width} = $split_line[7];    
  }
  close(ALIGNMENT_TABLE);

  ## Call the program 'convert-matrix' to add the empty columns
  ## to the aligned logos and retrieve the logos in RC
  foreach my $id (keys %alignment_info){

    ## Reset the variables
    my $offset_left = $alignment_info{$id}{offset_left};
    my $offset_right = $alignment_info{$id}{offset_right};
    my $file_name = $alignment_info{$id}{file_name};
    my $strand = $alignment_info{$id}{strand};

    ## Run the convert-matrix command to add the empty columns to the logos
    if($strand eq "D"){

      ## Add the empty columns
      my $cmd = $SCRIPTS."/convert-matrix -i ".$file_name;
      $cmd .= " -from tf -to tf -logo_format png -return counts,consensus,parameters,logo";
      $cmd .= " -insert_col_left ".$offset_left;
      $cmd .= " -insert_col_right ".$offset_right;
      $cmd .= " -o ".$main::outfile{prefix}."_aligned_logos/aligned_logos";
      &doit($cmd, 0, $die_on_error, $verbose);

    }else{

      ## First convert the matrix to reverse complement 
      my $temp_mat = $main::outfile{prefix}."_aligned_logos/temp.tf";
      $cmd = $SCRIPTS."/convert-matrix -i ".$file_name;
      $cmd .= " -from tf -to tf -rc -return counts,consensus";
      $cmd .= " -o ".$temp_mat;
      &doit($cmd, 0, $die_on_error, $verbose);
      
      ## Then add the gaps
      $cmd = $SCRIPTS."/convert-matrix -i ".$temp_mat;
      $cmd .= " -from tf -to tf -logo_format png -return counts,consensus,parameters,logo";
      $cmd .= " -insert_col_left ".$offset_left;
      $cmd .= " -insert_col_right ".$offset_right;
      $cmd .= " -o ".$main::outfile{prefix}."_aligned_logos/aligned_logos";
      &doit($cmd, 0, $die_on_error, $verbose);
      unlink($temp_mat);
    }
    unlink($file_name);

    ## Store the path of the logos
    $aligned_logos_path{$id}{strand} = $strand;
    $aligned_logos_path{$id}{logo} = $main::outfile{prefix}."_aligned_logos/".$id."_logo.png";
    $aligned_logos_path{$id}{logo_rc} = $main::outfile{prefix}."_aligned_logos/".$id."_logo_rc.png";
  }    
}


#################################################
## Print the matrices in separated files. They 
## will be used to add empty columns with 
## convert-matrices and to create the merged
## consensus
sub create_single_matrix_files(){

    my @ids = ();
    my ($desc) = &OpenInputFile($main::outfile{matrix_descriptions});
    while(<$desc>){
	chomp;
	next if /^#/;
	my @split = split(/\t/, $_);
	push(@ids, $split[1]);
    }
    close($desc);

    &RSAT::message::TimeWarn("Creating single matrix files") if ($main::verbose >= 2);

    ## Split the matrix file into single matrices file, 
    ## in order to process individually each matrix
    my %matrix_files = ();
    my $cmd = $SCRIPTS."/convert-matrix";
    $cmd .= " -i ".$infile{matrices}." -from ".$main::matrix_format." -to tf -split -o ".$main::outfile{prefix}."_single_matrices";
    &doit($cmd, 0, $die_on_error, $verbose);
    
    $main::outfile{matrix_single_list} = $main::outfile{prefix}."_single_matrices_matrix_list.tab";
    my ($mat_file_list) = &OpenInputFile($main::outfile{matrix_single_list});
    while(<$mat_file_list>){
	chomp;
	next if /^#/;
	my @split = split(/\t/, $_);
	my $id = $split[1];
	$to_delete{$id} = $main::outfile{prefix}."_single_matrices_".$id.".tf";
	if(grep( /^$id$/, @ids)){
	    my $id_file = $main::outfile{prefix}."_single_matrices_".$id.".tf";
	    $matrix_files{$id}{file_name} = $id_file;
	}
    }
    close($main::outfile{matrix_single_list});
    unlink($main::outfile{matrix_single_list});
    return(%matrix_files);
}


#########################################################################
## Merge the matrices at each level of the hclust tree, and produce a
## branch-wise matrix + logo + consensus.
sub Merge_matrices(){

    
    ## Read the file with the information of the intermediate alignments
    ## This info will be used to create the branch-motifs
    my %int_align_files = ();
    my ($int_align_file) = &OpenInputFile($main::outfile{int_align});
    while (<$int_align_file>) {
	chomp;
	my $line = $_;
	my @split_line = split("\t", $line);
	my $cluster_number = "cluster_".$split_line[1];
	my $level_number = "merge_level_".$split_line[2];
	my $file_path = $split_line[3];
	$int_align_files{$cluster_number}{$level_number} = $file_path;
    }
    close $int_align_file;


    &RSAT::message::TimeWarn("Merging matrices for", scalar(@clusters_to_HTML), "clusters") if ($main::verbose >= 2);
    ## Get the cluster sizes
    
    foreach my $cluster (@clusters_to_HTML){

	my @nodes = @{$cluster_nodes{$cluster}};
	&RSAT::message::Debug("Merging matrices for cluster", $cluster, "Nodes", join (";", @nodes)) if ($main::verbose >= 3);
	
	$clusters_info{$cluster} = scalar(@nodes); 
	$clusters_info{$cluster} =~ s/\s+//g;

	
	## Folders with the aligned matrices
	my @folder_merged_matrices = ();
	chomp(@folder_merged_matrices = `ls $main::outfile{prefix}_clusters_information/$cluster/merged_consensuses`);
	
	my %int_align_info = ();
	foreach my $folder (@folder_merged_matrices){

	    ## Read the table with the number of spaced for each matrix,
	    ## for each level of each cluster
	    my $merge_level = $folder;
	    $main::outfile{int_align_offset} = $main::outfile{prefix}."_clusters_information/".$cluster."/levels_JSON_".$cluster."_".$merge_level."_dataframe.tab";
	    my @level_motifs = ();
	    my ($int_align_dataframe) = &OpenInputFile($main::outfile{int_align_offset});
	    while (<$int_align_dataframe>) {
		chomp;
		my $line = $_;
		my @split_line = split("\t", $line);
		my $motif_id = $split_line[0];
		#$motif_id =~ s/\./-/;
		my $motif_strand = $split_line[3];
		my $offset_up = $split_line[6];
		my $offset_down = $split_line[7];
		$int_align_info{$cluster}{$merge_level}{$motif_id}{offset_up} = $offset_up;
		$int_align_info{$cluster}{$merge_level}{$motif_id}{offset_down} = $offset_down;	
		$int_align_info{$cluster}{$merge_level}{$motif_id}{strand} = $motif_strand;	
		push(@level_motifs, $motif_id);
	    }
	    close $int_align_dataframe;	    
	    unlink($main::outfile{int_align_offset});

	    ## For each level add the gaps to the matrices
	    foreach my $motif (@level_motifs){

		## Reset the variables
		my $offset_left = $int_align_info{$cluster}{$merge_level}{$motif}{offset_up};
		my $offset_right = $int_align_info{$cluster}{$merge_level}{$motif}{offset_down};
		my $strand = $int_align_info{$cluster}{$merge_level}{$motif}{strand};
		my $file_name = $alignment_info{$motif}{file_name};

		## Run the convert-matrix command to add the empty columns to the logos
		if($strand eq "D"){

		    ## Add the empty columns
		    my $cmd = $SCRIPTS."/convert-matrix -i ".$file_name;
		    $cmd .= " -from tf -to tf -return counts,consensus";
		    $cmd .= " -insert_col_left ".$offset_left;
		    $cmd .= " -insert_col_right ".$offset_right;
		    $cmd .= " -o ".$main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$merge_level."/".$motif.".tf";
		    &doit($cmd, 0, $die_on_error, $verbose);
		    
		}else{
		    
		    ## First convert the matrix to reverse complement 
		    my $temp_mat = $main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$merge_level."/temp.tf";
		    $cmd = $SCRIPTS."/convert-matrix -i ".$file_name;
		    $cmd .= " -from tf -to tf -rc -return counts,consensus";
		    $cmd .= " -o ".$temp_mat;
		    &doit($cmd, 0, $die_on_error, $verbose);
		    
		    ## Then add the gaps
		    $cmd = $SCRIPTS."/convert-matrix -i ".$temp_mat;
		    $cmd .= " -from tf -to tf -return counts,consensus";
		    $cmd .= " -insert_col_left ".$offset_left;
		    $cmd .= " -insert_col_right ".$offset_right;
		    $cmd .= " -o ".$main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$merge_level."/".$motif.".tf";
		    &doit($cmd, 0, $die_on_error, $verbose);
		    unlink($temp_mat);
		}
	    }
	    
	    my @file_names = @level_motifs;
	    ## Get the names of the files of each level
	    foreach my $m (@file_names){
	    	$m = $main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$merge_level."/".$m.".tf";
	    }
	    my $files = join(" ", @file_names);

	    ## Merge the matrices and create a single matrix
	    my $cat_file = $main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$merge_level."/".$merge_level."_cat.tf";
	    my $merged_mat_file = $main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$merge_level."/".$merge_level."_matrices.tf";
	    my $cmd = "cat ".$files." >".$cat_file;
	    $cmd .= "; ".$SCRIPTS."/merge-matrices -i ".$cat_file;
	    $cmd .= " -in_format tf -out_format tf";
	    $cmd .= " -o ".$merged_mat_file;
	    &doit($cmd, 0, $die_on_error, $verbose);
	    ## Delete files with single matrices
	    unlink($cat_file);
	    foreach my $file (@file_names){
	    	unlink($file);
	    }    

	    ## Create branch-wise logos
	    $cmd = $SCRIPTS."/convert-matrix -i ".$merged_mat_file;
	    $cmd .= " -from tf -to tf -logo_format png -return counts,consensus,logo";
	    $cmd .= " -o ".$main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$folder."/".$folder; 
	    &doit($cmd, 0, $die_on_error, $verbose);
	    
	    $merged_consensuses_files{$folder}{$cluster}{logo} = $main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$folder."/merged_logo.png";
	    $merged_consensuses_files{$folder}{$cluster}{logo_RC} = $main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$folder."/merged_logo_rc.png";
	    
	    $merged_consensuses_files{$folder}{$cluster}{consensus} = $main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$folder."/merged_logo_rc.png";
	    
	    my $mat_file = $main::outfile{prefix}."_clusters_information/".$cluster."/merged_consensuses/".$folder."/".$folder."_matrices.tf";
	    my $cons = `more $mat_file | grep '^DE'`;
	    chomp($cons);
	    $cons =~ s/^DE\s+//;
	    $merged_consensuses_files{$folder}{$cluster}{consensus} = $cons;
	}
    }
}


########################################
## Before modify the width and heigth
## of the alignments, creates the <div>
## in HTML script to visualize the clusters
sub Add_div_to_HTML(){
    my $line = "";
    my $print = "";
    my $temp = &logo_tree();

    my $cmd = "cp ".$ENV{RSAT}."/public_html/templates_html/display_d3_tree.html ".$main::outfile{logo_cladogram_html};
    &doit($cmd, 0, $die_on_error, $verbose);

    my %clusters_info_sorted = ();
    my %clusters_info_cp = %clusters_info;
    my @sorted_keys = keys %clusters_info;
    foreach my $k (@sorted_keys){
	$k =~ s/cluster_//;
	$clusters_info_sorted{$k} = delete $clusters_info_cp{"cluster_".$k};
    }
    

    open(TEMP, ">".$main::outfile{temp}) || &RSAT::error::FatalError($main::outfile{temp}, "Cannot create temporary file");
    open(TREE,$main::outfile{logo_cladogram_html}) || &RSAT::error::FatalError($main::outfile{logo_cladogram_html}, "Cannot found the HTML tree file");

    while(<TREE>){
	chomp;
	$line = $_;
	## Add one <div> for each cluster
	if(/^\s*\/\/Divisions/){
	    $line = "";
	    foreach my $cluster (sort {$a <=> $b} keys %clusters_info_sorted){             
		$line .= "<div id=\"cluster_".$cluster."\"><h2>cluster_".$cluster."</h2><\/div>\n";
	    }
	}

	## 
	if(/^\s*\/\/Body/){
	    $line = "";	
	    foreach my $cluster (sort {$clusters_info_sorted{$a} <=> $clusters_info_sorted{$b}} keys %clusters_info_sorted){      
		$line .= $temp."\n";
	    }
	}

	$print .= $line."\n";
    }
    print TEMP $print;
    close(TREE);
    close(TEMP);
    unlink($main::outfile{logo_cladogram_html});
    $cmd = "mv ".$main::outfile{temp}." ".$main::outfile{logo_cladogram_html};
    &doit($cmd, 0, $die_on_error, $verbose);    
}


###############################
## Export the cluster header
sub cluster_delim {

  my $cluster_delim = 
      '	
        <!--Div with cluster 1 delimitation and buttons to display results-->
	<div class="cluster_division button_click --Cluster_id_head--">
		<strong>--Cluster_id--</strong>
	</div>
';
  
  return($cluster_delim);
}

##########################################
## Store in a string the cluster header
sub hide_show_buttons {

  my $HS_buttons = 
      '	
      <div style="clear:both; display:block; margin: 2px 5px 1px 5px;">
        <!--Div with cluster 1 delimitation and buttons to display results-->
	<div class="hide_show_button button_click" id="show_all_button">
		<strong>Show All</strong>
	</div>
	<div class="hide_show_button button_click" id="hide_all_button">
		<strong>Hide All</strong>
	</div>
      </div>
';
  
  return($HS_buttons);
}
 

###########################
## Slide buttons cluster header
sub cluster_head_buttons{
  
  my $size = shift;
  my $jquery_toggle_buttons = "";

  if($size > 1){
    $jquery_toggle_buttons = '

  // Slide the buttons to show the results
  $(document).ready(function(){
    $(\'.--Cluster_id_head--\', this).click(function(){
       $(\'#branch_consensus_cluster_--nb--\').slideToggle(\'fast\');
       $(\'#cluster_--nb--\').slideToggle(\'fast\');
       $(this).toggleClass(\'selected_cluster\');
     }); 
       $(\'#hide_tree_--nb--\').css(\'display\', \'block\');
    
  });
    ';
  } else{

    $jquery_toggle_buttons = '

  // Slide the buttons to show the results
  $(document).ready(function(){
    $(\'.--Cluster_id_head--\', this).click(function(){
       $(\'#cluster_--nb--\').slideToggle(\'fast\');
       $(this).toggleClass(\'selected_cluster\');
     }); 
       $(\'#hide_tree_--nb--\').css(\'display\', \'block\');
  });
    ';
  }
  return($jquery_toggle_buttons);
}


############################################
## Stores in a string the Alignment table
sub alignment_table{

  my $align_table = '
    <div class="tab alignment_tab" id="alignment_table_--nb--">
		<table>
			<thead>
				<tr>
					<th colspan="8">Cluster information and consensus alignment</th>
				</tr>
				<tr>
					<th class="tab_col">Motif id</th>
                                        <th class="tab_col">Motif name</th>
					<th class="tab_col tab_spacer_2">Cluster number</th>
					<th class="tab_col tab_spacer_2">Orientation</th>
					<th class="tab_col tab_spacer_2">Offset<br>upstream</th>
					<th class="tab_col tab_spacer_2">Offset<br>downstream</th>
					<th class="tab_col tab_spacer_2">Alignment<br>width</th>
					<th class="tab_col">Consensus Alignment</th>
				</tr>
			</thead>
                        <tbody>
                        <!-- Insert rows-->
                        HERE
                        </tbody>
                </table>
     </div>
    ';

  return($align_table);
}


###################################
## Hide/show the alignment table
sub toogle_branch_consensus_table{

    my $toogle_branch_consensus_tab  = 
'
// Slide the branch-motif table
  $(document).ready(function(){
    $(\'#button_branch_consensus_cluster_--nb--\').click(function(){
       $(\'.branch_consensus_cluster_--nb--\').slideToggle(\'slow\');
     }); 
  $(\'.branch_consensus_cluster_--nb--\').css(\'display\', \'none\');
  });
';
    return($toogle_branch_consensus_tab);
}


###################################
## Show selected branch motifs
sub Display_Selected_Branch{

    my $selected_branch  = 
'
  $(document).ready(function(){
    $(\'#cluster_--nb--_merge_level_--level--\').click(function(){
       showOneRow("cluster_--nb--_level_--level--");
       showOneTable("branch_consensus_cluster_--nb--");
     }); 
  }); 
';
    return($selected_branch);
}


###################################
## Hide/show the alignment table
sub hide_branch_motifs {

  my $hide_branch_motifs  = 
      '
// Hide the logo tree
  $(document).ready(function(){
    $(\'#hide_branch_table_--nb--\').click(function(){
         $(\'#branch_consensus_cluster_--nb--\').hide();
     }); 
  });
';
  return($hide_branch_motifs);
}


###################################
## Hide/show the alignment table
sub hide_tree {

  my $hide_tree  = 
      '
// Hide the logo tree
  $(document).ready(function(){
    $(\'#hide_tree_--nb--\').click(function(){
       $(\'#cluster_--nb--\').hide();
       $(\'#branch_consensus_cluster_--nb--\').hide();
       $(\'.head_cluster_--nb--\').removeClass(\'selected_cluster\');
     }); 
  });
';
  return($hide_tree);
}


##############################################################
## Insert D3 logo tree: This is the body of d3 script, each 
## time a new cluster is added to the file the next code is 
## pasted and modified           
sub logo_tree{

  my $logo_tree = 
      '

	(function(){
        var width = --widthtree--,
	height = --height--;
	;


	var cluster = d3.layout.cluster()
		.size([height, --size--])
	        .separation(function(a, b) { return (a.parent == b.parent ? 1: 1); });


	var svg = d3.select("#--cl_id--").append("svg")
		.attr("width", width)
		.attr("height", height)
		.append("g")
		.attr("class","drawarea")
		.attr("transform", "translate(40,0)");
		


d3.json("--jsonfile--", function(json) {
				
	var nodes = cluster.nodes(json);

	var link = svg.selectAll("path.link")
		.data(cluster.links(nodes))
		.enter().append("path")
		.attr("class", "link")
                .attr("stroke", "--stroke--")
		.attr("d", elbow);


	var node = svg.selectAll("g.node")
		.data(nodes)
		.enter().append("g")
		.attr("class", "node")
		.attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

	
	node.append("circle")
		.attr("r", --radius--)
                .attr("fill", "--stroke--")
                --insert--;


       /*Insert labels*/
       --lab--


       /*Insert consensus*/

		
	node.append("svg:image")
		.attr("xlink:href", function(d) { return d.image; })  
		.attr("width", function(d) { return (d.size + 2)  * --svgwidth--; })
		.attr("height", --svgheight--)
		.attr("x", --x1--)    
		.attr("y", --y1--) 
		.attr("preserveAspectRatio", "none");	
		
	node.append("svg:image")
		.attr("xlink:href", function(d) { return d.image_rc; })  
		.attr("width", function(d) { return (d.size + 2)  * --svgwidth--; })
		.attr("height", --svgheight--)
  		.attr("x", function(d) { return (d.size + 2)  * --x2--; })  
		.attr("y", --y1--) 
		.attr("preserveAspectRatio", "none");
			
	});
	

	function elbow(d, i) {
		
		return "M" + d.source.y + "," + d.source.x
		+ "V" + d.target.x + "H" + d.target.y;
	}
})();
	
';

  return($logo_tree);
}


#########################
## Insert D3 logo tree
sub branch_consensus_table{

  my $branch_consensus_table = 
      '
    <div class="hide_show tab cons_tab" id="branch_consensus_cluster_--nb--" style="display:none">
    <div id="hide_branch_table_--nb--" class="Cluster_results buttons_click" style="display:block; clear:both"><strong>cluster_--nb--</strong></div>
		<table style="display:block; clear:both;">
			<thead>
				<tr>
					<th colspan="5">Branch-consensus and branch-motifs</th>
				</tr>
				<tr>
					<th class="tab_col">Consensus id</th>
					<th class="tab_col">Consensus</th>
					<th class="tab_col">Logo Direct (link)</th>
                                        <th class="tab_col">Logo Reverse (link)</th>
					<th class="tab_col">Matrix (Transfac format; link)</th>
				</tr>
			</thead>
                        <tbody>
                        <!-- Insert rows-->
                        --here--
                        </tbody>
                </table>
     </div>
';

  return($branch_consensus_table);
}


##############################################################
## When the option -top is used the analysis is restricted 
## to the first X motifs, however the input motif file is 
## splitted on individual files, although not all of them 
## are not. This functions will delete those files
sub Delete_temporal_files {
  foreach my $f (keys %to_delete){
    unlink($to_delete{$f});
  }
}

##############################################
## When the option -clone_input is selected
## the input file is exported in the result 
## folder
sub Clone_input{
  my $cmd = "cp ".$infile{matrices}." ".$main::outfile{motif_file};
  &RSAT::util::one_command($cmd, 1,"");
  &RSAT::message::TimeWarn("Input motif file", $main::outfile{motif_file}) if ($main::verbose >= 2);
}


##################################
## Read the cluster-color table
sub Read_cluster_colors{

  my %hexa_hash = ();

  open(HEXA, $main::outfile{hexa_colors}) || &RSAT::error::FatalError( "Cannot open Hexadecimal code for colors file", $main::outfile{hexa_colors});

  while(<HEXA>){
    chomp;
    my @string_split = split(/\s+/, $_);
    my $cl = $string_split[0];
    my $hexa = $string_split[1];
    $hexa =~ s/FF$//ig;
    $hexa_hash{$cl} = $hexa;
  }
  close(HEXA);
  unlink($main::outfile{hexa_colors});

  return(%hexa_hash);
}


################################################################
## Generate a compressed archive with all the results
sub Archive {

  my ($remove_first, $to_archive) = @_;



  &RSAT::message::TimeWarn("\n; Archiving data and results") if ($main::verbose >= 2);

  ## Delete previous version of the archive to avoid including the old archive in the new one
  $cmd .= "rm -f ".$main::outfile{archive}."; " if ($remove_first);


  ################################################################
  ## Define archiving parameters

  ## By default, archive the whole output directory
  $to_archive = $main::dir{output} unless $to_archive;

  ## Archive all data and results
  my ($archive_dir, $archive) = &SplitFileName($main::outfile{archive});
  my ($archive_dir_dir, $archive_dir_base) = &SplitFileName($archive_dir);
#  $to_archive_rel_path = &RSAT::util::RelativePath($main::outfile{archive}, $to_archive);
  my $to_archive_rel_path = &RSAT::util::RelativePath($archive_dir_dir, $to_archive);
  my $archive_rel_path = &RSAT::util::RelativePath($archive_dir_dir, $main::outfile{archive});
  if ($main::verbose >= 0) {
    &RSAT::message::Debug("folder to archive", $to_archive);
#    die "HELLO";
  }

  ## Avoid crash of the program when run from the "$archive_dir_dir"
  if ($archive_dir_dir eq "") {
    $archive_dir_dir = ".";
    $to_archive_rel_path = $to_archive;
    $archive_rel_path = $main::outfile{archive};	 
  }

  my $cmd = "";
  if ($main::param{archive_format} eq "zip") {
    $cmd .= "(cd ".$archive_dir_dir." ; ";
    $cmd .= " zip -ryq ".$archive_rel_path." ".$to_archive_rel_path;
    $cmd .= " -x ".$archive;
    $cmd .= ")";
  } elsif (($main::param{archive_format} eq "tar") ||
	   ($main::param{archive_format} eq "tgz")) {
    $cmd .= "tar -cpf ".$main::outfile{archive};
    $cmd .= " -z" if ($main::param{archive_format} eq "tgz");
    $cmd .= " -C ".$archive_dir_dir; ## Avoid including the whole path in the archive paths
    $cmd .= " --exclude ".$archive;
    $cmd .= " ".$to_archive_rel_path;
    #$cmd .= " ".$to_archive;
  } else {
    &RSAT::error::FatalError($main::param{archive_format}, "Invalid archive format. Supported: zip, tar, tgz.");
  }

#  $cmd .= "zip -q ".$archive." ".$to_archive;
  &one_command($cmd, 1);

  &RSAT::message::TimeWarn("Archive", $main::outfile{archive}) if ($main::verbose >= 2);
}


################################################################
## Set output file names + check output directories
sub set_output_file_names {
  ## Create output dir if required
  my $basename;
  ($dir{output}, $basename) = &RSAT::util::SplitFileName($main::outfile{prefix});
  $dir{output} = "." if ($dir{output} eq "");
  &RSAT::util::CheckOutDir($dir{output});
  push @dirs, "output";

  ## Create output directories
  local @output_folders = qw( tables html figures pairwise_compa_logos aligned_logos);
  foreach my $f (@output_folders){
      my $new_f = $main::outfile{prefix}."_".$f;
      &RSAT::util::CheckOutDir($new_f);
  }

  ## Directory containing the matrix logos (to be displayed in the HTML tree)
  $dir{logos} = $main::outfile{prefix}."_pairwise_compa_logos"; push @dirs, "logos";

  ## Directory to create the aligned logos
  $dir{aligned_logos} = $main::outfile{prefix}."_aligned_logos";

  ################################################################
  ## Specify output file names and open output stream
  $main::outfile{log} = $main::outfile{prefix}."_log.txt"; push @outfiles, "log";
  $main::outfile{Rlog} = $main::outfile{prefix}."_Rlog.txt"; push @outfiles, "Rlog";
  $main::out = &OpenOutputFile($main::outfile{log});


  ## Pairwise comparisons between matrices
  $main::outfile{pairwise_compa} = $main::outfile{prefix}."_tables/pairwise_compa.tab"; push @outfiles, "pairwise_compa"; 
  $main::outfile{pairwise_compa_html} = $main::outfile{prefix}."_html/pairwise_compa.html";  push @outfiles, "pairwise_compa_html";

  ## Individual matrix descriptions
  $main::outfile{matrix_descriptions} = $main::outfile{prefix}."_tables/pairwise_compa_matrix_descriptions.tab"; push @outfiles, "matrix_descriptions"; &AddTabToConvert("matrix_descriptions");
  $main::outfile{matrix_descriptions_html} = $main::outfile{prefix}."_html/pairwise_compa_matrix_descriptions.html";  push @outfiles, "matrix_descriptions_html";

  ## List with the single matrix files paths
  ## Filled in the method create_single_matrix_files()
  $main::outfile{matrix_single_list} = "";

  ## Hexadecimal color for the clusters
  $main::outfile{hexa_colors} = $main::outfile{prefix}."_hexa_colors.txt";

  ## Simliarity network between matrices
  if ($main::return_field{network}) {
    $main::outfile{matrix_network_gml} = $main::outfile{prefix}."_matrix_network.gml"; push @outfiles, "matrix_network_gml";
    $main::outfile{matrix_network_png} = $main::outfile{prefix}."_matrix_network.png"; push @outfiles, "matrix_network_png";
  }
  ## MCL clustering (by segmentation of the matrix network)
  if ($main::return_field{mcl_clusters}) {
    $main::outfile{clusters_mcl} = $main::outfile{prefix}."_clusters.mcl"; push @outfiles, "clusters_mcl";
    $main::outfile{clusters_tab} = $main::outfile{prefix}."_clusters.tab"; push @outfiles, "clusters_tab"; &AddTabToConvert("clusters_tab");
    $main::outfile{clusters_subgraph} = $main::outfile{prefix}."_clusters_subgraph.tab"; push @outfiles, "clusters_subgraph";
    $main::outfile{clusters_subgraph_gml} = $main::outfile{prefix}."_clusters_subgraph.gml"; push @outfiles, "clusters_subgraph_gml";
    $main::outfile{clusters_subgraph_png} = $main::outfile{prefix}."_clusters_subgraph.png"; push @outfiles, "clusters_subgraph_png";
    $main::outfile{intra_cluster_degree} = $main::outfile{prefix}."_intra_clusters_degree.tab"; push @outfiles, "intra_cluster_degree";
  }

  ## Output files for the hierarchical clustering trees
  $main::outfile{distance_table} = $main::outfile{prefix}."_tables/distance_table.tab"; push @outfiles, "distance_table"; &AddTabToConvert("distance_table");
  $main::outfile{alignment_table} = $main::outfile{prefix}."_tables/alignment_table.tab"; push @outfiles, "alignment_table"; &AddTabToConvert("alignment_table");
  $main::outfile{internal_nodes_attributes_table} = $main::outfile{prefix}."_tables/internal_nodes_attributes.tab"; push @outfiles, "internal_nodes_attributes_table";

  $main::outfile{consensus_cladogram_json} = $main::outfile{prefix}."_trees/tree.json"; push @outfiles, "consensus_cladogram_json";
  $main::outfile{logo_cladogram_html} = $main::outfile{prefix}."_logo_tree.html"; push @outfiles, "logo_cladogram_html";
  $main::outfile{heatmap_jpg} = $main::outfile{prefix}."_figures/heatmap.jpg";
  $main::outfile{heatmap_pdf} = $main::outfile{prefix}."_figures/heatmap.pdf";


  ## Newick-formatted phylogram with motif consensuses
  if ($export_tree_format eq "newick"){
    $main::outfile{consensus_phylogram_newick} = $main::outfile{prefix}."_trees/tree.newick"; push @outfiles, "consensus_phylogram_newick";  
  }

  ## Clone input (only if the user selects this option)
  if($clone_input_flag == 1){
      &RSAT::util::CheckOutDir($main::outfile{prefix}."_data");
      $main::outfile{motif_file} = $main::outfile{prefix}."_data/input_motifs.tf";
  }

  ## Files required for the summary
  $main::outfile{summary_temp} = $main::outfile{prefix}."_SUMMARY_TEMP.html";
  $main::outfile{summary} = $main::outfile{prefix}."_SUMMARY.html"; push @outfiles, "summary";

  ## Some temporary files
  $main::outfile{temp} = $main::outfile{prefix}."_temporary.html";
  $main::outfile{int_align} = $main::outfile{prefix}."_tables/intermediate_alignments.tab";

  ## Archive to facilitate transfer of all the results
  $main::outfile{archive} = $main::outfile{prefix}."_archive.".$main::param{archive_format};
#  $main::outfile{archive} = &OutFileName("", ".".$main::param{archive_format}, "archive");
  &RSAT::message::Debug("Archive", $main::outfile{archive}) if ($main::verbose >= 0);
#  die ("HELLO");

  ## Open the HTML index file and write header
  $main::outfile{html_index} = $main::outfile{prefix}."_html/index.html";
  push @outfiles, "html_index";
  
}

##########################################
## Open the HTML page for the synthesis
sub OpenSynthesis {

  my $refresh_time;
  if ($main::param{progressive_synthesis}) {
    $refresh_time = 120;
  } else {
     $refresh_time = 0;
  }

  $main::html_index = &OpenOutputFile($main::outfile{html_index});
  my $header = &PrintHtmlResultHeader(program=>"matrix-clustering", refresh_time=>$refresh_time);
  #      &RSAT::message::Debug("header", $header) if ($main::verbose >= 10);
  print $main::html_index $header;
  
  ## Report command
  print $html_index "<p><tt><b>Command:</b> matrix-clustering ";
  &PrintArguments($main::html_index, 1);
  print $html_index "</tt></p>\n";

  ## Open the summary HTML file
  $syn = &OpenOutputFile($main::outfile{summary});
  $synthesis_path = `dirname $main::outfile{summary}`;
  chomp($synthesis_path);

  ## Add the JS libraries paths
  my $html_lib = '
   <script type="text/javascript" src="'.$d3_base.'"></script>
   <script type="text/javascript" src="'.$jquery_base.'"></script>
   <script type="text/javascript" src="'.$datatable_base.'"></script>
   <link rel="stylesheet" type="text/css" href="'.$datatable_css_base.'">
</head>
     ';
  
  ## Add the CSS style for matrix-clustering summary and 
  ## concatenate it to header the CSS sytles
  my $css_matrix_clustering = &ReportStyleCSS();
  $html_lib .= $css_matrix_clustering."\n";
  
  my $head = &PrintHtmlResultHeader(program=>"matrix-clustering", "title"=>$main::param{title});
  $head =~ s|</head>|$html_lib|;
  
  print $syn $head;

  &ReportCommand();
}


##########################################
sub CloseSynthesis {
    print $syn '<div><hr style="float:left;display:block;clear:both"></div>';
    print $syn '<div><hr style="float:left;display:block;clear:both"></div>';
    print $syn '<div><hr style="float:left;display:block;clear:both"></div>';
    print $syn "</body>\n";
    print $syn "</html>\n";
    close $syn;
}

################################################################
## Report the command before running the analysis, for the sake of
## debugging and to facilitate copy-paste of the options.
sub ReportCommand {
  print $syn &open_menu_heading($menu_nb++, "<a name='logs'></a><h3>Command</h3>", 1);
  print $syn "<pre>";
  print $syn "matrix-clustering ";
  &PrintArguments($syn);
  print $syn "</pre>";
  print $syn &close_menu_heading();
}

#################################################
## CSS style for the matrix-clustering summary 
## (dynamic tables + D3 trees)
sub ReportStyleCSS{
    my $CSS_mat_clus = '
<style>
  
  h3 a:hover {
	font-weight: bold;
	text-decoration: none;
  }
  
  .alignment_tab_head{
	background-color: #DCE4EC;
	float: left;
	margin-top: 1px;
	margin-bottom: 3px;
	height: 35px;
	position: relative;
	display: block;
	text-align: left;
	color: #34373B;
	font-size: 15px;
	padding: 6px;
	clear: both;
	border-radius:5px;  
  }
  
  
  .cluster_division {
	background-color: #97C0F9;
	float: left;
	margin: 5px 3px 3px 3px;
	width: 75px;
	height: 15px;
	position: relative;
	display: inline-block;
	text-align: center;
	color: #34373B;
	font-size: 12px;
	padding: 4px;
	cursor: pointer;
	border-radius:5px;
	border: 1px solid blue;
  }
  
  
  .button_click:active {
  position:relative;
  top:1px;
  }
  
  
  .tab{
    font-size: 15px;
    margin-top: 15px;
    margin-bottom: 20px;
    text-align: center;
    color: #000000;
    font-family: Arial;
    text-decoration: none;
    display: block;
    background-color: #E6E6E6;
    font-size: 10px;
    clear: both;
    float: left;
    position: relative;
    border-radius:5px;
    padding: 5px 12px 5px 12px;
  }
  
  
  .sep {
  background-color: #B1D4F9;
  height: 17px;
  }
  
  
  .tab_list{
  margin-top: 20px;
  text-align: left;
  color: #000000;
  font-family: Arial;
  text-decoration: none;
  display: none;
  float: left;
  background-color: #E6E6E6;
  font-size: 15px;
  clear: both;
  position: relative;
  border-radius:5px;
  padding: 5px 12px 5px 12px;
  }


  .tab_header {
  border-bottom: 1px solid black;
  width: 175px;
  padding: 7px;
  }

  .tab_col {
  padding: 7px 30px 7px 30px;
  background-color: #B1D4F9;
  }

  .seq {
  font-family: Monospace;
  font-size: 15px;
  }

  .Cluster_results {
  margin-top: 3px;
  width: 90px;
  heigth: 80px;
  border: 1px;
  position: relative;
  padding: 1px;
  font-size: 13px;
  margin-top: 20px;
  text-align: center;
  color: #ffffff;
  background:#cc0000;
  border-radius:5px;
  cursor: pointer;
  float: left;
  clear: both;
  display: none;
  }

  .Cluster_results:active {
  position:relative;
  top:1px;
  }

  #File_list {
  background-color: #DCE4EC;
  float: left;
  margin-top: 10px;
  width: 200px;
  height: 20px;
  position: relative;
  display: block;
  text-align: center;
  color: #34373B;
  font-size: 15px;
  padding: 4px;
  clear: both;
  border-radius:5px;
  cursor: pointer;
  }

  .file_link {
  cursor: pointer;
  text-decoration: none;
  }

  .file_link:hover {
  text-decoration: underline;
  }

  #hclust_tree_head {
  width: 900px;
  heigth: 400px;
  margin-top: 15px;
  margin-bottom: 5px;
  display: inline-block;
  position: relative;
  padding: 3px;
  background-color: #B1D4F9;
  float: left;
  border-radius:5px;
  font-size: 12px;
  clear: both;
  }

  .logo {
	position: relative;
	max-width: 100%;
	max-height: 13%;
	width: 120px;
	height: 65px;
	float: left;
	clear: both;
  }

  .logo_tab {
	position: relative;
	max-width: 100%;
	max-height: 10%;
	height: 45px;
	width: 60px
	float: left;
	clear: both;
  }

  .logo_tree {
  position: relative;
  float: left;
  display: none;
  clear: both;
  }

  .branch_motifs_head {
  width: 950px;
  heigth: 500px;
  margin-top: 15px;
  margin-bottom: 5px;
  display: none;
  position: relative;
  padding: 3px;
  background-color: #B1D4F9;
  float: left;
  border-radius:5px;
  font-size: 12px;
  clear: both;
  }

  .spacer {
  heigth: 200px;
  display: block;
  position: relative;
  clear: both;
  float: left;
  background-color: #B1D4F9;
  }


  .tab_spacer_1 {
  padding: 2px 12px 2px 12px;
  font-size: 12px;
  }


  .tab_spacer_2 {
    padding: 3px 2px 3px 2px;
    font-size: 12px;
  }

  #heatmap {
	heigth: 700px;
	width: 875px;
  }
  
  #show_forest {
	heigth: auto;
	width: 900px;
	position: relative;
	float: left;
	clear: both;
	border-radius:5px;
	border: 2px solid blue;
  }

  #display_clusters{
    background-color: #B1D4F9;
    text-align: center;
    padding-top: 3px 1px 1px 1px; 
  }

  .par_text {
    font-size: 12px;
    text-align: center;
  }

  .sep_clusters_div {
    clear: both;
    float: left;
    display: block;
    margin: 1px 5px 2px 5px;
  }

  .display{
	height: auto;
	width: 95%;
	border-radius: 5px;
	background-color: #FFFFFF; 
	margin: 10px;
        padding: 7px;
	text-align: left; 
	font-size: 17px;
	border: solid 3px #004F72; 
	clear: both;
	position: relative;
	float: left;
	display: block;
  }

  #individual_results{
	text-align:center; 
	padding: 1px 20px 20px 20px; 
	border: solid 3px #004F72; 
	width: auto;
	height: auto;
	border-radius: 10px; 
	background-color: #B1D4F9; 
        position: relative;
        clear: both;
    margin: 7px;
    display: block;
    float: left;
  } 
 
  .cluster_info_head {
	background-color: #DCE4EC;
	float: left;
	height: 45px;
	width: 630px;
	position: relative;
	display: block;
	text-align: left;
	color: #34373B;
	font-size: 15px;
	padding: 0px;
	border-radius:5px;
	clear: both;
        margin-top: 5px;
  }

  .hide_show_button{
	float: left;
	margin: 5px 3px 3px 3px;
	width: 75px;
	height: 15px;
	position: relative;
	display: inline-block;
	text-align: center;
	color: #34373B;
	font-size: 12px;
	padding: 4px;
	cursor: pointer;
	border-radius:5px;
  }

  #show_all_button{
     background-color: #76F076;
     border: 1px solid green;
  }

  #hide_all_button{
    background-color: #FCA0A0;
    border: 1px solid red;
  }

  .selected_cluster {
    background-color: #76F076;
    border: 1px solid green;
  }

  /****************/
  /* D3 CSS sytle */
  /****************/

  div {
  border-radius: 0.5px;
  }


  table {
  border: #2377D2;
  }


  .node circle {
  stroke-width: 0.5px;
  }


  .node {
  font: 10px sans-serif;
  }


  .link {
  fill: none;
  stroke-width: 1px;
  }

  svg {
  pointer-events: all;
  background-color: white;
  overflow: scroll;
  }

</style>
';

    return($CSS_mat_clus);
}


###########################################
## PArameters table of matrix-clustering.
## The values are filled with variables  
## taken from other parts of the code
sub ParametersTable{

  my $threshold_values_html = "";
  foreach my $par (sort keys %lth){
    $threshold_values_html .= "<strong>".$par."</strong> = ".$lth{$par}."<br>";
  } 

    my $par_table = '
  <!-- Div with the table of selected parameters-->
  <div class="tab">
    <table id="parameters_table">
      <thead>
	<tr>
	  <th colspan="5"><strong>Summary</strong></th>
	</tr>
	<tr>
	  <th class="tab_col">Input motifs</th>
	  <th class="tab_col">Nb Clusters</th>
	  <th class="tab_col">Clustering method</th>
	  <th class="tab_col">Parameters</th>
	  <th class="tab_col">Download</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td class="par_text">'.$number_of_motifs.'</td>
	  <td class="par_text">'.$number_of_clusters.'</td>
	  <td class="par_text"><a target=\'_blank\' href="http://www.econ.upf.edu/~michael/stanford/maeb7.pdf">'.$hclust_method.'</a></td>
	  <td class="par_text">'.$threshold_values_html.'</td>
	  <td class="par_text"><a href="'.$main::outfile{archive}.'">Download all results</a></td>
	</tr>
      </tbody>
    </table>
  </div>
'."\n\n";

  print $syn $par_table;
}


#######################################################################
## Read the alignment table and saves the data in a hash table
## Cluster_ID -> Motif_ID -> [name strand offset consensus logo_path]
sub ReadAlignmentTable {
    my @split_line = ();
    
    ## First read the alignment table and save the results in a hash
    my ($line, $id, $cluster_id);
    my ($cluster_handle) = &RSAT::util::OpenInputFile($outfile{alignment_table});
    
    while (<$cluster_handle>) {
	next if (/^#/); ## Skip header line
	next if (/^;/); ## Skip comment lines
	next unless (/\S/); ## Skip empty lines
	chomp;
	$line = $_;
	@split_line = split("\t", $line);
	$id = $split_line[0];
	$cluster_id = $split_line[2];
	$alignment_table_data{$cluster_id}{$id}{name} = $split_line[1];
	$alignment_table_data{$cluster_id}{$id}{collection} = $split_line[3];
	$alignment_table_data{$cluster_id}{$id}{strand} = $split_line[4];
	$alignment_table_data{$cluster_id}{$id}{offset_up} = $split_line[5];
	$alignment_table_data{$cluster_id}{$id}{offset_down} = $split_line[6];
	$alignment_table_data{$cluster_id}{$id}{width} = $split_line[7];
	$alignment_table_data{$cluster_id}{$id}{consensus} = $split_line[8];
	$alignment_table_data{$cluster_id}{$id}{consensus_rc} = $split_line[9];

	my $link_logo_d = $main::outfile{prefix}."_aligned_logos/".$id."_logo.png";
	my $link_logo_r = $main::outfile{prefix}."_aligned_logos/".$id."_logo_rc.png";
	$alignment_table_data{$cluster_id}{$id}{logo} = &RSAT::util::RelativePath($main::outfile{summary}, $link_logo_d);
	$alignment_table_data{$cluster_id}{$id}{logo_rc} = &RSAT::util::RelativePath($main::outfile{summary}, $link_logo_r);

	## Calculate the max nb of characters and the width of the alignment 
	## This numbers will be used to set the logos properly in the logo trees
	if(length($split_line[1]) >= $nb_char){
	    $nb_char = length($split_line[1]);
	    $alignment_size{$cluster_id}{nb_char} = $nb_char;
	} if($display_title_flag == 1){
	    if(length($main::param{title}) >= $nb_char){
		$nb_char = length($main::param{title});
	    }
	}

	$alignment_size{$cluster_id}{width} = $split_line[6];

	$number_of_motifs++;

	$ids_to_cluster{$id} = $cluster_id;
    }
    close $cluster_handle;

}


##############################################
## Insert the Alignment table in the summary 
## HTML file
sub InsertAlignmentTable{

    ## Alignment table skeleton (it is filled in the next lines)
    my $tab = '
  <!-- Div with the aligment table with all the motifs-->
	<div class="tab">
	  <table id="alignment_dyn_table">
		  
		   	<!--Div: search in alignment table-->
			<div class="alignment_tab_head">
				<strong>Click on the column names to change the order of the data.</strong><br>
				<strong>Write the name of one cluster, collection or a pattern in the <i>Search</i> window.<br>
				<p></p>
			</div>
	    <thead>
	      <tr>
		<th colspan="8"><strong>Alignment</strong></th>
	      </tr>
	      <tr>
		<th class="tab_col">Motif id</th>
		<th class="tab_col">Motif name</th>
		<th class="tab_col">Cluster</th>
		<th class="tab_col">Collection</th>
		<th class="tab_col">Aligned consensus</th>
		<th class="tab_col">Aligned consensus (Reversed)</th>
		<th class="tab_col">Aligned Logo (Forward)</th>
		<th class="tab_col">Aligned Logo (Reverse)</th>
	      </tr>
	    </thead>
	    <tbody>
	      --insert_col_here--
	    </tbody>
	  </table>
	</div>
';

    $alignment_table_columns = "";
    my $logo_width = 0;
    ## Fill the column's table 
    foreach my $id (keys %ids_to_cluster){

	$logo_width = 10*$alignment_table_data{$ids_to_cluster{$id}}{$id}{width};

	$alignment_table_columns .= '
				<tr>					
					<td class="tab_spacer_1">'.$id.'</td>
                                        <td class="tab_spacer_1">'.$alignment_table_data{$ids_to_cluster{$id}}{$id}{name}.'</td>
					<td class="tab_spacer_1">'.$ids_to_cluster{$id}.'</td>
                                        <td class="tab_spacer_1">'.$alignment_table_data{$ids_to_cluster{$id}}{$id}{collection}.'</td>
					<td class="seq tab_spacer_1">'.&RSAT::SeqUtil::ColorConsensus($alignment_table_data{$ids_to_cluster{$id}}{$id}{consensus}, bold=>1, iupac=>$main::param{iupac_coloring}).'</td>
					<td class="seq tab_spacer_1">'.&RSAT::SeqUtil::ColorConsensus($alignment_table_data{$ids_to_cluster{$id}}{$id}{consensus_rc}, bold=>1, iupac=>$main::param{iupac_coloring}).'</td>
                                        <th class="tab_spacer_2"><a target="_blank" href="'.$alignment_table_data{$ids_to_cluster{$id}}{$id}{logo}.'"><img class="logo_tab" width="--width--" src="'.$alignment_table_data{$ids_to_cluster{$id}}{$id}{logo}.'" /></a></th>
                                        <th class="tab_spacer_2"><a target="_blank" href="'.$alignment_table_data{$ids_to_cluster{$id}}{$id}{logo_rc}.'"><img class="logo_tab" width="--width--" src="'.$alignment_table_data{$ids_to_cluster{$id}}{$id}{logo_rc}.'" /></a></th>
				</tr>
        ';	
    }
    $tab =~ s/--width--/$logo_width/gi;
    $tab =~ s/--insert_col_here--/$alignment_table_columns/;

    ## Print the HTML to the summary file
    print $syn $tab;
}

#######################################################
## Insert the separation of the alignment table with
## the single-cluster buttons. This div contains the
## description of the Branch-motifs and logo trees
sub InsertInfoDiv{
    my $info = '
	<div id="hclust_tree_head">
	  <ul type="square">
	    <li>
	      <strong>Logo tree and alignment. </strong>This results shows the hierarchical tree with all the motifs of the corresponding cluster and the logo alignment in F (left logo) and R (rigth logo) orientation.
            </li>
            <li>
	      <strong>Branch-motifs. </strong>On the logo trees are displayed the branch number in which the motifs were grouped. The Branch-Motifs table shows the details of each consensus corresponding to each branch: the logo in both orientations and a file in TRANSFAC format corresponding to the branch-motif.
            </li>
          </ul>
	</div>
';

    ## Print the HTML to the summary file
    print $syn $info
}


########################################
## Insert the logo tree in small size
## this div is a link pointing to the 
## logo forest d3 file
sub InsertSmallForest {

    my $label_single_tree_no_link = '
	node.append("text")
	        .text(function(d) { return d.children ? "" :  d.name; })
		.attr("dx", function(d) { return d.children ? 0 : 20; })
		.attr("dy", function(d) { return d.children ? 0 : 3; })
		.attr("font-size", "8px")
		.attr("text-anchor", function(d) { return d.children ? "end" : "start"; });
    ';

    ## D3 values of the parameters of the small trees
    my $svg_width = 7;
    my $svg_height = 18;
    my $svg_x1 = 6 * $nb_char;
    my $svg_y1 = -7;
    my $svg_x2 = '6 + '.$svg_x1.' + 30';
    
    my $div = "";
    ## Open the <div> and the <a> where the small forest will be set
    my $small_forest = '<div id="show_forest"><a target="_blank" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{logo_cladogram_html}).'">'."\n";  
    my $small_tree = '' ;
    my $sum_motifs = 0;
    my $sum = 0;
    my $cluster_sum = 0;

    ## Insert link to the logo forest
    $small_forest .= '
    <div id="display_clusters"><h2>Click here to display all the clusters</h2></div><hr>
    ';

    foreach my $num (1..scalar(keys %alignment_table_data)){
	#foreach my $num (1..2){

	$cl_id_s = "cluster_".$num."_s";
	$cl_id = "cluster_".$num;
	
	my $cluster_size = scalar(keys %{$alignment_table_data{$cl_id}});
	my $sum = $sum_motifs + $cluster_size;
	if($sum < 20){
	    
	    ## Draw the logo forest 
	    $div .= '<div id="'.$cl_id_s.'"></div>';
	    
	    if($cluster_sum < 3){
		$div .= '<hr>'."\n";
	    }
	    
	    my $tree = &logo_tree();
	    $tree =~ s/--lab--/$label_single_tree_no_link/;
	    $tree =~ s/--widthtree--/800/g;
	    $tree =~ s/--radius--/3/g;
	    $tree =~ s/--size--/300/g;
	    $tree =~ s/--insert--//g;
	    $tree =~ s/--nb--/$num/g;
	    $tree =~ s/--height--/70 + 13 * $cluster_size/g;
	    $tree =~ s/--cl_id--/$cl_id_s/g;
	    $tree =~ s/--stroke--/$hexa_code{$cl_id}/g;
	    my $json_name = &RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{prefix}."_trees/parsed_tree_cluster_".$num.".json");
	    $tree =~ s/--jsonfile--/$json_name/g;
	    $tree =~ s/--svgwidth--/$svg_width/g;
	    $tree =~ s/--svgheight--/$svg_height/g;
	    $tree =~ s/--x1--/$svg_x1/g;
	    $tree =~ s/--y1--/$svg_y1/g;
	    $tree =~ s/--x2--/$svg_x2/g;
	    
	    $small_tree .= $tree."\n";
	    
	    $cluster_sum++;
	    $sum_motifs += $cluster_size;
	}
	
	if($cluster_sum == 4){
	    last; 
	}
    }

    ## Insert one <div> </div> + <script> </script> for each cluster depicted  
    $small_forest .= $div."\n".'<script type="text/javascript">'."\n".$small_tree."\n".'</script>'."\n";

    ## Close the <a> and <div>
    $small_forest .= '</a></div>';

    print $syn $small_forest
}


############################
## Insert Heatmap picture
sub InsertHeatMap {

    my $heat_map = ' 
	<div class="tab">
		<p><strong>Heatmap with consensus alignment</strong>  |  <a target="_blank" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{distance_table}).'">Distance table</a>  |  <a target="_blank" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{heatmap_pdf}).'">PDF</a></p>
		<img id="heatmap" src="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{heatmap_jpg}).'">
	</div>
    ';

    print $syn $heat_map;
}


#########################################
## Open the <scrip> tag for JQuery code
sub OpenScriptJQuery {
  $script_jquery = '<script>
// Dynamic parameter table
$(document).ready( function () {
    $(\'#parameters_table\').DataTable({
        "paging":   false,
        "searching": false,
        "ordering": false,
        "info":     false,
        "columnDefs": [
	    { "width": "15%", "targets": [0,1,2,3,4] }
	]		
    });
});

// Dynamic alignment table
$(document).ready( function () {
    $(\'#alignment_dyn_table\').DataTable({
        "info":     false,
        "iDisplayLength": --display--,
        "order": [[ 2, "asc" ]],
	"search": {
	    "regex": true,
	    "smart": true
	},
	"aoColumnDefs": [
            { "bSortable": true, "aTargets": [ 6,7 ] }
	],
        "columnDefs": [ {
            "targets": -1,
            "data": null,
            "width": "3%", "targets": [0,1,2,3,4,5,6,7]
        } ]	
    });
});

// Show all results button
$(document).ready(function(){
    $(\'#show_all_button\').click(function(){

       $(\'.branch_motifs\').show();
       $(\'.cons_tab\').show();
        $(\'.hide_show\').show();
        $(\'.cluster_division\').addClass(\'selected_cluster\');
    }); 
});

// Hide all results button
$(document).ready(function(){
    $(\'#hide_all_button\').click(function(){
        $(\'.hide_show\').hide();
        $(\'.cluster_division\').removeClass(\'selected_cluster\');
    }); 
});

// Change the color of buttons
$(document).ready(function() {
    
    ///////////////////
    // Hide/Show All
    $(\'#show_all_button\').mouseenter(function(){
        $(this).fadeTo(\'fast\',1); 
    });

    $(\'#show_all_button\').mouseleave(function(){
        $(this).fadeTo(\'fast\',0.5); 
    });

    $(\'#hide_all_button\').mouseenter(function(){
        $(this).fadeTo(\'fast\',1); 
    });

    $(\'#hide_all_button\').mouseleave(function(){
        $(this).fadeTo(\'fast\',0.5); 
    });

    /////////////////////
    // Cluster buttons
    $(\'.cluster_division\').mouseenter(function(){
        $(this).fadeTo(\'fast\',1); 
    });

    $(\'.cluster_division\').mouseleave(function(){
        $(this).fadeTo(\'fast\',0.5); 
    });

    /////////////////////////////
    // Additional files button
    $(\'#File_list\').mouseenter(function(){
        $(this).fadeTo(\'fast\',1); 
    });

    $(\'#File_list\').mouseleave(function(){
        $(this).fadeTo(\'fast\',0.5); 
    });

});

// Slide the alignment table
$(document).ready(function(){
    $(\'#File_list\').click(function(){
	$(\'.tab_list\').slideToggle(\'fast\');
    }); 
});
';
}


##########################
## Display single trees
sub InsertTreesAndBranchMotifs {

    my  $svg_width = 8.5;
    my  $svg_height = 35;
    my  $svg_x1 = 6.5 * $nb_char;
    my  $svg_y1 = -15;
    my  $svg_x2 = '7 + '.$svg_x1.' + 40';
    my $label_single_tree = '
	node.append("a")
	        .attr("xlink:href", function(d) { return d.url; })
	        .append("text")
	        .text(function(d) { return d.children ? "" :  d.name; })
		.attr("dx", function(d) { return d.children ? 0 : 20; })
		.attr("dy", function(d) { return d.children ? 0 : 3; })
		.attr("font-size", "8px")
		.attr("text-anchor", function(d) { return d.children ? "end" : "start"; });

		node.append("text")
		.text(function(d) { return d.children ? d.branch : ""; })
		.attr("dx", function(d) { return d.children ? -2 : 0; })
		.attr("dy", function(d) { return d.children ? -6 : 0; })
		.attr("fill", function(d) { return d.children ? "blue" : ""; })
		.attr("text-anchor", function(d) { return d.children ? "end" : "start"; });
    ';

    if($display_title_flag == 1){
	$label_single_tree .= '
        node.append("text")
	.text(function(d){ return d.children ? "" : "'.$main::param{title}.'"; })
	.attr("x", function(d){ return d.children ? 0 : 20; })
	.attr("dy", function(d){ return d.children ? 0 : 15; })
	.attr("font-size", "8px")
        .attr("fill", "blue")
	.attr("text-anchor", function(d){ return d.children ? "end" : "start"; })
        ';
    }


    ## The next procces is repeated for each cluster
    foreach my $num (1..scalar(keys %alignment_table_data)){
	
	## Insert the header of the cluster

	my $head_insert .= &cluster_delim();
	my $cl_id = "cluster_".$num;
	$head_insert =~ s/--Cluster_id--/$cl_id/g;
	$head_insert =~ s/--Cluster_id_head--/head_$cl_id/g;
	$head_insert =~ s/--nb--/$num/g;
	my $insert_div = "\n".$head_insert."\n\n";

	## Insert Id + Pointer
	my $insert_id = '
                .attr("cursor", function(d) { return d.children ? "pointer" : ""; })
                .attr("id", function(d) { return d.children ? d.id : ""; })

        ';
	
	## Make dynamics the buttons of the cluster header
	my %current_alignment_table_data =  %{$alignment_table_data{$cl_id}};
	my $buttons = &cluster_head_buttons(scalar(keys %current_alignment_table_data));
	my $motifs_nb = scalar(keys %current_alignment_table_data);
	$buttons =~ s/--Cluster_id--/$cl_id/g;
	$buttons =~ s/--Cluster_id_head--/head_$cl_id/g;
	$buttons =~ s/--nb--/$num/g;
	$script_jquery .= $buttons."\n";

	## Draw the logo tree
	my $d3_logo_tree .= '       
	              <!--Div containing D3 logo tree-->
                      <div id="cluster_--nb--" class="logo_tree hide_show">
                      <div id="hide_tree_--nb--" class="Cluster_results buttons_click" style="clear:both; position:relative; float:left" ><strong>cluster_--nb--</strong></div>
		      <script type="text/javascript">
                ';

	$d3_logo_tree .= &logo_tree();
	$d3_logo_tree =~ s/--lab--/$label_single_tree/;
	$d3_logo_tree =~ s/--cl_id--/$cl_id/;
	$d3_logo_tree =~ s/--widthtree--/1000/g;
	$d3_logo_tree =~ s/--nb--/$num/g;
	$d3_logo_tree =~ s/--insert--/$insert_id/g;
	$d3_logo_tree =~ s/--size--/400/g;
	$d3_logo_tree =~ s/--radius--/6/g;
	$d3_logo_tree =~ s/--height--/100 + 30 * $motifs_nb/g;
	$d3_logo_tree =~ s/--stroke--/$hexa_code{$cl_id}/g;
	my $jname = &RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{prefix}."_trees/parsed_tree_cluster_".$num.".json");
	$d3_logo_tree =~ s/--jsonfile--/$jname/g;
	$d3_logo_tree =~ s/--svgwidth--/$svg_width/g;
	$d3_logo_tree =~ s/--svgheight--/$svg_height/g;
	$d3_logo_tree =~ s/--x1--/$svg_x1/g;
	$d3_logo_tree =~ s/--y1--/$svg_y1/g;
	$d3_logo_tree =~ s/--x2--/$svg_x2/g;
	$d3_logo_tree .= '
                         </script>
	                 </div>
                 ';
        $all_d3_trees .= "\n".$d3_logo_tree."\n";

	my $hide_single_tree = &hide_tree();
	$hide_single_tree =~ s/--nb--/$num/g;

	my $hide_single_branch_table = &hide_branch_motifs();
	$hide_single_branch_table =~ s/--nb--/$num/g;

	$script_jquery .= $hide_single_tree."\n\n";
	$script_jquery .= $hide_single_branch_table."\n\n";
	
	## Draw the branch-consensus table
	if(scalar(keys %current_alignment_table_data) > 1){

	    $consensus_table = "";
	    $consensus_table = &branch_consensus_table();
	    my $consensus_table_columns = "";
	    foreach my $level (1..scalar(keys %current_alignment_table_data)-1){
		
		my ($cons, $logo_D, $logo_R, $transfac_file, $transfac_file_2);
		$logo_D = &RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{prefix}."_clusters_information/cluster_".$num."/merged_consensuses/merge_level_".$level."/merged_logo.png");
		$logo_R = &RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{prefix}."_clusters_information/cluster_".$num."/merged_consensuses/merge_level_".$level."/merged_logo_rc.png");
		$transfac_file = &RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{prefix}."_clusters_information/cluster_".$num."/merged_consensuses/merge_level_".$level."/merge_level_".$level."_matrices.tf");
		$transfac_file_2 = $main::outfile{prefix}."_clusters_information/cluster_".$num."/merged_consensuses/merge_level_".$level."/merge_level_".$level."_matrices.tf";
		$cons = `more $transfac_file_2 | grep DE`;
		$cons =~ s/DE\s+//gi;
		
		$consensus_table_columns .= "\n".'<tr id="cluster_'.$num.'_level_'.$level.'" class="branch_motifs">'."\n";
		$consensus_table_columns .= '   <th class="tab_spacer_2">Merge level '.$level.'</th>'."\n";
		$consensus_table_columns .= '   <th class="seq tab_spacer_1">'.&RSAT::SeqUtil::ColorConsensus($cons, bold=>1, iupac=>$main::param{iupac_coloring}).'</th>'."\n";
		$consensus_table_columns .= '   <th class="tab_spacer_2"><a target="_blank" href="'.$logo_D.'"><img class="logo" src="'.$logo_D.'" /></a></th>'."\n";
		$consensus_table_columns .= '   <th class="tab_spacer_2"><a target="_blank" href="'.$logo_R.'"><img class="logo" src="'.$logo_R.'" /></a></th>'."\n";
		$consensus_table_columns .= '   <th class="tab_spacer_2"><a target="_blank" href="'.$transfac_file.'">Branch motif (TRANSFAC format)</a></th>'."\n";
		$consensus_table_columns .= "</tr>\n";

		## Add the code to hide/show the branch-consensus table
		my $selection_branch = &Display_Selected_Branch();
		$selection_branch =~ s/--nb--/$num/g;
		$selection_branch =~ s/--level--/$level/g;
		$script_jquery .= $selection_branch."\n";
	    }
	    $consensus_table =~ s/--nb--/$num/g;
	    $consensus_table =~ s/--here--/$consensus_table_columns/g;
	    $all_consensus_table .= "\n".$consensus_table."\n";
	    
	    ## Add the code to hide/show the branch-consensus table
	    my $cons_tab = &toogle_branch_consensus_table();
	    $cons_tab =~ s/--nb--/$num/g;
	    $script_jquery .= $cons_tab."\n";
	}
	print $syn $insert_div;
    }

    $script_jquery .= "\n".'
    function showOneRow(id) {
       $(\'.branch_motifs\').css(\'display\', \'table-row\');
       $(\'.branch_motifs\').not(\'#\' + id).hide();
     };

    function showOneTable(id) {
       $(\'.cons_tab\').css(\'display\', \'table\');
       $(\'.cons_tab\').not(\'#\' + id).hide();
     };'."\n";
    $script_jquery .= "</script>\n";
}


###########################################
## Insert the JQuery script in the report
sub InsertJquery {
    print $syn $script_jquery;
}
  

################################################################
## Insert the code where the single trees and branch-motifs 
## will be displayed
sub DisplaySingleCluster{
    my $div_display = '
    <div class="sep_clusters_div" id="individual_results">
	<!--Div with the header of the buttons-->
	<div class="cluster_info_head">
          <ul type="square" style="margin:2px 0px 2px 5px; position:relative">
           <li><strong>Click on the upper buttons to display separately the information of each cluster.</strong></li>
           <li><strong>Click on the circles at each tree to display its corresponding merged motifs.</strong></li>
         </ul>
	 </div>
	<div class="display"><strong style="display:block">Display Logo Trees</strong>'."\n\n".$all_d3_trees.'</div> 
	<br>
	<div class="display"><strong style="display:block">Display Branch-Motifs</strong>'."\n\n".$all_consensus_table."\n\n".'</div>
    </div> 
    ';
    print $syn $div_display;
}

#######################################
## Insert the list of files exported
sub InsertListOfFiles {

      my $add_files = 
	  '

	<div id="File_list" class="button_click"><strong>List of files</strong></div>
	<div class="tab_list">
	  <table>
	    <thead>
	      <tr>
		<th colspan="2"><strong>Exported files</strong></th>
	      </tr>
	      <tr>
		<th class="tab_col">File</th>
		<th class="tab_col">Description</th>
	      </tr>
	    </thead>
	    <tbody>
		   <tr>
		      <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{distance_table}).'"><strong>Distance table</strong></a></td>
		      <td class="tab_spacer_2">This table shows the distances between the motifs based in the selected metric to measure the similarity.</td>
		   </tr>
		   <tr>
		      <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{logo_cladogram_html}).'"><strong>Logo Forest</strong></a></td>
		      <td class="tab_spacer_2">This file shows the forest with all the logo trees resulting after partition the original tree using the user-selected thresholds.</td>
		   </tr>
		   <tr>
		      <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{pairwise_compa}).'"><strong>Pairwise comparison</strong></a></td>
		      <td class="tab_spacer_2">This table shows the pairwise comparison between all the input motifs using different metrics. This is the <em>compare-matrices</em> result.</td>
		   </tr>
		   <tr>
		      <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{matrix_descriptions}).'"><strong>Matrix description</strong></a></td>
		      <td class="tab_spacer_2">This table shows information of each input motif.</td>
		   </tr>
                         ';

      if($number_of_motifs > 1){
	  $add_files .='
                   <tr>
                   <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{internal_nodes_attributes_table}).'"><strong>Internal nodes attributes</strong></a></td>
		      <td class="tab_spacer_2">This table shows the grouping steps of the hierarchical tree.</td>
		   </tr>
		   <tr>
		      <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{prefix}.'_figures/tree_of_consensus.pdf').'"><strong>Tree of consensus</strong></a></td>
		      <td class="tab_spacer_2">A PDF file showing the alignment of the consensus. Each cluster is represented with a different color.</td>
		   </tr>
                ';
      }

      ## If it is specified, add the heatmap
      if($draw_heatmap == 1 && $number_of_motifs > 1){
	$add_files .= 
	    '

		   <tr>
		      <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{heatmap_pdf}).'"><strong>Heatmap</strong></a></td>
		      <td class="tab_spacer_2">The heatmap showing the hierarchical tree with the clusters and the alignments.</td>
		   </tr>
                     ';
      }

      ## If it is specified, add the heatmap
      if($clone_input_flag == 1){
	$add_files .= 
	    '

		   <tr>
		      <td class="tab_spacer_2"><a target="_blank" class="file_link" href="'.&RSAT::util::RelativePath($main::outfile{summary}, $main::outfile{prefix}.'_data/input_motifs.tf').'"><strong>Input motifs</strong></a></td>
		      <td class="tab_spacer_2">The input motifs analyzed with matrix-clustering.</td>
		   </tr>
                     ';
      }

      $add_files .= '
	    </tbody>
	  </table>
	</div>
';

      print $syn $add_files;
}

################################################################
## Generate a HTML report with summarizing the main results with
## links to the iriginal result files.
sub Synthesis {

    &RSAT::message::TimeWarn("\n; Generating HTML summary") if ($main::verbose >= 2);

    &OpenSynthesis() unless ($main::param{progressive_synthesis});

    ## Initialize the variables
    %ids_to_cluster = ();
    %alignment_table_data = ();
    %alignment_size = ();
    $script_jquery = "";
    $all_d3_trees = "";
    $all_consensus_table = "";
    $number_of_motifs = 0;
    $nb_char = 0;

    $menu_nb = 200; ## Numbering of the IDs for collapsible elements

    &ReadAlignmentTable();
    $number_of_clusters = scalar(keys %alignment_table_data);      

    &create_html_tree_file();

    &OpenScriptJQuery();
    
    &ReportStyleCSS();

    &ParametersTable();

    &InsertSmallForest();

    &InsertAlignmentTable();

    &InsertInfoDiv();

    print $syn &hide_show_buttons."\n";
    print $syn '<div class="sep_clusters_div">'."\n";
    &InsertTreesAndBranchMotifs();
    print $syn "\n".'</div>';

    &DisplaySingleCluster();

    if($draw_heatmap == 1 && $number_of_motifs > 1){
	&InsertHeatMap();
    }

    &InsertListOfFiles();

    $script_jquery =~ s/--display--/$number_of_motifs/g;
    &InsertJquery();
    
    ## End of the HTML file
    &CloseSynthesis();

    
    ## Add the HTML synthesis report to the archive
    #&Archive(0, $main::outfile{synthesis}) if ($task{archive}); 
    
    &RSAT::message::TimeWarn("Report", $main::outfile{summary}) if ($main::verbose >= 2);
}
__END__
