################################################################
## cluster_motifs.R
##
## This script takes as input a matrix comparison file (that can be
## generated by compare-matrices), performs hierarchical
## clustering.
##
## It returns the resulting tree in json format, which can be loaded
## by the d3 library for display purposes.

## TO DO
## - Define an argument infile.consensus, providing a 3-columns file with the logo ID + its consensus in direct and reverse complementary strands. This consensus file should be exported by comapre-matrices.
## -> this consensus could e used to display trees in R, without requiring the

## Load required libraries
library("RJSONIO")
library("ctc")
library("reshape")
library("dendroextras")

## Redefine the main directory (this should be adapted to local configuration)
dir.main <- getwd()

dir.rsat <- Sys.getenv("RSAT")
if (dir.rsat == "") {
  stop("The environment variable RSAT is not defined.")
}

## Load some libraries
source(file.path(dir.rsat, 'R-scripts/config.R'))
source(file.path(dir.rsat, 'R-scripts/cluster_motifs_lib.R'))


## Options
plot.tree <- FALSE
export <- 'json'


################################################################
## Read arguments from the command line.
##
## Arguments passed on the command line will over-write the default
## arguments specified above.
args = commandArgs(trailingOnly=TRUE);
print("Parsing command-line arguments")
if (length(args >= 1)) {
  print(args)
  for(i in 1:length(args)){
    eval(parse(text=args[[i]]))
  }
}

## Check parameters
check.param()

##
lth <- as.numeric(lth)

##################################
## Read matrix comparison table
compare.matrices.table <- read.csv(infile, sep = "\t", comment.char = ";")
names(compare.matrices.table)[1] <- sub("^X.", "", names(compare.matrices.table)[1])


################################################################
## Read description table 
description.table <- read.csv(description.file, sep = "\t", comment.char = ";")
matrix.labels <-  as.vector(description.table$label)
names(matrix.labels) <- as.vector(description.table$id)

## Extract score values
score.values <- compare.matrices.table[,score] 
score.dist <- 1 - score.values

##############################################
## Extract the score from the matrix comparison table

## Check that the compare-matrices table contains the required score column
if (length(grep(pattern=score, names(compare.matrices.table))) < 1) {
  stop(paste(sep="", "Input file (", infile, ") does not contain the score column (", score, ")."))
}

## Extract score values
score.values <- compare.matrices.table[,score]

################################################################
## Convert user-selected score to distance metrics
convert.scores(score.values, score)


## Add a column with score column to the compare matrices table, will
## be used to generate a cross-table
compare.matrices.table$score.dist <- score.dist

################################################################
## Build a distance matrix from the distance score list
dist.table <- t(xtabs(score.dist ~ name1+name2, compare.matrices.table) )
## Ensure that symmetrical distances are defined
for (i in 1:nrow(dist.table)) {
  for (j in i:ncol(dist.table)) {
    if (i==j) {next}
    dist.max <- max(dist.table[i,j], dist.table[j,i])
    dist.table[i,j] <- dist.max
    dist.table[j,i] <- dist.max
  }
}
#print(dist.table)
write.table(dist.table, file = distance.table, quote = FALSE, row.names = TRUE, col.names=NA, sep = "\t")

## Convert distance table into a distance matrix, required by hclust()
dist.matrix <- as.dist(dist.table)

################
### Inefficient (but probably more robust) way to build a distance matrix, involving two loops
## matrix.names <- sort(unique(as.vector(as.matrix((compare.matrices.table[,c(1,2)])))))
## matrix.nb <- length(matrix.names)
## dist.matrix <- data.frame(matrix(NA, nrow=matrix.nb, ncol=matrix.nb))
## names(dist.matrix) <- matrix.names
## rownames(dist.matrix) <- matrix.names
## for (i in 1:matrix.nb) {
##   for (j in i:matrix.nb) {
##     ## Identify the relevant rows in matrix comparison table
##     matrix.id1 <- matrix.names[i]
##     matrix.id2 <- matrix.names[j]
##     matches <- ((compare.matrices.table[,1] == matrix.id1 & compare.matrices.table[,2] == matrix.id2) |
##                 (compare.matrices.table[,1] == matrix.id2 & compare.matrices.table[,2] == matrix.id1))
##     if (sum(matches) >= 1) {
##       current.score <- compare.matrices.table[which(matches),score]
##     } else {
##       current.score <- "NA"
##     }    
##     dist.matrix[i,j] <- current.score
##     dist.matrix[j,i] <- current.score
##   }
## }


##############################################
### Build the tree by hierarchical clustering, and export it in Newick format
tree <- hclust(dist.matrix, method = hclust.method)
tree$labels <- as.vector(description.table$label)
if (plot.tree) {
  plot(tree) 
}
if (export == "newick") {
  newick.file <- paste(sep='.', out.prefix, "newick")
  verbose(paste("Exporing newick file", newick.file), 1)
  write(hc2Newick(tree, flat = TRUE), file=newick.file)
}

#######################################
### Creates and parse the json file
halfway.tree <- hclustToTree(tree)
jsonTree <- toJSON(halfway.tree)
## Fix some little technical issues for JSON compatibility with the tree display javascript
jsonTree <- gsub("\\],", "\\]", jsonTree, perl = TRUE)
jsonTree <- paste("{\n\"name\": \"\",\n\"children\":", jsonTree, "}", sep = "")
jsonTree <- gsub("\n\"order\":\\s+\\d+", "", jsonTree, perl = TRUE)
#jsonTree <- gsub(",\\s*\n\\s*}", "\n}", jsonTree, perl = TRUE)


#############################
### Prints the .json file 
json.file <- paste(out.prefix, ".json", sep="")
verbose(paste("JSON tree file", json.file), 1)
writeLines(jsonTree, con=json.file)


###########################
### Traversing the tree ###
###########################

#tree$labels <- as.vector(description.table$consensus)
tree$labels <- paste(as.vector(description.table$consensus), 1:length(description.table$consensus))

#############################################################
## Bottom-up traversal of the tree to orientate the logos
merge.level <- 1
motifs.info <- list()

merge.levels.leaves <- leaves.per.node(tree)
for (merge.level in 1:nrow(tree$merge)) {

  child1 <- tree$merge[merge.level,1]
  child2 <- tree$merge[merge.level,2]

  ########################################
  ## Case 1: merging between two leaves ##
  ########################################
   if ((child1 < 0) && (child2 < 0)) {
     alignment <- align.two.leaves(child1, child2, motifs.info, tree, lth)
     motifs.info <- alignment$info
     tree <- alignment$tree
   }


  ############################################
  ## Case 2: merging a motif with a cluster ##
  ############################################
  if(((child1 < 0) && (child2 > 0)) || ((child1 > 0) && (child2 < 0))){
    alignment <- align.leave.and.cluster(child1, child2, motifs.info, tree, lth)
    motifs.info <- alignment$info
    tree <- alignment$tree
  }


  ##########################################
  ## Case 3: merging between two clusters ##
  ##########################################
  if ((child1 > 0) && (child2 > 0)) {
    alignment <- align.clusters(child1, child2, motifs.info, tree, lth)
    motifs.info <- alignment$info
    tree <- alignment$tree
  }
}

## Fill the downstream end 
motifs.info <- fill.downstream(motifs.info)

## Reset the labels
for(nb in 1:length(tree$labels)){
  tree$labels[nb] <- paste(motifs.info[[get.id(nb)]][["consensus"]], nb, sep = " ")
}

## Get the aligment width, to calculate the limits of the plot
alignment.width <- nchar(motifs.info[[1]][["consensus"]])
mar4 <- alignment.width + 5 - 10

## Export the tree with the aligment
plot.format <- "pdf" ## Default for testing inside the loop
for (plot.format in c("pdf", "png")) {
  w.inches <- 10 ## width in inches
  h.inches <- 7 ## height in inches
  resol <- 72 ## Screen resolution
  tree.drawing.file <- paste(sep="", out.prefix, "_hclust_tree.", plot.format)
  verbose(paste("Exporting hclust tree drawing", tree.drawing.file), 1)
  if (plot.format == "pdf") {
    pdf(file=tree.drawing.file, width=w.inches, height=h.inches)
  } else if (plot.format == "png") {
    png(filename=tree.drawing.file, width=w.inches*resol, height=h.inches*resol)
  }
 #dev.new(width=10, height=7)
  par(mar=c(3,2,1,mar4),family="mono")
  plot(as.dendrogram(tree), horiz=TRUE)
  dev.off()
}

## Produce the aligment table
alignment.table <- lapply(motifs.info, function(X){
  return(c(X[["number"]], X[["strand"]], X[["spacer"]], X[["offset_down"]], X[["alignment_status"]], X[["consensus"]]))
})
alignment.table <- as.data.frame(t(data.frame(alignment.table)))
alignment.table$id <- as.vector(rownames(alignment.table))

## Get the final length of the motifs
final.width <- as.vector(sapply(motifs.info, function(X){
  nchar(X[["consensus"]])
}))
alignment.table$width <- final.width

##  Re-order the table and export it
alignment.table <- alignment.table[,c(7, 1:4, 8, 5, 6)]
colnames(alignment.table) <- c("#id", "number", "strand", "offset_up", "offset_down", "width", "alignment_status", "aligned_consensus")
alignment.file <- paste(sep="", out.prefix, "_alignment_table.tab")
write.table(alignment.table, alignment.file, sep = "\t", quote = FALSE, row.names = FALSE)
