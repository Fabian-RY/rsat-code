<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="RSATWS.xsl"?>
<definitions name="RSATWS"
  targetNamespace="urn:RSATWS"
          xmlns:tns="urn:RSATWS"
          xmlns:xsd="http://www.w3.org/2001/XMLSchema"
          xmlns="http://schemas.xmlsoap.org/wsdl/"
	  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
	  xmlns:html="http://www.w3.org/1999/xhtml"
	  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <types>
    <xsd:schema targetNamespace="urn:RSATWS" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<!-- RSAT CLASSICAL TOOLS REQUESTS -->
      <xsd:complexType name="RetrieveSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation retrieve_seq.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A list of query genes.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Return sequences for all the genes of the organism if value = 1. Incompatible with query.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="noorf" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream open reading frames (ORF) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Inferior limit of the region to retrieve. Default is organism dependant (example: Saccharomyces cerevisiae = -800).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Superior limit of the region to retrieve. Default is '-1'.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of genome features to load. Supported: CDS, mRNA, tRNA, rRNA. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Sequence type. Supported: upstream, downstream, ORF (unspliced open reading frame).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, FastA</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="lw" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Line width (0 for whole sequence on one line).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Field(s) to be used in the sequence label. Multiple fields can be specified, separated by commas. 
Supported: id, name, organism_name, sequence_type, current_from, current_to, ctg, orf_strand, reg_left, reg_right. 
Default: name.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label_sep" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Separator between the label fields. Default: | (pipe character).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="nocom" type="xsd:int" minOccurs="0">
           <xsd:annotation>
              <xsd:documentation>No comments if value = 1. Only the identifier and the sequence are returned. 
By default, the comment indicates the ORF and upstream sequence coordinates.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="repeat" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the repeat masked version of the genome if value = 1. Attention: repeated regions are annotated for some genomes only.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="imp_pos" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Admit imprecise positions if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveEnsemblSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation retrieve_ensembl_seq.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="ensembl_host" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Address of ensembl database server (default is EBI server).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="db_name" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Name of EnsEMBL database (alternative to organism).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A list of query genes.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Return sequences for all the genes of the organism if value = 1. Incompatible with query.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="noorf" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream open reading frames (ORF) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="nogene" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream gene (extreme transcripts limits) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Inferior limit of the region to retrieve. Default is organism dependant (example: Saccharomyces cerevisiae = -800).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Superior limit of the region to retrieve. Default is '-1'.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of genome features to load. Supported: CDS, mRNA, tRNA, rRNA. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Sequence type. Supported: upstream, downstream, ORF (unspliced open reading frame).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="chromosome" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Chromosome name or number (to use with -left and -right).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="left" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Left limit of sequence to retrieve.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="right" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Right limit of sequence to retrieve.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="strand" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Strand of sequence to retrieve when using -left and -right. Values: 1, -1</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="features" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Features.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feat_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Features format. Supported: ft, gft</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mask_coding" type="xsd:int" minOccurs="0">
           <xsd:annotation>
              <xsd:documentation>All coding sequence is replaced by N in the retrieved sequence if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="repeat" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the repeat masked version of the genome if value = 1. Attention: repeated regions are annotated for some genomes only.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all_transcripts" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Get sequences for all transcript of genes. Use purge-sequence if you do pattern discovery afterwards if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="first_intron" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>With feattype intron, get only first intron sequence if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="non_coding" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>With feattype exon, get only non-coding (part of) exons if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PurgeSequenceRequest">
       <xsd:sequence>
        <xsd:element name="output" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or 'both'. 
Default is 'both'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="sequence" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Sequence to purge. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation> Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="format" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, FastA.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="match_length" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Minimal match length. Default is 40.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="mismatch" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Number of mismatches allowed. Default is 3.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="str" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Discard duplications on the direct strand only (1) or on the reverse complement as well (2). Default is 2.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="delete" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Delete repeats instead of masking them if value = 1.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="mask_short" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Mask (replace by N characters) sequences shorter than the specified length.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="OligoAnalysisRequest">
       	<xsd:sequence>
        <xsd:element name="output" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Verbosity.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="sequence" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="format" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="length" type="xsd:int" minOccurs="1">
	  <xsd:annotation>
	    <xsd:documentation>Oligomer length.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="organism" type="xsd:string" minOccurs="1">
	  <xsd:annotation>
	    <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="background" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Background model: Type of sequences used as background model for estimating expected oligonucleotide frequencies. 
Supported: upstream, upstreamL, upstream-noorf, intergenic, input.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="stats" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>List of statistics to return. Supported:occ, mseq, freq, proba, ratio, zscore, like, pos, rank.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="noov" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>No overlapping of oligos allowed if value = 1. Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="str" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="sort" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Sort oligomers according to overrepresentation if value = 1.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="lth" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Lower threshold on some parameter. Format='param value'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="pseudo" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Pseudo-weight. Must be a real value between 0 and 1.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DyadAnalysisRequest">
       	<xsd:sequence>
        <xsd:element name="output" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="sequence" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Name of the file with input sequence on the server. 
You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="format" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="length" type="xsd:int" minOccurs="1">
	  <xsd:annotation>
	    <xsd:documentation>Dyad length.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="spacing" type="xsd:string" minOccurs="1">
	  <xsd:annotation>
	    <xsd:documentation>Spacing between elements of the dyads.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="organism" type="xsd:string" minOccurs="1">
	  <xsd:annotation>
	    <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="background" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Background model: Type of sequences used as background model for estimating expected oligonucleotide frequencies. 
Supported: upstream, upstreamL, upstream-noorf, intergenic, input.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="stats" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>List of statistics to return. Supported: occ, mseq, freq, proba, ratio, zscore, like, pos, rank.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="type" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>dyad_type (dr | ir | rep | any) 
In order to fasten execution, the program can be asked to restrict its analysis to symmetric dyads. 
Four types are accepted: 
	dr - direct repeats: the second element is the same as the first one; 
	ir - inverted repeats: the second element is the revers complement of the first one; 
	rep - repeats: direct and inverted repeats are evaluated. 
	any - (default) 
When selecting the option any, the analysis is performed on all non-symmetric dyads as well.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="noov" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>No overlapping of dyads allowed if value = 1. 
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="str" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Dyad occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="sort" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Sort dyads according to overrepresentation if value = 1.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="under" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Detect under-represented instead of over-represented dyads (left tail significance test) if value = 1.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="two_tails" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Detect under-represented and over-represented dyads (two-fail significance test) if value = 1.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="zeroocc" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Report also dyads with zero occurrences (provided they fit the other thresholds) if value = 1. 
By default, the program reports only patterns present in the sequence. 
If the left tail or two-tail test is applied, patterns with zero occurrences are automatically taken into account. 
In some other cases, one would also like to detect patterns absent from the sequence. 
This is the function of the option -zeroocc.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="lth" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Lower threshold on some parameter. Format='param value'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="uth" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Upper threshold on some parameter. Format='param value'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PatternAssemblyRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
		Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="score_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Score column. Column of the input file that contains the scores. if not specified, patterns are incorporated according to their order in the input file. However, if the input file has been generated with oligo-analysis or dyad-analysis with a verbosity >= 1, pattern-assembly detects the occ_sig column in the file header and uses this column as score column.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Strands for the assembly: 1 for single-strand; 2 for two-strand assembly. Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="maxfl" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum flanking segment size. Default is 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="subst" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum allowed substitutions. Default is 0.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="maxcl" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum assembly size, i.e. number of patterns per assembly. Default is 50.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="maxpat" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of allowed patterns. If the number of patterns exceeds this value, the program issues a fatal error. Default: no limit.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="toppat" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of patterns to analyze. If the number of patterns exceeds this value, the program selects a subset of them, , starting from the top of the. Default: 100.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DnaPatternRequest">
       	<xsd:sequence>
        <xsd:element name="output" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="sequence" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="format" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="subst" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Number of substitutions allowed.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="pattern" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Pattern to match. Use this option or the 'pattern_file' option</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="pattern_file" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>File with patterns to match. Use this option or the 'pattern' option</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="tmp_pattern_file" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>File located on the server with patterns to match (workflow usage).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="id" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Pattern identifier.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="origin" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Origin for the calculation of positions (0 for end of sequence).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="noov" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>No overlapping of oligos allowed if value = 1. Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="score" type="xsd:int" minOccurs="0">
	<xsd:annotation>
	<xsd:documentation>Score column. Column of the pattern file which contains the score</xsd:documentation>
	</xsd:annotation>
	</xsd:element>
	<xsd:element name="str" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="sort" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Sort oligomers according to overrepresentation if value = 1.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="th" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Threshold on match count.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	 <xsd:element name="return" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>List of fields to return. Multiple fields can be entered separated by commas.
Supported fields: colsum,counts,ct,limits,profiles,rank,rowsum,scores,sites,stats,table,total.
  -return sites:   return match positions (default)
  -return limits: return start and end positions for each input sequence
  -return counts: return the count of matches per sequence.  
  -return rank: return the rank of the sequence (this is especially useful in combination with the option -sort).
  -return score: return a score per sequence, computed by summing the scores of the matching patterns.
  -return ct:    same as '-return counts', except that it returns the sum of matches in all the files of the sequence file list, instead of the count within each separate file.
  -return table: return the count of pattern matches per sequence in the form of a table.  (one line per sequence, one column per pattern)
  -return colsum (together with -return table) prints an extra column with the total occurrences per sequence
  -return rowsum (together with -return table) prints an extra row with total occurrences per pattern
  -return total (together with -return table) prints an extra column with the total occurrences per sequence and an extra row with total occurrences per pattern.  (amounts to combine -colsum and -rowsum)
  -return stats return matching statistics
  -return profiles return matching profiles with sliding windows.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertFeaturesRequest">
       <xsd:sequence>
	<xsd:element name="output" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
        <xsd:element name="input" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Input data</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Input file on the server (workflow usage)</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="from" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Input format. Supported: dnapat,ft,gft,gff3,gff.</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="to" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Output format. Supported: dnapat,ft,gft,gff3,gff.</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FeatureMapRequest">
       	<xsd:sequence>
          <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
		Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="features" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>a list of features (ORFs, regulatory sites). Each feature is represented by a single line, which should	provide the following information:
		Input file columns:
		1. map label (eg gene name)
		2. feature type
		3. feature identifier (ex: GATAbox, Abf1_site)
		4. strand (D for Direct, R for Reverse),
		5. feature start position
		6. feature end position
		7. (optional) description 
		8. (optional) score
		The standard input format assumes that these topics are provided in this order, separated by tabs. Start and end positions can be positive or negative.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (features).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output image format. Supported: png,jpg,ps,gif (default = jpg)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Lower limit of the positions represented on the graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Upper limit of the positions represented on the graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="title" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Generic Title for the feature map.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="label" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Define the info to display for each feature. Valid keys are: id, strand, descr (feature descritption), pos (feature start and end positions).
		Several keys can be entered separated by commas without space. ex: -label pos,id. (default = id).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="symbol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Associates a graphical symbol (i.e. rectangle, circle, buterfly, ...) to each feature. This is convenient to distinguish the features on black and white printings.
		Mutually exclusive with the -dot option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="dot" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A color dot is associated to each feature. This allows to distinguish overlapping structures on a color screen. Mutually exclusive with the -symbol option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mlen" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>map length (in pixels).Default is 600.Length refers to either height (for vertical maps) of width (for horizontal maps).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="mapthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Map thickness.Thickness refers to either width (for vertical maps) or height (horizintal maps). This parameter allows to change the thickness allocated to each map. This is useful when labels are too large. Default is 150.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mspacing" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Map spacing.The size of the border between maps (in pixel).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="origin" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>All coordinates are recalculated relative to this origin.This allows to display all coordinates with respect to the ORF start or transcription start site.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="legend" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Draws a legend on the graph, showing the symbol associated to each distinct feature.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scalebar" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Draws a scale bar on the left of the graph.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scalestep" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Step between annotations of the scale bar. If not specified, a reasonable step is calculated on basis of the scale bar range.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scorethick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Each feature is displayed with a thickness proportional to its score. Only positive scores are represented.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="maxscore" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>(only valid when -scorethick is active) Maximal allowed score value. Higher score values are clipped for the drawing.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="minscore" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>(only valid when -scorethick is active) Minimal allowed score value. Features with smaller score are not displayed.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="maxfthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Max feature thickness</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="minfthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Min feature thickness</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="htmap" type="xsd:int" minOccurs="0">
            <xsd:annotation>
	      <xsd:documentation>HTML map.An HTML document is automatically generated, which includes the feature map GIF file as an HTML map.
		In other words,this document displays a figure with sensitive areas. Each time the mouse is positioned above a feature, information about this particuliar feature is displayed at the bottom of the browser window.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mono" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Monochrome palette (for printing on black/white printer).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="orientation" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Orientation of the map. Valid values are "horiz" for an horizontal map (default) and "vertic" for a vertical map.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="select" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Only display the features whose ID is in the provided id_list.
		The id_list contains one or several IDs, separated by commas.IDs may be embraced in single quotes to allow multiple words within the IDs. Commas and single quotes are not allowed within an ID.
		Example:-select 'gataag','gattag' only displays features identified by gataag or gattag.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="tmp_sequence_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Reference sequence file on the server (workflow usage)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="sequence_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Format of reference sequence file on the server (workflow usage)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GeneInfoRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
		Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>List of gene(s) for which you want info on or list of keywords to search for (can be regular expressions).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="full" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Full match only (no substring matching) if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noquery" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Do not print the query at the begining of each line if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="descr" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Match query against the description, too, not just against gene ID and name if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Feature type (CDS, mRNA, tRNA, rRNA, scRNA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ClassFreqRequest">
	      <xsd:sequence>
		      <xsd:element name="inputFile" type="xsd:string" minOccurs="1">
			      <xsd:annotation>
				      <xsd:documentation>Input file</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="classinterval" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>class interval. If not specified, takes the value (max - min)/20</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="col" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>column to which apply the program. This option can be used iteratively.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="min" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>numbers strictly smaller than this value are not taken into account</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="max" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>numbers strictly higher than this value are not taken into account</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="from" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>inferior limit for the classes to display
					      values lower than this limit are however taken into account
					      in the calculation of statistics (avg, variance, ...) and of
                				class frequencies (In contrast with the -min option).
				      </xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="to" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>superior limit for the classes to display
					      values higher than this limit are however taken into account
					      in the calculation of statistics (avg, variance, ...) and of
					      class frequencies (In contrast with the -min option).
				      </xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
	      </xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="XYGraphRequest">
	      <xsd:sequence>
		      <xsd:element name="inputFile" type="xsd:string" minOccurs="1">
			      <xsd:annotation>
				      <xsd:documentation>The input file should contain columns with numeric data. Each line contains info about one point of the graph. By  default, the first column is considered to contain X data, and the second column Y data. X and Y columns can be changed with -xcol and -ycol options. Columns should be separated by tabs.
                              		</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="format" type="xsd:string" minOccurs="1">
			      <xsd:annotation>
				      <xsd:documentation>Supported : png,pdf,jpg,eps,gif</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="title1" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>first graph title</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="title2" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>second graph title</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="lines" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>points are jointed by lines</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="legend" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>
					      use the content of the first line from input file as
                        		      legend for Y data.
				      </xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="header" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>
					      first line of the data file contains a column header
                        		      if option -legend is active, this header is used as
                        		      legend, else it is ignored.
					</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="xleg1" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>first x legend</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="xleg2" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>second x legend</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="yleg1" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>first y legend</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="yleg2" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>second y legend</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="xmax" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>maximal value represented on X axis.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="ymax" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>maximal value represented on Y axis.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="xmin" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>minimal value represented on X axis.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="ymin" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>minimal value represented on Y axis.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="ylog" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>Y data are displayed on a logarithmic scale
					      If the next argument is a number, it provides the
                        		     log base. Default log base is 10.
				      </xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="xlog" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>X data are displayed on a logarithmic scale
					      		 If the next argument is a number, it provides the
                			                 log base. Default log base is 10.
				      </xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="xcol" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>column containing data for the X axis.
					      A zero value indicates that there is no column with X va
					      lues.
                        In this case, X values are ordinal.
				      </xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="ycol" type="xsd:string" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>column containing data for the Y axis.
					      Several columns can be specified by:
					      -ycol #,#,#
					      A range of columns can be specified by:
					      -ycol #-#
                        They have to be separated by commas without spaces.
				      </xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
	      </xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="TextToHtmlRequest">
       <xsd:sequence>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The text input file that will be converted in html</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="chunk" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Chunk size (when there are many rows, the program splits the table into several HTML tables, to reduce the waiting time on the browser.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="font" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Use fixed or variable fonts in html. Supported : variable,fixed</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="SupportedOrganismsRequest">
       <xsd:sequence>
	<xsd:element name="output" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
        <xsd:element name="format" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Output format. Supported: html_list, html_table, array, text, keys, names, sizes, full, tree, html_tree.</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="taxon" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Root taxon.</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>
      
      
      <xsd:complexType name="ConvertSeqRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert_seq.</xsd:documentation>
        </xsd:annotation>
       <xsd:sequence>
	<xsd:element name="output" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
        <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Sequence to convert.</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
        <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="from" type="xsd:string" minOccurs="1">
	 <xsd:annotation>
	  <xsd:documentation>Format of input sequence (embl, fasta, filelist, gcg, genbank, ig, maf, multi, ncbi, raw, tab, wc, wconsensus).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="to" type="xsd:string" minOccurs="1">
	 <xsd:annotation>
	  <xsd:documentation>Format of output sequence (fasta, filelist, ft, ig, multi, raw, tab, wc, wconsensus).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareClassesRequest">
       <xsd:annotation>
	<xsd:documentation>Parameters for the operation compare_classes.</xsd:documentation>
       </xsd:annotation>
       <xsd:sequence>
	<xsd:element name="output" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="ref_classes" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
         <xsd:annotation>
          <xsd:documentation>A tab-delimited text file containing the description of reference classes</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
	<xsd:element name="query_classes" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>A tab-delimited text file containing the description of query classes</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
	<xsd:element name="return_fields" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>List of fields to return separated by a comma. Supported: dotprod, entropy, freq, jac_sim, members, occ, proba, rank</xsd:documentation>
         </xsd:annotation>
        </xsd:element> 
        <xsd:element name="score_column" type="xsd:int" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Specify a column of the input file containing a score associated to each member</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="input_classes" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>This file will be used as both reference and query.This is equivalent to -q input_file -r input_file.</xsd:documentation>
         </xsd:annotation>
        </xsd:element> 
        <xsd:element name="upper_threshold_field" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Supported fields: E(QR), E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), 
I(Q,R), IC, P(QR), P(Q|R), P(R|Q), P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, jac_sim, rank, sigE(QR),E_val,F(!Q!R),F(Q!R),F(Q),F(QR),F(R!Q),F(R),H(Q),H
(Q,R),H(Q|R),H(R),H(R|Q),I(Q,R),IC,P(QR),P(Q|R),P(R|Q),P_val,Q,QR,QvR,R,U(Q|R),U
(R|Q),dH(Q,R),dotprod,dp_bits,jac_sim,log2_dp,names,prodrts,sig,sqrt_dp. semicolumn (":") as there are fields containing commas.</xsd:documentation>
         </xsd:annotation>
        </xsd:element> 
        <xsd:element name="upper_threshold_value" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Upper threshold value for a supported field. There must be as many thresholds values as thresholds fields in the same order as the list of threshold fields were given. </xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="lower_threshold_field" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Supported fields: same fields as upper_threshold_field.</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="lower_threshold_value" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Lower threshold value for a given field.</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="sort" type="xsd:string" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>Sort on the basis of the specified key.</xsd:documentation>
          </xsd:annotation>
        </xsd:element> 
        <xsd:element name="distinct" type="xsd:int" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>Prevent to compare each class with itself (when the reference and query files contain the same classes)</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
	<xsd:element name="triangle" type="xsd:int" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>(only valid if query file and reference file are the same) Do not perform the reciprocal comparisons.</xsd:documentation>
          </xsd:annotation>
        </xsd:element>  
	<xsd:element name="matrix" type="xsd:string" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>Return a pairwise matrix, where each row corresponds to a reference class, each column to a query class, and each cell contains a comparison between the two classes. 
The next argument indicates which statistics has to be return in the matrix (default = sig) 
Supported: E(QR), E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), I(Q,R), IC, P(QR), P(Q|R), P(R|Q),
P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, jac_sim, rank, sig</xsd:documentation>
          </xsd:annotation>
        </xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      
   <xsd:complexType name="ConvertClassesRequest">
       <xsd:annotation>
	<xsd:documentation>Parameters for the operation convert-classes.</xsd:documentation>
       </xsd:annotation>
       <xsd:sequence>
	<xsd:element name="informat" type="xsd:string" minOccurs="1">
	 <xsd:annotation>
	  <xsd:documentation>Input format : supported tab, profiles, mcl</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="outformat" type="xsd:string" minOccurs="1">
	 <xsd:annotation>
	  <xsd:documentation>Output format : supported tab, profiles, mcl</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="member_col" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Member column. Column containing the member names in the tab format (default 1).</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
	<xsd:element name="class_col" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Class column. Column containing the class names in the tab format  (default 2).</xsd:documentation>
         </xsd:annotation>
        </xsd:element> 
        <xsd:element name="score_col" type="xsd:int" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Score column. Column containing the score in the tab format : if not specified, scores are not defined..</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="min_score" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Minimal score value for member to class assignation.</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="inputclasses" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Input classes in the format defined by the input_format tag</xsd:documentation>
         </xsd:annotation>
        </xsd:element> 
       </xsd:sequence>
      </xsd:complexType>

      
     <xsd:complexType name="ContingencyTableRequest">
       <xsd:annotation>
	<xsd:documentation>Parameters for the operation contingency-table.</xsd:documentation>
       </xsd:annotation>
       <xsd:sequence>
        <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
         <xsd:annotation>
          <xsd:documentation>A tab delimited file</xsd:documentation>
         </xsd:annotation>
        </xsd:element> 
        <xsd:element name="col1" type="xsd:int" minOccurs="1">
         <xsd:annotation>
          <xsd:documentation>First column to use for the contingency table</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="col2" type="xsd:int" minOccurs="1">
         <xsd:annotation>
          <xsd:documentation>Second column to use for the contingency table</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="margin" type="xsd:int" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Calculate the marginal sums</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="null" type="xsd:int" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Value for the null character (default: 0).</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
       </xsd:sequence>
      </xsd:complexType>
      
      
           <xsd:complexType name="ContingencyStatsRequest">
       <xsd:annotation>
	<xsd:documentation>Parameters for the operation contingency-stats.</xsd:documentation>
       </xsd:annotation>
       <xsd:sequence>
        <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
         <xsd:annotation>
          <xsd:documentation>A contingency table : a N*M table used to compare the contents of two classifications. Rows represent the clusters of the first classification (considered as reference), and columns the clusters of the second classification (query).</xsd:documentation>
         </xsd:annotation>
        </xsd:element> 
        <xsd:element name="decimals" type="xsd:int" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Number of decimals to display for the computed statistics.</xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="return" type="xsd:string" minOccurs="0">
         <xsd:annotation>
           <xsd:documentation>List of fields to return.
	  	stats : table-wise statistics
                rowstats : row-wise statistics (one line per row of the contingency table)
                colstats : column-wise statistics (one line per column of the contingency table)
                tables : full tables for each statistics (counts, Sn, PPV, separation).
                margins : marginal statistics besides the tables (requires to return tables).
           </xsd:documentation>
         </xsd:annotation>
        </xsd:element>
        <xsd:element name="rsizes" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Specify row group sizes in a separate file. This option can be used in particular cases where the marginal sum of the contingency table does not correspond to the group sizes (for example if a classification supoprts the same elements assigned to multiple groups, or on the contrary if some elements can be unassigned).
            The row size file must contain one row per row of the contingency table, and two columns. The first column indicated the name of the row (the same name as in the contingency table), and the second the  size of the corresponding group.
          </xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
        <xsd:element name="csizes" type="xsd:string" minOccurs="0">
         <xsd:annotation>
          <xsd:documentation>Specify column group sizes in a separate file.
            Same description as for -rsizes tag.
          </xsd:documentation>
         </xsd:annotation>
        </xsd:element>	
       </xsd:sequence>
      </xsd:complexType>

      
      
      
      
      
      
      
      
      
      <xsd:complexType name="MatrixDistribRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation matrix distrib</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The matrix file content. Matrix format is specified with the option "matrix_format" (see below) Default format: tab.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_matrix_file" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Name of the file containing matrix on the server. You need to supply either this parameter or the previous one (matrix_file).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element> 
	  <xsd:element name="matrix_pseudo" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo counts to apply on the matrix. Default: 1.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model file is a tab-delimited file containing the specification of oligonucleotide frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_pseudo" type="xsd:float" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo frequency for the background models. Value must be a real between 0 and 1. Default: 0.01.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of decimals for the matrix frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation></xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MatrixScanRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation matrix scan</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence_file" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Sequence file - all the formats supported in RSAT can be used as input (default: fasta)</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The matrix file is specified with the option "matrix_format" (see below) Default format: tab.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element> 
	  <xsd:element name="matrix_list" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Indicate a file containing a list of matrices to be used for scanning the region. This facilitates the scanning of a sequence with a library of matrices (e.g. all the matrices from RegulonDB or TRANSFAC) 
Format: the matrix list file is a text file. The first word of each row is suppose to indicate a file name. Any further information on the same row is ignored.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="top_matrices" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Only scan with the top # matrices per matrix file. This option is valid for some file formats containing multiple matrices where top matrices are generally more informative.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model file is a tab-delimited file containing the specification of oligonucleotide frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_input" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Calculate background model from the input sequence set. This option requires to specify the order of the background model with the option markov.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_window" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Size of the sliding window for the background model calculation. This option requires to specify the order of the background model with the option markov (suitable for short order model only markov 0 or 1)</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="markov" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Order of the markov chain for the background model. This option is incompatible with the option background.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_pseudo" type="xsd:float" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo frequency for the background models. Value must be a real between 0 and 1. If this option is not specified, the pseudo-frequency value depends on the background calculation.
For -bginput and -window, the pseudo frequency is automatically calculated with the length (L) of the sequence following this formula : square-root of L divided by L+squareroot of L. 
For -bgfile, default value is 0.01. If the training sequence length (L) is known, the value can be set by -bg_pseudo option to square-root of L divided by L+squareroot of L.   
              </xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return_fields" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>List of fields to return. Supported fields: sites, rank, limits, normw, bg_model, matrix, freq_matrix, weight_matrix, distrib .</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="upper_threshold_field" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: E(QR), E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), 
I(Q,R), IC, P(QR), P(Q|R), P(R|Q), P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, jac_sim, rank, sig</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="upper_threshold_value" type="xsd:float" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Upper threshold value for a supported field</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lower_threshold_field" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: same fields as upper_threshold_field.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lower_threshold_value" type="xsd:float" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Lower threshold value for a given field.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="both_strand" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Scan both strands for DNA sequences.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="single_strand" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Single-strand search for DNA sequences.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation random_seq.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	 <xsd:element name="output" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Return type. Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client), or  'both'. 
Default is 'both'.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
         <xsd:element name="sequence_length" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length of sequence to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="repetition" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Number of sequences to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="format" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Format of sequence(s) to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="line_width" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>A newline character will be inserted in the sequence every # bases, where # is the number provided. 
Default is 70. A value of 0 will prevent newline insertion.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="type" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Type of sequence(s) to generate (protein | DNA | other).</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="seed" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Seed for the random generator.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="alphabet" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Alphabet. Must be followed by residue frequencies expressed precisely this way:    a:t # c:g #</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="expfreq" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Expected frequencies of oligomers in sequence(s) to generate. Indicate the file that contains expected oligomer frequencies. 
When this option is used, the sequences are generated according to a Markov chain.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="tmp_expfreq_file" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Name of the file with expected frequencies on the server.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="bg_model" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Background model. Automatically load a pre-calibrated exected frequency file from the RSAT genome distribution. 
When this option is used, the options organism and oligo_length are also required, to indicate the organism and the oligonucleotide length, respectively.
This option is incompatible with the option expfreq.                 
Type of sequences used as background model for estimating expected oligonucleotide frequencies (supported models):
  - equi (equiprobable residue frequencies [default]), 
  - upstream (all upstream sequences, allowing overlap with upstream ORFs. Requires to speciy a model organism), 
  - upstream-noorf (all upstream sequences, preventing overlap with upstream ORFs. Requires to specify a model organism), and 
  - intergenic (intergenic frequencies. Whole set of intergenic regions, including upstream and downstream sequences. Requires to specify a model organism).</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="organism" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Name of the organism when using a background model.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="oligo_length" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length of oligomer when using a background model.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
	 <xsd:element name="length_file" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length file. Allows to generate random sequences with the same lengths as a set of reference sequences.
The length file contains two columns : sequence ID (ignored) and sequence length.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

<!-- RSAT GRAPH TOOLS REQUESTS -->
      <xsd:complexType name="ConvertGraphRequest">
	<xsd:sequence>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ecolors" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>
	        Compute an edge color for the GML output. The color intensity is
        	proportional to the weight of the edge. All weights in the column
                indicated by the -wcol argument must thus be real values. Supported
                : green, blue, red, fire, grey.
              </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="eccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that containsthe color of the edge (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the source node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the target node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="undirected" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The graph is considered as being undirected (useful for the adjacency matrix input and output).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="layout" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify whether the disposition of each node has to be calculated using the $RSAT/bin/fr_layout program.
This option is only useful for GML output.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ewidth" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>
	        Calculate the edge width for the GML output. The width is
                proportional to the weight of the edge. This value can only be
                computed for the GML output. All weights in the column indicated by
                the -wcol argument must thus be real values.</xsd:documentation>
	      </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="AlterGraphRequest">
	<xsd:sequence>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether the edges must be considered as directed, i.e., an     edge from node A to node B is different from an edge from B to A (by default, edges are not directed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="duplicate" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether more than one edge may link two nodes. (by default, duplicated edges are not allowed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allows self loops (by default, self loops are not allowed)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="target" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Nodes that have to be removed in the graph (if existing). The node names must be separated by comas.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="add_nodes" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to add. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="rm_nodes" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to remove. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="add_edges" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to add. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="rm_edges" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to remove. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      
      
      <xsd:complexType name="DisplayGraphRequest">
	      <xsd:sequence>
		      <xsd:element name="informat" type="xsd:string" minOccurs="1">
			      <xsd:annotation>
				      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="outformat" type="xsd:string" minOccurs="1">
			      <xsd:annotation>
				      <xsd:documentation>Output format. Supported: ps, png, jpeg.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
	              <xsd:element name="ewidth" type="xsd:int" minOccurs="0">
	                <xsd:annotation>
	                  <xsd:documentation>
	                    Calculate the edge width for the GML output. The width is
                            proportional to the weight of the edge. This value can only be
                            computed for the GML output. All weights in the column indicated by
                            the -wcol argument must thus be real values.</xsd:documentation>
	                  </xsd:annotation>
	                </xsd:element>
		      <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
			      <xsd:annotation>
				      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="wcol" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="scol" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="tcol" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="eccol" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>Specify a column of the input graph that containsthe color of the edge (no default).</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="sccol" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>Specify a column of the input graph that contains the color of the source node (no default).</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="tccol" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>Specify a column of the input graph that contains the color of the target node (no default).</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="layout" type="xsd:int" minOccurs="0">
			      <xsd:annotation>
				      <xsd:documentation>
					      		Calculates the layout according to the Fruchterman and Reingold algorithm.
							This option must be provided if the input graph is not GML.
				      </xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
	      </xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="CompareGraphsRequest">
	<xsd:sequence>
	  <xsd:element name="Qinformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format of query graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rinformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format of reference graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outweight" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Q (weights of the query graph), R (weights of the reference graph), sum (sum of the weights of the two graphs), 
mean (mean of the weights of the two graphs), mean.g (geometrical mean of the weights of the two graphs), min (minimum weight), max (maximum weight), Q::R (weight of the two graphs) (default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rinputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The reference graph in the format specified by the informat tag.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qinputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The query graph in the format specified by the informat tag</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qwcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qscol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qtcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rwcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rscol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rtcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>intersection, union, difference, R.and.Q, Q.and.R, Q.or.R, Q.not.R, R.not.Q, Q.and.R+Q, 
Q.and.R+R, R.and.Q+Q, R.and.Q+R, intersection+Q, intersection+R.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs must be considered as directed, i.e., an arc from node A to node B is different from an arc from B to A.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs can admit self-loops, i.e., an arc from a node to itself. 
Note that the graphs do not specially need to contain actual self-loops, the question is whether it would or not be acceptable for the considered input graphs to contain self-loops.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNodeDegreeRequest">
	<xsd:sequence>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The degree of all nodes will be computed.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nodefile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A file containing the nodes for which you want to know the degree.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomGraphRequest">
	<xsd:sequence>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="random_type" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Randomization type:
- scratch (de novo graph) : don't forget to specify the number of nodes and of edges,
- ER (Erdos-Renyii randomization) : corresponds to the randomization of a input graph, keeping the nodes and the number of edges but changing its characteristics,
- node_degree : each node will keep the same degree that in the input graph (edge randomization),
- node_degree_distrib : the global distribution of node degree will remain the same as in the input graph.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="edges" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of requested edges (for scratch randomization type).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="degree" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal degree of the nodes in the ER random graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nodes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of requested nodes (for scratch randomization type).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mean" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Mean value on the weight of the arcs. This argument can only be used with the scratch and ER randomization type and must be combined with the -sd option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sd" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Standard deviation value of the weight of the arcs. This argument can only be used with the scratch and ER randomization type and must be combined with the -mean option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs must be considered as directed, i.e., an arc from node A to node B is different from an arc from B to A.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_single" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Prevent the ER / scratch graph from containing nodes with no neighbour.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="duplicate" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether more than one edge may link two nodes (by default, duplicated edges are not allowed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col_conservation" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Only compatible with ER randomization of a graph. Source and target nodes stay source and target nodes in the randomized graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="normal" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>This option can only be used with ER randomization type and if the input graph is weighted. 
Using this option will generate randomly the weight of the output random graph according to a normal distribution of weights. 
The mean and standard deviation can then be chosen (-mean and -sd option) or will be calculated according to the weights the input graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      
      
<xsd:complexType name="MCLRequest">
	<xsd:sequence>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the tab delimited format first column : source node, second column : target node, third column : edge weight</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inflation" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sets the main inflation value. This value is the main handle for affecting cluster granularity. It is usually chosen somewhere in the range [1.2-5.0]. -I 5.0 will tend to result in fine-grained clusterings, and -I 1.2 will tend to result in very coarse grained clusterings.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>      
      
      
      
      
      
      
      <xsd:complexType name="GraphNeighboursRequest">
	<xsd:sequence>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The neighbours of all nodes will be searched.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stats" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Only valid when the number of step is equal to 1. The output file is presented differently, with one line for each seed node.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Include each node in its neighborhood, with a distance of 0, even if there is no self-loop at this node. 
This allows to extract the node together with its neighborhood, rather than the neighborhood only (default). This option cannot be used with the stats option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="seedfile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of nodes for which you want to know the neighbours.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="steps" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal number of steps between a seed node and its neighbours. Default: 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphGetClustersRequest">
	<xsd:sequence>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Return format. Supported: table, cluster, graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="clusters" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Specification of the clusters to which belong the nodes.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="distinct" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>As some nodes may belong to more than one group, using this option will duplicate the nodes belonging to more than one group.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="induced" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Using this option, only the first column of the cluster file will be taken into account. 
The output graph will thus consist in the graph induced by all nodes of the first column.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      <!-- RSAT CLASSICAL TOOLS Response -->
      <xsd:complexType name="RetrieveSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveEnsemblSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="PurgeSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="OligoAnalysisResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="DyadAnalysisResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PatternAssemblyResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DnaPatternResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

<xsd:complexType name="ConvertFeaturesResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

<xsd:complexType name="FeatureMapResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GeneInfoResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="SupportedOrganismsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      
      <xsd:complexType name="TextToHtmlResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
            
      
      <xsd:complexType name="XYGraphResponse">
	      <xsd:sequence>
		      <xsd:element name="server" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="command" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="client" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>The results.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
	      </xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="ClassFreqResponse">
	      <xsd:sequence>
		      <xsd:element name="server" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="command" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="client" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>The results.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
	      </xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="ConvertSeqResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
 
      <xsd:complexType name="CompareClassesResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="ConvertClassesResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="ContingencyStatsResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="ContingencyTableResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>          
      <xsd:complexType name="MatrixScanResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
       <xsd:complexType name="MatrixDistribResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

<!-- RSAT GRAPH TOOL RESPONSE -->
      <xsd:complexType name="ConvertGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="AlterGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="DisplayGraphResponse">
	      <xsd:sequence>
		      <xsd:element name="server" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="command" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
		      <xsd:element name="client" type="xsd:string">
			      <xsd:annotation>
				      <xsd:documentation>The results.</xsd:documentation>
			      </xsd:annotation>
		      </xsd:element>
	      </xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="GraphNodeDegreeResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareGraphsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNeighboursResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      
      <xsd:complexType name="MCLResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>      
      
      
      <xsd:complexType name="RandomGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphGetClustersResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

<!-- RSA CLASSICAL TOOLS -->
      <xsd:element name="retrieve_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RetrieveSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RetrieveSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_ensembl_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RetrieveEnsemblSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_ensembl_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RetrieveEnsemblSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="purge_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:PurgeSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="purge_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:PurgeSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="oligo_analysis">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:OligoAnalysisRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="oligo_analysisResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:OligoAnalysisResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dyad_analysis">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DyadAnalysisRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dyad_analysisResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DyadAnalysisResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="pattern_assembly">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:PatternAssemblyRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="pattern_assemblyResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:PatternAssemblyResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="dna_pattern">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DnaPatternRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dna_patternResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DnaPatternResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_features">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:ConvertFeaturesRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_featuresResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:ConvertFeaturesResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="feature_map">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:FeatureMapRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="feature_mapResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:FeatureMapResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="gene_info">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GeneInfoRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="gene_infoResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GeneInfoResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="supported_organisms">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:SupportedOrganismsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>


      
      <xsd:element name="supported_organismsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:SupportedOrganismsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>
      
      
      <xsd:element name="text_to_html">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:TextToHtmlRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>


      
      <xsd:element name="text_to_htmlResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:TextToHtmlResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>      
      
      
      <xsd:element name="classfreq">
	      <xsd:complexType>
		      <xsd:sequence>
			      <xsd:element name="request" type="tns:ClassFreqRequest" />
		      </xsd:sequence>
	      </xsd:complexType>
      </xsd:element>
      <xsd:element name="classfreqResponse">
	      <xsd:complexType>
		      <xsd:sequence>
			      <xsd:element name="response" type="tns:ClassFreqResponse" />
		      </xsd:sequence>
	      </xsd:complexType>
      </xsd:element>
      <xsd:element name="xygraph">
	      <xsd:complexType>
		      <xsd:sequence>
			      <xsd:element name="request" type="tns:XYGraphRequest" />
		      </xsd:sequence>
	      </xsd:complexType>
      </xsd:element>
      <xsd:element name="xygraphResponse">
	      <xsd:complexType>
		      <xsd:sequence>
			      <xsd:element name="response" type="tns:XYGraphResponse" />
		      </xsd:sequence>
	      </xsd:complexType>
      </xsd:element>      
      <xsd:element name="convert_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertSeqRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertSeqResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_classes">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:CompareClassesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_classesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:CompareClassesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_classes">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertClassesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_classesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertClassesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>      
      
      
      <xsd:element name="contingency_stats">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ContingencyStatsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_statsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ContingencyStatsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>     
      
      <xsd:element name="contingency_table">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ContingencyTableRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_tableResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ContingencyTableResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>     
          
      
      <xsd:element name="matrix_scan">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MatrixScanRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_scanResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MatrixScanResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>
      
         <xsd:element name="matrix_distrib">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MatrixDistribRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_distribResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MatrixDistribResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RandomSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RandomSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <!-- RSAT GRAPH TOOLS -->
      <xsd:element name="convert_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>
      
      <xsd:element name="alter_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:AlterGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="alter_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:AlterGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>      
      
      
      <xsd:element name="display_graph">
	      <xsd:complexType>
		      <xsd:sequence>
			      <xsd:element name="request" type="tns:DisplayGraphRequest" />
		      </xsd:sequence>
	      </xsd:complexType>
      </xsd:element>
      <xsd:element name="display_graphResponse">
	      <xsd:complexType>
		      <xsd:sequence>
			      <xsd:element name="response" type="tns:DisplayGraphResponse" />
		      </xsd:sequence>
	      </xsd:complexType>
      </xsd:element>
      <xsd:element name="compare_graphs">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:CompareGraphsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_graphsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:CompareGraphsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_node_degree">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphNodeDegreeRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_node_degreeResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphNodeDegreeResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_neighbours">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphNeighboursRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>
      
      <xsd:element name="graph_neighboursResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphNeighboursResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>      
      
      <xsd:element name="mcl">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MCLRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="mclResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MCLResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RandomGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RandomGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_get_clusters">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphGetClustersRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_get_clustersResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphGetClustersResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element> 
    </xsd:schema>
  </types>

<!-- RSAT CLASSICAL TOOLS MESSAGE -->
  <message name="retrieve_seqRequest">
    <part name="parameters" element="tns:retrieve_seq"/>
  </message>

  <message name="retrieve_seqResponse">
    <part name="output" element="tns:retrieve_seqResponse"/>
  </message>

  <message name="retrieve_ensembl_seqRequest">
    <part name="parameters" element="tns:retrieve_ensembl_seq"/>
  </message>

  <message name="retrieve_ensembl_seqResponse">
    <part name="output" element="tns:retrieve_ensembl_seqResponse"/>
  </message>

  <message name="purge_seqRequest">
    <part name="parameters" element="tns:purge_seq"/>
  </message>

  <message name="purge_seqResponse">
    <part name="output" element="tns:purge_seqResponse"/>
  </message>

  <message name="oligo_analysisRequest">
    <part name="parameters" element="tns:oligo_analysis"/>
  </message>

  <message name="oligo_analysisResponse">
    <part name="output" element="tns:oligo_analysisResponse"/>
  </message>

  <message name="dyad_analysisRequest">
    <part name="parameters" element="tns:dyad_analysis"/>
  </message>

  <message name="dyad_analysisResponse">
    <part name="output" element="tns:dyad_analysisResponse"/>
  </message>

  <message name="pattern_assemblyRequest">
    <part name="parameters" element="tns:pattern_assembly"/>
  </message>

  <message name="pattern_assemblyResponse">
    <part name="output" element="tns:pattern_assemblyResponse"/>
  </message>

  <message name="dna_patternRequest">
    <part name="parameters" element="tns:dna_pattern"/>
  </message>

  <message name="dna_patternResponse">
    <part name="output" element="tns:dna_patternResponse"/>
  </message>

  <message name="convert_featuresRequest">
    <part name="parameters" element="tns:convert_features"/>
  </message>

  <message name="convert_featuresResponse">
    <part name="output" element="tns:convert_featuresResponse"/>
  </message>

  <message name="feature_mapRequest">
    <part name="parameters" element="tns:feature_map"/>
  </message>

  <message name="feature_mapResponse">
    <part name="output" element="tns:feature_mapResponse"/>
  </message>

  <message name="gene_infoRequest">
    <part name="parameters" element="tns:gene_info"/>
  </message>

  <message name="gene_infoResponse">
    <part name="output" element="tns:gene_infoResponse"/>
  </message>

  <message name="supported_organismsRequest">
    <part name="parameters" element="tns:supported_organisms"/>
  </message>

  <message name="supported_organismsResponse">
    <part name="output" element="tns:supported_organismsResponse"/>
  </message>
  
  <message name="text_to_htmlRequest">
    <part name="parameters" element="tns:text_to_html"/>
  </message>

  <message name="text_to_htmlResponse">
    <part name="output" element="tns:text_to_htmlResponse"/>
  </message>  
  
  <message name="classfreqRequest">
	  <part name="parameters" element="tns:classfreq"/>
  </message>
  
  <message name="classfreqResponse">
	  <part name="output" element="tns:classfreqResponse"/>
  </message>
  <message name="xygraphRequest">
	  <part name="parameters" element="tns:xygraph"/>
  </message>
  
  <message name="xygraphResponse">
	  <part name="output" element="tns:xygraphResponse"/>
  </message>
  <message name="convert_seqRequest">
    <part name="parameters" element="tns:convert_seq"/>
  </message>

  <message name="convert_seqResponse">
    <part name="output" element="tns:convert_seqResponse"/>
  </message>

  <message name="compare_classesRequest">
    <part name="parameters" element="tns:compare_classes"/>
  </message>

  <message name="compare_classesResponse">
    <part name="output" element="tns:compare_classesResponse"/>
  </message>

  <message name="convert_classesRequest">
    <part name="parameters" element="tns:convert_classes"/>
  </message>

  <message name="convert_classesResponse">
    <part name="output" element="tns:convert_classesResponse"/>
  </message>  
  
  <message name="contingency_statsRequest">
    <part name="parameters" element="tns:contingency_stats"/>
  </message>

  <message name="contingency_statsResponse">
    <part name="output" element="tns:contingency_statsResponse"/>
  </message>   
  
  <message name="contingency_tableRequest">
    <part name="parameters" element="tns:contingency_table"/>
  </message>

  <message name="contingency_tableResponse">
    <part name="output" element="tns:contingency_tableResponse"/>
  </message>   
  
  <message name="matrix_scanRequest">
    <part name="parameters" element="tns:matrix_scan"></part>
  </message>

  <message name="matrix_scanResponse">
    <part name="output" element="tns:matrix_scanResponse"></part>
  </message>
  
   <message name="matrix_distribRequest">
    <part name="parameters" element="tns:matrix_distrib"></part>
  </message>

  <message name="matrix_distribResponse">
    <part name="output" element="tns:matrix_distribResponse"></part>
  </message>

  <message name="random_seqRequest">
    <part name="parameters" element="tns:random_seq"/>
  </message>

  <message name="random_seqResponse">
    <part name="output" element="tns:random_seqResponse"/>
  </message>

  <!-- RSAT GRAPH TOOLS MESSAGE -->
  <message name="convert_graphRequest">
    <part name="parameters" element="tns:convert_graph"/>
  </message>

  <message name="convert_graphResponse">
    <part name="output" element="tns:convert_graphResponse"/>
  </message>
  <message name="alter_graphRequest">
    <part name="parameters" element="tns:alter_graph"/>
  </message>

  <message name="alter_graphResponse">
    <part name="output" element="tns:alter_graphResponse"/>
  </message>  
  <message name="display_graphRequest">
	  <part name="parameters" element="tns:display_graph"/>
  </message>
  
  <message name="display_graphResponse">
	  <part name="output" element="tns:display_graphResponse"/>
  </message>
  <message name="compare_graphsRequest">
    <part name="parameters" element="tns:compare_graphs"/>
  </message>

  <message name="compare_graphsResponse">
    <part name="output" element="tns:compare_graphsResponse"/>
  </message>

  <message name="graph_node_degreeRequest">
    <part name="parameters" element="tns:graph_node_degree"/>
  </message>

  <message name="graph_node_degreeResponse">
    <part name="output" element="tns:graph_node_degreeResponse"/>
  </message>

  <message name="random_graphRequest">
    <part name="parameters" element="tns:random_graph"/>
  </message>

  <message name="random_graphResponse">
    <part name="output" element="tns:random_graphResponse"/>
  </message>

  <message name="graph_get_clustersRequest">
    <part name="parameters" element="tns:graph_get_clusters"/>
  </message>

  <message name="graph_get_clustersResponse">
    <part name="output" element="tns:graph_get_clustersResponse"/>
  </message>

  <message name="graph_neighboursRequest">
    <part name="parameters" element="tns:graph_neighbours"/>
  </message>

  <message name="graph_neighboursResponse">
    <part name="output" element="tns:graph_neighboursResponse"/>
  </message>

  <message name="mclRequest">
    <part name="parameters" element="tns:mcl"/>
  </message>

  <message name="mclResponse">
    <part name="output" element="tns:mclResponse"/>
  </message>  
  
  
  <portType name="RSATWSPortType">
<!-- 	  RSAT CLASSICAL TOOLS Porttype -->
      <operation name="retrieve_seq">
         <input name="RetrieveSequenceRequest" message="tns:retrieve_seqRequest"/>
         <output name="RetrieveSequenceResponse" message="tns:retrieve_seqResponse"/>         
	 <documentation>Returns upstream, downstream or coding DNA sequences
           for list of query genes.
         </documentation>
      </operation>
      <operation name="retrieve_ensembl_seq">
         <input name="RetrieveEnsemblSequenceRequest" message="tns:retrieve_ensembl_seqRequest"/>
         <output name="RetrieveEnsemblSequenceResponse" message="tns:retrieve_ensembl_seqResponse"/>         
	 <documentation>Returns upstream, downstream or coding DNA sequences
           for list of query genes (in EnsEMBL database).
         </documentation>
      </operation>
      <operation name="purge_seq">
         <input name="PurgeSequenceRequest" message="tns:purge_seqRequest"/>
         <output name="PurgeSequenceResponse" message="tns:purge_seqResponse"/>
         <documentation>Mask repeated fragments of an input sequence.</documentation>
      </operation>
      <operation name="oligo_analysis">
         <input name="OligoAnalysisRequest" message="tns:oligo_analysisRequest"/>
         <output name="OligoAnalysisResponse" message="tns:oligo_analysisResponse"/>
         <documentation>Analysis of the statistical significance of all the oligomers
	   of a given size in a sequence. Commonly used to detect
	   over-represented oligonucleotides in a set of promoter
	   sequences.
         </documentation>
      </operation>
      <operation name="dyad_analysis">
         <input name="DyadAnalysisRequest" message="tns:dyad_analysisRequest"/>
         <output name="DyadAnalysisResponse" message="tns:dyad_analysisResponse"/>
         <documentation>Analysis of the statistical significance of all the
	   spaced dyads
	   of a given size in a sequence. Commonly used to detect
	   over-represented spaced dyads in a set of promoter
	   sequences.
         </documentation>
      </operation>
      <operation name="pattern_assembly">
         <input name="PatternAssemblyRequest" message="tns:pattern_assemblyRequest"/>
         <output name="PatternAssemblyResponse" message="tns:pattern_assemblyResponse"/>
         <documentation>
         </documentation>
      </operation>
      <operation name="dna_pattern">
         <input name="DnaPatternRequest" message="tns:dna_patternRequest"/>
         <output name="DnaPatternResponse" message="tns:dna_patternResponse"/>
         <documentation>Searches all occurrences of a pattern within DNA sequences.
         </documentation>
      </operation>
      <operation name="convert_features">
         <input name="ConvertFeaturesRequest" message="tns:convert_featuresRequest"/>
         <output name="ConvertFeaturesResponse" message="tns:convert_featuresResponse"/>
         <documentation>
         </documentation>
      </operation>
      <operation name="feature_map">
         <input name="FeatureMapRequest" message="tns:feature_mapRequest"/>
         <output name="FeatureMapResponse" message="tns:feature_mapResponse"/>
         <documentation>
         </documentation>
      </operation>
      <operation name="gene_info">
         <input name="GeneInfoRequest" message="tns:gene_infoRequest"/>
         <output name="GeneInfoResponse" message="tns:gene_infoResponse"/>
         <documentation>Get information about genes.
         </documentation>
      </operation>
      <operation name="supported_organisms">
         <input name="SupportedOrganismsRequest" message="tns:supported_organismsRequest"/>
         <output name="SupportedOrganismsResponse" message="tns:supported_organismsResponse"/>
         <documentation>Converts a tab-delimited file into an HTML table.
         </documentation>
      </operation>
      <operation name="text_to_html">
         <input name="TextToHtmlRequest" message="tns:text_to_htmlRequest"/>
         <output name="TextToHtmlResponse" message="tns:text_to_htmlResponse"/>
         <documentation>Converts a tab-delimited file into a HTML table
         </documentation>
      </operation>
      <operation name="xygraph">
	      <input name="XYGraphRequest" message="tns:xygraphRequest"/>
	      <output name="XYGraphResponse" message="tns:xygraphResponse"/>
	      <documentation>Plot a graph and export it.
	      </documentation>
      </operation>
      <operation name="classfreq">
	      <input name="ClassFreqRequest" message="tns:classfreqRequest"/>
	      <output name="ClassFreqResponse" message="tns:classfreqResponse"/>
	      <documentation>This script takes a group of numbers (real or integers) and outputs
        their distribution among classes.
	      </documentation>
      </operation>
      <operation name="convert_seq">
         <input name="ConvertSeqRequest" message="tns:convert_seqRequest"/>
         <output name="ConvertSeqResponse" message="tns:convert_seqResponse"/>
         <documentation>Converts a sequence between two formats (e.g. fasta -> raw).
         </documentation>
      </operation>
      <operation name="compare_classes">
        <input name="CompareClassesRequest" message="tns:compare_classesRequest"/>
        <output name="CompareClassesResponse" message="tns:compare_classesResponse"/>
	<documentation>Compare two class files(the query file and the reference file). Each class of the query file is compared to each class of the reference file.
The number of common elements is reported, as well as the probability to observe at least this number of common elements by chance alone.
        </documentation>
      </operation>
<operation name="convert_classes">
        <input name="ConvertClassesRequest" message="tns:convert_classesRequest"/>
        <output name="ConvertClassesResponse" message="tns:convert_classesResponse"/>
	<documentation>Interconversions between different formats of cluster files.
        </documentation>
      </operation>
<operation name="contingency_stats">
        <input name="ContingencyStatsRequest" message="tns:contingency_statsRequest"/>
        <output name="ContingencyStatsResponse" message="tns:contingency_statsResponse"/>
	<documentation>This programs takes as input a contingency table, and calculates various     matching statistics between the rows and columns. The description of these statistics can be found in Brohee and van Helden (2006).
        </documentation>
      </operation>
<operation name="contingency_table">
        <input name="ContingencyTableRequest" message="tns:contingency_tableRequest"/>
        <output name="ContingencyTableResponse" message="tns:contingency_tableResponse"/>
	<documentation> Create a contingency table from a two-column file.
        </documentation>
      </operation>
      <operation name="matrix_scan">
        <input name="MatrixScanRequest" message="tns:matrix_scanRequest"/>
        <output name="MatrixScanResponse" message="tns:matrix_scanResponse"/>
	<documentation>Scan sequences with one or several position-specific scoring matrices (PSSM) to identify instances of the corresponding motifs(putative sites). 
This program supports a variety of background models (Bernoulli, Markov chains of any order).
	</documentation>
      </operation>
      <operation name="matrix_distrib">
        <input name="MatrixDistribRequest" message="tns:matrix_distribRequest"/>
        <output name="MatrixDistribResponse" message="tns:matrix_distribResponse"/>
	<documentation>Returns the theoretical distribution of matrix weight within the defined background model.
	</documentation>
      </operation>
      <operation name="random_seq">
         <input name="RandomSequenceRequest" message="tns:random_seqRequest"/>
         <output name="RandomSequenceResponse" message="tns:random_seqResponse"/>
         <documentation>Generates random sequences.
         </documentation>
      </operation>

      <!-- 	  RSAT GRAPH TOOLS Porttype -->
      <operation name="convert_graph">
	      <input name="ConvertGraphRequest" message="tns:convert_graphRequest"/>
	      <output name="ConvertGraphResponse" message="tns:convert_graphResponse"/>         
	      <documentation>Convert graphs between different formats
	      </documentation>
      </operation>
      <operation name="alter_graph">
	      <input name="AlterGraphRequest" message="tns:alter_graphRequest"/>
	      <output name="AlterGraphResponse" message="tns:alter_graphResponse"/>         
	      <documentation>Alter a graph either by adding or removing edges or nodes
	      </documentation>
      </operation>
      <operation name="display_graph">
	      <input name="DisplayGraphRequest" message="tns:display_graphRequest"/>
	      <output name="DisplayGraphResponse" message="tns:display_graphResponse"/>         
	      <documentation>Produces the figure of a graph
	      </documentation>
      </operation>
      <operation name="compare_graphs">
	      <input name="CompareGraphsRequest" message="tns:compare_graphsRequest"/>
	      <output name="CompareGraphsResponse" message="tns:compare_graphsResponse"/>         
	      <documentation>Computes the union / difference or intersection of two graphs
	      </documentation>
      </operation>
      <operation name="graph_node_degree">
	      <input name="GraphNodeDegreeRequest" message="tns:graph_node_degreeRequest"/>
	      <output name="GraphNodeDegreeResponse" message="tns:graph_node_degreeResponse"/>         
	      <documentation>Calculates the in / out / global degree for a selection of seed nodes</documentation>
      </operation>
      <operation name="random_graph">
	      <input name="RandomGraphRequest" message="tns:random_graphRequest"/>
	      <output name="RandomGraphResponse" message="tns:random_graphResponse"/>         
	      <documentation>Generate random graphs either from scratch of from an existing graph using
		      different randomization models
	      </documentation>
      </operation>	
      <operation name="graph_get_clusters">
	      <input name="GraphGetClustersRequest" message="tns:graph_get_clustersRequest"/>
	      <output name="GraphGetClustersResponse" message="tns:graph_get_clustersResponse"/>         
	      <documentation>Compares a graph with a classification/clustering file.
	      </documentation>
      </operation>
      <operation name="graph_neighbours">
	      <input name="GraphNeighboursRequest" message="tns:graph_neighboursRequest"/>
	      <output name="GraphNeighboursResponse" message="tns:graph_neighboursResponse"/>         
	      <documentation>Find the neihbours up to a certain distance of a collection of seed nodes
	      </documentation>
      	   </operation>
      <operation name="mcl">
	      <input name="MCLRequest" message="tns:mclRequest"/>
	      <output name="MCLResponse" message="tns:mclResponse"/>         
	      <documentation>Find the neihbours up to a certain distance of a collection of seed nodes
	      </documentation>
      	   </operation>	
  </portType>
  
  <binding name="RSATWSBinding" type="tns:RSATWSPortType">
<!-- 	  RSAT CLASSICAL TOOLS BINDING -->
      <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
      <operation name="retrieve_seq">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="retrieve_ensembl_seq">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="purge_seq">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="oligo_analysis">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="dyad_analysis">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="pattern_assembly">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="dna_pattern">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="convert_features">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="feature_map">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="gene_info">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="supported_organisms">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="text_to_html">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="classfreq">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="xygraph">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="convert_seq">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="compare_classes">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="convert_classes">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="contingency_stats">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="contingency_table">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation> 
      <operation name="matrix_scan">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="matrix_distrib">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <operation name="random_seq">
         <soap:operation soapAction=""/>
         <input>
             <soap:body use="literal" />
         </input>
         <output>
             <soap:body use="literal" />
         </output>
      </operation>
      <!-- 	  RSAT GRAPH TOOLS BINDING -->
      <operation name="convert_graph">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="alter_graph">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="display_graph">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="compare_graphs">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="graph_neighbours">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="mcl">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="graph_node_degree">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="graph_get_clusters">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
      <operation name="random_graph">
	      <soap:operation soapAction=""/>
	      <input>
		      <soap:body use="literal" />
	      </input>
	      <output>
		      <soap:body use="literal" />
	      </output>
      </operation>
  </binding>

  <service name="RSATWebServices">
    <documentation>
      Web services for the Regulatory Sequence Analysis Tools (RSAT).
      Tools developed by Jacques van Helden
      (jvanheld@scmbb.ulb.ac.be), SOAP/WSDL interface developed by
      Olivier Sand (oly@scmbb.ulb.ac.be).
   </documentation>
    <port name="RSATWSPortType" binding="tns:RSATWSBinding">
      <soap:address location="http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.cgi"/>
    </port>
  </service>
</definitions>
