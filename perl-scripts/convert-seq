#!/usr/bin/perl
############################################################
#
# $Id: convert-seq,v 1.14 2004/05/07 07:11:44 jvanheld Exp $
#
# Time-stamp: <2002-09-24 21:24:13 jvanheld>
#
############################################################

if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";

$start_time = `date`;
$line_width = 60;

#### initialise parameters ####
$accepted_input_string = join "\n\t\t\t", "",keys %accepted_input_seq;
$accepted_output_string = join "\n\t\t\t", "", keys %accepted_output_seq; 

&ReadArguments();


#### check argument values ####
unless ($line_width >= 0) {
    print "\tinvalid line width\n";
    print "\ttype convert-seq -h for help\n";
    exit;

}
&CheckInputSeqFormat($in_format);
&CheckOutputSeqFormat($out_format);

if ($out_format eq "wc") {
    $line_width = 0;
}
if ($out_format eq "multi") {
    $line_width = 0;
}

### open input file ###
($in, $input_dir) = &OpenInputFile($inputfile);

### open output file ###
$out = &OpenOutputFile($outputfile);
if ($outputfile) {
    $output_dir = `dirname $outputfile`;
}
unless ($output_dir) {
    $output_dir = `pwd`;
}
chomp $output_dir;

#### verbose ####
if ($verbose) {
    print ";convert-seq result\n";
    if ($inputfile ne "") {
	print ";Input file	$inputfile\n";
    }
    if ($outputfile ne "") {
	print ";Output file	$outputfile\n";
    }
    print ";Input format\t$in_format\n";
    print ";Output format\t$out_format\n";
}

###### execute the command #########
#die join "\t", $in_format, $input_dir , "\n";
while ((($current_seq, $current_id, @comments) = &ReadNextSequence($in, $in_format, $input_dir)) &&
       (($current_seq ne "") || ($current_id ne ""))) {

    $seq_nb++;

    #### case conversion
    if ($lowercases) {
        $current_seq = lc($current_seq);

    } elsif ($uppercases) {
        $current_seq = uc($current_seq);
    } 

    #### DNA only
    if ($dna) {
        $current_seq = &CleanDNA($current_seq);
    }

    #### identifier specified with the -id option
    if ($seq_identifier) {
	$current_id = $seq_identifier;
    }

    #### sequence id from file name
    if ($in_format eq "raw") {
	$current_id =~ s/\.raw$//;
    }

    #### check that the a sequence identifier has a value
    unless ($current_id) {
	$current_id = $seq_nb;
    }

    if ($out_format eq "filelist") {
	#$current_id = `basename $current_id .$in_format`;
	#if ($current_id =~ /\.$in_format/) {
	#    $current_id = $';
	#}

	#### ensure that the id is a valid filename
	chomp $current_id;
	$current_id =~ s/\|/_/g;
	$current_id =~ s/\;/_/g;
	$current_id =~ s/\&/_/g;


	$one_seq_file = "$current_id.raw";
	open RAW, "> ${output_dir}/$one_seq_file"
	    || die "Error: cannot write file ${output_dir}/$one_seq_file\n";
	&PrintNextSequence(RAW, "raw", 0, $current_seq, $current_id);
	close RAW;
	print $out "$one_seq_file\t$current_id\n";
    } else {
	&PrintNextSequence($out, $out_format, $line_width, $current_seq, $current_id, @comments);
    }
    if ($add_RC) {
	$current_id .= "_reverse_complement";
	@comments = ();
	$rev_seq = &ReverseComplement($current_seq);
	if ($lowercases) {
	    $rev_seq = lc($rev_seq);
	} elsif ($uppercases) {
	    $rev_seq = uc($rev_seq);
	} 
	if ($out_format eq "filelist") {
	    $one_seq_file = "${current_id}.raw";
	    open RAW, "> $one_seq_file";
	    &PrintNextSequence(RAW, "raw", 0, $rev_seq, $current_id);
	    close RAW;
	    print $out "$one_seq_file\n";
	} else {
	    &PrintNextSequence($out, $out_format, $line_width, $rev_seq, $current_id, @comments);
	}
    }
}

###### verbose ######
if ($verbose) {
    $done_time = `date`;
    print ";Job started $start_time";
    print ";Job done    $done_time";
}


###### close input file ######
if ($inputfile ne "") {
    close $in;
}

###### close output file ######
if ($outputfile ne "") {
    close $out;
}


exit(0);



################################################################
######################### SUBROUTINES ##########################
################################################################


sub PrintHelp {
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
	convert-seq

        v1.0, 1997 by Jacques van Helden (jvanheld\@scmbb.ulb.ac.be)
	
DESCRIPTION
	Converts sequences between different formats. Optionally, also
	returns the reverse-complement of the input sequences.

CATEGORY
	util
	sequences

USAGE
        consert-seq [-i inputfile] [-o outputfile] [-v] 
	          -id identifier
                  -from inputformat -to outputformat
                  [-lw line_width]
	
OPTIONS
	-v #	verbose level
	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-from   input format 
		    Supported input formats : $accepted_input_string
        -to     output format
		    Supported output formats : $accepted_output_string
        -lw #   line width. A carriage return is inserted every # 
                characters within the output sequence.
                Default is 60. A 0 value indicates that no carriage 
                return must be inserted.
        -addrc  adds the reverse complement of each input sequence
                to the output file. This is usefull for programs that 
                cannot handle reverse complement (like the Gibbs Sampler).
	-lc	lowercase. the sequence is printed in lowercase.
	-uc	lowercase. the sequence is printed in uppercase.
	-dna	convert any non-acgt character into "." 
		This is to filter out partly speciied nucleotides.
	-id identifier
		sequence identifier (useful for converting a raw
		sequence from the STDIN)

SUPPORTED FORMATS
    INPUT $accepted_input_string
	
    OUTPUT $accepted_output_string
	
EXAMPLES
	convert-seq -i myseq.IG -from IG -to FASTA -o myseq.FASTA

End_of_help
  close HELP;
  exit(0);
}

sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_shorthelp;
consvert-seq options
--------------------
-h      detailed help message
-help   short help message (shows the present message)
-v #	verbose level
-i      inputfile
-o      outputfile
-from   input format (see below for accepted formats)
-to     output format (see below for accepted formats)
-lw #   line width. 
-addrc  adds the reverse complement of each input sequence
-lc	lowercase
-uc	uppsercase
-dna	convert any non-acgt character into "." 
-id identifier

SUPPORTED FORMATS
    INPUT $accepted_input_string
	
    OUTPUT $accepted_output_string
End_shorthelp
  close HELP;
  exit(0);
}



sub ReadArguments {
#### read arguments ####
    foreach $a (0..$#ARGV) {
	
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions;
	    
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-id") {
	    $seq_identifier = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-from") {
	    $in_format = lc($ARGV[$a+1]);
	    
	} elsif ($ARGV[$a] eq "-to") {
	    $out_format = lc($ARGV[$a+1]);
	    
	} elsif ($ARGV[$a] eq "-lw") {
	    $line_width = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-lc") {
	    $uppercases = 0;
	    $lowercases = 1;
	    
	} elsif ($ARGV[$a] eq "-uc") {
	    $uppercases = 1;
	    $lowercases = 0;
	    
	} elsif ($ARGV[$a] eq "-addrc") {
	    $add_RC = 1;

	} elsif ($ARGV[$a] eq "-dna") {
	    $dna = 1;
	    
	}
    }
}
