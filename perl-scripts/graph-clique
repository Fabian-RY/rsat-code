#!/usr/bin/perl -w
############################################################
#
# $Id: graph-clique,v 1.2 2008/04/08 10:42:30 rsat Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

graph-clique

=head1 VERSION

$program_version

=head1 DESCRIPTION

Find all cliques of (a) given size(s) in a graph

=head1 AUTHORS

Sylvain Brohee <sylvain@scmbb.ulb.ac.be>

=head1 CATEGORY

util

=head1 USAGE

graph-clique [-i inputfile] [-o outputfile] [-v #] -size # [-size #]

=head1 INPUT FORMATS

Graph in GML or TAB format (to be specified by the -in_format option)

See I<convert-graph> for a description of the supported input graph
formats. Default format for the input graph: tab.

=head1 OUTPUT FORMAT
A tab-delimited text file with 2 columns. The first column
indicates the elements of the clique, the second column the number of the clique. 


=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
use warnings;
use re 'eval';
require "RSA.lib";
require RSAT::Graph2;
use RSAT::Family;
use RSAT::Classification;

################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();
    $program_version = do { my @r = (q$Revision: 1.2 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };

    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::out = STDOUT;

    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	tab=>1,
	gml=>1
    );
    $supported_input_formats = join (",", keys %supported_input_format);
    local $source_col = 1;
    local $target_col = 2;
    
    # Size of the cliques
    local %sizes = ();

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values


    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ## Initialize and read the input graph
    $graph = new RSAT::Graph2();
    $graph->set_attribute("label", "input graph");
    $graph->graph_from_text($input_format,$main::infile{graph}, $source_col, $target_col, 0);

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    ################################################################
    ## Execute the command
    my @arcs = $graph->get_attribute("arcs");
    my %node_name_id = $graph->get_attribute("nodes_name_id");
    my %arcs_name_id = $graph->get_attribute("arcs_name_id");
    my @nodes = keys %node_name_id;
    my @sizes_sorted = ();
    my $max_size = 32000;
    if (scalar(keys (%sizes)) != 0) {
      my @sizes = keys (%sizes);
      @sizes_sorted = sort {$a <=> $b} @sizes;
      $max_size = pop @sizes_sorted;
    }
    
    
    my @cliques; # Each row of this 2D array contains the list of nodes forming the clique. It is initialize with all cliques of size 2 (all edges)
    my @cliques_id; # The row i of this 2D array contains the list of indices in @cliques corresponding to cliques of size i
    my %seen_cliques = (); # Hash of cliques already detected (to avoid redundancy as in n1,n2,n3 and n3,n2,n1, ... The nodes are sorted alphabetically and separated by "_"
    
    
    # Initialization of @cliques with all the edges contained in $graph.
    for (my $i = 0; $i < scalar (@arcs); $i++) {
      $cliques[$i][0] = $arcs[$i][0];
      $cliques[$i][1] = $arcs[$i][1];
      $cliques_id[2][$i] = $i;
    }
    
    my $found = 1; # This tag equals 1 if the algorithm could find a clique of size $i
    my $size = 3;
    while ($found) {
      &RSAT::message::Info("\t","Looking for cliques of size",$size) if ($main::verbose >= 2);
      $found = 0;
      # For all cliques of size $size-1, we look if it exists a node that is linked to all
      # nodes contained of the clique.
      my @id_cliques_of_size_n = @{$cliques_id[$size-1]};
      foreach my $id_clique (@id_cliques_of_size_n) {
        my @clique_nodes = @{$cliques[$id_clique]};
        &RSAT::message::Info("\t","Analyzing clique of size",$size-1, join(",", @clique_nodes)) if ($main::verbose >= 4);
        foreach $node (@nodes) {
          my $potential_clique = 1; # Tag = 1 while there is a node in @nodes having a connection with the nodes in @clique_nodes
          my @potential_new_clique = ($node);
          my $clique_node;
          my @potential_existing_clique = ($node, @clique_nodes);
          my $potential_existing_clique_members = join ("_", sort @potential_new_clique);
          next if (defined ($seen_cliques{$potential_existing_clique_members}));
          foreach $clique_node (@clique_nodes) {
            my $arc_id = join ("_",$node, $clique_node,1);
            my $arc_id_rev = join ("_",$clique_node, $node,1);
            push @potential_new_clique, $clique_node;
            $potential_clique = 0 if ((!defined ($arcs_name_id{$arc_id}) && !defined($arcs_name_id{$arc_id_rev})) || ($node eq $clique_node)); 
            last if (!$potential_clique);
          }
          # if we found a node connecting to all nodes of a clique, create a new clique of size n and add it to the index of clique
          $clique_members = join ("_", sort @potential_new_clique);
          if ($potential_clique && !defined ($seen_cliques{$clique_members})) {
            my $nb_cliques = scalar @cliques;
            foreach my $potential_clique_nodes (@potential_new_clique) {
              push @{$cliques[$nb_cliques]}, $potential_clique_nodes;
            }
            push @{$cliques_id[$size]}, $nb_cliques;
            &RSAT::message::Info("\t","With node",$node,"found clique of size", $size, join(",",@potential_new_clique),"id", $nb_cliques) if ($main::verbose >= 4);
            $found = 1; # We found at least a clique of size $size... we can continue
            $seen_cliques{$clique_members}++;
          } 
        }
      }
      if (scalar @sizes == 0 && $found && defined($sizes{$size})) {
        $requested_sizes{$size}++;
      }
      
      last if ($max_size == $size);
      $size ++;
    }
    
    ################################################################
    ## Print output
    print $out join("\t", "#element" ,"cluster")."\n" if ($main::verbose >=1);
    my $cpt = 1;
    foreach $size (keys %requested_sizes) {
      my @id_cliques_of_size_n = @{$cliques_id[$size]};
      foreach my $id (@id_cliques_of_size_n) {
        my $cluster_id = "cluster_".$cpt;
        foreach my $node (@{$cliques[$id]}) {
          print $out join("\t", $node ,$cluster_id)."\n" if ($main::verbose >=1);
        }
        $cpt++;
      }
    }


    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }


    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});


    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{graph} = shift(@arguments);

	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ### Input format  
=pod

=item B<-in_format input_format>

Input format. Supported: tab, gml. By default, the output format is tab.

=cut
	} elsif ($arg eq "-in_format") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});
=item B<-scol>

Source column. Column containing the source nodes. 

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes. 

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }
		
		
	    ### Size of the clique
=pod

=item B<-size #>

Size of the cliques that are looked for. As K-clique problem is known to be NP-complete, so it is advisable to limit the number of edges according to your predefined threshold, rather than exhaustively searching them. This option can be used multiple times. 

=cut
	} elsif ($arg eq "-size") {
	    $this_size = shift(@arguments);
	    unless (&IsNatural($this_size) && ($this_size > 0)) {
		&RSAT::error::FatalError(join("\t", $this_size, "Invalid value for the size of the searched clique. Must be a strictly positive natural number"));
	    }
	    $sizes{$this_size}++;
		
		
	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; graph-clique ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
}



__END__

=pod

=head1 SEE ALSO

=head1 WISH LIST

=cut
