#!/usr/bin/perl -w
############################################################
#
# $Id: matrix-scan,v 1.37 2006/11/14 06:21:56 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################
## TO DO:  calcualte and display residue priors for each matrix, according to the background
## TO DO: add an option -t to select the top scores or each sequence
## TO DO: add -return rank + uth and lth on this field. This should return the rank per sequence, and thus allow tos elect the X top scores. 
## TO DO: add an option to sort hits either by position or by score
## TO DO: add a pseudo-weight to the bg odel (for the time being, it only affects the matrix)

## use strict;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "RSA.seq.lib";

use RSAT::feature;
use RSAT::matrix;
use RSAT::MarkovModel;

=pod

=head1 NAME

matrix-scan

=head1 DESCRIPTION

Scan sequences with one or several position-specific scoring matrices
(PSSM) to identify instances of the corresponding motifs (putative
sites). This program supports a variety of background models
(Bernoulli, Markov chains of any order).

=head1 AUTHORS

=item Jean Valery Turatsinze jturatsi@scmbb.ulb.ac.be

=item Jacques van Helden jvanheld@scmbb.ulb.ac.be

=head1 CATEGORY

= over

=item sequences

=item pattern matching

=item PSSM

=back

=head1 USAGE

matrix-scan -m matrixfile [-i inputfile] [-o outputfile] [-v]
    [-bgfile backgroundfile|-bgorder #]

=head1 INPUT FORMATS

=over

=head2 Sequence file

All the formats supported in RSAT can be used as input (default: fasta).  


=head2 Matrix file

The matrix format is specified with the option -matrix_format.  Supported :
consensus,gibbs,meme,tab. Default : tab.

=back

=head1 OUTPUT FORMAT

The output is a tab-delimited file, with one row per match. This file
can directly be used as input for the program I<feature-map>.


=head1 SCORING SCHEME

The program scans the input sequences with a position-specific scoring
matrix (PSSM) by selecting, at each position, a sequence segment (S)
of the same length as the matrix, and assigning a score to this
segment.

The secgment score (weight) is calculated according to the theory
developed by Jerry Hertz and Gary Stormo, but with the capability to
use Markov chain-based background models, as prposed by Thijs et
al. (2001).


The weight of a sequence segment (Ws) is calculated as the log-ratio
between two probabilities:

=item I<Ws = log[P(S|M)/P(S|B)]>

where

=over

=item I<proba_M = P(S|M)>: 

The probability to generate the sequence segment given the matrix.

=item I<proba_B = P(S|B)>: 

The probability to generate the sequence segment given the background
model.

=back

By default, the program uses natural logarithms, but the option -base
allows to specify any alternative base (e.g. 2 to obtain bit units);


=head1 BACKGROUND MODELS

=over

An essential parameter of any pattern detection approach is the choice
of an appropriate background model. This model is used to estimate the
probability for each site to occur by chance, rather than as an
instance of the motif.

The program matrix-scan supports Markov models of arbitrary order as
background models. A Markov model of order m means that the
probability of each residue depends on the m preceding residues in the
sequence. Note that a Markov model of order 0 corresponds to a
Bernoulli model, since eahc residue is independent from the preceding
ones.

A variety of options for specifying the background model.

=over

=item I<-bgfile>

This option allows to enter the background model from a background
model file. Background model files are tab-delimited files containing
the specification of oligonucleotide frequencies. A Markov model of
order m=k-1 is automatically obtained from the frequencies of
oligonucleotides of length k. There is thus no need to use the option
-markov when the background model is secified with a bg file.

The RSAT data folder contains pre-calibrated background model files
for all the supported organisms.

$RSAT/data/genomes/My_organism/oligo-frequencies/

=item I<-bginput>

The backgound model is calculated from the whole set of input
sequences. This option requires to specify the order of the background
model with the option -markov.

=item I<-window>

The background model is calculated locally at each step of the scan,
by computing transition frequencies from a sliding window centred
around the considered segment. The model is thus updated at each
scanned position. This model is called "adaptive". Note that the
sliding window must be large enough to train the local Markov
model. The required sequence length increases exponentially with the
Markov order. This option is thus usually suitable for short order
models only (-markov 0 to 1).

=back


=back

=head1 REFERENCES

=over

1. Hertz, G.Z. and G.D. Stormo, Identifying DNA and protein patterns
   with statistically significant alignments of multiple
   sequences. Bioinformatics, 1999. 15(7-8): p. 563-77.

2. Hertz, G.Z., G.W. Hartzell, 3rd, and G.D. Stormo, Identification of
   consensus patterns in unaligned DNA sequences known to be
   functionally related. Comput Appl Biosci, 1990. 6(2): p. 81-92.

3. Thijs, G., et al., A higher-order background model improves the
   detection of promoter regulatory elements by Gibbs
   sampling. Bioinformatics, 2001. 17(12): p. 1113-22.

=back

=cut


################################################################
## Main package
    package main;
{

    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();
    $decimals=2;
    
    %main::infile = ();
    %main::outfile = ();

    @main::matrix_files = ();
    @matrices = ();

    $markov = -1; ## To make the distinction with 0, which is a valid value for the markov order
    $window = -1; 
    $bg_method = "";

    $bg_in_format = "oligo-analysis";
    $bg_out_format = "tab";
    $sequence_number = 0;
    $sum_seq_len = 0;
    $main::base=exp(1); ## Base for the logarithms
    $main::both_strands = 0;
    $main::sum_seq_len = 0;
    $main::origin = 0;
    $main::pseudo_counts = 1;
    $main::equi_pseudo = 0;
    $main::matrix_format = "tab";
    $main::seq_format = "fasta";
    $main::verbose = 0;
#    $main::in = STDIN;
#    $main::out = STDOUT;
    
    ## Threshold parameters
    local %lth = (); # lower threshold values
    local %uth = (); # upper threshold values
    @supported_thresholds = qw ( score normw proba_M proba_B rank );
    $supported_thresholds = join ",", @supported_thresholds;
    %supported_threshold = ();
    foreach my $thr (@supported_thresholds) {
	$supported_threshold{$thr} = 1;
    }

    ## Treatment of N characters
    %supported_n_treatment = (skip=>1, score=>1);
    $supported_n_treatment = join ",", keys %supported_n_treatment;
    $n_treatment = "score";

    ## Return fields
    %supported_return_fields = (
				sites=>1,
				rank=>1,
				limits=>1,
				normw=>1,
				matrix=>1,
				freq_matrix=>1,
				weight_matrix=>1,
				bg_model=>1,
				);
    $supported_return_fields = join (",", sort(keys( %supported_return_fields)));

    &ReadArguments();
    
    ################################################################
    #### check argument values


    &RSAT::error::FatalError("You must specify the method for bagkground estimation (an option among -bgfile, -bginput, -window)") unless ($bg_method);

    ## Calculate only once the denominator for the logarithms
    $main::log_base = log($base);

    ## Return fields
    if (scalar(keys(%return_fields)) < 1) {
	$return_fields{sites} = 1;
    } else {
	foreach my $field (keys(%return_fields)) {
	    $return_fields{$field} = 1;
	}
    }
    if ((defined($uth{normw})) || (defined($lth{normw}))) {
	$return_fields{normw} = 1;
    }
    if ((defined($uth{rank})) || (defined($lth{rank}))) {
	$return_fields{rank} = 1;
    }


    ## normw is incompatible with sliding windows
    if (($return_fields{normw}) && ($bg_method eq "window")) {
      &RSAT::message::Warning("The normw computation cannot be done with a sliding window. Normw will not be returned.");
      undef($return_fields{normw});
    }

    ## weight_matrix is incompatible with orders > 0
    if (($return_fields{weight_matrix}) && ($markov > 0)) {
      &RSAT::message::Warning("The concept of weight matrix is incompatible with higher order Markov chains. Weight matrix will not be returned.");
      undef($return_fields{weight_matrix});
    }

    ################################################################
    ## Check that there is at least one input matrix
    unless (scalar(@matrix_files >= 1)) {
	&RSAT::error::FatalError("You must specify at least one matrix file.");
    }


    ################################################################
    ### open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ## Background model specification
    local $bg_model = new RSAT::MarkovModel();

    if ($main::both_strands) {
	$bg_model->set_attribute("strand", "insensitive");
    } else {
	$bg_model->set_attribute("strand", "sensitive");
    }
    $bg_model->set_attribute("n_treatment", $n_treatment);

    if ($infile{bg}) {
	## Read background model from a file
	&RSAT::message::TimeWarn(join("\t", "Reading background model from file", $infile{bg})) 
	    if ($main::verbose >= 2);
	$bg_model->load_from_file($infile{bg}, $bg_in_format);
	$bg_model->check_missing_transitions();

#      &RSAT::message::Debug($bg_model->to_string($bg_out_format)) if ($main::verbose >= 0);
    } elsif ($main::markov >= 0) {
	$bg_model->set_attribute("order", $main::markov);
	if (($main::window >= 0) && ($main::window < $main::markov+1)) {
	    &RSAT::error::FatalError(join("", 
					  "Window size (",
					  $main::window,
					  ") must be larger than Markov order + 1 (",
					  $main::markov."+1)."));
	}

	## TO DO: read the sequences once to determine prior frequencies, in
	## order to set the pseudo-weight distribution

	################################################################
	## If the model is taken from the whole set of input sequences, read them
	## first without scanning, just to calculate the model
	if ($bg_method eq "input") {
	    unless ($main::infile{input}) {
		&RSAT::error::FatalError("The option -bg_input requires to specify an input file (STDIN is not supported with this option.");
	    }
	    my ($in, $input_dir) = &OpenInputFile($main::infile{input});
	    while ((($current_seq, $seq_id) = &ReadNextSequence($in, $seq_format, $input_dir, "",$mask)) &&
		   (($current_seq ne "") || ($seq_id ne ""))) {
		
		## Sequence length
		$current_seq = lc($current_seq);
		$bg_model->calc_from_seq($current_seq, add=>1);
		
	    }
	    close $in;
	    $bg_model->check_missing_transitions();
	}
    } else {
	&RSAT::error::FatalError("You should either define the Markov order (-markov) or specify a file (-bgfile) for the background model.");
    }
    
    
    ################################################################
    ## Read the position-specific scoring matrices
    ################################################################
    ## Set prior matrix frequencies from the bg model and calculate
    ## derived statistics
    my %prior = $bg_model->get_attribute("suffix_proba");
    &RSAT::message::TimeWarn(join("\t", "PRIOR", join(" ", %prior))) if ($main::verbose >= 2);
    foreach my $matrix_file (@matrix_files) {
	my ($matrix_name) = &RSAT::util::ShortFileName($matrix_file);
	$matrix_name =~ s/\.\S+$//; ## suppress the extensin from the file name
	my $matrix = new RSAT::matrix();
	$matrix->readFromFile($matrix_file, $matrix_format);
	$matrix->set_attribute("matches", 0); ## Initialize the match counter
	$matrix->set_attribute("pseudo", $pseudo_counts);
	$matrix->set_attribute("equi_pseudo", $main::equi_pseudo);
	$matrix->set_attribute("file", $matrix_file);
	$matrix->set_attribute("n_treatment", $n_treatment);
	$matrix->set_attribute("name", $matrix_name);
	$matrix->push_attribute("parameters", "pseudo");
	$matrix->index_alphabet();

	## Check that the matrix width is smaller than markov order + 1
	my $matrix_width = $matrix->ncol();
	my $markov_order = $bg_model->get_attribute("order");
	if ($matrix_width < $markov_order + 1) {
	    &RSAT::error::FatalError(join (" ", 
					   "Markov order (".$markov_order.")",
					   "is too large for matrix",
					   $matrix->get_attribute("name"),
					   "of width ".$matrix_width."."));
	}

	## Calculate min and max values for P(S|M)
	$matrix->proba_range();

	## Set the matrix prior
	$matrix->setPrior(%prior);
	&RSAT::message::TimeWarn(join("\t", "Setting matrix priors for matrix", 
				      $matrix->get_attribute("name"),
				      join(" ", $matrix->getPrior()),
				      )) if ($main::verbose >= 2);
	## Calculate min and max weight values
	my ($Wmin, $Wmax, $Wrange) = $matrix->weight_range();
	&RSAT::message::TimeWarn(join("\t", "Calculated weight range for matrix", 
				      $matrix->get_attribute("name"), 
				      $Wmin, $Wmax, $Wrange,
				      )) if ($main::verbose >= 2);

	push @matrices, $matrix;

	&RSAT::message::TimeWarn(join("\t", "read matrix", 
				      scalar(@matrices), 
				      $matrix->get_attribute("name"),
				      $matrix->get_attribute("file")
				      )) if ($main::verbose >= 2);
    }

    ################################################################
    #### print verbose
    &Verbose() if ($main::verbose);

    ## Print header
    print $out "#", join ("\t", 
			  "seq_id",
			  "ft_type",
			  "ft_name",
			  "strand",
			  "start",
			  "end",
			  "sequence",
			  "weight",
			  "proba_M",
			  "proba_B",
			  );
    print $out "\tnormw" if ($return_fields{normw});
    print $out "\trank" if ($return_fields{rank});
    print $out "\n";

    ################################################################
    ##### Scan the sequences
    my ($in, $input_dir) = &OpenInputFile($main::infile{input});
    while ((($current_seq, $seq_id) = &ReadNextSequence($in, $seq_format, $input_dir, "",$mask)) &&
	   (($current_seq ne "") || ($seq_id ne ""))) {

	## If the rank is required, it is calculated for each input sequence independently
	local @matches = (); ## Only used whe the rank of the site is required
	local %matches_per_matrix = ();

	## Sequence length
	$current_seq = lc($current_seq);
        $sequence_number++;
        my $seq_len = length($current_seq);
	$sum_seq_len += $seq_len;

	## Calculate the origin
	$orig_pos = 0;
	if (($main::origin <  0) || ($main::origin eq "-0")) {
	    $orig_pos = $seq_len + $main::origin + 1; 
	} else {
	    $orig_pos = $main::origin;
	}

	################################################################
	## Report sequence limits
	&PrintSequenceLimits($seq_id, $seq_len, $orig_pos) if ($return_fields{"limits"});

	################################################################
	## Calculate background model from the current sequence
	my $window_offset = 0;
	if (($main::markov >= 0) && ($bg_method ne "input")){
	    if ($main::window >= $main::markov + 1) {
		if ($main::window > $seq_len) {
		    &RSAT::message::Warning(join("\t",
						 $seq_id,
						 "sequence length",
						 $seq_len,
						 "smaller than sliding window size",
						 $main::window,
						 )) if ($main::verbose >= 2);
		    $bg_model->calc_from_seq($current_seq);
		} else {
		    ## initialize the model with the first window
		    $bg_model->calc_from_seq(substr($current_seq,0,$main::window));
		}
	    } else {
		## calculate the model from the entire current sequence
		$bg_model->calc_from_seq($current_seq);
	    }
	}

	################################################################
	## Detect sites
	&RSAT::message::TimeWarn(join ("\t", "Scanning sequence", $sequence_number,  "len=".$seq_len, "orig=".$orig_pos,  $seq_id))
            if ($main::verbose >= 2);
	if ($return_fields{"sites"}) {
	    my $n_containing_region = 0;
	    for my $pos (1..$seq_len) {

		## Update background model if required
		if (($main::window > 0) &&
		    ($pos > $main::window/2) &&
		    ($pos + $main::window <= $seq_len)) {
		    my $added_word = substr($current_seq, $window_offset + $main::window - $main::markov, $markov+1);
		    my $deleted_word = substr($current_seq, $window_offset, $markov+1);
		    $bg_model->two_words_update($added_word, $deleted_word, $window_offset);
		    $window_offset++;
		}

		## Detect sites
		foreach my $matrix (@matrices) {
		    my $ncol = $matrix->{ncol};
		    next if ($seq_len - $pos +1 < $ncol);
		    my $segment = substr($current_seq, $pos-1, $ncol);

		    ## Skip N-containing segments
		    if (($n_treatment eq "skip") &&
			($segment =~ /n/i)) {
			unless ($n_containing_region) {
			    ## Start of an N-containing region
			    &RSAT::message::Info(join("\t", "N-containing segment start at position", $pos))
				if ($main::verbose >= 3);
			}
			$n_containing_region = 1;
			next;
		    }

		    ## Report the end of the N-containing region
		    if (($n_treatment eq "skip") && ($n_containing_region)) {
			&RSAT::message::Info(join("\t", "N-containing segment ended at position", $pos -1))
			    if ($main::verbose >= 3);
			$n_containing_region = 0;
		    }

		    ## TO DO: test if this piece of code can be
		    ## optimized by passing the pointer rather than the
		    ## whole matrix
		    &score_segment($segment, $matrix, $seq_id, $pos, "D");
		    if ($main::both_strands) {
			&score_segment( &ReverseComplement($segment),$matrix, $seq_id, $pos, "R");
		    };
		}
	    }
	}

	################################################################
	## Return ranked matches
	if ($return_fields{rank}) {
	    &RSAT::message::TimeWarn("Ranking matches for sequence", $seq_id) if ($main::verbose >= 2);
	    foreach my $matrix (@matrices) {
		
	      #		my @ranked_matches = sort {$b->get_attribute('score') <=> $a->get_attribute('score')} @matches;

	      unless (defined(@{$matches_per_matrix{$matrix->get_attribute('name')}})) {
		## Sort the matches per score
		&RSAT::message::Info("No match for matrix", "matrix", 
				      $matrix->get_attribute('name'),
				      "in sequence",
				      $seq_id,
				     ) if ($main::verbose >= 3);
		
		next;
	      }
	      
	      ## Sort the matches per score
	      &RSAT::message::Info("Ranking", scalar(@{$matches_per_matrix{$matrix->get_attribute('name')}}), 
				    "matches for matrix",
				    $matrix->get_attribute('name'),
				    "in sequence",
				    $seq_id,
				   ) if ($main::verbose >= 3);

	      my @ranked_matches = 
		sort {$b->get_attribute('score') <=> $a->get_attribute('score')} 
		  @{$matches_per_matrix{$matrix->get_attribute('name')}};
	      
		my $rank = 0;
		foreach my $match (@ranked_matches) {
		    $rank++;
		    $match->force_attribute('rank', $rank);
		    next if ((defined($lth{rank})) && ($rank < $lth{rank}));
		    &print_match($match); $matrix->{matches}++;
		    last if ((defined($uth{rank})) && ($rank >= $uth{rank}));
		}
	    }
	}
    }
    close $in if ($main::infile{input});
    
    
    ################################################################
    ## Print additional information

    ################################################################
    ## Report the PSSM Matrices


    ## Print summary statistics of each matrix
    print $main::out ";\n; Matrices\n";
    print $out join ("\t", ";", 
		     "name",
		     "ncol",
		     "nrow",
		     "pseudo",
		     "Pmin",
		     "Pmax",
		     "Wmin",
		     "Wmax",
		     "Wrange",
		     "prior",
		     ), "\n";
    foreach my $matrix (@matrices) {
	print $out join ("\t", ";", 
			 $matrix->get_attribute("name"),
			 $matrix->get_attribute("ncol"),
			 $matrix->get_attribute("nrow"),
			 $matrix->get_attribute("pseudo"),
			 sprintf("%5.2g", $matrix->get_attribute("min(P(S|M))")),
			 sprintf("%5.2g", $matrix->get_attribute("max(P(S|M))")),
			 sprintf("%.3f", $matrix->get_attribute("Wmin")),
			 sprintf("%.3f", $matrix->get_attribute("Wmax")),
			 sprintf("%.3f", $matrix->get_attribute("Wrange")),
			 );
	my %prior = $matrix->getPrior();
	print $out "\t";
	foreach my $letter (sort keys %prior) {
	    printf $out "%s:%.3f ", $letter, $prior{$letter};
	}
	print $out "\n";
    }
    
    
    ## Return count matrices
    if ($return_fields{matrix}) {
      foreach my $matrix (@matrices) {
	print $out ";\n; Count matrix\t", $matrix->get_attribute("name"), "\n";
	    print $out $matrix->toString(col_width=>(7), decimals=>0, type=>"counts",format=>"tab", comment_string=>";");
	}
    }

    ## Return frequency matrices
    if ($return_fields{matrix}) {
	foreach my $matrix (@matrices) {
	    print $out ";\n; Frequency matrix\t", $matrix->get_attribute("name"), "\n";
	    print $out $matrix->toString(col_width=>(7), decimals=>0, type=>"frequencies",format=>"tab", comment_string=>";");
	}
    }

    ## Return weight matrices
    if ($return_fields{weight_matrix}) {
	foreach my $matrix (@matrices) {
	    print $out ";\n; Weight matrix\t", $matrix->get_attribute("name"), "\n";
	    print $out $matrix->toString(col_width=>(7), decimals=>3, type=>"weights", format=>"tab", comment_string=>";");
	}
    }

    ## Report background model
    if ($return_fields{bg_model}) {
	print $out ";\n; Background model\n";
	print $out $bg_model->to_string($bg_out_format, comment_string=>"; ");
    }

    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {

	## Sequence statistics
	printf $main::out "; %-21s\t%s\n", "Number of sequences scanned", $sequence_number;
	printf $main::out "; %-21s\t%s\n", "Sum of sequence lengths", $sum_seq_len;

	## Matching statistics
	print $main::out "; Matches per matrix\n";
	my $total_matches = 0;
	foreach my $matrix (@matrices) {
	    my $matches = $matrix->get_attribute("matches");
	    $total_matches += $matches;
	    printf $main::out ";\t%-15s\t%d\n", $matrix->get_attribute("name"), $matches;
	}
	printf $main::out ";\t%-15s\t%d\n", "Total matches", $total_matches;
	
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    

    ################################################################
    ###### close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
#    foreach my $a (0..$#ARGV) {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Background model file
=pod

=item B<-bgfile background_file>

Background model file.

=cut
	} elsif ($arg eq "-bgfile") {
	  &RSAT::error::FatalError("Options -bgfile, -bginput and -window are mutually exclusive") if ($main::bg_method);
	  $main::bg_method = "file";
	  $main::infile{bg} = shift(@arguments);
	  &RSAT::error::FatalError("The options -markov and -bgfile are mutually exclusive.") 
	    if ($main::markov >= 0);
	  
	  ## Background calculated from the input sequence set
=pod

=item B<-bginput>

Calculate background model from the input sequence set.

=cut
	} elsif ($arg eq "-bginput") {
	  &RSAT::error::FatalError("Options -bgfile, -bginput and -window are mutually exclusive") if ($main::bg_method);
	  $main::bg_method = "input";
	  &RSAT::error::FatalError("The options -bginput and -window are mutually exclusive.") 
	    if ($main::window >= 0);
	  &RSAT::error::FatalError("The options -bginput and -bgfile are mutually exclusive.") 
		if defined($main::infile{bg});
	  
	  ## Calculate background model from the input sequence
=pod

=item B<-markov>

Order of the markov chain for the background model. 

This option is incompatible with the option -bgfile. 

=cut
	} elsif ($arg eq "-markov") {
	    $main::markov = shift(@arguments);
	    &RSAT::error::FatalError("Markov order must be a natural number.") 
		unless &RSAT::util::IsNatural($main::markov);
	    &RSAT::error::FatalError("The options -markov and -bgfile are mutually exclusive.") 
		if defined($main::infile{bg});


=pod

=item B<-window>

Size of the sliding window for the background model calculation. 

=cut
	} elsif ($arg eq "-window") {
	  &RSAT::error::FatalError("Options -bgfile, -bginput and -window are mutually exclusive") if ($main::bg_method);
	  $main::bg_method = "window";
	  $main::window = shift(@arguments);
	  &RSAT::error::FatalError("Window size must be a natural number.") 
	    unless &RSAT::util::IsNatural($main::window);
	  &RSAT::error::FatalError("The options -window and -bgfile are mutually exclusive.") 
	    if defined($main::infile{bg});
	  
	  
	    ## Matrix file
=pod

=item B<-m matrixfile>

Matrix file. 

This argument can be used iteratively to scan the sequence with
multiple matrices.

=cut
	} elsif ($arg eq "-m") {
	    push @matrix_files, shift(@arguments);
#	    $main::infile{matrix} = shift(@arguments);
	    
# 	    ## Matrix name
# =pod
#
# =item B<-mname matrix_name>
#
# Matrix name. 
#
# =cut
# 	} elsif ($arg eq "-mname") {
# 	    $main::matrix_name = shift(@arguments);
	    
	    ## Sequence format
=pod

=item B<-seq_format sequence_format>

Sequence format. 

=cut
	} elsif ($arg eq "-seq_format") {
	    $seq_format = shift(@arguments);
	    
	    ## Matrix format
=pod

=item B<-matrix_format matrix_format>

Matrix format. 

=cut
	} elsif ($arg eq "-matrix_format") {
	    $matrix_format = shift(@arguments);
	    
	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);

	    ## mask
=pod

=item B<-mask upper|lower>

Mask lower or uppercases, respecively, i.e. replace selected case by N
characters.

=cut

	} elsif ($arg eq "-mask") {
	    $main::mask = shift(@arguments);
	    &CheckMask($main::mask);	    

=pod 

=item B<-n [skip|score]>

Treatment of N characters. These characters are often used in DNA
sequences to represent undefined or masked nucleotides.

=over

=item I<skip>

N-containing regions are skipped.

=item I<score>

N-containing regions are scored. The probability of an N is 1 for both
the background model and the matrix. The N residues will thus
contribute neither positively nor negatively to the weight score of
the N-containing fragment. This option can be useful to detect sites
which are at the border of N-containing regions, or in cases there are
isolated N in the sequences.

=back

=cut
	} elsif ($arg eq "-n") {
	    $main::n_treatment = shift(@arguments);
	    &RSAT::error::FatalError("Invalid value for the -n option. supported: ".$supported_n_treatment)
	      unless ($supported_n_treatment{$main::n_treatment});



	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ## Pseudo weight
=pod

=item B<-pseudo pseudo_counts>

Pseudo-weight.

=cut
	} elsif ($arg eq "-pseudo") {
	    $main::pseudo_counts = shift(@arguments);
	    &RSAT::error::FatalError(join("\t", $main::pseudo_counts, 
					  "Invalid value for a pseudo-weight. Must be a positive real number."))
		unless ((&RSAT::util::IsReal($main::pseudo_counts) )
			&& ($main::pseudo_counts >= 0));


	    ## Equiprobable distribution of the pseudo-weight
=pod

=item B<-equi_pseudo>

If this option is called, the pseudo-weight is distributed in an equiprobable
way between residues.

By default, the pseudo-weight is distributed proportionally to residue priors.

=cut

	} elsif ($arg eq "-equi_pseudo") {
	    $main::equi_pseudo = 1;

	## Origin
=pod

=item B<-origin pos>

Define pos as the origin for the calculation of positions.

-origin -0 defines the end of each sequence as the origin. The matching
positions are then negative values, providing the distance between the match
and the end of the sequence.

=cut

	} elsif ($arg eq "-origin") {
	    $main::origin = shift(@arguments);
	    &RSAT::error::FatalError("$main::origin. Invalid origin, should be a natural number.")
		unless (($main::origin eq "-0") || (&RSAT::util::IsNatural($main::origin)));


	    ## base for the logarihtms
=pod

=item	B<-base #>

Base for the logarithms (default: $base)

=cut
	} elsif ($arg eq "-base") {
	    $base = shift @arguments;
	    &RSAT::error::FatalError("base should be a real number") unless (&IsReal($base));
	    &RSAT::error::FatalError("base should be larger than 1") if ($base <= 1);

	    ## Number of decimals for the score
=pod

=item B<-decimals #>

Number of decimals displayed for the score.

=cut

	} elsif ($arg eq "-decimals") {
	    $decimals = shift @arguments;
	    &RSAT::error::FatalError("decimals should be a positive integer") unless ((&IsNatural($decimals)) && ($decimals >= 0));

	    ## Thresholds
=pod
    
=item	B<-lth param lower_threshold>

=item	B<-uth param upper_threshold>

Threshold on some parameter (-lth: lower, -uth: upper threshold). 

Supported threshold fields : score normw proba_M proba_B rank

=cut
	    
	    ### Lower threshold
	} elsif ($arg eq "-lth") {
	    my $thr_field = shift(@arguments);
	    my $thr_value =  shift(@arguments);
	    unless ($supported_threshold{$thr_field}) {
		&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
	    }
	    &RSAT::error::FatalError($thr_value, "Invalid value for a lower threshold. Should be a real number. ") 
	      unless (&RSAT::util::IsReal($thr_value));
	    $lth{$thr_field} = $thr_value;

	    ### Upper threshold
	} elsif ($arg eq "-uth") {
	    my $thr_field = shift(@arguments);
	    my $thr_value = shift(@arguments);
	    unless ($supported_threshold{$thr_field}) {
		&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
	    }
	    &RSAT::error::FatalError($thr_value, "Invalid value for an upper threshold. Should be a real number. ") 
	      unless (&RSAT::util::IsReal($thr_value));
	    $uth{$thr_field} = $thr_value;


	    ## Scan both strands
=pod

=item B<-2str>

Scan both strands for DNA sequences.

=cut
	} elsif ($arg eq "-2str") {
	    $main::both_strands = 1;

	    ## Scan direct strand only
=pod

=item B<-1str>

single-strand search for DNA sequences.

=cut
	} elsif ($arg eq "-1str") {
	    $main::both_strands = 0;


	    ## Return fields
=pod

=item B<-return return_fields>

List of fields to return. 

Supported fields: sites,ranks,limits,normw,bg_model,matrix,freq_matrix,weight_matrix

=over

=item B<sites:> Matching sites. 

Return the osition of matching sites in aformat which can be sed as
input by I<feature-map>.

=item B<rank:> Rank.

Sort the sites per decreasing values of score (weight), and return the
rank value. The rank is calculated independently for each sequence and
each matrix. 

A common usage of the rank is to select the top scoring site per
matrix and per sequence (-th rank 1) or the 3 top scoring sites per
matrix and per sequence (-uth rank 3). 

=item B<limits:> limits (start, end) of the input sequences. 

This is useful for drawing feature maps with sequences of different
lengths.

=item B<normw:> normalized weights. 

Normailzed weights are calculated according to Thijs' formula : normw
= (W -Wmin)/(Wmax - Wmin). Note that Wmin and Wmax are approximated
using a Bernoulli model, for reasons of commputational efficiency.

=item B<bg_model:> Background model. 

Transition matrix of the background model. Note that this option only
makes sense for fixed background models (-bgfile or -bginput), since
when the background model is adaptive (-mindow), the transition matrix
changes along he sequence.

=back

=cut
        } elsif ($arg eq "-return") {
	    $arg = shift (@arguments);
            chomp($arg);
            my @fields_to_return = split ",", $arg;
            foreach my $field (@fields_to_return) {
		$field = lc($field);
                if ($supported_return_fields{$field}) {
                    $return_fields{$field} = 1;
                } else {
                    &RSAT::error::FatalError(join("\t", $field, "Invalid return field. Supported:", $supported_return_fields));
		}
	    }



	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


}

################################################################
#### verbose message
sub Verbose {

    ## Report the command line
    print $main::out "; matrix-scan ";
    &PrintArguments($main::out);

    ## Input files
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
	print $main::out "; Matrix files\n";
	for my $m (0..$#matrix_files) {
	    printf $out ";\tmatrix %d\t%s\n", $m+1, $matrix_files[$m];
	}

    }
    printf $main::out "; %-21s\t%s\n", "Sequence format", $seq_format;

    ## Output files
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }

    ## Pseudo counts
    printf $main::out "; %-21s\t%s\n", "Pseudo counts", $pseudo_counts;

    ## Background model
    printf $main::out "; Background model\n";
    my $order = $bg_model->get_attribute("order");
    printf $main::out ";\t%-14s\t%s\n", "Method", $bg_method;
    if ($order == 0) {
	printf $main::out ";\t%-14s\n", "Bernoulli model (order=0)";
    } else {
	printf $main::out ";\t%-14s\t%d\n", "Markov order", $order;
    }
    printf $main::out ";\t%-14s\t%s\n", "Strand", $bg_model->get_attribute("strand");
    if ($window > 0) {
	printf $main::out ";\t%-14s\t%d\n", "Background window", $window;
    }

    my $missing_transitions = $bg_model->get_attribute("missing_transitions");
    if ($missing_transitions > 0) {
      printf $main::out ";\t%-14s\t%d %s\n", "WARNING", , $missing_transitions, "missing transitions. You should reduce the Markov order";
    }


    ## Thresholds
    my %th_keys = (%lth, %uth);
    print $main::out "; Thresholds\tlower\tupper\n";
    foreach $f (sort keys %th_keys) {
	print $main::out ";\t$f";
	if (defined($lth{$f})) {
	    printf $main::out "\t%-5g", $lth{$f};
	} else {
	    print $main::out "\tNA";
	}
	if (defined($uth{$f})) {
	    printf $main::out "\t%-5g", $uth{$f};
	} else {
	    print $main::out "\tNA";
	}
	print $main::out "\n";
    }


}


################################################################
=pod

=head1 INTERNAL PROCEDURES

=cut

################################################################
=pod

=item B<score_segment>

Assign a score to a sequence segment and print it if it passes the
thresholds. Return value is 1 if the segment passed the thresholds.

=cut
sub score_segment {
    my ($segment, $matrix, $seq_id, $pos, $strand) = @_;
    my $ncol = $matrix->{ncol};
    my $proba_M = 1;
    my $proba_B = 1;

    $proba_M = $matrix->segment_proba($segment);
    return(0) unless (&check_thresholds("proba_M", $proba_M));

    $proba_B = $bg_model->segment_proba($segment);
    return(0) unless (&check_thresholds("proba_B", $proba_B));


    ## Calculate segment weight and  normalized weight
    my $score = "NA";
    my $normw = "NA";
    if (($proba_M > 0) && ($proba_B > 0)) {
	$score = sprintf("%.${decimals}f", log($proba_M/$proba_B))/$log_base;

	if ($return_fields{normw}) {
	  $normw = sprintf("%6.4f", ($score - $matrix->{'Wmin'})/($matrix->{'Wrange'}));
	}
    } elsif ($proba_M == 0) {
	if ($proba_B > 0) {
	    $score = "-Inf";
	    if ($return_fields{normw}) {
		$normw = 0;
	    }
	}
    }

#    &RSAT::message::Debug("scoring segment", $segment, $seq_id, $pos, $strand, 
#			  $proba_M , $proba_B, $score) if ($main::verbose >= 10);

    return(0) unless (&check_thresholds("score", $score));
    return(0) unless (&check_thresholds("normw", $normw));

    ## Calculate information
#    my $info = $score * $proba_B;
#    return(0) unless (&check_thresholds("info", $info));
    
    ## Calculate start and end position
    my $start_pos = $pos - $orig_pos;
    my $end_pos = $start_pos + $ncol -1;

#    &RSAT::message::Debug("Creating a fteaure for new match") if ($main::verbose >= 10);
    my $match = new RSAT::feature();
    $match->set_attribute('seq_name', $seq_id);
    $match->set_attribute('ft_type', 'site');
    $match->set_attribute('feature_name', $matrix->get_attribute('name'));
    $match->set_attribute('strand',$strand);
    $match->set_attribute('start',$start_pos);
    $match->set_attribute('end',$end_pos);
    $match->set_attribute('description',uc($segment));
    $match->set_attribute('score',$score);
    $match->set_attribute('proba_M',$proba_M);
    $match->set_attribute('proba_B',$proba_B);
    $match->set_attribute('normw',$normw) if ($return_fields{normw});

    if ($return_fields{rank}) {
#	if (defined($uth{rank})) {
#	    my @ranked_matches = sort 
#	    {$b->get_attribute('score') <=> $a->get_attribute('score')}
#	    (@ranked_matches, $match);
#	    @ranked_matches = @ranked_matches[1..$uth{rank}];
#	} else {
	    push @matches , $match;
	    push @{$matches_per_matrix{$matrix->get_attribute('name')}} , $match;
#	}
    } elsif ($main::return_fields{sites}) {
	&print_match($match); $matrix->{matches}++;
    }
    return(1);
}

################################################################
=pod

=item B<print_match>

Print the matching site.

=cut

sub print_match {
    my ($match) = @_;

    print $out join ("\t", 
		     $match->get_attribute('seq_name'),
		     $match->get_attribute('ft_type'),
		     $match->get_attribute('feature_name'),
		     $match->get_attribute('strand'),
		     $match->get_attribute('start'),
		     $match->get_attribute('end'),
		     $match->get_attribute('description'),
		     $match->get_attribute('score'),
		     sprintf("%5.2g\t%5.2g",
			     $match->get_attribute('proba_M'),
			     $match->get_attribute('proba_B')
			     )
		     );
#			 "site",
#			 $matrix->{name},
#			 $strand,
#			 $start_pos,
#			 $end_pos,
#			 $segment,
#			 $score,
#			 sprintf("%5.2g\t%5.2g",
#				 $proba_M,
#				 $proba_B,
#				)
    
    print $out "\t", $match->get_attribute('normw') if ($return_fields{normw});
    print $out "\t", $match->get_attribute('rank') if ($return_fields{rank});
    print $out "\n";
}

# ################################################################
# =pod

# =item B<print_match>

# Print the matching site.

# =cut

# sub print_match {
#     my ($match) = @_;

#     print $out join ("\t", 
# 		     $match->get_attribute('seq_name'),
# 		     $match->get_attribute('ft_type'),
# 		     $match->get_attribute('feature_name'),
# 		     $match->get_attribute('strand'),
# 		     $match->get_attribute('start'),
# 		     $match->get_attribute('end'),
# 		     $match->get_attribute('description'),
# 		     $match->get_attribute('score'),
# 		     sprintf("%5.2g\t%5.2g",
# 			     $match->get_attribute('proba_M'),
# 			     $match->get_attribute('proba_B')
# 			     )
# 		     );
# #			 "site",
# #			 $matrix->{name},
# #			 $strand,
# #			 $start_pos,
# #			 $end_pos,
# #			 $segment,
# #			 $score,
# #			 sprintf("%5.2g\t%5.2g",
# #				 $proba_M,
# #				 $proba_B,
# #				)
    
#     print $out "\t", $match->get_attribute('normw') if ($return_fields{normw});
#     print $out "\t", $match->get_attribute('rank') if ($return_fields{rank});
#     print $out "\n";
# }

################################################################
=pod

=item B<check_thresholds>

Check the lower and upper threshold for a given score. 

=cut

sub check_thresholds {
    my ($key, $value) = @_;
    if ((defined($lth{$key})) && 
	(($value eq "NA") || ($value < $lth{$key}))
       ) {
	return 0;
    }
    if ((defined($uth{$key})) && 
	(($value eq "NA") || ($value > $uth{$key}))
       ) {
	return 0;
    }
    return 1;
}


################################################################
## Print the start and end positions of the sequence
sub PrintSequenceLimits {
    my ($seq_id, $seq_len, $orig_pos) = @_;

    print $main::out join ("\t", 
			   $seq_id,
			   "limit",
			   "SEQ_START",
			   "DR",
			   1-$orig_pos,
			   1-$orig_pos,
			   ".",
			  ), "\n";
    print $main::out join ("\t", 
			   $seq_id,
			   "limit",
			   "SEQ_END",
			   "DR",
			   $seq_len-$orig_pos,
			   $seq_len-$orig_pos,
			   ".",
			  ), "\n";
}


__END__
    
=pod

=head1 SEE ALSO

=over

=item I<convert-matrix>

=item I<convert-background-model>

=item I<feature-map>

=back

=cut
