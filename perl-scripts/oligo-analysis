#!/usr/bin/perl
############################################################
#
# $Id: oligo-analysis,v 1.65 2003/12/30 15:12:31 jvanheld Exp $
#
# Time-stamp: <2003-10-21 01:06:25 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.classes";


################################################################
###### initialize parameters ##########
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;

#### background models
%supported_bg = ('upstream'=>1,
		 'upstream-noorf'=>1,
		 'intergenic'=>1
		 );
$supported_bg = join ",", sort keys %supported_bg;
    
$palindroms = 0;
$in_format = "fasta";
@output_fields = ();
@output_patterns = ();

$sum_rc = 1;
#$group_rc = 1;
$proba_occ_threshold = 1;
$proba_mseq_threshold = 1;

$markov_order = -2;
$sequence_number = 0;
$nb_possible_pos = 0;
$nb_possible_oligo = 0;
$sum_seq_length = 0;

$max_seq_verbose = 99;

### default residue probabilities      
$seq_type = "DNA";
$residue_proba{'a'} = 0.25;
$residue_proba{'c'} = 0.25;
$residue_proba{'g'} = 0.25;
$residue_proba{'t'} = 0.25;

#### read arguments ####
&ReadArguments();
   
##############################
### check parameter values ###
##############################

### check output fields
if (@output_fields == ()) { #default output is occurrence numbers
    @output_fields = ("occurrences");
    $return{'occ'} = 1;
} elsif (($return{'proba'}) || 
	 ($return{'like'}) || 
	 ($return{'ratio'})) {
    $return{'exp_freq'} = 1;
}

#### conditions which require the calculateion of the overlap coefficient
if ($return{'zscore'} && !($noov)) {
    $return{'ovlp'} = 1;
}
if ($return{'mseq'} && $return{'proba'} && !($noov)) {
    $return{'ovlp'} = 1;
}

### check oligomer length
&FatalError("You should specify an oligomer length.") unless (defined($oligo_length));
&FatalError("Oligomer length should be a natural number.") unless (&IsNatural($oligo_length));
&FatalError("Oligomer length should be strictly positive.") unless ($oligo_length > 0);

## minimum overlap distance
if ($noov) {
    $min_overlap_dist = $oligo_length;
}

### Markov order
if ($method eq "Markov chain") {
    if ($markov_order < 0){
	if ($oligo_length == 1) {
	    $markov_order = 0;
	} else {
	    $markov_order = $oligo_length + $markov_order;
	}
    }

    
    if (($markov_order > $oligo_length -2) && 
	($markov_order > 0)){ 
	&FatalError("Markov order ($markov_order) cannot be higher than word length - 2 ($oligo_length -2)"); 
    } elsif ($markov_order < 0) {
	&FatalError("invalid markov order $markov_order");
    }
}



### check input format 
&CheckInputSeqFormat($in_format);

### Pre-defined frequency tables
### for background frequency calibration
if ($background_model) {
    
    $data_dir = $supported_organism{$organism_name}->{'data'};
    
    ### localize dyad non-coding frequency file
    $method = "Frequency file";
    
    $exp_freq_file = &ExpectedFreqFile($organism_name, $oligo_length, $background_model);

#### read alphabet from a file
} elsif ($alphabet_file) {
    ($alpha) = &OpenInputFile($alphabet_file);
    while (<$alpha>) {
	next if (/^;/);
	next unless (/\S/);
	if (/^(\S)\s+(\S+)/) {
	    my $residue = $1;
	    my $freq = $2;
	    unless (&IsReal($freq)) {
		&FatalError("Invalid value for frequency: $freq. Must be a real number.");
	    }
	    unless ($freq >= 0) {
		&FatalError("Invalid value for frequency: $freq. Must be >=0.");
	    }
	    $residue_proba{$residue} = $freq;

	} else {
	    &Warning("This line does not conform the alphabet format\t$_");
	}
    }
    close $alpha;
}

#### normalize alphabet (sum must be 1)
if (($alphabet) && !($input_alphabet)) {
    my $proba_sum = 0;
    foreach my $r (keys %residue_proba) {
	$proba_sum += $residue_proba{$r};
    }
    if ($proba_sum == 0 ) {
	&FatalError("Sum of residue probabilities must be > 0");
    }
    unless ($proba_sum ==1) {
	foreach my $r (keys %residue_proba) {
	    $residue_proba{$r} /= $proba_sum;
	}
    }
}

################################################################
#### Read expected frequencies from a file

if (($method eq "Frequency file") && 
    ($return{'exp_freq'})) {    #### expected frequencies ####
    &ReadExpectedFrequencies($exp_freq_file, $sum_rc);
}

#### open sequence stream
($in, $input_dir) = &OpenInputFile($inputfile);

#### open output stream
$out = &OpenOutputFile($outputfile);

&CountOligo();

&CalcSubWordFrequencies() if (($method eq "Markov chain") || ($method eq "lexicon"));
&CalcAlphabet() if ($input_alphabet); # || ($return{'zscore'}));
&Degenerate() if ($one_var_position);
&CalcFrequencies() if (($return{'freq'}) || ($verbose >= 1) || ($method eq "Markov chain"));
&SumReverseComplements() if ($sum_rc);
#&GroupRc() if ($group_rc);
&SelectPalindroms() if ($palindroms);
&OccurrenceThreshold() if ($occurrence_threshold > 0);
&MatchingSeqThreshold() if ($mseq_threshold > 0); 
&NbPossibleOligo();
&CalcOverlapCoefficient();# if ($return{'ovlp'});
&CalcExpected() if ($return{'exp_freq'});
&CalcZscore() if ($return{'zscore'});
&CalcLikelihood() if ($return{'like'});
&CalcRatio() if ($return{'ratio'});
&CalcProba() if ($return{'proba'}) ;

if ($return{'table'}) {
    ## already printed
} elsif ($return{'distrib'}) {
    &PrintCountDistrib();
} else {
    &PrintResult();
}

if ($verbose >= 1) {
    $done_time  = `date '+%d/%m/%y %H:%M:%S %Z'`;
    print $out "; Job started $start_time";
    print $out "; Job done    $done_time";
}

close $out unless ($outputfile eq "");

exit(0);


########################################################################################
################################### SUBROUTINE DEFINITION ##############################
########################################################################################



################################################################
#### Read input sequences and count oligomers ####
sub CountOligo {
    if ($verbose >= 2) {
	&Warning(&AlphaDate()."\tCounting oligo frequencies");
    }
    
    if ($return{'table'}) {
	
	if ($seq_type eq "DNA") {
	    @possible_oligos = &all_oligos($oligo_length);
	} else {
	    @possible_oligos = sort keys %patterns;
	}

	#### print verbose
	&Verbose() if ($verbose >= 1);

    } elsif ($return{'distrib'}) {
	if ($seq_type eq "DNA") {
	    @possible_oligos = &all_oligos($oligo_length);
	} else {
	    @possible_oligos = sort keys %patterns;
	}
    }


    while ((($current_seq, $current_id, @comments) = &ReadNextSequence($in, $in_format, $input_dir, $seq_type)) &&
	   (($current_seq) || ($current_id))) {
	
	### remove tabs and blank spaces ###    
	$current_seq = &FoldSequence($current_seq,0);
	
	### statistics about sequences ###
	$sequence_number++;  
	$id_list[$sequence_number] = $current_id;
	$seq_length[$sequence_number] = length($current_seq);
	
	if ($verbose >= 3) {
	    &Warning(join "\t", &AlphaDate(),$sequence_number,  $current_id, $seq_length[$sequence_number]);
	}
	
	$sum_seq_length += $seq_length[$sequence_number];
	if ($seq_length[$sequence_number] < $oligo_length) {
	    next;
	} else {
#	    if ($sum_rc) {
#		$nb_possible_pos += 2*($seq_length[$sequence_number] + 1 - $oligo_length);
#	    } else {
		$nb_possible_pos += $seq_length[$sequence_number] + 1 - $oligo_length;
#	    }
	}
	$last_pos = $seq_length[$sequence_number] - $oligo_length; ### note: the first position has index 0	
	
	### calculate alphabet from input sequence ####
#    if (($input_alphabet) || ($return{'zscore'}) || ($method eq "Markov chain")) {
	&Warning(&AlphaDate()."\t$current_id\tcalculating alphabet") if ($verbose >= 4);
	
	for $pos (0..$seq_length[$sequence_number]-1) {
	    $letter = lc(substr($current_seq,$pos,1));
	    $residue_occ{$letter}++;
	}
#    }
	
	#### for markov chains, count trailing oligomers of length shorter than $oligo_length ####
	if ($method eq "Markov chain") {
	    for $w (1..$oligo_length - 1) {
		$subseq = lc(substr($current_seq,$seq_length[$sequence_number]-$w,$w));
		$sub_word[$w]{$subseq}->{occ}++;
	    }
	}
	
	#### count oligomers ####
	$offset = 0;
	my $current_pos = $last_pos;
	my $chunk=100000;
	
	#### the sequence is read from the end to the start, in order to progressively release memory
	while ($current_pos >=0) {
	    if ($verbose >= 3 && (($current_pos%$chunk) == 0) && ($current_pos > 0)) {
		$current_length = length($current_seq);
		&Warning( "\t$current_id\t". &AlphaDate()."\tremain to read: $current_pos");
	    }
	    
	    ### occurrences
	    $pattern_seq = lc(substr($current_seq,$current_pos,$oligo_length));
	    chop $current_seq;  ### eat the tail to release memory

	    #### prevent overlapping matches
	    if ($noov) {
		if ((&IsNatural($last_pos{$pattern_seq})) && 
		    ($last_pos{$pattern_seq} - $current_pos < $min_overlap_dist)) {
		    $patterns{$pattern_seq}->{overlaps}++;
		    $current_pos--;
		    next;
		} 
		if ($sum_rc) {
		    $rc = lc(&SmartRC($pattern_seq));
		    if ((&IsNatural($last_pos{$rc})) && 
			($last_pos{$rc} - $current_pos < $min_overlap_dist)) {
			$patterns{$rc}->{overlaps}++;
			$current_pos--;
			next;
		    }
		}

		#### substract the forbidden positions from the nb of possible positions
		$forbidden_pos = &min($min_overlap_dist-1,
				      $last_pos - $current_pos);
		$patterns{$pattern_seq}->{nb_possible_pos} -= $forbidden_pos;
		$patterns{$rc}->{nb_possible_pos} -= $forbidden_pos if ($sum_rc);
	    }
	    $patterns{$pattern_seq}->{occ}++;
	    $last_pos{$pattern_seq} = $current_pos;
	    if ($return{'pos'}) {
		push(@{$match_pos{$pattern_seq}[$sequence_number]}, $current_pos+1);
	    }
	    
	    ### matching sequences (only count first occurrence per sequence)
	    if ($return{'mseq'}) {
		if (($sum_rc==0) || ($current_mseq{lc(&SmartRC($pattern_seq))} < 1)) {
		    $current_mseq{$pattern_seq} = 1;
		}
	    }
	    $current_pos--;
	}

	#### update the counts of first occurrences
	if ($return{'mseq'}) {
	    foreach $pattern_seq (keys %current_mseq) {
		$patterns{$pattern_seq}->{mseq} += 1;
		if ($sum_rc) {
		    $rc = lc(&SmartRC($pattern_seq));
		    unless ($rc eq $pattern_seq) { ### palindroms
			$patterns{$rc}->{mseq} += 1;
		    }
		}
	    }
	    undef %current_mseq;
	}
	
	undef %last_pos;
	
	if (($return{'table'}) || ($return{'distrib'})){
	    ## summarize pattern counts
	    foreach my $pattern_seq (@possible_oligos) {
		## Assign 0 values
		unless ($patterns{$pattern_seq}->{occ} > 0 ) {
		    $patterns{$pattern_seq}->{occ} = 0;
		}
	    }
	    &SumReverseComplements() if ($sum_rc);
	    @output_patterns = sort keys %patterns;

	    if ($return{'table'}) {
		## Print table header before the first pattern counts
		unless ($header_printed) {
		    &PrintTableHeader(@output_patterns);
		    $header_printed = 1;
		}
		
		## Print patern counts for the current sequence
		print $out $current_id;
		foreach my $pattern_seq (@output_patterns) {
		    print $out "\t", $patterns{$pattern_seq}->{occ};
		}
		print $out "\n";
	    } elsif ($return{'distrib'}) {
		foreach my $pattern_seq (@possible_oligos) {
		    ## Check if no occurrences were found
		    unless ($patterns{$pattern_seq}->{occ}) {
			$patterns{$pattern_seq}->{occ} = 0;
		    }
		    ## Increment the occurrence counter
		    $distrib{$pattern_seq}{$patterns{$pattern_seq}->{occ}}++;
		}
	    }
	    undef(%patterns);
	}
	
    }
    undef $current_seq; ### release the memory occupied
    close $in;
    

    #### filter out undefined residues for DNA sequences
    if ($seq_type eq "DNA") {
	foreach $pattern_seq (keys %patterns) {
	    if ($pattern_seq =~ /[^atcg]/i) {
		$discarded_occurrences += $patterns{$pattern_seq}->{occ};
		delete $patterns{$pattern_seq};
	    }
	}
	$nb_possible_pos -= $discarded_occurrences;
	foreach $letter (keys %residue_occ) {
	    if ($letter =~ /[^atcg]/i) {
		$discarded_residues += $residue_occ;
		delete $residue_occ{$letter};
	    }
	}
    }

    if ($sequence_number < 1) {
	&FatalError("The input contained no readable sequence. The file might be empty or be wronlgy formatted."); 
    }

}

################################################################
## Print header for oligo count table
sub PrintTableHeader {
    my @output_patterns = @_;
    print $out "; seq";
    foreach my $pattern_seq (@output_patterns) {
	print $out "\t", &PatternID($pattern_seq);
    }
    print $out "\n";
}

################################################################
## Prit pattern ID, depending on the strands
sub PatternID {
    my ($pattern_seq) = @_;
    if ($sum_rc) {
	return join( "",  $pattern_seq, "|", lc(&SmartRC($pattern_seq)));
    } else {
	return $pattern_seq;
    }
}

################################################################
### sum occurrences of reverse complement patterns
sub SumReverseComplements {
    if ($verbose >= 2) {
	&Warning(&AlphaDate()."\tSumming occurrences for pairs of reverse complements");
    }
#    if ($seq_type eq "DNA") {
#	$discarded_occurrences *=2;
#    }
    foreach my $pattern_seq (keys %patterns) {
	my $rc_pattern_seq = lc(&SmartRC($pattern_seq));

	if ($rc_pattern_seq eq $pattern_seq) {
	    #### don't count twice the reverse palindroms !!!!!!!
	    $occ_2strands{$pattern_seq} = $patterns{$pattern_seq}->{occ};
	    $overlaps_2strands{$pattern_seq} = $patterns{$pattern_seq}->{overlaps};
	} else {
	    #### sum occurrences of each pattern with its reverse complement
	    $occ_2strands{$rc_pattern_seq} = $occ_2strands{$pattern_seq} = $patterns{$pattern_seq}->{occ} + $patterns{$rc_pattern_seq}->{occ};
	    $overlaps_2strands{$rc_pattern_seq} = $overlaps_2strands{$pattern_seq} = $patterns{$pattern_seq}->{overlaps} + $patterns{$rc_pattern_seq}->{overlaps};
	}
#	warn join( "\t", "HELLO", $pattern_seq, $rc_pattern_seq,  
#			   $occ_2strands{$pattern_seq} ,  $occ_2strands{$rc_pattern_seq},
#			   ), "\n" if ($main::verbose >= 10);
    }
    foreach my $pattern_seq (keys %occ_2strands) {
	$patterns{$pattern_seq}->{occ} = $occ_2strands{$pattern_seq};
	$patterns{$pattern_seq}->{overlaps} = $overlaps_2strands{$pattern_seq};
    }
    undef %occ_2strands;
    undef %overlaps_2strands;
    
    ### residue occurrences
    foreach my $residue (keys %residue_occ) {
	my $rc_residue =lc(&SmartRC($residue));
	$occ_2str{$rc_residue} = $occ_2str{$residue} = $residue_occ{$residue} + $residue_occ{$rc_residue};
    }
    foreach my $residue (keys %occ_2str) {
	$residue_occ{$residue} = $occ_2str{$residue};
    }
    undef %occ_2str;

    ### positions ###
    if (($return{'pos'}) || ($noov)) {
	for $seq (1..$sequence_number) {
	    foreach $pattern_seq (sort keys %patterns) {
		$rc_pattern_seq = lc(&SmartRC($pattern_seq));
		if ($rc_pattern_seq eq $pattern_seq) {
		    @{$m_pos_bothstrands{$pattern_seq}[$seq]} = @{$match_pos{$pattern_seq}[$seq]};
		} else {
		    @{$m_pos_bothstrands{$pattern_seq}[$seq]} = (@{$match_pos{$pattern_seq}[$seq]},@{$match_pos{$rc_pattern_seq}[$seq]});
		}	  
	    }
	    foreach $pattern_seq (sort keys %patterns) {
		@{$match_pos{$pattern_seq}[$seq]} = @{$m_pos_bothstrands{$pattern_seq}[$seq]};
		@{$match_pos{$pattern_seq}[$seq]}= sort {$a <=> $b} @{$match_pos{$pattern_seq}[$seq]};
		undef @{$m_pos_bothstrands{$pattern_seq}[$seq]};
	    }   
	}
    }
    &GroupRc(); #### remove the duplicate pattern (only retain the first by alphabetical order) 
}

################################################################
#### when grouping occurrences with their reverse complement, 
#### only retain one of each pair. 
sub GroupRc {
    foreach $pattern_seq (keys %patterns) {
	$rc_pattern_seq = lc(&SmartRC($pattern_seq));
	if ($rc_pattern_seq gt $pattern_seq) { ### only suppress one oligo from the pair
	    delete $patterns{$rc_pattern_seq};
	}
    }
}

################################################################
#### check occurrence threshold
sub OccurrenceThreshold {
  if ($verbose >= 2) {
    &Warning(&AlphaDate()."\tThreshold on occurrences");
  }
  
  foreach $pattern_seq (keys %patterns) {
    if ($patterns{$pattern_seq}->{occ} < $occurrence_threshold) {
      delete $patterns{$pattern_seq};
    }
  }  
}

################################################################
#### check threshold on matching sequences
sub MatchingSeqThreshold {
  if ($verbose >= 2) {
    &Warning(&AlphaDate()."\tThreshold on matching sequences");
  }
  foreach $pattern_seq (keys %patterns) {
    if ($patterns{$pattern_seq}->{mseq} < $mseq_threshold) {
      delete $patterns{$pattern_seq};
    }
  }  
}

################################################################
### Calculate subword frequencies
sub CalcSubWordFrequencies {
    if ($verbose >= 2) {
	&Warning(&AlphaDate()."\tCalculating subword frequencies");
    }
    
    foreach $pattern_seq (keys %patterns) {
	### w-1 word occurrences
	$w = $oligo_length-1;
	$subseq = substr($pattern_seq,0,$w);
	$sub_word[$w]{$subseq}->{occ} += $patterns{$pattern_seq}->{occ} + $patterns{$pattern_seq}->{overlaps};
    }
    
    ### occurrences of words with length from w-2 to 1
    for $k (2..$oligo_length-1) {
	$w = $oligo_length - $k;
	foreach $pattern_seq (keys %{$sub_word[$w+1]}) {
	    $subseq = substr($pattern_seq,0,$w);
	    $sub_word[$w]{$subseq}->{occ} += $sub_word[$w+1]{$pattern_seq}->{occ} ;
	}
    }
  
    ### sum occurrences on both strands if requested
    if ($sum_rc) {
	for $w (1..$oligo_length-1) {
	    foreach $subseq (keys %{$sub_word[$w]}) {
		$rc = lc(&SmartRC($subseq));
		if ($rc eq $subseq) {
		    #### count  palindromic patterns only once !!!!!!!!!!!!
		    $sub_occ_2str[$w]{$subseq} = $sub_word[$w]{$subseq}->{occ};
		} else {
		    #### group each word with its erverse complement
		    $sub_occ_2str[$w]{$subseq} = $sub_occ_2str[$w]{$rc} = $sub_word[$w]{$subseq}->{occ} + $sub_word[$w]{$rc}->{occ};
		}
	    }
	    
	    foreach $subseq (keys %{$sub_occ_2str[$w]}) {
		$sub_word[$w]{$subseq}->{occ} = $sub_occ_2str[$w]{$subseq};
	    }
	    undef  %sub_occ_2str;
	}
    }
    
    ### calculate relative frequencies from occurrences
    for $w (1..$oligo_length-1) {
	$occ_sum[$w] = 0;
	foreach $subseq (keys %{$sub_word[$w]}) {
	    unless (($sum_rc) && ($subseq gt lc(&SmartRC($subseq)))) {
		$occ_sum[$w] += $sub_word[$w]{$subseq}->{occ};
	    }
	}
	foreach $subseq (keys %{$sub_word[$w]}) {
	    $sub_word[$w]{$subseq}->{freq} = $sub_word[$w]{$subseq}->{occ}/$occ_sum[$w];
	}
    }	
    
    if ($verbose >= 4) {
	for $w (1..$oligo_length-1) {
	    foreach $pattern_seq (sort keys %{$sub_word[$w]}) {
		&Warning( ";\tsubword_freq\t$w\t$occ_sum[$w]\t$pattern_seq\t%15.13f\n".$sub_word[$w]{$pattern_seq}->{freq});
	    }
	}
    }
}

################################################################
#### calculate relative frequencies if requested
sub CalcFrequencies {
    if ($verbose >= 2) {
	&Warning(&AlphaDate()."\tCalculating relative frequencies");
    }
    
    #### sum of occurrences
    $sum_overlaps = 0;
    $sum_noov = 0;
    $sum_occurrences = 0;
    foreach $pattern_seq (keys %patterns) {
	$sum_occurrences += $patterns{$pattern_seq}->{occ} + $patterns{$pattern_seq}->{overlaps};
	$sum_overlaps += $patterns{$pattern_seq}->{overlaps};
	$sum_noov += $patterns{$pattern_seq}->{occ};
    }
    
    #### relative frequencies
    foreach $pattern_seq (keys %patterns) {
	$patterns{$pattern_seq}->{freq} = $patterns{$pattern_seq}->{occ}/$sum_occurrences;
    }

    #### frequency of matching sequences
    if ($return{'mseq'}) {
	foreach $pattern_seq (keys %patterns) {
	    $patterns{$pattern_seq}->{ms_freq} = $patterns{$pattern_seq}->{mseq}/$sequence_number;
	}
    }
}


################################################################
### residue frequencies from input sequences
sub CalcAlphabet {
    %residue_proba = ();
    &Warning(&AlphaDate()."\tCalculating residue frequencies from input sequences") if ($verbose >= 2);
    
    foreach $key (sort keys %residue_occ) {
	$residue_total += $residue_occ{$key};
    }
    if ($residue_total > 0) {
	foreach $key (sort keys %residue_occ) {
	    if ($sum_rc) {
		$residue_proba{$key} = ($residue_occ{$key} + $residue_occ{lc(SmartRC($key))})/(2*$residue_total);
	    } else {
		$residue_proba{$key} = $residue_occ{$key}/$residue_total;
	    }
	}
    }
    return %residue_proba;
}


################################################################
### calculate occurrences with 1 degenerated position 
sub Degenerate {
  if ($verbose >= 2) {
    &Warning(&AlphaDate()."\tNeighborhood");
  }
  
  foreach $d (@degenerate_code) {  
    foreach $n (@{$IUPAC{$d}}) {
      push(@{$nucl_neighb{$n}}, $d);
    }
  }
  
  foreach $pattern_seq (keys %patterns) {
    for $l (1..length($pattern_seq)) {
      $n = substr($pattern_seq,$l-1,1);
      foreach $neighb (@{$nucl_neighb{$n}}) {
	$deg = substr($pattern_seq,0,$l-1);
	$deg .= $neighb;
	$deg .= substr($pattern_seq,$l);
	$deg_occurrences{$deg} += $patterns{$pattern_seq}->{occ};
	if ($return{'mseq'}) {
	  $deg_mseq{$deg} += $patterns{$pattern_seq}->{mseq};
	}
      }
    }
  }  
  
  %patterns = %deg_occurrences;
  undef %deg_occurrences;
  if ($return{'mseq'}) {
    foreach $pattern_seq (sort keys %deg_mseq) {
      $patterns{$pattern_seq}->{mseq} = $deg_mseq{$pattern_seq};
      undef %deg_occurrences;
    }
  }
}


################################################################
#### calculate number of possible oligomers
sub NbPossibleOligo {
    @alphabet = keys %residue_occ;
    if ($seq_type eq "DNA") {
	$alphabet_size = 4;
    } elsif ($seq_type eq "protein") {
	$alphabet_size = 20;
    } else {
	$alphabet_size = $#alphabet + 1;
    }

    $nb_possible_oligo = $alphabet_size**$oligo_length;      

    if ($seq_type eq "DNA") {
	if ($one_var_position) {
	    $nb_possible_oligo = $oligo_length * ($#degenerate_code+1) * $alphabet_size**($oligo_length-1);      
	}
	if ($sum_rc) {  
	    if ($oligo_length%2 == 0) {
		### take into account the fact that palindromes have not to be grouped by pairs
		$nb_possible_palindroms = $alphabet_size**($oligo_length/2);
	    } else {
		$nb_possible_palindroms = 0;
	    }
	    $nb_possible_oligo -= ($nb_possible_oligo - $nb_possible_palindroms)/2;
	}
    }
}



################################################################
#### expected oligomer frequencies
sub CalcExpected {
    if ($verbose >= 2) {
	&Warning(&AlphaDate()."\tCalculating probabilities");
    }
    
    ### expected frequency file
    if ($method eq "Frequency file") {    
	if ($one_var_position) {
	    foreach $deg_pattern_seq (sort keys %patterns) {
		$pattern = &IUPAC_to_regular($deg_pattern_seq);
		@matching_exp_freq = grep /$pattern/i, keys(%exp_freq);
		foreach $m  (@matching_exp_freq) {
		    $deg_exp_freq{$deg_pattern_seq} += $exp_freq{$m};
		}
	    }
	    %exp_freq = %deg_exp_freq;
	    undef %deg_exp_freq;
	}
	
    } elsif ($method eq "Markov chain") {  ### Markov chain
	### expected frequency according to Markov chain model
	foreach $pattern_seq (sort keys %patterns) {
	    $patterns{$pattern_seq}->{exp_freq} = 1;
	    for $offset (0..($oligo_length - $markov_order -1)) {
		$subseq = substr($pattern_seq,$offset,$markov_order+1);
		$patterns{$pattern_seq}->{exp_freq} *= $sub_word[$markov_order+1]{$subseq}->{freq};
		if (($markov_order > 0) && ($offset > 0)) {
		    $subseq = substr($pattern_seq,$offset,$markov_order);
		    $patterns{$pattern_seq}->{exp_freq} /= $sub_word[$markov_order]{$subseq}->{freq};
		}
	    }
	}

    } elsif ($method eq "lexicon") {  ### Markov chain
	my $l  = 1;
	foreach $pattern_seq (@alphabet ) {
#	    print join "\t", $l, $pattern_seq, $sub_word[$l]{$pattern_seq}->{freq}, $sub_word[$l]{$pattern_seq}->{occ}, "\n";
	    $sub_word[$l]{$pattern_seq}->{max_freq} = $sub_word[$l]{$pattern_seq}->{freq};
	}
	for $l (2..$oligo_length - 1) {
	    foreach $pattern_seq (keys %{$sub_word[$l]}) {
		$sub_word[$l]{$pattern_seq}->{exp_freq} = 0;
		$sub_word[$l]{$pattern_seq}->{max_freq} = $sub_word[$l]{$pattern_seq}->{freq};
		
		#### all possible segmentations of the word
		for $s (1..$l-1) {
		    $head = substr($pattern_seq,0,$s);
		    $tail = substr($pattern_seq,$s);
		    $segmentation_freq = $sub_word[$s]{$head}->{max_freq} * $sub_word[$l-$s]{$tail}->{max_freq};
		    if ($segmentation_freq > $sub_word[$l]{$pattern_seq}->{exp_freq}) {
			$sub_word[$l]{$pattern_seq}->{exp_freq} = $segmentation_freq;
			$sub_word[$l]{$pattern_seq}->{max_freq} = &max($sub_word[$l]{$pattern_seq}->{max_freq},
								     $sub_word[$l]{$pattern_seq}->{exp_freq});
		    }
#		    print join ("\t", $l, $pattern_seq, 
#				$sub_word[$l]{$pattern_seq}->{freq}, 
#				$sub_word[$l]{$pattern_seq}->{exp_freq}, 
#				$head, $sub_word[$s]{$head}->{max_freq},
#				$tail, $sub_word[$l-$s]{$tail}->{max_freq},
#				$sub_word[$s]{$head}->{max_freq}* $sub_word[$l-$s]{$tail}->{max_freq},
#				"\n");
		}
	    }
	}
	$l = $oligo_length;
	foreach $pattern_seq (keys %patterns) {
	    $patterns{$pattern_seq}->{exp_freq} = 0;
	    #### all possible segmentations of the word
	    for $s (1..$l-1) {
		$head = substr($pattern_seq,0,$s);
		$tail = substr($pattern_seq,$s);
		$segmentation_freq = $sub_word[$s]{$head}->{max_freq} * $sub_word[$l-$s]{$tail}->{max_freq};
		if ($segmentation_freq > $patterns{$pattern_seq}->{exp_freq}) {		
		    $patterns{$pattern_seq}->{exp_freq} = $segmentation_freq;
		    $patterns{$pattern_seq}->{segments} = join (" ", 
							   $head,
							   $tail,
							   sprintf("%15.13f", $sub_word[$s]{$head}->{max_freq}),
							   sprintf("%15.13f", $sub_word[$l-$s]{$tail}->{max_freq})
								#,$sub_word[$s]{$head}->{max_freq} * $sub_word[$l-$s]{$tail}->{max_freq}
							   );
#		    print join ("\t", $l, $pattern_seq, 
#				$patterns{$pattern_seq}->{freq}, 
#				$patterns{$pattern_seq}->{exp_freq}, 
#				$head, $sub_word[$s]{$head}->{max_freq},
#				$tail, $sub_word[$l-$s]{$tail}->{max_freq},
#				$sub_word[$s]{$head}->{max_freq}* $sub_word[$l-$s]{$tail}->{max_freq},
#				"\n");
		}
	    
	    }
	}

    } else {    
	### calculate the expected oligo frequency with 
	#### independent nucleotide probabilities 
	#### calculate probability for ambiguous nucleotide codes  ####
	$method = "alphabet";
	if ($seq_type eq "DNA") {
	    $residue_proba{'r'} = $residue_proba{'a'}+$residue_proba{'g'};
	    $residue_proba{'y'} = $residue_proba{'c'}+$residue_proba{'t'};
	    $residue_proba{'w'} = $residue_proba{'a'}+$residue_proba{'t'};
	    $residue_proba{'s'} = $residue_proba{'g'}+$residue_proba{'c'};
	    $residue_proba{'m'} = $residue_proba{'a'}+$residue_proba{'c'};
	    $residue_proba{'k'} = $residue_proba{'g'}+$residue_proba{'t'};
	    $residue_proba{'h'} = $residue_proba{'a'}+$residue_proba{'c'}+$residue_proba{'t'};
	    $residue_proba{'b'} = $residue_proba{'c'}+$residue_proba{'g'}+$residue_proba{'t'};
	    $residue_proba{'v'} = $residue_proba{'a'}+$residue_proba{'c'}+$residue_proba{'g'};
	    $residue_proba{'d'} = $residue_proba{'a'}+$residue_proba{'g'}+$residue_proba{'t'};
	    $residue_proba{'n'} = 1;
	}
	
	foreach $pattern_seq (keys %patterns) {
	    $patterns{$pattern_seq}->{exp_freq} = 1;
	    foreach $l (0..length($pattern_seq)-1) {
		$nt = substr($pattern_seq, $l, 1);
		$patterns{$pattern_seq}->{exp_freq} *= $residue_proba{$nt};
	    }
	}
    } 
    
    #### correct expected frequencies with pseudo weight
    if ($pseudo_weight > 0) {
	$pseudo_frequency = $pseudo_weight/$nb_possible_oligo;
	foreach $pattern_seq (keys %patterns) {
	    $patterns{$pattern_seq}->{exp_freq} *= 1 - $pseudo_weight;
	    $patterns{$pattern_seq}->{exp_freq} += $pseudo_frequency;;
	}
    }


    ################################################################
    ### sum expected frequencies for pairs of reverse complements
    if (($sum_rc) &&
	($method ne "Frequency file")) {    #### this has alrady been treated when reading expected frequency file
	foreach $pattern_seq (sort keys %patterns) {
	    $rc = lc(&SmartRC($pattern_seq));
	    unless (defined($patterns{$rc}->{exp_freq})) {
		$patterns{$rc}->{exp_freq} = $patterns{$pattern_seq}->{exp_freq};
	    }
	}
	&SumExpectedFrequencies(%patterns);
    }

    ################################################################
    #### expected number of occurrences and matching sequences ####
    foreach $pattern_seq (sort keys %patterns) {
#	if ($noov) {
#	    $patterns{$pattern_seq}->{nb_possible_pos} = $nb_possible_pos - ($patterns{$pattern_seq}->{occ} * ($oligo_length -1));
#	} else {
	$patterns{$pattern_seq}->{nb_possible_pos} += $nb_possible_pos;
#	}
	$patterns{$pattern_seq}->{exp_occ} = $patterns{$pattern_seq}->{exp_freq} * $patterns{$pattern_seq}->{nb_possible_pos}; 
	if ($return{'mseq'}) {
	    ### expected number of matching sequences ###
	    $avg_seq_length = $sum_seq_length/$sequence_number;
	    $pos_per_seq = $avg_seq_length - $oligo_length + 1;
#	    $pos_per_seq *=2 if ($sum_rc);
	    
	    $exp_freq_est = $patterns{$pattern_seq}->{exp_freq};
	    
	    $one_seq_match_proba =  1 - (1-$exp_freq_est)**$pos_per_seq;
#	    $one_seq_match_proba =  &sum_of_binomials($exp_freq_est, $pos_per_seq, 1, $pos_per_seq);
	    $patterns{$pattern_seq}->{exp_ms} =  $one_seq_match_proba*$sequence_number;
	    
	    unless ($noov) {
		## Mireille Regnier's Correction on expected
		## frequencies to calculate the probability of
		## first occurrences for self-overlapping patterns
		unless (defined($patterns{$pattern_seq}->{ovlp})) {
		    $patterns{$pattern_seq}->{ovlp} = $patterns{&SmartRC($pattern_seq)}->{ovlp}
		} 
		$exp_freq_est = $patterns{$pattern_seq}->{exp_freq}/$patterns{$pattern_seq}->{ovlp};
		$one_seq_match_proba =  1 - (1-$exp_freq_est)**$pos_per_seq;
		$patterns{$pattern_seq}->{ems_cor} =  $one_seq_match_proba*$sequence_number;
		warn join ( "\t", $pattern_seq, 
			    "overlap: $patterns{$pattern_seq}->{ovlp}",
			    "exp_freq: $patterns{$pattern_seq}->{exp_freq}",
			    "exp_freq_est: $exp_freq_est", 
			    "ems_cor", $patterns{$pattern_seq}->{ems_cor}
			    ), "\n" if ($verbose >= 4);
	    }
	}
    }	
} # CalcExpected


################################################################
#### calculate overlap coefficient
sub CalcOverlapCoefficient {
    foreach $pattern_seq (keys %patterns) {
	$patterns{$pattern_seq}->{ovlp} = &OverlapCoeff($pattern_seq, %residue_proba);
	warn join ( "\t", "overlap", $pattern_seq, $patterns{$pattern_seq}->{ovlp}), "\n" if ($verbose >= 4);
    }
}

sub CalcZscore {
    #### z-scores ####
    if ($return{'occ'}) {
	foreach $pattern_seq (keys %patterns) {
	    if ($noov) {
		$patterns{$pattern_seq}->{est_var} = $patterns{$pattern_seq}->{exp_occ};
	    } else {
#		$patterns{$pattern_seq}->{ovlp} = &OverlapCoeff($pattern_seq);
		$patterns{$pattern_seq}->{est_var} = $patterns{$pattern_seq}->{nb_possible_pos} * $patterns{$pattern_seq}->{exp_freq}*(2*$patterns{$pattern_seq}->{ovlp} - 1 - (2*$oligo_length+1)*$patterns{$pattern_seq}->{exp_freq});

#       	$patterns{$pattern_seq}->{est_var} = $patterns{$pattern_seq}->{nb_possible_pos} * $patterns{$pattern_seq}->{exp_freq}*(1 - $patterns{$pattern_seq}->{exp_freq});
	    }
	    if ($patterns{$pattern_seq}->{est_var} > 0) {
		$stdev = sqrt($patterns{$pattern_seq}->{est_var});
		$patterns{$pattern_seq}->{zscore} = ($patterns{$pattern_seq}->{occ} - $patterns{$pattern_seq}->{exp_occ})/$stdev;
	    } else {
		$stdev = "NA";
		$patterns{$pattern_seq}->{zscore} = "NA";
	    }
#  	    print STDERR join ("\t", 
#  			       $pattern_seq,
#  			       $patterns{$pattern_seq}->{occ},
#  			       $patterns{$pattern_seq}->{exp_occ},
#  			       $patterns{$pattern_seq}->{nb_possible_pos},
#  			       $patterns{$pattern_seq}->{exp_freq},
#  			       1-$patterns{$pattern_seq}->{exp_freq},
#  			       $patterns{$pattern_seq}->{ovlp},
#  			       $patterns{$pattern_seq}->{est_var},
#  			       sqrt($patterns{$pattern_seq}->{est_var}),
#  			       $patterns{$pattern_seq}->{zscore}
#  			       ), "\n";
	}
    }
}



################################################################
#### Calculate log likelihood
sub CalcLikelihood {
### log likelihood ###
  if ($return{'occ'}) {
    foreach $pattern_seq (keys %patterns) {
      if (($patterns{$pattern_seq}->{exp_freq} > 0) && ($patterns{$pattern_seq}->{freq} > 0)) {
	$patterns{$pattern_seq}->{occ_lkh} = $patterns{$pattern_seq}->{freq} * log($patterns{$pattern_seq}->{freq}/$patterns{$pattern_seq}->{exp_freq});
      } else {
	$patterns{$pattern_seq}->{occ_lkh} = "NA";
      }
    }
  }
  if ($return{'mseq'}) {
    foreach $pattern_seq (keys %patterns) {
      if (($patterns{$pattern_seq}->{exp_ms} > 0) && ($patterns{$pattern_seq}->{mseq} > 0)) {
	$patterns{$pattern_seq}->{ms_lkh} = $patterns{$pattern_seq}->{mseq} * log($patterns{$pattern_seq}->{mseq}/$patterns{$pattern_seq}->{exp_ms}) / $sequence_number;
      } else {
	$patterns{$pattern_seq}->{ms_lkh} = "NA";
      }
    }
  }
}  ### CalcLikelihood


################################################################
#### Calculate observed/expected ratio
sub CalcRatio {
  if ($return{'freq'}) {
    foreach $pattern_seq (sort keys %patterns) {
      if ($patterns{$pattern_seq}->{exp_freq} == 0) {
	$patterns{$pattern_seq}->{ratio} = 0;
      } else {
	$patterns{$pattern_seq}->{ratio} =  $patterns{$pattern_seq}->{freq}/$patterns{$pattern_seq}->{exp_freq};
      }
      #### check threshold on occurrence probability ####
      if ($patterns{$pattern_seq}->{ratio} < $ratio_threshold) {
	delete $patterns{$pattern_seq};
      }
    }
  } elsif ($return{'occ'}) {
    foreach $pattern_seq (sort keys %patterns) {
      if ($patterns{$pattern_seq}->{exp_occ} == 0) {
	$patterns{$pattern_seq}->{ratio} = 0;
      } else {
	$patterns{$pattern_seq}->{ratio} =  $patterns{$pattern_seq}->{occ}/$patterns{$pattern_seq}->{exp_occ};
      }
      
      #### check threshold on occurrence probability ####
      if ($patterns{$pattern_seq}->{ratio} < $ratio_threshold) {
	delete $patterns{$pattern_seq};
      }
    }
  }
} ### CalcRatio



################################################################
#### Calculate probabilities
sub CalcProba {
    #### converts threshold on occurence significance index into a 
    #### threshold on occurrence probability
    if (defined($occ_significance_threshold)) {
	$proba_occ_threshold = exp(-$occ_significance_threshold*log(10))/$nb_possible_oligo;
    }
    
    #### converts threshold on mseq significance index into a 
    #### threshold on mseq probability
    if (defined($mseq_significance_threshold)) {
	$proba_mseq_threshold = exp(-$mseq_significance_threshold*log(10))/$nb_possible_oligo;
    }

    
    ### calculate oligo probabilities
    foreach $pattern_seq (sort keys %patterns) {
	if ($verbose >= 4) {
	    printf ("oligo-analysis\t". &AlphaDate()."\tcalculating proba $pattern_seq occ %7d exp_occ %7.1f\texp_freq %g\tpos %g\n", 
		    $patterns{$pattern_seq}->{occ}, 
		    $patterns{$pattern_seq}->{exp_occ},
		    $patterns{$pattern_seq}->{exp_freq},
		    $patterns{$pattern_seq}->{nb_possible_pos}
		    );
	}
	
#	$rc = uc(&SmartRC($pattern_seq));
	
	if ($under_represented) {
	    #### probability of observing less than the observed number of occurrences ####
	    #### for searching under-represented patterns only
#	    if (($sum_rc) && (uc($pattern_seq) eq $rc)) {
#		$patterns{$pattern_seq}->{occ_pro} = &sum_of_binomials($patterns{$pattern_seq}->{exp_freq},
#								 $patterns{$pattern_seq}->{nb_possible_pos}/2,
#								 0,
#								 $patterns{$pattern_seq}->{occ}/2-1);
#		$patterns{$pattern_seq}->{remark} = "\tpalindrome";
#	    } else {
	    $patterns{$pattern_seq}->{occ_pro} = &sum_of_binomials($patterns{$pattern_seq}->{exp_freq},
								   $patterns{$pattern_seq}->{nb_possible_pos},
								   0,
								   $patterns{$pattern_seq}->{occ}-1);
#	    }
	} else {
	    ### probability of observing at least the observed number of occurrences ####
#	    if (($sum_rc) && (uc($pattern_seq) eq $rc)) {
#		$patterns{$pattern_seq}->{occ_pro} = &binomial_boe($patterns{$pattern_seq}->{exp_freq},
#								   $patterns{$pattern_seq}->{nb_possible_pos}/2,
#								   $patterns{$pattern_seq}->{occ}/2);
#		$patterns{$pattern_seq}->{remark} = "\tpalindrome";
#	    } else {

	    
	    $patterns{$pattern_seq}->{occ_pro} = &binomial_boe($patterns{$pattern_seq}->{exp_freq},
							       $patterns{$pattern_seq}->{nb_possible_pos},
							       $patterns{$pattern_seq}->{occ});

#  	    warn join( "\t", "HELLO", 
#  			       $pattern_seq, 
#  			       $patterns{$pattern_seq}->{occ},  
#  			       $patterns{$pattern_seq}->{exp_freq},  
#  			       $patterns{$pattern_seq}->{nb_possible_pos},
#  			       $patterns{$pattern_seq}->{occ_pro}
#  			       ),"\n" if ($main::verbose >= 10);

#	    }
	}

	#### check threshold on occurrence probability ####
	if ($patterns{$pattern_seq}->{occ_pro} > $proba_occ_threshold) {
	    delete $patterns{$pattern_seq};
	    next;
	}
	
	### Significance index for occurrence number
	if ($nb_possible_oligo > 0) {
	    $patterns{$pattern_seq}->{occ_E} = $nb_possible_oligo*$patterns{$pattern_seq}->{occ_pro};
	    if ($patterns{$pattern_seq}->{occ_pro} > 0) {
		$patterns{$pattern_seq}->{occ_sig} = -log($patterns{$pattern_seq}->{occ_E})/log(10);
	    } else {
		$patterns{$pattern_seq}->{occ_sig} = 999; ### arbitrary number to indicate we are over the precision limit
	    }
	}
	
	
	#### matching seq probability
	if ($return{'mseq'}) {	    
	    ### probability of the observed number of matching sequences ####
	    $avg_mseq_proba = $patterns{$pattern_seq}->{exp_ms}/$sequence_number;
	    $patterns{$pattern_seq}->{ms_pro} = &binomial_boe($avg_mseq_proba, $sequence_number, $patterns{$pattern_seq}->{mseq});    
	    
	    #### check threshold on mseq probability ####
	    if ($patterns{$pattern_seq}->{ms_pro} > $proba_mseq_threshold) {
		delete $patterns{$pattern_seq};
		next;
	    }
	    
	    ### Significance index for number of matching sequences
	    if ($nb_possible_oligo > 0) {
		$patterns{$pattern_seq}->{ms_E} = $nb_possible_oligo*$patterns{$pattern_seq}->{ms_pro};
		if ($patterns{$pattern_seq}->{ms_pro} > 0) {
		    $patterns{$pattern_seq}->{ms_sig} = -log($patterns{$pattern_seq}->{ms_E})/log(10);
		} else {
		    $patterns{$pattern_seq}->{ms_sig} = 999;
		}
	    }
	}
    }  
} ### CalcProba


################################################################
#### Print the header line before the result
sub PrintHeaderLine {
    $col_description{"seq"} = "oligomer sequence";
    $col_description{"sequence"} = "oligomer sequence";
    $col_description{"identifier"} = "oligomer identifier";
    $col_description{"id"} = "oligomer identifier";
    $col_description{"observed_freq"} = "observed relative frequency"; 
    $col_description{"expected_freq"} = "expected relative frequency"; 
    $col_description{"occ"} = "observed occurrences";
    $col_description{"exp_occ"} = "expected occurrences"; 
    $col_description{"occ_P"} = "occurrence probability (binomial)";
    $col_description{"occ_E"} = "E-value for occurrences (binomial)";
    $col_description{"occ_sig"} = "occurrence significance (binomial)";
    $col_description{"zscore"} = "z-score (normal)"; 
    $col_description{"occ_lkh"} = "occurrence likelihood"; 
    $col_description{"ovl_occ"} = "number of overlapping occurrences (discarded from the count)"; 
    $col_description{"ratio"} = "observed/expected ratio"; 
    $col_description{"ms"} = "number of matching sequences";
    $col_description{"exp_ms"} = "expected number of matching sequences";
    $col_description{"ems_cor"} = "expected number of matching sequences, corrected for autocorrelation (Poisson approx)";
    $col_description{"ms_P"} = "matching sequence probability (binomial)";
    $col_description{"ms_sig"} = "matching sequenc significance (binomial)";
    $col_description{"ms_E"} = "E-value for matching sequences (binomial)";
    $col_description{"ms_freq"} = "observed matching sequence frequency"; 
    $col_description{"exp_msf"} = "expected matching sequence frequency"; 
    $col_description{"ms_rati"} = "observed/expected matching seqyences"; 
    $col_description{"ms_lkh"} = "matching sequence likelihood"; 
    $col_description{"rank"} = "rank"; 
    $col_description{"positions"} = "matching positions"; 
    $col_description{"ovlp"} = "overlap coefficient"; 
    $col_description{"est_var"} = "estimation of the variance on occurrences"; 
    $col_description{"remark"} = "remark"; 
    $col_description{"segments"} = "word segmentation"; 
    @out_col = ();
    ### print header line ###
    if ($oligo_length < 8) {
	push(@out_col,"seq");
    } else {
	push(@out_col,"sequence");
    }
    if (($oligo_length > 8) ||
	(($oligo_length > 5) && ($sum_rc))) {   
	push(@out_col,"identifier");
    } else {
	push(@out_col,"id");
    }
    
    ### occurrence frequencies
    push(@out_col,"observed_freq") if ($return{'freq'});
    push(@out_col,"expected_freq") if ($return{'exp_freq'});
    
    ### occurrences
    if ($return{'occ'}) {
	push(@out_col,"occ");
	push(@out_col,"exp_occ") if ($return{'exp_freq'});
	if ($return{'proba'}) {
	    push(@out_col,"occ_P");
	    push(@out_col,"occ_E");
	    push(@out_col,"occ_sig");
	}
	push(@out_col,"zscore") if ($return{'zscore'});
	push(@out_col,"occ_lkh") if ($return{'like'});
	push(@out_col,"ovl_occ") if ($noov);
	#    push(@out_col,"est_var") if ($return{'zscore'});
    }
    push(@out_col,"ratio") if ($return{'ratio'});
    
    ### matching sequences
    if ($return{'mseq'}) {
	push(@out_col,"ms");
	if ($return{'proba'}) {
	    push(@out_col,"exp_ms");
	    push(@out_col,"ems_cor") unless ($noov);
	    push(@out_col,"ms_P");
	    push(@out_col,"ms_E");
	    push(@out_col,"ms_sig");
	}
	push(@out_col,"ms_freq") if ($return{'freq'});
	push(@out_col,"exp_msf") if ($return{'exp_freq'});
	push(@out_col,"ms_rati") if ($return{'ratio'});
	push(@out_col,"ms_lkh") if ($return{'like'});
    }
    
    ### rank
    push(@out_col,"rank") if ($return{'rank'});

    ### positions
    push(@out_col,"positions") if ($return{'pos'});
    
    ### miscellaneous
    push(@out_col,"ovlp") if ($return{'ovlp'});
    push(@out_col,"est_var") if ($return{'est_var'});
    push(@out_col,"remark") if ($return{'remark'});
    push(@out_col,"segments") if ($return{'segments'});

    if ($verbose >= 1) {
	print $out "; column headers\n";
	foreach $c (0..$#out_col) {
	    printf $out ";\t%d\t%-15s\t%s\n", $c+1, $out_col[$c], $col_description{$out_col[$c]};
	}
    }

    print $out ";";
    print $out join("\t",@out_col);
    print $out "\n";

}


################################################################
#### verbose
sub Verbose {
    ### verbose ###
    if ($verbose >= 1) {
	print $out "; oligo-analysis ";
	&PrintArguments($out);
	printf $out "; %s\n", "Citation: van Helden et al. (1998). J Mol Biol 281(5), 827-42. ";
	if ($return{proba}) {
	    if ($under_represented) {
		printf $out "; %s\n", "Detection of under-represented words";
	    } else {
		printf $out "; %s\n", "Detection of over-represented words";
	    }
	}
	printf $out "; %-29s\t%s\n", "Oligomer length", $oligo_length;
	printf $out "; %-29s\t%s\n", "Input file",	$inputfile if ($inputfile);
	printf $out "; %-29s\t%s\n", "Input format", $in_format;

	    printf $out "; %-29s\t%s\n", "Output file", $outputfile if ($outputfile);
	    if ($noov) {
		print $out "; Discard overlapping matches\n";
	    } else {
		print $out "; Count overlapping matches\n";
	    }
	if ($sum_rc) {
	    print $out "; Counted on both strands\n";
#	    if ($group_rc) {
		print $out "; \tgrouped by pairs of reverse complements\n";
#	    }
	} else {
	    print $out "; Counted on a single strand\n";
	}
	if ($one_var_position) {
	    print $out "; Neighborhood: one variable position\t";
	    foreach $d (@degenerate_code) {
		print $out ";\t$d "; 
	    }
	    print $out "\n"; 
	}

	unless ($return{'table'}) {
	    
	    printf $out "; %-29s\t%s\n", "Background model", $background_model if ($background_model);
	    printf $out "; %-29s\t%s\n", "Organism", $organism_name if ($organism_name);
	    printf $out "; %-29s\t%s\n", "Method", $method;
	    printf $out "; %-29s\t%s\n", "Expected frequency file", $exp_freq_file if ($exp_freq_file);
	    printf $out "; %-29s\n", "\trescaled to 1" if ($rescale_freq);
	    printf $out "; %-29s\t%s\n", "Markov chain order", $markov_order if ($method eq "Markov chain");
	    printf $out "; %-29s\t%s\n", "Alphabet frequency file", $alphabet_file if ($alphabet_file);
	    if (($alphabet) || ($method eq "alphabet")){
		print $out "; Alphabet\n";
		foreach $key (sort keys %residue_proba) {
		    print $out ";\t$key\t$residue_proba{$key}\n";
		}
	    }
	    if ($pseudo_weight) {
		printf $out "; %-29s\t%s\n", "Pseudo weight", $pseudo_weight;
		printf $out "; %-29s\t%s\n", "Pseudo frequency", $pseudo_frequency;
	    }
	    
	    printf $out "; %-29s\t%s\n", "Sequence type", $seq_type;
	    printf $out "; %-29s\t%s\n", "Nb of sequences", $sequence_number;
	    printf $out "; %-29s\t%s\n", "Sum of sequence lengths", $sum_seq_length;
	    if ($seq_type eq "DNA") {
		printf $out "; %-29s\t%d\t%s\n", "discarded occurrences", $discarded_occurrences, " (contain other letters than ACGT)";
	    }
	    printf $out "; %-29s\t%s\n", "nb possible positions",$nb_possible_pos;
	    printf $out "; %-29s\t%s\n", "total oligo occurrences", $sum_occurrences;
	    if ($noov) {
		printf $out "; %-29s\t%s\n", "total overlapping occurrences", $sum_overlaps;
		printf $out "; %-29s\t%s\n", "total non overlapping occ", $sum_noov;
	    }
	    printf $out "; %-29s\t%s\n", "alphabet size", $alphabet_size;
	    printf $out "; %-29s\t%s\n", "nb possible oligomers", $nb_possible_oligo;
	    printf $out "; %-29s\t%s\n", "threshold on occurrences", $occurrence_threshold if ($occurrence_threshold > 0);
	    printf $out "; %-29s\t%s\n", "threshold on occ sig", $occ_significance_threshold if (defined($occ_significance_threshold));
	    printf $out "; %-29s\t%s\n", "threshold on matching seq sig", $mseq_significance_threshold if (defined($mseq_significance_threshold));
	    printf $out "; %-29s\t%s\n", "threshold on matching seq.", $mseq_threshold if ($mseq_threshold > 0);
	    printf $out "; %-29s\t%s\n", "threshold on occ proba", $proba_occ_threshold if ($proba_occ_threshold < 1);
	    printf $out "; %-29s\t%s\n", "threshold on occ ratio", $ratio_threshold if ($ratio_threshold > 0);
	    printf $out "; %-29s\t%s\n", "threshold on match. seq proba", $proba_mseq_threshold if ($proba_mseq_threshold < 1);

	    unless (($return{'table'}) || ($sequence_number > $max_seq_verbose)) {
		print $out "; Sequences:\n";
		foreach $s (1..$sequence_number) {
		    print $out ";\t$id_list[$s]\t$seq_length[$s]\n";
		}
	    }
	    print $out ";\n";
	}
    }
}


################################################################
### Print the result
sub PrintResult {
    ### open output file ###
    if ($verbose >= 2) {
	&Warning(&AlphaDate()."\tPrinting output file");
    }

    #### print verbose
    &Verbose() if ($verbose >= 1);

    ### sort oligomers in function of significance or alphabetically
    if ($sort_result) {
	### in priority, sort by occurrence probabilities
	if ($return{'occ'}) {
	    ### preferred fields for sorting are the most generally reliable
	    if ($return{'zscore'}){
		if ($return{'proba'}) { 
		    #### two-criteria sorting, sig is prioritary, but
		    #### zscore is useful when the proba reaches
		    #### calculation limits
		    @sorted_keys = sort {  $patterns{$b}->{zscore} <=>  $patterns{$a}->{zscore} || 
					       $patterns{$b}->{occ_sig} <=>  $patterns{$a}->{occ_sig}
				      } keys %patterns;
		} else {
		    @sorted_keys = sort {$patterns{$b}->{zscore} <=>  $patterns{$a}->{zscore}} keys %patterns;
		}
		$sorted = 1;
	    } elsif ($return{'proba'}) {
		@sorted_keys = sort {$patterns{$b}->{occ_sig} <=> $patterns{$a}->{occ_sig}} keys %patterns;
		$sorted = 1;
	    } elsif ($return{'like'}) {
		@sorted_keys = sort {$patterns{$b}->{occ_lkh} <=> $patterns{$a}->{occ_lkh}} keys %patterns;
		$sorted = 1;
	    } elsif ($return{'ratio'}) {
		@sorted_keys = sort {$patterns{$b}->{ratio} <=> $patterns{$a}->{ratio}} keys %patterns;
		$sorted = 1;
	    } else {
		@sorted_keys = sort {$patterns{$b}->{occ} <=> $patterns{$a}->{occ}} keys %patterns;
		$sorted = 1;
	    }
	} elsif ($return{'mseq'}) {
	    if ($return{'proba'}) {
		@sorted_keys = sort {$patterns{$b}->{ms_sig} <=>  $patterns{$a}->{ms_sig}} keys %patterns;
		$sorted = 1;
	    } elsif($return{'like'}) {
		@sorted_keys = sort {$patterns{$b}->{ms_lkh} <=>  $patterns{$a}->{ms_lkh}} keys %patterns;
		$sorted = 1;
	    } else {
		@sorted_keys = sort {$patterns{$b}->{occ} <=> $patterns{$a}->{mseq}} keys %patterns;
		$sorted = 1;
	    }
	    ### if no matching sequence request, sort by statistics on occurrences
	} elsif ($return{'freq'}) {
	    @sorted_keys = sort {$patterns{$b}->{freq} <=> $patterns{$a}->{freq}} keys %patterns;
	    $sorted = 1;
	}    
    }
    ### in all the other cases, sort by sequence
    @sorted_keys = sort keys %patterns unless ($sorted);

    &PrintHeaderLine();
    
    ### print result ###
    my $rank = 0;
    foreach $p (0..$#sorted_keys) {
	$rank++;
	my $pattern_seq = $sorted_keys[$p];
	### oligo sequence and identifier
	print $out "$pattern_seq";
	print $out "\t", &PatternID($pattern_seq);
	
	### relative frequencies
	printf $out "\t%15.13f", $patterns{$pattern_seq}->{freq} if ($return{'freq'});	
	printf $out "\t%15.13f", $patterns{$pattern_seq}->{exp_freq} if ($return{'exp_freq'});
	
	### occurrences ###
	if ($return{'occ'}) {
	    print $out "\t", $patterns{$pattern_seq}->{occ};
	    
	    ### expected occurrences
	    if ($return{'exp_freq'}) {
		if ($patterns{$pattern_seq}->{exp_occ} >= 0.01) {
		    printf $out "\t%.2f", $patterns{$pattern_seq}->{exp_occ};
		} else {
		    printf $out "\t%.2g", $patterns{$pattern_seq}->{exp_occ};
		}
	    }

	    ### TEMPORARY ###
#	    printf $out "\t%.2f", $patterns{$pattern_seq}->{nb_possible_pos};
	    
	    ### occurrence probability
	    if ($return{'proba'}) {
		if ($patterns{$pattern_seq}->{occ_pro} >= 0.0001) {
		    printf $out "\t%.5f", $patterns{$pattern_seq}->{occ_pro};
		} else {
		    printf $out "\t%.2g", $patterns{$pattern_seq}->{occ_pro};
		}
		printf $out "\t%.1e", $patterns{$pattern_seq}->{occ_E};
		printf $out "\t%.2f", $patterns{$pattern_seq}->{occ_sig};
	    }
	    
	    
	    ### zscore
	    if ($return{'zscore'}) {
		if (&IsReal($patterns{$pattern_seq}->{zscore})) {
		    printf $out "\t%.2f", $patterns{$pattern_seq}->{zscore};
		} else {
		    printf $out "\t%s", $patterns{$pattern_seq}->{zscore};
		}
		#			printf $out "\t%.1f", $patterns{$pattern_seq}->{est_var};
	    }
	    
	    ### log likelihood of occurrences
	    printf $out "\t%7.5f", $patterns{$pattern_seq}->{occ_lkh} if ($return{'like'});
	    
	    ### overlapping occurrences
	    if ($noov) {
		$patterns{$pattern_seq}->{overlaps} = 0 if ($patterns{$pattern_seq}->{overlaps} eq "");
		print $out "\t", $patterns{$pattern_seq}->{overlaps};
	    }
	}
	### obs/exp ratio
	if ($return{'ratio'}) {
	    printf $out "\t%.2f", $patterns{$pattern_seq}->{ratio};
	}
	
	### matching sequences ###
	if ($return{'mseq'}) {
	    print $out "\t", $patterns{$pattern_seq}->{mseq};
	    if ($return{'proba'}) {
		printf $out "\t%.2f", $patterns{$pattern_seq}->{exp_ms};
		printf $out "\t%.2f", $patterns{$pattern_seq}->{ems_cor} unless ($noov);
		if ($patterns{$pattern_seq}->{ms_pro} >= 0.0001) {
		    printf $out "\t%.5f", $patterns{$pattern_seq}->{ms_pro};     
		} else {
		    printf $out "\t%.2g", $patterns{$pattern_seq}->{ms_pro};   
		}
		printf $out "\t%.2g", $patterns{$pattern_seq}->{ms_E};
		printf $out "\t%.1f", $patterns{$pattern_seq}->{ms_sig};
	    }
	    printf $out "\t%7.5f", $patterns{$pattern_seq}->{ms_freq} if ($return{'freq'});
	    printf $out "\t%7.5f", $patterns{$pattern_seq}->{exp_ms}/$sequence_number if ($return{'exp_freq'});
	    printf $out "\t%7.5f", $patterns{$pattern_seq}->{mseq}/$patterns{$pattern_seq}->{exp_ms} if (($return{'ratio'}) && ($patterns{$pattern_seq}->{exp_ms} > 0));
	    printf $out "\t%7.5f", $patterns{$pattern_seq}->{ms_lkh} if ($return{'like'});
	    
	}
	
	### rank ###
	if ($return{'rank'}) {
	    print $out "\t", $p+1;
	}

	### positions ###
	if ($return{'pos'}) {
	    print $out "\t";
	    for $seq (1..$sequence_number) {
		for $p (0..$#{$match_pos{$pattern_seq}[$seq]}) {
		    print $out "$seq:$match_pos{$pattern_seq}[$seq][$p] ";	
		}
	    }
	}
	
	### miscellaneous info
	printf $out "\t%.5f", $patterns{$pattern_seq}->{ovlp} if ($return{'ovlp'});
	printf $out "\t%.3f", $patterns{$pattern_seq}->{est_var} if ($return{'est_var'});
	printf $out "\t%s", $patterns{$pattern_seq}->{remark} if ($return{'remark'});
	printf $out "\t%s", $patterns{$pattern_seq}->{segments} if ($return{'segments'});
	
	### next line
	print $out "\n";
    }
    
    
}



################################################################
#### read command-line arguments
sub ReadArguments {
    my $a = 0;
    while ($a <= $#ARGV) {
	
	#### verbose
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$a++;
		$verbose = $ARGV[$a];
	    } else {
		$verbose = 1;
	    }
	    
	} elsif ($ARGV[$a] eq "-vv") {
	    $verbose = 2;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions;

	    #### input file
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-format") {
	    $in_format = lc($ARGV[$a+1]);
	    
	    #### sequence type
	} elsif ($ARGV[$a] =~ /^-seqtype/i) {
	    $a++;
	    if ($ARGV[$a] =~ /^prot/i) {
		$sum_rc = 0;
#		$group_rc = 0;
		$seq_type = "protein";
		
		#### DNA sequences
	    } elsif ($ARGV[$a] =~ /^dna/i) {
		$seq_type = "DNA";
		
		#### any other sequence type
	    } elsif ($ARGV[$a] =~ /^other/i) {
		$sum_rc = 0;
#		$group_rc = 0;
		$seq_type = "other";

	    } else {
		&FatalError( "\tError: sequence type '$ARGV[$a]' is not supported");
	    }

	    #### output file
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];

	    
	    ### organism (for selecting the appropriate expected frequencies)
	} elsif ($ARGV[$a] =~ /^-org/i) {
	    $organism_name = $ARGV[$a+1];
	    

	    ################################################################ 
	    #### oligonucleotide counting options

	    #### oligonucleotide length
	} elsif ($ARGV[$a] eq "-l") {
	    $oligo_length = $ARGV[$a+1];
	    
	    #### strands
	} elsif ($ARGV[$a] eq "-1str") {
	    $sum_rc = 0;
#	    $group_rc = 0;
	    
	} elsif ($ARGV[$a] eq "-2str") {
	    $sum_rc = 1;
	    
	    #### reverse complement grouping or not
#	} elsif ($ARGV[$a] eq "-grouprc") {
#	    $sum_rc = 1;
#	    $group_rc = 1;
	    
#	} elsif ($ARGV[$a] eq "-nogrouprc") {
#	    $group_rc = 0;
	    
	    #### overlapping matches
	} elsif ($ARGV[$a] =~ /^-noov/) {
	    $noov = 1;
	    
	    #### return reverse palindroms only
	} elsif ($ARGV[$a] =~ /^-pal/) {
	    $palindroms = 1;
	    
	    #### degenerate code: one N at any position
	} elsif ($ARGV[$a] eq "-oneN") {
	    $one_var_position = 1;
	    @degenerate_code = ('n');
	    
	    #### degenerate code: one degenerate at any position in each pattern
	} elsif ($ARGV[$a] eq "-onedeg") {
	    $one_var_position = 1;
	    @degenerate_code = ('r','y','w','s','m','k','h','b','v','d','n');
	    
	    ################################################################
	    #### expected frequency calibration
	    ####
	    
	    #### expected frequency file
	} elsif ($ARGV[$a] eq "-expfreq") {
	    $method = "Frequency file";
	    $exp_freq_file = $ARGV[$a+1];

	    #### rescale expected frequencies to have a sum of 1
	} elsif ($ARGV[$a] eq "-rescale") {
	    $rescale_freq = 1;

	    ### use oligo non-coding frequencies as expected frequencies
	} elsif ($ARGV[$a] =~ /^-ncf/i) {
	    &Warning ("option -ncf is deprecated, use '-bg intergenic' instead");
	    $background_model = "intergenic";
#	    $rescale_freq = 1;

	    ### specify a background model for estimating expected frequencies
	} elsif ($ARGV[$a] =~ /^-bg/i) {
	    $background_model = $ARGV[$a+1];
	    $background_model =~ s/ncf/intergenic/;
	    unless ($supported_bg{$background_model}) {
		&FatalError("Invalid background model\t$background_model\tsupported: $supported_bg");
	    }

	    #### lexicon
	} elsif ($ARGV[$a] =~ /^-lex/i) { ### Markov chains
	    $method = "lexicon";
	    $return{'exp_freq'} = 1;
	    $return{'segments'} = 1;

	    #### markov chain
	} elsif ($ARGV[$a] =~ /^-markov/i) { ### Markov chains
	    $method = "Markov chain";
	    $return{'exp_freq'} = 1;
	    if (&IsInteger($ARGV[$a+1])) {
		$a++;
		$markov_order = $ARGV[$a];
	    } 
	    
	    #### markov chain
	} elsif ($ARGV[$a] =~ /^-pseudo/i) { ### Markov chains
	    $pseudo_weight = $ARGV[++$a];
	    unless ( (&IsReal($pseudo_weight)) &&
		     ($pseudo_weight <= 1) &&
		     ($pseudo_weight >= 0)) {
		&FatalError ("Error: $pseudo_weight is not a valid value for pseudo frequency.",
			     "Pseudo frequency must be a real value between 0 and 1.");
	    }
	    
	    #### fiel with alphabet utilization
	} elsif ($ARGV[$a] eq "-afile") {
	    $alphabet = 1;
	    $alphabet_file = $ARGV[$a+1];

	    #### alphabet
	} elsif ($ARGV[$a] eq "-a") {
	    $alphabet = 1;
	    if ($ARGV[$a+1] eq "yeast") {
		$residue_proba{'a'} = $residue_proba{'t'} = 0.308512197555054;
		$residue_proba{'c'} = $residue_proba{'g'} = 0.191487802444946;
	    } elsif ($ARGV[$a+1] eq "input") {
		$input_alphabet = 1;
	    } elsif (("$ARGV[$a+1] $ARGV[$a+2] $ARGV[$a+3] $ARGV[$a+4]" =~ /a:t (\S+) c:g (\S+)/i) && ($1 >=0) && ($2 >=0) && ($1 + $2 > 0)) {
		$residue_proba{'a'} = $residue_proba{'t'} = $1/(2*($1+$2));
		$residue_proba{'c'} = $residue_proba{'g'} = $2/(2*($1+$2));
	    } else {
		$residue_proba{'a'} = 0.25;
		$residue_proba{'c'} = 0.25;
		$residue_proba{'g'} = 0.25;
		$residue_proba{'t'} = 0.25;
	    }
	    
	    ################################################################
	    #### thresholds
	    
	    #### threshold on matching sequences
	} elsif (($ARGV[$a] eq "-thms") && 
		 (&IsInteger($ARGV[$a+1]))) {
	    $mseq_threshold = $ARGV[$a+1];
	    
	    #### threshold on occurrences
	} elsif (($ARGV[$a] eq "-tho") && 
		 (&IsInteger($ARGV[$a+1]))) {
	    $occurrence_threshold = $ARGV[$a+1];
	    
	    #### threshold on occurrence probability
	} elsif (($ARGV[$a] eq "-thpo") && 
		 (&IsReal($ARGV[$a+1]))
		 && ($ARGV[$a+1] >= 0) && ($ARGV[$a+1] <= 1)) {
	    $proba_occ_threshold = $ARGV[$a+1];
	    $return{'proba'} = 1;
	    
	    #### threshold on obs/exp ratio
	} elsif (($ARGV[$a] =~ /^-thrat/i) && 
		 (&IsReal($ARGV[$a+1]))
		 && ($ARGV[$a+1] >= 0)) {
	    $ratio_threshold = $ARGV[$a+1];
	    $return{'exp_freq'} = 1;
	    $return{'ratio'} = 1;
	    
	    #### threshold on matching sequence probability
	} elsif (($ARGV[$a] eq "-thpms") &&  
		 (&IsReal($ARGV[$a+1]))
		 && ($ARGV[$a+1] >= 0) && ($ARGV[$a+1] <= 1)) {
	    $proba_mseq_threshold = $ARGV[$a+1];
	    $return{'mseq'} = 1;
	    $return{'proba'} = 1;
	    
	    
	    #### threshold on occurrence significance
	} elsif ($ARGV[$a] eq "-thosig") {
	    &FatalError( "Error : significance threshold should be a real number\n") unless (&IsReal($ARGV[$a+1]));
	    $occ_significance_threshold = $ARGV[$a+1];
	    $return{'occ'} = 1;
	    $return{'proba'} = 1;
	    
	    #### threshold on matching sequence significance
	} elsif (($ARGV[$a] eq "-thmssig") && (&IsReal($ARGV[$a+1]))) {
	    $mseq_significance_threshold = $ARGV[$a+1];
	    $return{'mseq'} = 1;
	    $return{'proba'} = 1;
	    
	    
	    ################################################################
	    #### statistics to return
	} elsif ($ARGV[$a] eq "-return") {
	    chomp($ARGV[$a+1]);
	    my @fields_to_return = split ",", $ARGV[$a+1];
	    foreach $field (@fields_to_return) {
		if ($field eq "occ") {
		    $return{'occ'} = 1;
		    push(@output_fields, "occurrences");
		    
		} elsif ($field eq "rank") {
		    $return{'rank'} = 1;
		    push(@output_fields, "rank");
		    
		} elsif ($field eq "mseq") {
		    $return{'mseq'} = 1;
		    push(@output_fields, "mseq");
		    
		} elsif ($field eq "proba") {
		    $return{'exp_freq'} = 1;
		    $return{'proba'} = 1;
		    push(@output_fields, "exp");
		    push(@output_fields, "proba");
		    
		} elsif ($field eq "ratio") {
		    $return{'exp_freq'} = 1;
		    $return{'ratio'} = 1;
		    push(@output_fields, "exp");
		    push(@output_fields, "ratio");
		    
		} elsif ($field =~ /^zsc/i) {
		    $return{'exp_freq'} = 1;
		    $return{'zscore'} = 1;
		    push(@output_fields, "exp");
		    push(@output_fields, "zscore");
		    
		} elsif ($field =~ /^like/i) { ### log likelihood
		    $return{'exp_freq'} = 1;
		    $return{'like'} = 1;
		    $return{'freq'} = 1;
		    push(@output_fields, "exp");
		    push(@output_fields, "like");
		    push(@output_fields, "frequency");
	
		} elsif ($field eq "pos") {
		    $return{'pos'} = 1;
		    push(@output_fields, "positions");
		    
		} elsif ($field eq "freq") {
		    $return{'freq'} = 1;
		    push(@output_fields, "frequency");
		    
		} elsif ($field =~ /^over/) {
		    $return{'ovlp'} = 1;
		    push(@output_fields, "ovlp");
		    
		} elsif ($field eq "var") {
		    $return{'est_var'} = 1;
		    push(@output_fields, "est_var");
		    
		} else {
		    &FatalError("Invalid return field $field");
		}

	    }

	    ################################################################
	    ## Return a table with one row per sequence and one column per pattern
	} elsif ($ARGV[$a] eq "-table") {
	    if ($return{'distrib'}) {
		&FatalError("The options -table and -distrib are mutually incompatible");
	    }
	    $return{'table'} = 1;
	    push(@output_fields, "occ");
	    
	    
	    ################################################################
	    ## Return a table with one row per pattern and one column per occurrence value
	} elsif ($ARGV[$a] eq "-distrib") {
	    if ($return{'table'}) {
		&FatalError("The options -table and -distrib are mutually incompatible");
	    }
	    $return{'distrib'} = 1;
	    push(@output_fields, "occ");
	    
	    
	    ################################################################
	    #### sorting
	} elsif ($ARGV[$a] eq "-sort") {
	    $sort_result = 1;
	    
	} elsif ($ARGV[$a] eq "-under") {
	    $under_represented = 1;
	    
	}
	$a++;
    }
    
    if ($verbose >= 2) {
	&Warning(&AlphaDate()."\tStarting");
    }
}
 

################################################################
#### Print detailed help message
sub PrintHelp {
  open HELP, "| more";
  print HELP <<End_of_help; 
NAME
	oligo-analysis
	
        1997-99 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
DESCRIPTION
	calculates oligomer frequencies in a set of sequences,
        and detects overrepresented oligomers.

CATEGORY
	sequences
	pattern discovery

USAGE
	oligo-analysis -l length [-i inputfile]  [-format input_format]
		[-o outputfile] 
		[-return occ,freq,ratio,mseq,proba,zscore,like,rank]
		[-expfreq exp_freq_file | -a alphabet | -markov #]
		[-1str | -2str] [-seqtype dna|prot|other][-grouprc | -nogrouprc]
		[-tho #][-thpo #][-thosig #][-thratio #][-thms #]
		[-thpms #][-thmssig #] [-oneN | -onedeg][-v]

        oligo-analysis [-h | -help]

ARGUMENTS
    INPUT OPTIONS
	-i file	inputfile. This file should contain the sequences.
	-format	input file format. Must be followed by one of the 
		following options:
		   fasta (default)
		   wconsensus
		   IG
		   filelist
		   raw
		See below for the description of these formats.
	-l	oligomer length.

    PROBABILISTIC MODEL
	-a	alphabet
		must be followed by nucleotide frequencies expressed precisely 
		this way:
		-a a:t # c:g #
		ex: 
		-a a:t 0.3 c:g 0.2
		
		Special alphabet options
                -a input
                        use the alphabet of the input sequence
	-expfreq
		file containing the estimations for expected oligomer 
		frequencies. This can be for instance the olignonucleotide 
		frequency measured in the whole genome, or in all intergenic 
		regions, or in all coding regions. 
		This information is used for the calculation of probabilities.
		If omitted, expected frequencies are calculated on basis of
		an equiprobable nucleotide utilization.
	-rescale
		rescale expected frequencies to obtain a sum of 1.
		This allows to use absolute occurrences (rather than
		relative frequencies).
	-ncf	(deprecated, use "-bg intergenic" instead)
		use intergenic frequencies as background frequencies
	-bg	background model
		Type of sequences used as background model for
		estimating expected oligonucleotide frequencies.
		
		Supported models: 
		-bg upstream 
			 all upstream sequences, allowing overlap with
		         upstream ORFs

		-bg upstream-noorf
			  all upstream sequences, preventing overlap
			  with upstream ORFs

		-bg intergenic
		         intergenic frequencies 
			 Whole set of intergenic regions, including
			 upstream and downstream sequences

	-org	organism 
		This is necessary with the option -bg, to determine
		which frequency file has to be sued for expected
		frequency calibration.
	-markov #
		Markov chain: the frequency expected for each word is 
		calculated on basis of subword frequencies observed in the 
		input set. 
		
		The number # indicates the order of the Markov chain. 
		If negative, # is substracted to word length 
		e.g:
			-l 6 -markov -2
		is equivalent to
			-l 6 -markov 5
		
		Order 0 is equivalent to using single nucleotide frequencies
		(-a input).
			
		Ex: calculation of expected 6nt frequencies on basis 
		of a Markov chain of order 4 :
		              obs(GATAA) x obs(ATAAG)
		exp(GATAAG) = -----------------------
		                   obs(ATAA)

	-lexicon
		Expected word frequencies are calculated on the basis
		of subword frequencies, in a similar (but not
		identical) way to the "dictionary" approach developed
		by Harmen Bussemaker.  Each word is segmented in 2
		subwords in all possible ways:

			GATAAG	G & ATAAG
				GA & TAAG
				GAT & TAG
				GATA & AG
				GATAA & G

		The expected frequency of each segmented pair is the
		product of expected frequencies of its members. The
		expected word frequency is the maximum expected pair
		frequency.

	-pseudo #
		 pseudo-weight
		 # must be a real value between 0 and 1. 
		 This allows to circumvent the problem that the
		 expected frequency file might be incomplete (due to
		 a too small reference sequence set), in which case
		 some oligonucleotides might have an observed
		 frequency > 0, whereas the expected frequency is 0
		 (leading to an impossible event). The expected
		 frequency is corrected by a pseudo-frequency, which
		 is the pseudo-weight divided by the number of
		 possible patterns.

    COUNTING OPTIONS
	-noov	no overlapping. 
		Disable the detection of overlapping matches for 
		self-overlapping patterns (ex TATATA, GATAGA).
	-2str	(default)
		oligonucleotide occurrences found on both stands are summed. 
	-1str	
		inactivates the summation of occurrences on both strands.

    SEQUENCE TYPE
	-seqtype  dna|prot|other
		Input sequence type
		. DNA (default)
		    Only A, C, G, and T residues are
		    accepted. oligomers that contain partly defined
		    (IUPAC code) or undefined nucleotides (N) are
		    discarded from the countings.
		. protein
		    Oligopeptide analysis instead of oligonucleotide.
		    This inactivates the grouping of oligomers with
		    their reverse complements, and modifies the
		    alphabet size.
		. other
		    Any type of letters found in the input sequence is
		    considered valid. This allows to analyze texts in
		    human language.

    OUTPUT OPTIONS
	Note:	By default, the occurrences of each oligonucleotide on both 
		strands are summed. This can be inactivated with the 
		-1str option.
		
	-o file	outputfile. Returns a list of the oligomers 
		encountered in the sequences, with their frequencies.
	-v #	verbose level
			1 report parameters and statistics
			2 warn when the program enters a new subroutine
			3 warn when the program reads a new sequence
			4 very high verbosity (for debugging)

	-return	list of statistics to return
		this option is followed by a list of words, 
		separated by commas, indicating which values
		have to be returned for each oligomer. 
		Supported statistics:
			occ	number of occurrences .
			mseq	number of matching sequences.
			freq	relative frequencies 
				(occurrences/sum of occurrences)
			proba	binomial probability for observing
				>= obs occurrences
			ratio	observed/expected ratio
			zscore	z-score
			like	log likelihood
			pos	matching positions for each oligomer
			rank	rank of the pattern according to the sorting 
				criterion
		ex: -return freq,occ,zscore	

	-pal
		only return reverse palindroms
	-table
		return a table where rows represents input sequences,
		and columns the counts of occurrences for each
		possible oligo
	-distrib
		return occurrence distributions (one row per pattern)		
	-grouprc (default)
		group reverse complement with the direct sequence in the 
                output file. This avoids redundancy (since the frequence of 
                AAAAA is the same as TTTTT when one searches on both strands).
 		Can be inactivated by the -nogrouprc option.
		Incompatible with -1str.
	-nogrouprc
		inactivates grouping of reverse complement pairs.
	-oneN	group oligonucleotides by neighborhood, where one neighborhood
 		is defined as a set of oligo differing by one mismatch at a 
		common position.
		ex: the oligonucleotide atg admits 3 distinct neighborhoods:
			atN
			aNg
			Ntg
	-onedeg	sucessively insert one ambiguous nucleotide code at each 
		position of each pattern

	-sort   sort oligomers according to overrepresentation. 
		The sort criterion depends on the estimators returned, 
		by preference:
		- Z-score
		- binomial significance
		- occurrence number

	-under	detect under-represented instead of over-represented words
		(see below for details). 

    THRESHOLDS
	-tho #	where # is an integer. Occurrence threshold: only returns the 
		patterns occuring at least # times in the whole sequences. 
		This criterion differs from thg in that multiple occurrences 
                of a pattern in the same upstream regions are taken into 
                account.
	-thpo #	where # is a real value comprised between 0 and 1.
		Threshold on occurrence probability: only returns the patterns
                for which the probability to encounter a number of occurrences 
                higher or equals to that observed is smaller than #.  
	-thosig #	
                threshold on occurence significance index. 
		Only returns the patterns for which the occurence significance 
                index is higher than or equal to #.
	-thratio #
		threshold on observed/expected occurrence ratio
		Only returns patterns with higher ratios than the threshold.

	-thms #	where # is an integer. Gene threshold: only returns the 
		patterns encountered at least once in at least # upstream 
		regions.
	-thpms #	
                where # is a real value comprised between 0 and 1.
		Threshold on occurrence probability: only returns the patterns
                for which the probability of a number of matching sequences  
                higher or equals to that observed is smaller than #.  
	-thmssig #	
                threshold on matching sequence significance index. 
		Only returns the patterns for which the significance 
                index of matching sequences is higher than or equal to #.

INPUT FORMATS
	raw	The input file should contain raw sequences without any 
                comment or other text. Tabs (\\t), blank spaces and newline 
                characters (\\n) are accepted (they will be automatically 
                removed before analysis). The sequence must be terminated by 
                a newline character.
	
	multi	same as raw except than each new line is considered to contain
 		a new independent sequence in raw format.
		
	filelist	
		file list. Each line of the input file contains the 
		name of a file containing a single sequence.

	fasta	FastA format. 

	IG	IntelliGenetics format. 	
 		The first non-comment line must be the sequence identifier 
		(a single word without spaces). 
		The sequence follows the identifier line identifier. It can 
                include spaces, tabs or newlines, that will be removed for 
                sequence analysis.
                The end of one sequence is indicated by termination character:
		1 for linear, 2 for circular sequences. 
		A single file may contain several sequences. 

		EXAMPLE of IG suite:

		; sequence of the region upstream from NIL1
	        ; Locus GAT1
 	        ; ORF YFL021W  coord:   6 95964 97496
 	        ; upstream region size: 100
 	        ; upstream region coord:        6 95864 95963
 	        GAT1
 	        ACAGAGCAACAATAATAACAGCACTATGAGTCGCACACTT
  	        GCGGTGCCCGGCCCAGCCACATATATATAGGTGTGTGCCA
  	        CTCCCGGCCCCGGTATTAGC
  	        1
 	        ; sequence of the region upstream from PUT4
                ; Locus PUT4
                ; ORF YOR348C  coord:   15 988773 986890
                ; upstream region size: 100
                ; upstream region coord:        15 988873 988774
                PUT4
                GGGTTTGTGTTCCTCTTCCTTTCCTTTTTTTTTCTCTCTT
                CCCTTCCAGTTTCTTTTATTCTTTGCTGTTTCGAAGAATC
                ACACCATCAATGAATAAATC
                1	
		
PROBABILITIES

    EXPECTED OCCURRENCES
	                          S
	   Exp_occ = p * T = p * SUM (Lj + 1 - k)
	                         j=1
	
	where	p  = probability of the pattern
		     Severay models are supported for estimating the
		     prior probability (see options -a, -expfreq and
		     -bg).
		S  = number of sequences in the sequence set. 
		Lj = length of the jth regulatory region
		k  = length of oligomer
                T = the number of possible matching positions.
		


    PROBABILITY OF SEQUENCE MATCHING
	The probability to find at least one occurrence of the pattern within
	a single sequence is :
	
	                 T
	    q = 1 - (1-p)
	    
	with the same abbreviations as above


    EXPECTED NUMBER OF MATCHING SEQUENCES

	In this counting mode, only the first occurrence of each
	sequence is taken into connsideration. We have thus to
	calculate a probability of first occurrence.

	   Exp_ms = n (1 - (1 - p)^T)
	
	with the same abbreviations as above
	
	Correction for autocorrelation (from Mireille Regnier)
		Exp_ms_corrected = n (1 - (1 - p/a)^T)
	   Where 
		 a is the coefficient of autocorrelation
		
    
    PROBABILITY OF THE OBSERVED NUMBER OF OCCURRENCES (BINOMIAL)
	
	The probability to observe exactly obs occurrences in the whole family
  	of sequences is calculated by the binomial
	
	                                              obs      T-obs
	    P(obs) = bin(p,T,obs) =       T!         p    (1-p)
                                     ---------------
                                     obs! * (T-obs)! 
	
	where   obs is the observed number of occurrences,
                p   is the expected frequency for the pattern,
                T   is the number of possible matching positions,
                    as defined above. 
	
	The probability to observe obs or more occurrences in the whole family
  	of sequences is calculated by the sum of binomials:
	
	                 T              obs-1
	    P(>=obs) =  SUM P(i) =  1 -  SUM  P(i)
	               i=obs             i=0

    OVER/UNDER-REPRESENTATION

		By default, the program calculates probability to have
		at least obs occurrences:

			                 T
			    P(>=occ) =  SUM P(i)
			               i=occ

		With the option -under, the program calculates the
		probability of having less than obs occurrences : 

			               occ-1
			    P(<=occ) =  SUM P(i)
			                i=0

		The option -under does not affect the other statistics
		(zscore, loglikelihood). For z-score, the negative
		values can be used to asses word under-representation.

	                        
    SPECIFIC TREATMENT FOR DOUBLE STRAND COUNTS

	When occurrences are counted on both strands, each pattern is
	grouped with its erverse complement. 

	For reverse-palindromic patterns, probabilities are calculated
	on the basis of the single strand count, since the occurrence
	on the reverse complement strand is completely dependent on
	that on the direct strand. 

        A more biological justification for this is that, although the
        word is foudn on both strands in a string representation of
        the sequences, at the structural level, there is a single
        binding site for the factor. 


	On the contrary, for non-palindrommic patterns, occurrences on
        the direct and reverse complement strand represent distinct
        binding sites. Thus, 

		 Obs_occ(W|Wr) = Obs_occ(W) + Obs_occ(Wr)
		 Exp_freq(W|Wr) = Exp_freq(W) + Exp_freq(Wr)

	   where
		 W     is a given word
		 Wr    is the reverse complement of W

	Probabilities are then calculated as above, on the basis of
	the event W|Wr instead of simply W.

    E-VALUE

	The probability of occurrence by itself is not fully
	informative, because the threshold must be adapted depending
	on the number of patterns considered. Indeed, a simple
	hexanucleotide analysis amounts to consider 4096
	hypotheses. 

	The E-value represented the expected number of patterns which
	would be returned at random for a given P-value (probability).

	      E-value = NPO * P(>=obs)

	where	NPO	 is the number of possible oligomers of the 
	                 chosen length (eg 4096 for hexanucleotides). 

        Note that when searches are performed on both strands, NPO is
        corrected for the fact that non-palindromic patterns are
        grouped by pairs (for example, there are 2080 patterns when
        hexanucleotides are counted on both strands).


    SIGNIFICANCE INDEXES

        The significance index is simply a negative logarithm
        conversion of the E-value (in base 10).


	The significance indexes are calculated as follows:
	
	      Sig_occ = -log10(E-value);

	This index is very convenient to interpret : highest values
	correspond to the most exceptional patterns.


    OVERLAP COEFFICIENT
        overlap coefficient is calculated as follows 
        (after Pevzner et al.(1989). J. Biomol. Struct & Dynamics 
        5:1013-1026):

	           l    
            Kov = SUM kj (1/4)^j
                  j=1

        where l  is the pattern length. 
              j  is the overlap position, comprised between 0 and l.
              kj takes the value 1 if there is an overlap at pos j,
                 0 otherwise.

        When counts are performed on both strands, overlaps between
        the pattern and its reverse complement are also taken into account
        into the same formula.			

    Z-SCORE
	The Z-score is calculated in the following way

		Zsc = (obs_occ - exp_occ)/var_occ
	where
		obs_occ	is the observed number of occurrences
		exp_occ	is the expected number of occurrences
		var_occ	is the estimate for the variance on occurrences

	The estimation of the variance is derived from Pevzner et al.(1989). 
	J Biomol Struct & Dynamics 5:1013-1026):
		var_occ = exp_occ(2*Kov - 1 - (2*w-1)*exp_occ)

	In random sequences, Z-scores are normally distributed. The probability 
	to observe a given number of occurrences can thus be read in the 
	normal table from any book of statistics.

	Advantages of the Z-score:
	- Z-score corrects the bias due to self-overlapping of a word, which 
	  often leads to overestimate the overrepresentation of such words
	  (eg AAAAAA, TATATA). 
	- its calculation is very fast. 
	  This is especially critical when analyzing 
	  very big sequences (whole genomes), where the expected oligont 
	  occurrences are very high (and binomial calculation very slow).
	- Z-score provides a way to detect both over- and under-represented 
	  patterns. 

	Disadvantages:	
	- the use of Z-score assumes that the sequences are infinite

	Recommended thresholds:
	=======================
	strand	w	P(>=oc)	z-score
	-------------------------------
	1str	3	0.98437	2.155
	1str	4	0.00609	2.66
	1str	5	0.99902	3.095
	1str	6	0.99976	3.49	
	1str	7	0.99994	3.83
	1str	8	0.99998	4.1

	2str	3
	2str	4
	2str	5
	2str	6	0.99952	3.30
	2str	7	
	2str	8

EXAMPLE
	oligo-analysis \
		 -i $RSA/data/Saccharomyces_cerevisiae/genome/Contigs_Saccharomyces_cerevisiae.tab \ 
		 -format filelist -l 6 -occ \
                 -freq -o hexanucleotides.occ_and_freq -v
	
	will return a list of all hexanucleotides found in yeast genome, with 
	the number of occurrences and relative frequency for each one.
	
WEB VERSION
	oligo-analysis can be used via internet at the following site:
	http://www.ucmb.ulb.ac.be/bioinformatics/rsa-tools/

HISTORY
	1997	June	starting the oligo-analysis project
	1997	sept	calculation of the sig index
	1998	-	Markov chain (k-1 order)
	1998	-	z-score calculation with overlap coefficient
	1999	March	Markov chain of any order between 1 and k-1
End_of_help
  close HELP;
  exit(0);
}

################################################################
#### Princ option list
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_of_help; 
oligo-analysis options
----------------------
-h              display complete help message
-help           display this list of options
-i              input file
-format         input format. Accepted: fasta (default), wconsensus, IG, raw, filelist
-seqtype       	sequence type (dna|prot|other)
-o              output file
-v #            verbose level
-l              oligomer length
-a a:t # c:g #  alphabet utilization
-a yeast        use yeast genomic alphabet
-a input        use alphabet from input sequence
-expfreq        file with expected frequency table
-rescale	rescale expected frequencies to obtain a sum of 1
-ncf		(deprecated, use '-bg intergenic' instead) 
-bg		background model (supported: $supported_bg)
-org		organism 
-markov	#	calculate expected frequencies according to
		Markov chains of order #
-lexicon	exp word frequencies calculaed on the basis of word segments
-pseudo	#	pseudo-weight (# between 0 and 1)
-return		fields to return, among: 
			occ,proba,freq,mseq,ratio,zscore,like,pos,rank
-table		return a table sequences (rows)/oligo occurrences (cols)
-distrib	return occurrence distributions (one row per pattern)
-noov		no overlapping
-1str		inactivate summation of occ on both strands
-2str		sum occurences on both strands (default)
-grouprc        group reverse complement pairs (default)
-nogrouprc      do not group reverse complement pairs
-tho            threshold on occurence number
-thpo           threshold on occurence probability
-thratio	threshold on observed/expected occurrence ratio
-thosig         threshold on occurence significance index
-thms           threshold on matching sequence number
-thpms          threshold on matching sequence proba
-thmssig        threshold on matching sequence significance index
-oneN           one undefined position
-onedeg         one degenerate position		
-sort		sort oligomers by overrepresentation
-under		detect under-represented instead of over-represented words 
-pal		only return reverse palindroms
End_of_help
    close HELP;
    exit(0);
}



################################################################
#
# Select reverse palindromic patterns (delete all other patterns)
#
sub SelectPalindroms {
  if ($verbose >= 2) {
    &Warning(&AlphaDate()."\tSelcting reverse palindroms");
  }
  
  foreach $pattern_seq (keys %patterns) {
      my $rc = lc(&SmartRC($pattern_seq));
      unless ($rc eq $pattern_seq) { ### palindroms
	  delete $patterns{$pattern_seq};
      }
  }
}


################################################################
#
# Print oligo count distribution
#

sub PrintCountDistrib {
    my %min = ();
    my %max = ();
    my $distrib_min = undef;
    my $distrib_max = undef;

    #### Calculate maximum and minimum occurrence values
    foreach my $pattern_seq (@output_patterns) {
	my @sorted_values = sort {$a <=> $b} keys %{$distrib{$pattern_seq}};
	$min{$pattern_seq} = $sorted_values[0];
	$max{$pattern_seq} = $sorted_values[$#sorted_values];
	$distrib_min = &checked_min($distrib_min, $min{$pattern_seq});
	$distrib_max = &checked_max($distrib_max, $max{$pattern_seq});
	print $out join ("\t", 
			 $pattern_seq,
			 $min{$pattern_seq},
			 $max{$pattern_seq},
			 $distrib_min,
			 $distrib_max,
			 join (";", @sorted_values),
			 ), "\n" if ($main::verbose >= 5);
    }

    #### print verbose
    &Verbose() if ($verbose >= 1);

    #### Print the header
    print $out join ("\t", 
		     ";occ", 
		     $distrib_min..$distrib_max), "\n";

    #### Print the result
    foreach my $pattern_seq (@output_patterns) {
	print $out &PatternID($pattern_seq);
	foreach my $occ ($distrib_min..$distrib_max) {
	    my $freq = $distrib{$pattern_seq}{$occ} || 0;
	    print $out "\t", $freq;
	}
	print $out "\n";
    }
}
