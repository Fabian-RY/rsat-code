#!/usr/bin/perl -w
############################################################
#
# $Id: compare-features,v 1.5 2005/07/27 13:38:41 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################
# use strict;
#use diagnostics;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
    require "RSA.lib";
}
use RSAT::feature;
use RSAT::stats;


=pod

=head1 NAME

compare-features

=head1 DESCRIPTION

Compare two or more sets of features. 

This program takes as input several feature files (two or more), and
calculates the intersection and difference between features.

=head1 AUTHORS

=item Jean Valery Turatsinze <jturatsi@ulb.ac.be> 

=item Jacques van Helden <jvanheld@scmbb.ulb.ac.be>

=head1 CATEGORY

util

=head1 USAGE
    
compare-features -i inputfile_1 -i inputfile_2 [-i inputfile_3 ... ...] 
[-o outputfile] [-v]

=head1 INPUT FORMAT

The default input format is .ft (the same as for feature-map). Other
formats are also supported ($supported_input_formats).

=head2 Feature format

Each feature is represented by a single line, which 
should provide the following information:

Input file columns:

=item 1. map label (eg gene name)

=item 2. feature type

=item 3. feature identifier (ex: GATAbox, Abf1_site)

=item 4. strand (D for Direct, R for Reverse),

=item 5. feature start position

=item 6. feature end position

=item 7. (optional) description 

=item 8. (optional) score

The standard input format assumes that these topics 
are provided in this order, separated by tabs. 
Start and end positions can be positive or negative.


=head1 OUTPUT FORMAT

=cut

    
################################################################
#### Main package
    package main;
{
    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();
    
    #local %infile = ();
    local @inputfiles = ();
    local %outfile = ();
    
    local $verbose = 0;
    local $in = STDIN;
    local $out = STDOUT;
    
    ## Input formats
    local $input_format = "ft";
    %supported_input_format =(ft=>1,
			      gft=>1,
			      gff=>1,
			      dnapat=>1,
			     );
    $supported_input_formats = join (",", keys %supported_input_format);
    
    ## Output formats
    local $output_format = "ft";
    %supported_output_format =(ft=>1,
			       gft=>1,
			       gff=>1,
			       dnapat=>1
			      );
    $supported_output_formats = join (",", keys %supported_output_format);
    
    ## Return types
    %supported_return_type =(stats=>1,
			     inter=>1,
			     diff=>1
			    );
    $supported_return_types = join (",", sort(keys %supported_return_type));
    local @return_types = ();
    local %return_types = ();
    
    ## Variables for storing the data and results
    local @feature_lists = ();
    local $inter_nb = 0;
    local @intersection_counts = ();
    local @intersection_features = ();
    
    local $self_comparison = 0;
    
    local $null = "<NA>";
    
    &ReadArguments();
    
    ################################################################
    ## Return types
    if (scalar(@return_types) <= 0) {
	@return_types  = qw(stats inter);
    }
    foreach my $type (@return_types) {
	if ($supported_return_type{$type}) {
	    $return{$type}++;
	} else {
	    &FatalError(join ("\t", "Invalid return type", $type, "Supported: $supported_return_types"));
	}
    }
    

    ################################################################
    #### check argument values

    ## Number of input files should be >= 2
    unless (scalar(@inputfiles) >= 2) {
	&RSAT::error::FatalError("You must specify at least two input files\n");
    }




    ################################################################
    ##### read input
    my $feat_nb = 0;
    my %feature_ids = ();
    foreach my $f (0..$#inputfiles) {
	my @features = ();
	my $infile = $inputfiles[$f];
	&RSAT::message::TimeWarn(join("\t", "Reading features from file", $f, $infile)) if ($main::verbose >= 2);
	($in) = &OpenInputFile($infile);
	while (<$in>) {
	    ## Comment lines
	    if ((/^;\s+(.*)/) || (/^--\s+(.*)/)) {
		next;
	    }
	    next unless (/\S/);
	    chomp;
	    my $feature = new RSAT::feature();
	    $feat_nb++;
	    my $new_id = "ft_".$feat_nb;
	    $feature->parse_from_row($_, $input_format);
	    $feature->set_attribute("id", $new_id);
	    $feature->set_attribute("file_nb", $f);
	    $feature->set_attribute("filename", $infile);
	    push @features, $feature;
	    $feature_ids{$new_id} = $feature;
#	print $out $feature->to_text($output_format, $null);
	}
	close $in if ($infile);
	push @feature_lists, \@features;
    }

    ################################################################
    ## Open output stream
    $out = &OpenOutputFile($outfile{output});

    ################################################################
    #### print verbose
    &Verbose() if ($verbose);

    ################################################################
    ## Index of all the starting positions per sequence. The indexing keys are
    ## - sequence name
    ## - reference to the feature object
    ## The indexed value is the starting positions
    &RSAT::message::TimeWarn("Indexing features by position");
    my %left_index = (); 
    for my $a (0..$#inputfiles) {
	my $ref_a = $feature_lists[$a];
	&RSAT::message::TimeWarn(join("\t","", "Indexing file", 
				      ($a+1)."/".scalar(@inputfiles), 
				      $inputfiles[$a])) if ($main::verbose >= 2);
	foreach my $feature (@{$ref_a}) {
	    my $seq_name = $feature->get_attribute('seq_name');
	    my $start = $feature->get_attribute('start');
	    my $end = $feature->get_attribute('end');

	    ## Calcualate left and right coordinates
	    my $left = &RSAT::stats::min($start, $end);
	    $feature->set_attribute("left", $left);
	    my $right = &RSAT::stats::max($start, $end);
	    $feature->set_attribute("right", $right);
	    my $len = $right - $left + 1;
	    $feature->set_attribute("len", $len);


	    ## Index the feature 
	    my $id = $feature->get_attribute("id");
	    $left_index{$seq_name}->{$id} = $left;
# 	    &RSAT::message::Debug("Indexing left position", 
# 				  $a, $inputfiles[$a], $seq_name, $start, $end, $left,
# #				  $feature, \$feature, 
# 				  $feature->get_attribute("id"),
# 				  $feature->get_attribute("left"),
# 				  ) if ($main::verbose >= 0);
	}
    }

    ## Detect intersection between features
    my $seq_nb = scalar(keys %left_index);
    my $s = 0;
    foreach my $seq_name (keys (%left_index)) {
	$s++;
	my %seq_features = %{$left_index{$seq_name}};
	my @sorted_features = sort {$left_index{$seq_name}->{$a} <=> $left_index{$seq_name}->{$b} } keys %seq_features;
	&RSAT::message::TimeWarn(join("\t", "Finding intersections between", 
				      scalar(keys(%seq_features)), 
				      "features in sequence",
				      $s."/".$seq_nb,
				      $seq_name)
			     ) if ($main::verbose >= 2);
	foreach my $f (0..$#sorted_features) {
	    my $current_id = $sorted_features[$f];
	    my $current_ft = $feature_ids{$current_id};
#	    &RSAT::message::Debug("Sorted features",
#				  $f+1, 
#				  scalar(@sorted_features),
#				  $current_id, 
#				  $seq_name,
#				  $current_ft->get_attribute("strand"),
#				  $current_ft->get_attribute("left"),
#				  $current_ft->get_attribute("right"),
#				  $current_ft->get_attribute("len"),
#				  $current_ft->get_attribute("file_nb"),
#				  $current_ft->get_attribute("filename"),
#				  ) if ($main::verbose >= 0);

	    ## Detect next features overlapping with the current one
	    my $next = $f;
	    my $inter_len = 0;
	    while ($next <= ($#sorted_features-1)) {
		$next++;
		my $next_id = $sorted_features[$next];
		my $next_ft = $feature_ids{$next_id};
		my $inter_len = $current_ft->get_attribute("right") - $next_ft->get_attribute("left") + 1;
		$inter_len = &RSAT::stats::max(0,$inter_len);
		if ($inter_len <= 0) {
		    last;
		} else {
#		    &RSAT::message::Debug("Intersection", #
#					  $f+1,
#					  $current_id, 
#					  $current_ft->get_attribute("left"),
#					  $current_ft->get_attribute("right"),
#					  $next+1,
#					  $next_id, 
#					  $next_ft->get_attribute("left"),
#					  $next_ft->get_attribute("right"),
#					  $inter_len) if ($main::verbose >= 0);
		    &CreateIntersection($current_ft,$next_ft);
		}
	    }
	}
    }

    

    &PrintStatistics if ($return{stats});

    ################################################################
    ## Print the comparison features
    if ($return{inter}) {
	foreach my $feature (@intersection_features) {
	    print $out $feature->to_text($output_format, $null);
	}
    }

    ################################################################
    ###### finish verbose
    if ($verbose >= 1) {
	my $done_time = &AlphaDate();
	print $out "; Job started $start_time\n";
	print $out "; Job done    $done_time\n";
    }


    ################################################################
    ###### close output stream
    close $out if ($outfile{output});

    exit(0);
    
}

################################################################
################### subroutine definition ######################
################################################################

################################################################
## Print statistics
sub PrintStatistics {
    ## Calculate max length of file names for aligning the stat tables
    local $filename_len = 0;
    foreach my $filename (@inputfiles) {
	$filename_len = &RSAT::stats::max($filename_len, length($filename));
    }

    ## INTERSECTION COUNTS
    &PrintTable("INTERSECION COUNTS", "%d", @intersection_counts);

    ## FEATURES WITH AT LEAST ONE INTERSECTION
    ## Count intersections per features 
    my %intersections_per_ft = ();
    foreach my $intersection_ft (@intersection_features) {
	my ($a, $b) = ($intersection_ft->get_attribute("files"));
	my ($id_a, $id_b) = ($intersection_ft->get_attribute("feature_ids"));
#	&RSAT::message::Debug($a, $b, $id_a, $id_b) if ($main::verbose >= 0);
	$intersections_per_ft{$a}->{$b}->{$id_a}++; ## intersections for feature id_a of file A in file B
	$intersections_per_ft{$b}->{$a}->{$id_b}++; ## intersections for feature id_b of file B in file A
    }

    ## Features with at least one intersection
    my @one_inter_per_ft = ();
    foreach my $a (0..$#inputfiles) {
	foreach my $b (0..$#inputfiles) {
	    my $a_in_b = 0;
	    if (!($self_comparison) && ($a == $b)) {
		$a_in_b = "<NA>";
	    } elsif (defined($intersections_per_ft{$b}->{$a})) {
		$hash_ref = $intersections_per_ft{$b}->{$a};
		$a_in_b = scalar(keys(%$hash_ref));
	    } else {
		$a_in_b = 0;
	    }
#	    &RSAT::message::Debug("One intersection per feature", 
#				  $a,
#				  $b,
#				  $a_in_b) if ($main::verbose >= 0);
	    $one_inter_per_ft[$a][$b] = $a_in_b;
	}
    }
    &PrintTable("FEATURES WITH LEAST ONE INTERSECTION", "%d", @one_inter_per_ft);


    ## FRACTION OF FEATURES WITH AT LEAST ONE INTERSECTION
    my @intersection_percent = ();
    for my $a (0..$#inputfiles) {
	my $ref_a = $feature_lists[$a];
	my $nb_features_a = scalar(@{$ref_a});
	for my $b (0..$#inputfiles) {
	    my $ref_b = $feature_lists[$b];
	    my $nb_features_b = scalar(@{$ref_b});
	    if (&IsReal($one_inter_per_ft[$a][$b]) && (&IsReal($nb_features_b))) {
		$intersection_percent[$a][$b] = $one_inter_per_ft[$a][$b]/$nb_features_b;
	    } else {
		$intersection_percent[$a][$b] = $null;
	    }
	    if (&IsReal($one_inter_per_ft[$b][$a]) && (&IsReal($nb_features_a))) {
		$intersection_percent[$b][$a] = $one_inter_per_ft[$b][$a]/$nb_features_a;
	    } else {
		$intersection_percent[$b][$a] = $null;
	    }
	}
    }
    &PrintTable("FRACTION OF FEATURES WITH LEAST ONE INTERSECTION", "%7.5f", @intersection_percent);
}

################################################################
## Print one stat table
sub PrintTable {
    my ($title, $format, @table) = @_;
    $format = $format || "%7g";
    print $out ";\n";
    print $out "; ",$title,"\n";
    print $out join ("\t", ";", "file_nb", sprintf("%-${filename_len}s", "file name"));
    for my $a (0..$#inputfiles) {
	print $out "\tfile_".($a+1);
    }
    print $out "\n";

    for my $a (0..$#inputfiles) {
	print $out join "\t", ";", "file_".($a+1), sprintf("%-${filename_len}s", $inputfiles[$a]);
	for my $b (0..$#inputfiles) {
	    unless (defined($table[$a][$b])) {
		if (($self_comparison) || ($a != $b)) {
		    $table[$a][$b] = 0;
		} else {
		    $table[$a][$b] = $null;
		}
	    }
	    if (&IsReal($table[$a][$b])) {
		print $out "\t", sprintf($format, $table[$a][$b]);
	    } else {
		print $out "\t", $table[$a][$b];
	    }
	}
	print $out "\n";
    }    
    print $out ";\n";
}
    
    
################################################################
## Create a feature with the intersection between two features, and
## append it to the list.
sub CreateIntersection {
    my ($current_ft, $next_ft) = @_;
    my $file_1 = $current_ft->get_attribute("file_nb");
    my $file_2 = $next_ft->get_attribute("file_nb");

    ## Check if self-comparison
    if (($file_1 == $file_2) && !($self_comparison)) {
	return();
    }
    
    my $file_a = &RSAT::stats::min($file_1, $file_2);
    my $file_b = &RSAT::stats::max($file_1, $file_2);
    
    ## Add the intersection in statistics
    $intersection_counts[$file_a][$file_b]++;
    if ($file_a != $file_b) {
	$intersection_counts[$file_b][$file_a]++;
    }
    
    ## create a new feature for the intersection
    my $intersection_ft = new RSAT::feature();
    $inter_nb++;
    $intersection_ft->set_attribute("id", "inter".$inter_nb);
    $intersection_ft->set_attribute("seq_name", $current_ft->get_attribute("seq_name"));
    $intersection_ft->set_attribute("ft_type", "inter");
    
    ## Intersection name
    my $inter_name = "";
    $inter_name .= ($file_a+1).".inter.".($file_b+1);
    $intersection_ft->set_attribute("feature_name", $inter_name);
    
    ## Intersection boundaries
    $intersection_ft->set_attribute("start", $next_ft->get_attribute("left"));
    $intersection_ft->set_attribute("end", $current_ft->get_attribute("right"));

    ## Length calculations
    my $pair_left = &RSAT::stats::min($next_ft->get_attribute("left"),
				      $current_ft->get_attribute("left"));
    my $pair_right = &RSAT::stats::max($next_ft->get_attribute("right"),
				      $current_ft->get_attribute("right"));
    my $pair_len = $pair_right - $pair_left + 1;
    my $inter_len = $intersection_ft->get_attribute("end") -  $intersection_ft->get_attribute("start") + 1;
    my $len_cov = $inter_len/$pair_len;
    $intersection_ft->set_attribute("pair_len", $pair_len);
    $intersection_ft->set_attribute("inter_len", $inter_len);
    $intersection_ft->set_attribute("len_cov", $len_cov);

#     &RSAT::message::Debug("Intersection len", 
# 			  $intersection_ft->get_attribute("seq_name"),
# 			  $current_ft->get_attribute("filename"),
# 			  $current_ft->get_attribute("id"),
# 			  $current_ft->get_attribute("left"),
# 			  $current_ft->get_attribute("right"),
# 			  $next_ft->get_attribute("filename"),
# 			  $next_ft->get_attribute("id"),
# 			  $next_ft->get_attribute("left"),
# 			  $next_ft->get_attribute("right"),
# 			  $inter_len,
# 			  $pair_len,
# 			  $len_cov,
# 			 );

    ## Intersection strand
    if ($current_ft->get_attribute("strand") eq $next_ft->get_attribute("strand")) {
	$intersection_ft->set_attribute("strand", $current_ft->get_attribute("strand"));
    } else {
	$intersection_ft->set_attribute("strand", "DR");
    }
    
    ## Intersection description
    my $description = "Intersection";
    $description .= " (".$intersection_ft->get_attribute("inter_len");
    $description .= "/";
    $description .= $intersection_ft->get_attribute("pair_len").")";
    $description .= " between ";
    $description .= join (":", 
			  $current_ft->get_attribute("filename"),
			  $current_ft->get_attribute("id"),
			  $current_ft->get_attribute("feature_name")
			  );
    $description .= " and ";
    $description .= join (":", 
			  $next_ft->get_attribute("filename"),
			  $next_ft->get_attribute("id"),
			  $next_ft->get_attribute("feature_name")
			  );
    $intersection_ft->set_attribute("description", $description);

    
    $intersection_ft->set_attribute("score", sprintf("%.2f", $intersection_ft->get_attribute("len_cov")*10));

    ## Intersection files
    $intersection_ft->push_attribute("files",$current_ft->get_attribute("file_nb"));
    $intersection_ft->push_attribute("files",$next_ft->get_attribute("file_nb"));

    ## Intersection features
    $intersection_ft->push_attribute("feature_ids",$current_ft->get_attribute("id"));
    $intersection_ft->push_attribute("feature_ids",$next_ft->get_attribute("id"));
    
    ## Add this intersecion to the list
    $current_ft->push_attribute("intersections", $intersection_ft);
    $next_ft->push_attribute("intersections", $intersection_ft);
    push @intersection_features, $intersection_ft;
}


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
    foreach my $a (0..$#ARGV) {

	## Verbosity
=pod


=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$main::verbose = $ARGV[$a+1];
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

display options

=cut
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions();
	    

	    ## Input file
=pod

=item B<-i inputfile>

This option can be used iteratively to specify several input files.
It must be used at least 2 times, since the comparison requires at
least two feature files.

=cut
	} elsif ($ARGV[$a] eq "-i") {
	    push @main::inputfiles, $ARGV[$a+1];
	    
	    ## Input files
=pod

=item B<-files inputfile_1 inputfile_2 ...>

Specify multiple input files. All the arguments following the option
-files are considered as input files.

=cut
	} elsif ($ARGV[$a] eq "-files") {
	    for my $a (($a+1)..$#ARGV) {
		push @inputfiles, $ARGV[$a];
	    }
	    last;
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($ARGV[$a] eq "-o") {
	    $main::outfile{output} = $ARGV[$a+1];
	    

	    ### input format  
=pod

=item B<-iformat input_format>

Input feature format (Supported: $supported_input_formats)

=cut
	} elsif ($ARGV[$a] eq "-iformat") {
	    $main::input_format = $ARGV[$a+1];
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supoprted: $supported_input_formats")
		unless ($supported_input_format{$input_format});

	    ### output format  
=pod

=item B<-oformat output_format>

Output feature format (Supported: $supported_output_formats)

=cut
	} elsif ($ARGV[$a] eq "-oformat") {
	    $main::output_format = $ARGV[$a+1];
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supoprted: $supported_output_formats")
		unless ($supported_output_format{$output_format});
	    
    ### Self-comparison
=pod

=item B<-self>

Also perform comparison between features in the same file
(self-comparison). This can be useful to detect redundancy between
annotated features.

=cut
	} elsif ($ARGV[$a] eq "-self") {
    $self_comparison = 1;

    ### Return types
=pod

=item B<-return output1[,output2,...]>

Specify the output type(s).

Supported output types:

=over

=item inter

Intersections between features (pairwise comparisons). For each
intersection between two features, a feature of type "inter" is
created.

=item diff

Pairwise differences between files. For each pair of file, a feature
of type "diff" is created. Its ID of the "diff" feature indicates the
number of the files containing and not containing the feature,
respezctively. For example, the ID "1.not.3" indictaes a feature found
in file 1 and without any intersection with features oof file 3.

=back

=cut
	} elsif ($ARGV[$a] eq "-return") {
          push  @return_types, split(",", $ARGV[$a+1]);

	}
    }

=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $out "; compare-features ";
    &PrintArguments($out);
    print $out "; Input files\n";
    print $out join ("\t", ";", "file#", "feat#", "file name"), "\n";
    foreach my $f (0..$#main::inputfiles) {
	my $infile = $main::inputfiles[$f];
	my $feature_list_ref = $main::feature_lists[$f];
	my @feature_list = @{$feature_list_ref};
	my $nb_features = scalar(@feature_list);
	print $out join("\t", ";", 
			$f+1,
			$nb_features,
			$infile,
			), "\n";
    }

    if (defined(%main::outfile)) {
	print $out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $out ";\t$key\t$value\n";
	}
    }

    if ($self_comparison) {
	print $out "; Self-comparison included\n";
    } else {
	print $out "; No self-comparison\n";
    }

}


__END__

=pod

=head1 SEE ALSO

=item feature-map

=item convert-features


=cut
