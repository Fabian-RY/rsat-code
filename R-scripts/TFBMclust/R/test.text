##############################################################
## Align a leaf and one cluster: align the single motif relative
## to the already aligned cluster; creates a list with the info
## (strand, consensus, offset) of the aligned motifs
align.leaf.and.cluster <- function(child1, child2, desc.table, compa.table, score = "Ncore", thresholds = list(Ncor = 0.4, cor = 0.6, w = 5), method = "average", metric = "Ncor", hclust.tree, nodes.attributes = TRUE){

  ## Identify the node numbers, the new leaf and the aligned leaves
  merge.level <- which(hclust.tree$merge == child1)
  n1 <- abs(min(child1, child2))
  n.aligned <- leaves.per.node(hclust.tree)[[merge.level]][which(leaves.per.node(hclust.tree)[[merge.level]] != n1)]
  n2 <- n.aligned
  ids.aligned <- get.id(n.aligned, desc.table)

  ## Get the id of each node on the description table
  id1.hclust <- get.id(n1, desc.table)
  id2.hclust <- get.id(n2, desc.table)

  ## Check the if the node shall be aligned
  aligned.motif.flag <- 0
  aligned.motif.flag <- alignment.test(id1.hclust, id2.hclust, compa.table, thresholds, hclust.method = method, hclust.metric = metric)

  ## Fill the attributes table
  if(nodes.attributes == TRUE){

    ## Save the merge clas: (1) two leaves, (2) one leaf and one cluster, (3) two clusters
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["merge_class"]] <<- 2

    ## Save the status of the alignment
    if(aligned.motif.flag == 0){
      internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_status"]] <<- "Non-aligned"
    } else{
      internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_status"]] <<- "Aligned"
    }
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_flag"]] <<- aligned.motif.flag

    ## Save the number of the motifs on each cluster, for each merge level
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["cluster_1"]] <<- paste(n1, collapse = " ")
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["cluster_2"]] <<- paste(n2, collapse = " ")
  }

  ## In case the motifs should not be aligned
  ## fill the motifs.info list with the default parameters
  if(aligned.motif.flag == 0){

    motifs.info.temp <-  sapply(c(n1, n2), function(X){
      list(
        name = get.name(get.id(X, desc.table),desc.table),
        consensus = get.consensus(get.id(X, desc.table), desc.table, RC = FALSE),
        strand = "D",
        number = X,
        spacer.up = 0,
        spacer.dw = 0
      )
    })
    motifs.info.temp <-  data.frame(t(motifs.info.temp))
    rownames(motifs.info.temp) <- motifs.info.temp$name
    motifs.info.temp <- apply(motifs.info.temp, 1, as.list)
    motifs.info[names(motifs.info.temp)] <<- motifs.info.temp[names(motifs.info.temp)]

  ## Conversely align the motifs
  } else{

    ## Set the number of the motifs
    ## This is done here because the variable storing this number can be changed
    motifs.info[[get.id(n1, desc.table)]][["number"]] <<- as.numeric(n1)

    ## Find the central motif of the cluster
    ## Get the id of each node on the description table
    central.motifs <- closest.or.farthest.motifs.ids(id1.hclust, id2.hclust, compa.table, score = "Ncor", closest = TRUE)
    id1 <- central.motifs[1]
    id2 <- central.motifs[2]

    ## NOTE: the order of the ids (ID1 or ID2) should be the same as in the comparison table
    ## If the order in the hclust tree is the opposite, then the order of the numbers is inverted
    switch.ids <- 0
    new <- NULL
    aligned <- NULL
    if(id1 != id1.hclust){
      aligned <- id1
      new <- id2
      temporal <- NULL
      temporal <- n1
      n1 <- n2
      n2 <- temporal
      switch.ids <- 1
    } else{
      aligned <- id2
      new <- id1
    }
    rm(id1.hclust, id2.hclust)

    ## Get the comparison number in the compare-matrices table
    compa.nb <- get.comparison.number(id1, id2, compa.table)[1]

    ## Get the strand
    strand <- as.vector(compa.table[compa.nb, "strand"])

    ## Get the offset
    offset <- as.vector(compa.table[compa.nb, "offset"])

    ## Assign values for the cases (1-8)
    ## Each case depends if the Ids were inverted, if the strand of the comparison between the closest motifs
    ## is R or D, and in the orientation of the previously aligned motif.
    case <- 0
    if(switch.ids == 1){
      if(strand == "D"){
        if(motifs.info[[aligned]][["strand"]] == "D"){

          ## Case 1: inverted IDs, current comparison strand = 'D' and strand of previously aligned motif = 'D'
          case <- 1
        } else{
          ## Case 2: inverted IDs, current comparison strand = 'D' and strand of previously aligned motif = 'R'
          case <- 2
        }
      } else{
        if(motifs.info[[aligned]][["strand"]] == "D"){

          ## Case 3: inverted IDs, current comparison strand = 'R' and strand of previously aligned motif = 'D'
          case <- 3
        } else{
          ## Case 4: inverted IDs, current comparison strand = 'R' and strand of previously aligned motif = 'R'
          case <- 4
        }
      }
    }else{
      if(strand == "D"){
        if(motifs.info[[aligned]][["strand"]] == "D"){

          ## Case 5: non-inverted IDs, current comparison strand = 'D' and strand of previously aligned motif = 'D'
          case <- 5
        } else{
          ## Case 6: non-inverted IDs, current comparison strand = 'D' and strand of previously aligned motif = 'R'
          case <- 6
        }
      } else{
        if(motifs.info[[aligned]][["strand"]] == "D"){

          ## Case 7: non-inverted IDs, current comparison strand = 'R' and strand of previously aligned motif = 'D'
          case <- 7
        } else{
          ## Case 8: non-inverted IDs, current comparison strand = 'R' and strand of previously aligned motif = 'R'
          case <- 8
        }
      }
    }

    ## In some cases it is required to invert the alignment (change its orientation)
    ## in order to align the new leaf and store in the motifs.info variable
    if(case %in% c(2,4,6,7)){
      inverted.alignment.aligned.ids <- inverted.alignment(ids.aligned, motifs.info, desc.table)
      motifs.info[names(inverted.alignment.aligned.ids)] <<- inverted.alignment.aligned.ids[names(inverted.alignment.aligned.ids)]
    }

    ## Choose the consensus for the new motif
    if(case %in% c(1,2,5,6,7,8)){
      consensus.new <- get.consensus(new, desc.table, RC = FALSE)
      motifs.info[[new]][["strand"]] <<- "D"
      motifs.info[[new]][["consensus"]] <<- consensus.new

    } else if(case %in% c(3,4)){
      consensus.new <- get.consensus(new, desc.table, RC = TRUE)
      motifs.info[[new]][["strand"]] <<- "R"
      motifs.info[[new]][["consensus"]] <<- consensus.new
    }
    motifs.info[[new]][["name"]] <<- get.name(new, oct4.tfbm.desc)

    ## Reset the offset
    aligned.spacer.up <- as.numeric(motifs.info[[aligned]][["spacer.up"]])
    if(case %in% c(1:4)){
      spacer.diff <- aligned.spacer.up
    } else if(case %in% c(5:8)){
      spacer.diff <- -aligned.spacer.up
    }
    offset <- offset + spacer.diff

    ## Create the spacer
    spacer <- paste(collapse="",rep(x="-",times = abs(offset)))

    ## Add the gaps
    if(offset <= 0){
        ids.mod <- get.id(n1, desc.table)
    }else{
      ids.mod <- get.id(n2, desc.table)
    }
    temp.motifs.info <- motifs.info
    sapply(ids.mod, function(id){
      temp <- list()
      temp[[id]][["strand"]] <- temp.motifs.info[[id]][["strand"]]
      temp[[id]][["consensus"]] <- paste(spacer, temp.motifs.info[[id]][["consensus"]], sep="")
      temp[[id]][["name"]] <- temp.motifs.info[[id]][["name"]]
      temp[[id]][["number"]] <- as.numeric(temp.motifs.info[[id]][["number"]])
      temp[[id]][["spacer.up"]] <- get.spacer.nb(motifs.info[[id]][["consensus"]])$up.spacer
      temp[[id]][["spacer.dw"]] <- get.spacer.nb(motifs.info[[id]][["consensus"]])$dw.spacer
      temp.motifs.info[names(temp)] <<- temp[names(temp)]
    })

    ## Fill the downstream end
    motifs.info[names(temp.motifs.info)] <<- temp.motifs.info[names(temp.motifs.info)]
    temp.motifs.info <- fill.downstream(get.id(leaves.per.node(tree)[[merge.level]], desc.table), motifs.info)
    motifs.info[names(temp.motifs.info)] <<- temp.motifs.info[names(temp.motifs.info)]
  }
}


#####################################################################
## Evaluate if the mean of scores for all pairs of leaves between
## the two clusters is upper/lower than the threshold,
## if so, then the two clusters should be aligned

alignment.test <- function(id1, id2, compa.table, thresholds = list(Ncor = 0.4, cor = 0.6, w = 5), hclust.method = "average", hclust.metric = "Ncor"){

  ## Calculate the mean of the scores for all the pairs of motifs
  if(hclust.method == "average"){
    compa.numbers <- get.comparison.number(id1, id2, compa.table)

    scores <- compa.table[compa.numbers, names(thresholds)]

    ## Calculate the median of the data
    mean.scores <- apply(scores, 2, mean)

  ## Calculate the farthest motifs between all the pairs of motifs
  } else if(hclust.method == "complete"){

    farthest.motifs <- closest.or.farthest.motifs.ids(id1, id2, oct4.tfbm.compa, score = hclust.metric, closest = FALSE)
    id1.far <- farthest.motifs[1]
    id2.far <- farthest.motifs[2]

    compa.numbers <- get.comparison.number(id1.far, id2.far, compa.table)

    ## Get the scores of the comparisons
    farthest.scores <- compa.table[compa.numbers, names(thresholds)]

  ## Calculate the closest motifs between all the pairs of motifs
  } else if(hclust.method == "single"){

    closest.motifs <- closest.or.farthest.motifs.ids(id1, id2, oct4.tfbm.compa, score = hclust.metric, closest = TRUE)
    id1.close <- closest.motifs[1]
    id2.close <- closest.motifs[2]

    compa.numbers <- get.comparison.number(id1.close, id2.close, compa.table)

    ## Get the scores of the comparisons
    closest.scores <- compa.table[compa.numbers, names(thresholds)]
  }

  th <- list()

  ## According to the kind of metric selected
  ## evaluates if the clusters will be aligned
  th <- sapply(names(thresholds), function(names.th){

    if ((names.th == "Ncor")
        || (names.th =="cor")
        || (names.th =="logocor")
        || (names.th =="Nlocogor")
        || (names.th =="Icor")
        || (names.th =="NIcor")
        || (names.th =="w")
    ) {
      if(hclust.method == "average"){
        mean.scores[names.th] >= thresholds[names.th]
      } else if(hclust.method == "complete"){
        farthest.scores[names.th] >= thresholds[names.th]
      } else if(hclust.method == "single"){
        closest.scores[names.th] >= thresholds[names.th]
      }
    } else if ((names.th == "dEucl")
              || (names.th == "NsEucl")
              || (names.th == "SSD")
              || (names.th == "SW")
              || (names.th == "NSW")
    ){
      if(hclust.method == "average"){
        mean.scores[names.th] <= thresholds[names.th]
      } else if(hclust.method == "complete"){
        farthest.scores[names.th] <= thresholds[names.th]
      } else if(hclust.method == "single"){
        closest.scores[names.th] <= thresholds[names.th]
      }
    }
  })


  if(sum(unlist(th)) == length(thresholds)){
    return(1)
  }else{
    return(0)
  }
}
align.motifs <- function(hclust.tree, desc.table, compa.table, thresholds = list(Ncor = 0.4, cor = 0.6, w = 5), score = "Ncor", method = "average", metric = "Ncor", nodes.attributes = TRUE){

  motifs.info <<- list()
  internal.nodes.attributes <<- list()

  apply(tree$merge, 1, function(x){
    child1 <- x[1]
    child2 <- x[2]
    level <- which(tree$merge == child1)

    ## If it is indicated, save the nodes attributes.
    if(nodes.attributes == TRUE){
      internal.nodes.attributes[[paste("level_", level, sep = "")]][["level"]] <<- level
      internal.nodes.attributes[[paste("level_", level, sep = "")]][["method"]] <<- method
      internal.nodes.attributes[[paste("level_", level, sep = "")]][["node_1"]] <<- child1
      internal.nodes.attributes[[paste("level_", level, sep = "")]][["node_2"]] <<- child2
    }

    ##############################
    ## Case 1: align two leaves
    if ((child1 < 0) && (child2 < 0)) {
      align.two.leaves(child1, child2, desc.table, compa.table, score, thresholds, method, metric, hclust.tree, nodes.attributes = TRUE)
    }

    ###########################################################
    ## Case 2: align a leaf with a cluster (already aligned)
    if ((child1 < 0) && (child2 > 0)) {
      align.leaf.and.cluster(child1, child2, desc.table, compa.table, score, thresholds, method, metric, hclust.tree, nodes.attributes = TRUE)
    }

    ###########################################################
    ## Case 3: align two (already aligned) clusters
    if ((child1 > 0) && (child2 > 0)) {
      align.two.clusters(child1, child2, desc.table, compa.table, score, thresholds, method, metric, hclust.tree, nodes.attributes = TRUE)
    }
  })

  return(list(motifs.alignment = motifs.info, node.attributes = internal.nodes.attributes))
}


##############################################################
## Align two clusters: align the two cluster, in some cases is
## necessary invert the alignment; creates a list with the info
## (strand, consensus, offset) of the aligned motifs
align.two.clusters <- function(child1, child2, desc.table, compa.table, score = "Ncore", thresholds = list(Ncor = 0.4, cor = 0.6, w = 5), method = "average", metric = "Ncor", hclust.tree, nodes.attributes = TRUE){

  ## Identify the merge level and the node numbers of each cluster
  merge.level <- which(hclust.tree$merge == child1)
  N1 <- abs(min(child1, child2))
  N2 <- abs(max(child1, child2))
  n1 <- leaves.per.node(tree)[[N1]]
  n2 <- leaves.per.node(tree)[[N2]]

  ## Get the id of each node on the description table
  ids1.hclust <- get.id(n1, desc.table)
  ids2.hclust <- get.id(n2, desc.table)

  ## Check the if the node shall be aligned
  aligned.motif.flag <- 0
  aligned.motif.flag <- alignment.test(ids1.hclust, ids2.hclust, compa.table, thresholds, hclust.method = method, hclust.metric = metric)

  ## Fill the attributes table
  if(nodes.attributes == TRUE){

    ## Save the merge clas: (1) two leaves, (2) one leaf and one cluster, (3) two clusters
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["merge_class"]] <<- 3

    ## Save the status of the alignment
    if(aligned.motif.flag == 0){
      internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_status"]] <<- "Non-aligned"
    } else{
      internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_status"]] <<- "Aligned"
    }
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_flag"]] <<- aligned.motif.flag

    ## Save the number of the motifs on each cluster, for each merge level
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["cluster_1"]] <<- paste(n1, collapse = " ")
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["cluster_2"]] <<- paste(n2, collapse = " ")
  }

  ## Align the motifs
  if(aligned.motif.flag == 1){

    ## Find the central motif of the cluster
    ## Get the id of each node on the description table
    central.motifs <- closest.or.farthest.motifs.ids(ids1.hclust, ids2.hclust, compa.table, score = "Ncor", closest = TRUE)
    id1 <- central.motifs[1]
    id2 <- central.motifs[2]

    ## NOTE: the order of the ids (ID1 or ID2) should be the same as in the comparison table
    ## If the order in the hclust tree is the opposite, then the order of the numbers is inverted
    if(id1 %in% ids2.hclust){
      temporal <- NULL
      temporal <- ids1.hclust
      ids1.hclust <- ids2.hclust
      ids2.hclust <- temporal
    }

    ## Get the comparison number in the compare-matrices table
    compa.nb <- get.comparison.number(id1, id2, compa.table)[1]

    ## Get the strand
    strand <- as.vector(compa.table[compa.nb, "strand"])

    ## Get the offset
    offset <- as.vector(compa.table[compa.nb, "offset"])

    ## Get the previous orientation of the closest motifs which will be used as
    ## base to align the two cluster
    prev.strand.1 <- motifs.info[[id1]][["strand"]]
    prev.strand.2 <- motifs.info[[id2]][["strand"]]

    ## Assign values for the cases (1-8)
    ## Each case depends if the strand of the comparison between the closest motifs
    ## is R or D, and if the strand of the closest motifs is in D or D orientation.
    case <- 0
    if(strand == "D"){

      ## Case 1: current comparison strand = 'D', strand of motif 1 = 'R', strand of motif 2 = 'R'
      if(prev.strand.1 == "R" && prev.strand.2 == "R"){
        case <- 1

        ## Case 2: current comparison strand = 'D', strand of motif 1 = 'R', strand of motif 2 = 'D'
      } else if(prev.strand.1 == "R" && prev.strand.2 == "D"){
        case <- 2

        ## Case 3: current comparison strand = 'D', strand of motif 1 = 'D', strand of motif 2 = 'R'
      } else if(prev.strand.1 == "D" && prev.strand.2 == "R"){
        case <- 3

        ## Case 4: current comparison strand = 'D', strand of motif 1 = 'D', strand of motif 2 = 'D'
      } else if(prev.strand.1 == "D" && prev.strand.2 == "D"){
        case <- 4
      }
    } else{

      ## Case 5: current comparison strand = 'R', strand of motif 1 = 'R', strand of motif 2 = 'R'
      if(prev.strand.1 == "R" && prev.strand.2 == "R"){
        case <- 5

      ## Case 6: current comparison strand = 'R', strand of motif 1 = 'R', strand of motif 2 = 'D'
      } else if(prev.strand.1 == "R" && prev.strand.2 == "D"){
        case <- 6

      ## Case 7: current comparison strand = 'R', strand of motif 1 = 'D', strand of motif 2 = 'R'
      } else if(prev.strand.1 == "D" && prev.strand.2 == "R"){
        case <- 7

      ## Case 8: current comparison strand = 'R', strand of motif 1 = 'D', strand of motif 2 = 'D'
      } else if(prev.strand.1 == "D" && prev.strand.2 == "D"){
        case <- 8
      }
    }

    ## In some cases it is required to invert the alignment (change its orientation)
    ## in order to align properly the two clusters.
    ## Cases in which is required invert the aligment
    if(case %in% c(2,3,5,8)){

      if(case %in% c(3,8)){
        ids.inv <- ids2.hclust
      } else if (case %in% c(2,5)){
        ids.inv <- ids1.hclust
      }

      ## Invert the aligment and store the information in a list
      inverted.alignment.ids <- inverted.alignment(ids.inv, motifs.info, desc.table)
      motifs.info[names(inverted.alignment.ids)] <<- inverted.alignment.ids[names(inverted.alignment.ids)]

#       cluster.1.spacer <- as.numeric(motifs.info[[id1]][["spacer.up"]])
#       cluster.2.spacer <- as.numeric(motifs.info[[id2]][["spacer.up"]])
    }

    ## Get the (upstream) spacer length of the closest motifs which will be used as
    ## base to align the two clusters
    cluster.1.spacer <- as.numeric(motifs.info[[id1]][["spacer.up"]])
    cluster.2.spacer <- as.numeric(motifs.info[[id2]][["spacer.up"]])

    ## According to the cases, reset the offset
    if(case %in% c(1,6)){
      ofsset <- nchar(get.consensus(id, desc.table, RC = FALSE)) - nchar(get.consensus(id2, desc.table, RC = FALSE)) - offset + (cluster.1.spacer - cluster.2.spacer)
    } else if(case %in% c(2,3,4,5,7,8)){
      offset <- offset + (cluster.1.spacer - cluster.2.spacer)
    }

    ## Add the spacer to the motifs
    ids.mod <- NULL
    if(offset <= 0){
      ids.mod <- ids1.hclust
    } else{
      ids.mod <- ids2.hclust
    }
    spacer <- paste(collapse="",rep(x="-",times = abs(offset)))
    temp.motifs.info <- motifs.info[ids.mod]
    sapply(ids.mod, function(y){
      temp <- list()
      temp[[y]][["strand"]] <- temp.motifs.info[[y]][["strand"]]
      temp[[y]][["consensus"]] <- paste(spacer, temp.motifs.info[[y]][["consensus"]], sep="")
      temp[[y]][["name"]] <- temp.motifs.info[[y]][["name"]]
      temp[[y]][["number"]] <- as.numeric(temp.motifs.info[[y]][["number"]])
      temp[[y]][["spacer.up"]] <- get.spacer.nb(temp.motifs.info[[y]][["consensus"]])$up.spacer
      temp[[y]][["spacer.dw"]] <- get.spacer.nb(temp.motifs.info[[y]][["consensus"]])$dw.spacer

      ## Update the motifs list
      temp.motifs.info[names(temp)] <<- temp[names(temp)]
    })

    ## Fill the downstream end
    motifs.info[names(temp.motifs.info)] <<- temp.motifs.info[names(temp.motifs.info)]
    temp.motifs.info <- fill.downstream(get.id(leaves.per.node(tree)[[merge.level]], desc.table), motifs.info)
    motifs.info[names(temp.motifs.info)] <<- temp.motifs.info[names(temp.motifs.info)]

  }
}

##################################################
## Align two leaves: creates a list with the info
## (strand, consensus, offset) of the aligned motifs
align.two.leaves <- function(child1, child2, desc.table, compa.table, score = "Ncore", thresholds = list(Ncor = 0.4, cor = 0.6, w = 5), method = "average", metric = "Ncor", hclust.tree, nodes.attributes = TRUE){

  ## Identify the node number
  n1 <- min(-child1,-child2) ## row number of the first motif in the description table
  n2 <- max(-child1,-child2) ## row number of the second motif in the description table
  merge.level <- which(hclust.tree$merge == child1)

  ## Saves the order of the IDs in the hclust object
  id1.hclust <- get.id(n1, desc.table)
  id2.hclust <- get.id(n2, desc.table)

  ## Get the id of each node on the description table
  n1.id <- get.id(n1, desc.table)
  n2.id <- get.id(n2, desc.table)

  ## Check the if the node shall be aligned
  aligned.motif.flag <- 0
  aligned.motif.flag <- alignment.test(id1.hclust, id2.hclust, compa.table, thresholds, hclust.method = method, hclust.metric = metric)

  ## Fill the attributes table
  if(nodes.attributes == TRUE){

    ## Save the merge clas: (1) two leaves, (2) one leaf and one cluster, (3) two clusters
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["merge_class"]] <<- 1

    ## Save the status of the alignment
    if(aligned.motif.flag == 0){
      internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_status"]] <<- "Non-aligned"
    } else{
      internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_status"]] <<- "Aligned"
    }
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["alignment_flag"]] <<- aligned.motif.flag

    ## Save the number of the motifs on each cluster, for each merge level
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["cluster_1"]] <<- paste(n1, collapse = " ")
    internal.nodes.attributes[[paste("level_", merge.level, sep = "")]][["cluster_2"]] <<- paste(n2, collapse = " ")
  }

  ## In case the motifs should not be aligned export the default parameters
  if(aligned.motif.flag == 0){

    motifs.info.temp <-  sapply(c(n1, n2), function(X){
          list(
            name = get.name(get.id(X, desc.table),desc.table),
            consensus = get.consensus(get.id(X, desc.table), desc.table, RC = FALSE),
            strand = "D",
            number = X,
            spacer.up = 0,
            spacer.dw = 0
          )
    })
    motifs.info.temp <-  data.frame(t(motifs.info.temp))
    rownames(motifs.info.temp) <- motifs.info.temp$name
    motifs.info.temp <- apply(motifs.info.temp, 1, as.list)
    motifs.info[names(motifs.info.temp)] <- motifs.info.temp[names(motifs.info.temp)]

  ## Conversely align the motifs
  }else{

    ## Find the central motif of the cluster
    central.motifs <- closest.or.farthest.motifs.ids(n1.id, n2.id, compa.table, score = "Ncor", closest = TRUE)
    id1 <- central.motifs[1]
    id2 <- central.motifs[2]

    ## NOTE: the order of the ids (ID1 or ID2) should be the same as in the comparison table
    ## If the order in the hclust tree is the opposite, then the order of the numbers is inverted
    if(id1.hclust == id2){
      temporal <- n1
      n1 <- n2
      n2 <- temporal
    }
    rm(id1.hclust, id2.hclust, n1.id, n2.id)

    ## Comparison number in the compare-matrices table
    compa.nb <- get.comparison.number(id1, id2, compa.table)[1]

    ## Choose the relative orientation of the two motifs
    strand <- as.vector(compa.table[compa.nb, "strand"])
    consensus1 <- get.consensus(id1, desc.table, RC = FALSE) ## Consensus of the first motif
    id1.strand <- "D"
    if (strand == "R") {
      consensus2 <- get.consensus(id2, desc.table, RC = TRUE) ## Consensus of the second motif
      id2.strand <- "R"
    } else {
      consensus2 <- get.consensus(id2, desc.table, RC = FALSE) ## Consensus of the second motif
      id2.strand <- "D"
    }

    ## Add the offset to the logos
    offset <- as.vector(compa.table[compa.nb, "offset"])
    spacer <- paste(collapse="",rep(x="-",times=abs(offset)))

    if (offset < 0) {
      consensus1 <- paste(spacer, consensus1, sep="")
    } else {
      consensus2 <- paste(spacer, consensus2, sep="")
    }

    ## Update the motifs information
    motifs.info[[id1]][["name"]] <<- get.name(id1, desc.table)
    motifs.info[[id1]][["consensus"]] <<- consensus1
    motifs.info[[id1]][["strand"]] <<- id1.strand
    motifs.info[[id1]][["number"]] <<- n1
    motifs.info[[id1]][["spacer.up"]] <<- get.spacer.nb(motifs.info[[id1]][["consensus"]])$up.spacer
    motifs.info[[id1]][["spacer.dw"]] <<- get.spacer.nb(motifs.info[[id1]][["consensus"]])$dw.spacer

    motifs.info[[id2]][["name"]] <<- get.name(id2, desc.table)
    motifs.info[[id2]][["consensus"]] <<- consensus2
    motifs.info[[id2]][["strand"]] <<- id2.strand
    motifs.info[[id2]][["number"]] <<- n2
    motifs.info[[id2]][["spacer.up"]] <<- get.spacer.nb(motifs.info[[id2]][["consensus"]])$up.spacer
    motifs.info[[id2]][["spacer.dw"]] <<- get.spacer.nb(motifs.info[[id2]][["consensus"]])$dw.spacer

    temp <- fill.downstream(get.id(leaves.per.node(tree)[[merge.level]], desc.table), motifs.info)
    motifs.info[names(temp)] <<- temp[names(temp)]
  }
}

###########################################################
## Build a distance matrix from the distance score list
build.distance.matrix <- function(comparison.table,
                                  score="Ncor"){


  dist.table <- NULL
  distances.objects <- list()

  ## Extract score values
  score.values <- comparison.table[,score]

  ## If required, convert similarities to distances
  ## Similarity sores bounded to 1
  if ((score == "Ncor")
      || (score=="cor")
      || (score=="logocor")
      || (score=="Nlocogor")
      || (score=="Icor")
      || (score=="NIcor")
  ) {
    ## cor       Pearson correlation (computed on residue occurrences in aligned columns)
    ## Ncor 			Relative width-normalized Pearson correlation
    ## logocor 			correlation computed on sequence logos
    ## Nlogocor 			Relative width-normalized logocor
    ## Icor 			Pearson correlation computed on Information content
    ## NIcor 			Relative width-normalized Icor
    score.dist <- 1 - score.values

  } else if ((score == "logoDP")
             || (score == "cov")) {
    ## logoDP 			dot product of sequence logos
    ## cov 			covariance between residues in aligned columns

    stop("logoDP and cov scores are not supported yet")

  } else if ((score == "dEucl")
             || (score == "NdEucl")
             || (score == "NdEucl")
             || (score == "NsEucl")
             || (score == "SSD")
             || (score == "SW")
             || (score == "NSW")
  ) {
    ## dEucl 			Euclidian distance between residue occurrences in aligned columns
    ## NdEucl 			Relative width-normalized dEucl
    ## NsEucl 			similarity derived from Relative width-normalized Euclidian distance
    ## SSD 			Sum of square deviations
    ## SW 			Sandelin-Wasserman
    ## NSW 			Relative width-normalized Sandelin-Wasserman

    score.dist <- score.values

  } else if (score == "match_rank") {
    ## match_rank rank of current match among all sorted matches
    stop("match_rank score is not supported yet")

  } else {
    stop(paste(score, "is not a valid score", sep="\t"))
  }


  ## Add a column with score column to the compare matrices table, will
  ## be used to generate a cross-table
  comparison.table$score.dist <- score.dist

  ## Build the distance table from the column score
  dist.table <- xtabs(score.dist ~ id1+id2, comparison.table)


  ## Ensure that symmetrical distances are defined
  dist.table.sym <- pmax(dist.table,t(dist.table))

  ## Cast the distance table into an object of class "dist"
  dist.matrix <- as.dist(dist.table.sym)

  return(list(table = dist.table.sym, matrix = dist.matrix))
}

#################################################################
## Identify the "central" leaf (motif) of a subtree (cluster),
## i.e. the pair of motif with the smallest average distance to
## among all the other motifs of these clusters.
closest.or.farthest.motifs.ids <- function(id1, id2, compa.table, score = "Ncor", closest = TRUE){

  ## Get the comparison number between the pairs of motifs of both clusters
  compa.numbers <- as.vector(get.comparison.number(id1, id2, compa.table))

  ## Get the ids of the less distant nodes

  #########################################
  ## For correlations (Higher is better)
  if ((score == "Ncor")
      || (score=="cor")
      || (score=="logocor")
      || (score=="Nlocogor")
      || (score=="Icor")
      || (score=="NIcor")
  ) {
    if(closest == TRUE){
      compa.info <- compa.table[compa.numbers,][which(compa.table[compa.numbers, score] == max(compa.table[compa.numbers, score])),c("id1","id2")][1,]
    }else{
      compa.info <- compa.table[compa.numbers,][which(compa.table[compa.numbers, score] == min(compa.table[compa.numbers, score])),c("id1","id2")][1,]
    }

  #################################
  ## For distances (Lower is better)
  }else if ((score == "dEucl")
            || (score == "NsEucl")
            || (score == "SSD")
            || (score == "SW")
            || (score == "NSW")
  ){
    if(closest == TRUE){
      compa.info <- compa.table[compa.numbers,][which(compa.table[compa.numbers, score] == min(compa.table[compa.numbers, score])),c("id1","id2")][1,]
    } else {
      compa.info <- compa.table[compa.numbers,][which(compa.table[compa.numbers, score] == max(compa.table[compa.numbers, score])),c("id1","id2")][1,]
    }
  }
  return(as.vector(unlist(compa.info)))
}convert.to.JSON <- function(tree){

  ## Require ctc if it is required
  if(!require("RJSONIO")){
    install.packages("RJSONIO")
  }

  ## Load library
  suppressPackageStartupMessages(library("RJSONIO", warn.conflicts=FALSE))

  #######################################################
  ## Extract the tree from an hclust object
  createLeafNode <- function(hclust, i) {
    list(label = hclust$labels[[i]],
         order = hclust$order[[i]])
  }

  ########################################################
  ## Convert an hclust tree into a JSON format tree
  hclustToTree <- function(hclust) {
    if (length(hclust$merge) == 0)
      return(NULL)
    merges <- list()
    for (index in 1:nrow(hclust$merge)) {
      left <- hclust$merge[index, 1]
      right <- hclust$merge[index, 2]
      if (left < 0)
        left <- createLeafNode(hclust, -left)
      else
        left <- merges[[left]]
      if (right < 0)
        right <- createLeafNode(hclust, -right)
      else
        right <- merges[[right]]
      if (left$order > right$order) {
        tmp <- left
        left <- right
        right <- tmp
      }
      merges[[index]] <- list(
        children = list(
          left,
          right
        ),
        order = left$order
      )
    }
    return(merges[nrow(hclust$merge)])
  }

  ### Creates and parse the json string
  halfway.tree <- hclustToTree(tree)
  jsonTree <- toJSON(halfway.tree)


  ## Fix some little technical issues for JSON compatibility with the tree display javascript
  jsonTree <- gsub("\\],", "\\]", jsonTree, perl = TRUE)
  jsonTree <- paste("{\n\"name\": \"\",\n\"children\":", jsonTree, "}", sep = "")
  jsonTree <- gsub("\n\"order\":\\s+\\d+", "", jsonTree, perl = TRUE)

  return(jsonTree)
}


#####################################################
## Convert the hclust object to a character object
## with the lines ready to print a Newick file
export.newick <- function(tree, decimals = 3){

  ## Require ctc if it is required
  if(!require("ctc")){
    source("http://bioconductor.org/biocLite.R")
    biocLite("ctc")
  }

  ## Load library
  suppressPackageStartupMessages(library("ctc", warn.conflicts=FALSE))

  ## Round the decimals of the branches distances
  tree[[2]] <- round(tree[[2]], digits = decimals)

  ## Convert the hclust tree to Newick format
  ## If ‘flat=TRUE’ the result is a string can be written in a file                                     file).
  return(hc2Newick(temp.tree, flat = TRUE))
}

###########################################################
## The clusters are selected by traversing the tree with
## a bottom-up approach, rather than top-down as is used
## with the R-defined function cutree.
define.clusters.bottom.up <- function(attributes.list, tree){

  cluster.number <- 0
  level <<- 0
  clusters <<- list()
  attributes.cp <- attributes.list

  sapply(names(attributes.cp), function(X){

    level <<- level + 1

    class.level <- paste("class_", as.numeric(attributes.cp[[X]][["merge_class"]]), sep = "")
    switch(class.level,

      ## merge_class = 1
      ## Alignment of two leaves
      class_1 = {

        cluster.number <<- cluster.number + 1

        ## Creates one cluster with the motifs if the flag = 1
        if(as.numeric(attributes.cp[[X]][["alignment_flag"]]) == 1){

          ## Get the numbers of the nodes
          nodes.numbers <- leaves.per.node(tree)[[level]]

          ## Store the numbers in the list
          clusters[[paste("cluster_", cluster.number, sep = "")]] <<- nodes.numbers

        ## Conversely, two clusters are created
        } else{
          clusters[[paste("cluster_", cluster.number, sep = "")]] <<- as.numeric(attributes.cp[[X]][["cluster_1"]])
          cluster.number <<- cluster.number + 1


          clusters[[paste("cluster_", cluster.number, sep = "")]] <<- as.numeric(attributes.cp[[X]][["cluster_2"]])
          attributes.cp[[X]][["alignment_flag"]] <<- 0
        }
      },

      ## merge_class = 2
      ## Alignment of one leaf and one cluster
      class_2 = {

        if(as.numeric(attributes.cp[[X]][["alignment_flag"]]) == 1){

          ## Obtain the status of the cluster to merge
          prev.cluster.nb <- as.numeric(attributes.cp[[X]][["node_2"]])
          prev.status <- as.numeric(attributes.cp[[paste("level_", prev.cluster.nb, sep = "")]][["alignment_flag"]])

          ## Following the same order than the tree$merge
          ## If the cluster was succesfully aligned:
          ## add the number of the leaf to the number of the aligned cluster
          if(prev.status == 1){
            cluster.name <- return.cluster.name(leaves.per.node(tree)[[prev.cluster.nb]], clusters)
            clusters[[cluster.name]] <<- append(clusters[[cluster.name]], as.numeric(attributes.cp[[X]][["cluster_1"]]))

          ## Conversely, creates a new cluster with the single leaf
          }else{
            cluster.number <- cluster.number + 1
            clusters[[paste("cluster_", cluster.number, sep = "")]] <<- as.numeric(attributes.cp[[X]][["cluster_1"]])
            attributes.cp[[X]][["flag"]] <<- 0
          }

        ## Conversely, creates a new cluster with the single leaf
        } else{

          cluster.number <- cluster.number + 1
          clusters[[paste("cluster_", cluster.number, sep = "")]] <<- as.numeric(attributes.cp[[X]][["cluster_1"]])
          attributes.cp[[X]][["flag"]] <<- 0
        }
      },

      ## merge_class = 3
      ## Alignment of two clusters
      class_3 = {

        ## Obtain the status of the two clusters before merge them
        prev.cluster.1.nb <- as.numeric(attributes.cp[[X]][["node_1"]])
        prev.status.1 <- as.numeric(attributes.cp[[X]][["alignment_flag"]])

        prev.cluster.2.nb <- as.numeric(attributes.cp[[X]][["node_2"]])
        prev.status.2 <- as.numeric(attributes.cp[[X]][["alignment_flag"]])

        if(as.numeric(attributes.cp[[X]][["alignment_flag"]]) == 1){
          if(prev.status.1 == 0 | prev.status.2 == 0){
            attributes.cp[[X]][["flag"]] <<- 0
          } else{
            cluster.name <- return.cluster.name(leaves.per.node(tree)[[prev.cluster.1.nb]], clusters)
            cluster.2.nodes <- as.numeric(unlist(strsplit(attributes.cp[[X]][["cluster_2"]], " ")))
            cluster.name.erase <- return.cluster.name(cluster.2.nodes, clusters)
            clusters[[cluster.name]] <<- append(clusters[[cluster.name]], cluster.2.nodes)
            clusters[[cluster.name.erase]] <<- NULL
          }
        }else{
          attributes.cp[[X]][["alignment_flag"]] <<- 0
        }
      }
    )
  })


  ## Re-name the clusters
  names(clusters) <<- paste("cluster_", seq(1:length(clusters)), sep = "")
  clusters <- lapply(clusters,function(x){get.id(x,desc.table)})
  return(clusters)

  ########################################################################
  ## Search the name of the cluster which correspond to the given nodes
  ## NOTE: This function is called only inside the define.clusters.bottom.up() function
  return.cluster.name <- function(nodes, clusters.list){

    matches <- sapply(clusters.list, function(X){
      sum(nodes %in% X)
    })

    if(sum(matches[matches == length(nodes)]) == 0){
      return(0)
    } else{
      matches <- matches[matches == length(nodes)]
      return(names(matches))
    }
  }
}

fill.downstream <- function(ids.fill, motifs.list){

  motifs.temp <- motifs.list[ids.fill]

  ## Get the highest length among the consensuses
  consensuses <- sapply(ids.fill, function(X){
    nchar(motifs.temp[[X]][["consensus"]])
  })
  max.width <- max(unlist(consensuses))

  ## Add the downstream spacer
  sapply(ids.fill, function(x){

    temp.list <- list()
    ## Update the consensus
    cons.new <- NULL
    cons.new <- paste(motifs.temp[[x]][["consensus"]],
      paste(rep("-",
        times = max.width - nchar(motifs.temp[[x]][["consensus"]])),
        collapse = ""
      ),
      sep = ""
    )

    temp.list[[x]][["strand"]] <- motifs.temp[[x]][["strand"]]
    temp.list[[x]][["consensus"]] <- cons.new
    temp.list[[x]][["name"]] <- motifs.temp[[x]][["name"]]
    temp.list[[x]][["number"]] <- motifs.temp[[x]][["number"]]
    temp.list[[x]][["spacer.up"]] <- get.spacer.nb(temp.list[[x]][["consensus"]])$up.spacer
    temp.list[[x]][["spacer.dw"]] <- get.spacer.nb(temp.list[[x]][["consensus"]])$dw.spacer

    ## Update the motifs list
    motifs.temp[names(temp.list)] <<- temp.list[names(temp.list)]
  })
  #print(motifs.temp)
  return(motifs.temp)
}

##############################################################
## Given two sets of Ids, return the comparison numbers for
## all the pairs of the leaves belonging the two clusters
get.comparison.number <- function(id1, id2, compa.table){

  compa.numbers <- sapply(id2, function(X){
    sapply(id1, function(Y){
      which( (compa.table[,"id2"] == X & compa.table[,"id1"] == Y) | (compa.table[,"id1"] == X & compa.table[,"id2"] == Y) )
      #get.comparison.number(X, Y, compa.table)
    })
  })
  compa.numbers <- as.vector(compa.numbers)
  return(compa.numbers)
}

##########################################################
## Given the number of a leaf, search the id of the
## corresponding motif in the provided descrition table
get.consensus <- function(id, desc.table, RC = FALSE){

  return(as.vector(sapply(id, function(X){
    if(RC == FALSE){
      desc.table[which(desc.table$id == X),][,"consensus"]
    } else if(RC == TRUE){
      desc.table[which(desc.table$id == X),][,"rc.consensus"]
    }
  })))
}

##########################################################
## Given the number of a leaf, search the id of the
## corresponding motif in the provided descrition table
get.id <- function(num, desc.table){
  return(as.vector(sapply(num, function(X){
    desc.table[X,"id"]
  })))
}

########################################################
## Given the id of a motif, return its name
get.name <- function(id, desc.table){
  return(as.vector(sapply(id, function(X){
    desc.table[which(desc.table$id == X),][,"name"]
  })))
}

#####################
## Given a consensus string, count the number of gaps ("-")
## in the upstream and downstream ends. Return a list with
## these values.
get.spacer.nb <- function(consensus){

  ## Update the downstream spacer value
  ## Check if the consensus contains gaps ('-')
  if(grepl("-", consensus)){

    ## Check if contains gaps in both ends, if so calculate the downstream offset
    if(grepl("^-", consensus, perl = TRUE) & grepl("-$", consensus, perl = TRUE)){
        spacer.up <- nchar(unlist(strsplit(consensus, "\\w+"))[1])
        spacer.dw <- nchar(unlist(strsplit(consensus, "\\w+"))[2])
    }

    ## If there are gaps in the upstream en, but not in the downstream end, the downstream offset is zero
    if( (grepl("^-", consensus, perl = TRUE)) & !(grepl("-$", consensus, perl = TRUE))){
      spacer.up <- nchar(unlist(strsplit(consensus, "\\w+"))[1])
      spacer.dw <-  0
    }

    ## If there are gaps in the upstream end, but not in the downstream end, the downstream offset is zero
    if( !(grepl("^-", consensus, perl = TRUE)) & (grepl("-$", consensus, perl = TRUE))){
      spacer.up <-  0
      spacer.dw <- nchar(unlist(strsplit(consensus, "\\w+"))[2])
    }
  } else{
    spacer.up <-  0
    spacer.dw <-  0
  }
  return(list(up.spacer = spacer.up, dw.spacer = spacer.dw))
}

##################################################################
## Build the tree by hierarchical clustering using Rcpp library
## if it is indicated, export the tree in Newick format
hclust.motifs <- function(dist.matrix, hclust.method = "average"){

  ## Require Rclusterpp if it is required
  if(!require("Rclusterpp")){
    install.packages("Rclusterpp")
  }

  ## Load library
  suppressPackageStartupMessages(library(Rclusterpp, warn.conflicts=FALSE))

  return(Rclusterpp.hclust(dist.matrix, method = hclust.method))
}

########################################################
## Given a vector with IDs, return a list with the
## information (consensus, number, id, strand, spacer)
## of the inverted alignment
inverted.alignment <- function(ids.inv, motifs.list, desc.table){

  motifs.list.temp <- motifs.list[ids.inv]
  ## Create the new consensuses with the inverted orientation
  sapply(ids.inv, function(X){

    inverted.aligment.list <- list()
    inverted.consensus <- NULL
    spacer.up.length <- NULL
    spacer.up <- NULL
    spacer.dw.length <- NULL
    spacer.dw <- NULL

    ## Create the spacers
    spacer.up.length <- get.spacer.nb(motifs.list.temp[[X]][["consensus"]])$up.spacer
    spacer.dw.length <- get.spacer.nb(motifs.list.temp[[X]][["consensus"]])$dw.spacer

    spacer.up <- paste(rep("-", times = spacer.up.length), collapse = "")
    spacer.dw <- paste(rep("-", times = spacer.dw.length), collapse = "")

    ## Depending on the current orientation, get the consensus in the inverted orientation
    if(motifs.list.temp[[X]][["strand"]] == "D"){

      inverted.consensus <- get.consensus(X, desc.table, RC = TRUE)
      inverted.aligment.list[[X]][["strand"]] <- "R"

    } else{

      inverted.consensus <- get.consensus(X, desc.table, RC = FALSE)
      inverted.aligment.list[[X]][["strand"]] <- "D"
    }

    ## Create the new consensus
    new.consensus <- paste(spacer.dw, inverted.consensus, spacer.up, sep = "")

    ## Fill the new list
    inverted.aligment.list[[X]][["consensus"]] <- new.consensus
    inverted.aligment.list[[X]][["name"]] <- motifs.list.temp[[X]][["name"]]
    inverted.aligment.list[[X]][["number"]] <- as.numeric(motifs.list.temp[[X]][["number"]])
    inverted.aligment.list[[X]][["spacer.up"]] <- get.spacer.nb(inverted.aligment.list[[X]][["consensus"]])$up.spacer
    inverted.aligment.list[[X]][["spacer.dw"]] <- get.spacer.nb(inverted.aligment.list[[X]][["consensus"]])$dw.spacer

    motifs.list.temp[names(inverted.aligment.list)] <<- inverted.aligment.list[names(inverted.aligment.list)]
  })
  return(motifs.list.temp)
}

################################################################
## Collect the list of leaves (motif) associated to each
## internal node (motif cluster) of the tree.
##
## This method works for any hclust result tree, irrespective of the
## fact that it refers to motifs or anything else.
##
## Usage: generate a vector with the list of leaves (string-formatted)
## per internal node
##   treenodes <- leaves.per.node(tree) ## The input tre must be an hclust result
##
## Then to get a vector with the leaves associated to a given internal
## node (e.g. node 4):
##   leaves.for.node.4 <- as.numeric(unlist(strsplit(tree.nodes[4], split=" ")))
##
leaves.per.node <- function (tree) {
  merge.table <- tree$merge
  leave.lists <- list()

  for (i in 1:nrow(merge.table)) {
    branch1 <- merge.table[i, 1]
    branch2 <- merge.table[i, 2]

    ## Depending on whether the left branch points to a leave or an
    ## iternal nodes, collect a single leave or the pre-defined list
    ## of leaves from this internal node
    if (branch1 < 0) {
      nodes1 <- -branch1 ## branch one only contains one leave
    } else {
      nodes1 <- leave.lists[branch1]
    }

    ## Depending on whether the right branch points to a leave or an
    ## iternal nodes, collect a single leave or the pre-defined list
    ## of leaves from this internal node
    if (branch2 < 0) {
      nodes2 <- -branch2 ## branch one only contains one leave
    } else {
      nodes2 <- leave.lists[branch2]
    }

    leave.lists[i] <- paste(nodes1, nodes2)
  }

  ## Transform the list to export it
  if(length(leave.lists) > 1){
    leave.lists <- sapply(leave.lists, function(x){ as.numeric(unlist(strsplit(x, " "))) })
  } else{
    leave.lists <- list(as.numeric(unlist(strsplit(leave.lists[[1]], " "))))
  }
  return (leave.lists)
}
