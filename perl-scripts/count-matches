#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.seq.lib";
require RSAT::pattern;

################################################################
#### initialise parameters
my $start_time = &AlphaDate();

local %infile = ();
local %outfile = ();

local $both_strands=0;
local $verbose = 0;
local $in = STDIN;
local $out = STDOUT;
$slide = 0;
local @pattern1 = ();
local @pattern2 = ();

## lower and upper thresholds
%lth = ();
%uth = ();
@supported_threshold_fields = qw(
			      match
			      proba
			      weight
			      len1
			      len2
			      mlen
			      tlen
			      offset
			      max_w
			      rel_w
			      );
foreach my $field (@supported_threshold_fields) {
    $supported_threshold_field{$field} = 1;
}
$supported_threshold_fields = join (",", @supported_threshold_fields);


#### initialise parameters ####
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;
@supported_return_fields = qw(
			      match
			      proba
			      weight
			      seq
			      id
			      length
			      offset
			      strand
			      max_w
			      rel_w
			      top_s
			      );
foreach my $field (@supported_return_fields) {
    $supported_return_field{$field} = 1;
}
$supported_return_fields = join (",", @supported_return_fields);

my %field_format = (match=>"%d",
		    weight=>"%.2f",
		    proba=>"%.2g",
		    seq1=>"%s",		
		    seq2=>"%s",		
		    id1=>"%s",
		    id2=>"%s",		
		    len1=>"%d",
		    len2=>"%d",
		    mlen=>"%d",
		    tlen=>"%d",
		    offset=>"%g",
		    strand=>"%s",		
		    max_w=>"%.2f",
		    max_w1=>"%.2f",
		    max_w2=>"%.2f",
		    rel_w=>"%.3f",
		    rel_w1=>"%.3f",
		    rel_w2=>"%.3f",
		    top_s1=>"%s",
		    top_s2=>"%s",
		    );

&ReadArguments();

################################################################
## Check arguments

## return fields
if (scalar(@return_fields) < 1) {
    @return_fields = ("seq", "match");
}

my @temp_return_fields = @return_fields;
@return_fields = (); ## Ordered list of fields to return. 
%return_field = ();  ## Index for the fields to return.
foreach my $field (@temp_return_fields) {
    &RSAT::error::FatalError("$field\tInvalid return field. Supported: $supported_return_fields\n") unless $supported_return_field{$field};

    $return_field{$field}++;

#    warn "; Adding field\t", $field, "\n" if ($verbose >= 5);
    if ($field eq "seq") {
	push @return_fields, "seq1", "seq2";
    } elsif ($field eq "id") {
	push @return_fields, "id1", "id2";
    } elsif ($field eq "max_w") {
	push @return_fields, "max_w", "max_w1", "max_w2";
    } elsif ($field eq "rel_w") {
	push @return_fields, "rel_w", "rel_w1", "rel_w2";
    } elsif ($field eq "top_s") {
	push @return_fields, "top_s1", "top_s2";
    } elsif ($field eq "length") {
	push @return_fields, "len1", "len2", "mlen", "tlen";
    } else {
	push @return_fields, $field;
    }
}

################################################################
## Read input patterns from file
if ($pattern_file1) {
    push @pattern1, &ReadPatterns(pattern_file=>$pattern_file1);
}
if ($pattern_file2) {
    push @pattern2, &ReadPatterns(pattern_file=>$pattern_file2);
}


## Check input patterns
&RSAT::error::FatalError("You must specify at least one first sequence") unless (scalar(@pattern1) > 0);
&RSAT::error::FatalError("You must specify at least one second sequence") unless (scalar(@pattern2) > 0);


################################################################
### open output stream
$out = &OpenOutputFile($outfile{output});

################################################################
#### print verbose
&Verbose() if ($verbose >= 1);

## Print header
if ($verbose >= 1) {
    print $out ";", join ("\t", @return_fields), "\n";
}

## Count matches for each pair of input sequences	
foreach $pattern1 (@pattern1) {
    foreach $pattern2 (@pattern2) {
	&OneMatch($pattern1, $pattern2, 0);
	if ($both_strands) {
	    &OneMatch($pattern1, $pattern2, 1);
	}
    }
}

exit(0);

################################################################
################### subroutine definition ######################
################################################################

################################################################
## Match one pattern against another one
sub OneMatch {
    my ($pattern1, $pattern2, $reverse) = @_;
    $id1 =  $pattern1->get_attribute("id");
    $seq1 = $pattern1->get_attribute("sequence");
    $seq1 = &ExpandSeq($seq1);

    ## Match direct or reverse complement
    $strand = "D";
    if ($reverse) {
	$seq1 = &ReverseComplement($seq1);
	$strand = "R";
#	$id1 .= "_rev";
    }
    
    $id2 =  $pattern2->get_attribute("id");
    $seq2 = $pattern2->get_attribute("sequence");
    $seq2 = &ExpandSeq($seq2);

    ## Check input sequences
    &RSAT::error::FatalError("You must specify a first sequence") unless ($seq1);
    &RSAT::error::FatalError("You must specify a second sequence") unless ($seq2);

#    warn join("\t", "Comparing",  $id1, $seq1, $id2, $seq2),"\n" if ($main::verbose >= 10);

    local @result = ();
    local $match;
    local $weight;
    local $proba;
    local $offset;
    local $len1;
    local $len2;
    local $mlen;
    local $tlen;

    
    ################################################################
    ## Count the matches
    if ($slide) {
	($match, $weight, $proba, $mlen, $offset) = &BestMatch($seq1,$seq2);
    } else {
	($match, $weight, $proba, $mlen) = &CountMatches($seq1,$seq2);
    }
    if ($return_field{length}) {
	$len1 = length($seq1);
	$len2 = length($seq2);
	$tlen = $len1 + $len2 - $mlen; ## total length of the alignment
    }

    ################################################################
    ## Calculate max matching weights
    ($max_w1, $top_s1) = &MaxMatchingWeight($seq1);
    ($max_w2, $top_s2) = &MaxMatchingWeight($seq2);
    $max_w = &min($max_w1, $max_w2);

    ################################################################
    ## Calculate relative weights
    if ($max_w1 > 0) {
	$rel_w1 = $weight/$max_w1;
    } else {
	$rel_w1 = "NA";
    }
    
    if ($max_w2 > 0) {
	$rel_w2 = $weight/$max_w2;
    } else {
	$rel_w2 = "NA";
    }
    
    if ($max_w > 0) {
	$rel_w = $weight/$max_w;
    } else {
	$rel_w = "NA";
    }
    

    
    ################################################################
    ## Print the result for this comparison
    my $to_print = 1;
    foreach my $field (@return_fields) {
	my $result = $$field;

	## Check thresholds on this field
	if ((defined($lth{$field})) && ($result < $lth{$field})) {
	    $to_print = 0;
	    last
	    }
	if ((defined($uth{$field})) && ($result > $uth{$field})) {
	    $to_print = 0;
	    last
	    }
	
	## Format the field
	push @result, sprintf $field_format{$field}, $result;
	warn join "\t", ";", $field, $result, "\n" if ($verbose >= 3);
    }
    if ($to_print) {
	print $out join ("\t", @result), "\n";
    }
}

################################################################
#### display full help message 
sub PrintHelp {
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
	count-matches

AUTHOR
	Jacques van Helden (jacques\@scmbb.ulb.ac.be)

USAGE
	count-matches seq1 seq2

DESCRIPTION
	Count matching positions between two sequences provided as
	command line arguments.

CATEGORY
	util
	sequences

OPTIONS
	-h	display full help message
	-help   (must be first argument) display options
	-v	verbose
	-seq1	first sequence for the comparison
		This argument can be repeated on the same command line
		to enter multiple patterns.
	-seq2	second sequence for the comparison

		The options -seq1 and -seq2 can be used iteratively to
		specify multiple sequence patterns. Each sequence of
		group 1 is then compared to each sequence of group 2.
		   ex: -seq1 gataag -seq1 gattag -seq1 gataah 
		       -seq2 agataata -seq2 gtttag
		 Note that when many patterns have to be entered, the
		 options -file1 and -file2 are more convenient.
	-file1 	file containing a list of patterns to be used as first
         	sequences for the comparison (see format below). 
	-file2 	file containing a list of patterns to be used as second
         	sequences for the comparison (see format below). 
	-return	return fields
		Each selected field is returned in a separate column.
		Supported: $supported_return_fields

        -uth field #
                upper threshold value for a given field
                Supported_fields: $supported_threshold_fields

        -lth field #
                lower threshold value for a given field
                (same fields as -uth)

	-slide	find best match by sliding seq2 along seq1
		When this option is used, the best offset is also
		returned. The offset is the number of positions to
		shift seq1 in order to obtain the best scoring
		alignment. Negative values represent a shit of seq2 to
		the left side, positive values ot the right side.

	-2str 	Match on both strands 
		In addition to the direct matching (strand = D), the
		reverse complement of each pattern of group 1
		(specified by -seq1 or -file1) is matched against each
		pattern of group2.

INPUT FORMAT
    PATTERNS
	seq1 and seq2 must be DNA sequences (not peptidic). 
        IUPAC degenerate code is accepted in seq1 as well as seq2.

    PATTERN FILE
	A pattern file is a tab-delimited text file. Each row contains
	the description of one pattern. Column content:
	  1) Pattern sequence. This is the only mandatory column.
	  2) Pattern ID (optional).
	Additional columns can be used to specify other pattern
	attributes (description, score, ...), but they are by default
	ignored by the program. The option -sc allows to specify a
	score column.

OUTPUT FORMAT
       The output consists in a tab-separated text table, with one row
       per pair of sequences, and one column per return field.

RETURN FIELDS
       match	number of matching positions

       proba 	probability to observe a random match. The probability of
                an alignment is the product of probabilities of
                matching pairs of residues.

		If one assumes equiprobable nucleotides, the
		probability of random match is estimated as follows
		for non-ambiguous and ambiguous nucleotides.

	code	nucleotides	proba	mnemonics
	---------------------------------------------------------------
	A			1/4	(Adenine)
	C			1/4	(Cytosine)
	G			1/4	(Guanine)
	T			1/4	(Thymine)
	R	= A or G	1/2	(puRines)
	Y	= C or T	1/2	(pYrimidines)
	W	= A or T	1/2	(Weak hydrogen bonding)
	S	= G or C	1/2	(Strong hydrogen bonding)
	M	= A or C	1/2	(aMino group at common position)
	K	= G or T	1/2	(Keto group at common position)
	H	= A, C or T	3/4	(not G)
	B	= G, C or T	3/4	(not A)
	V	= G, A, C	3/4	(not T)
	D	= G, A or T	3/4	(not C)
	N	= G, A, C or T	1	(aNy)

	weight 	the weight reflects the number of matching positions,
                with a lower weight for matches between partially
                specified nucleotides (IUPAC codes).

		The weight is calculated as
		    -log4(proba)

		For an alignment between non-ambigous nucleotides, the
		weight is maximal, and its value is the number of
		matching residues.

	max weight
		Maximal weight for the match with a given pattern.
		max_w1	maximal weight for pattern 1
		max_w2	maximal weight for pattern 2
		max_w maximal weight between pattern 1 and pattern2
		      max_w = min(max_w1, max_w1)

	relative weight
		The relative weight is the ratio between matching weight and
		maximal weight.
		   rel_w1 = weight/max_w1
		   rel_w2 = weight/max_w2
		   rel_w = weight/max_w

	length	lengths 
		This option returns 4 length values
		     len1   length of sequence 1
		     len2   length of sequence 2
		     mlen   length of the match
		     tlen   total length of the alignment
		     	    tlen = len1 + len2 - mlen

	seq	sequences to be compared

EXAMPLES

	Single pair of sequences
	------------------------
	count-matches -seq1 GATAAT -seq2 GATWAG -return match,weight

	should return the value 5 matches (the degenerate code W
        stands for "T or A") and a weight of 4.5

	Multiple pairs of sequences
	---------------------------

	count-matches -seq1 GATAAG -seq2 GATWAG -seq2 GATAAG \
	    -seq2 GATAAT -seq2 gatha -seq2 gatnns -seq2 NNNNNN \
	    -v 1 -return match,weight,proba,length,seq

        Compares the firsts sequence with each sequence of group 2.
        Notice the difference between the columns match and weight.

	Sliding sequences
	-----------------
	count-matches -v 1 -seq1 gatasg -seq2 twagtt -slide \
	    -return match,weight,proba,seq,length

        Thresholds
	----------
	count-matches -v 1 -seq1 gatasg -seq2 twagtt -seq2 ccccga \
	    -slide -return match,weight,proba,seq,length -lth mlen 3

	This options sets a lower threshold of 3 on matching length.

End_of_help
  close HELP;
  exit;
}

################################################################
#### display short help message
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
count-matches options
----------------
-h		display full help message
-help   	display options
-seq1		first sequence for the comparison
-seq2		second sequence for the comparison
-file1		file containing a first list of sequences 
-file2		file containing a second list of sequences 
-return		return fields. Supported: $supported_return_fields
-lth            lower threshold on a given field
-uth            upper threshold on a given field
-slide	      	find best match by sliding seq2 along seq1
-2str		match on both strands
End_short_help
  close HELP;
  exit;
}


################################################################
#### read arguments 
sub ReadArguments {
    foreach my $a (0..$#ARGV) {
	### verbose  
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp();
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions();
	    
	    ### input file  
	} elsif ($ARGV[$a] eq "-i") {
	    $infile{input} = $ARGV[$a+1];
	    
	    ### output file  
	} elsif ($ARGV[$a] eq "-o") {
	    $outfile{output} = $ARGV[$a+1];
	    
	    ### first sequence  
	} elsif ($ARGV[$a] eq "-seq1") {
#	    push @pattern1, $ARGV[$a+1];
	    push @pattern1, new RSAT::pattern(sequence=>$ARGV[$a+1],
					     id=>$ARGV[$a+1]);
	    
	    ### second sequence  
	} elsif ($ARGV[$a] eq "-seq2") {
#	    push @pattern2, $ARGV[$a+1];
	    push @pattern2, new RSAT::pattern(sequence=>$ARGV[$a+1],
					     id=>$ARGV[$a+1]);

	    ### first sequence   file
	} elsif ($ARGV[$a] eq "-file1") {
	    $pattern_file1 = $ARGV[$a+1];

	    ### second sequence   file
	} elsif ($ARGV[$a] eq "-file2") {
	    $pattern_file2 = $ARGV[$a+1];

	    ### return fields
	} elsif ($ARGV[$a] eq "-return") {
	    push @return_fields, split ",", $ARGV[$a+1];
	    
            #### threshold values
        } elsif ($ARGV[$a] eq "-lth") {
            my $field = $ARGV[$a+1];
            my $value = $ARGV[$a+2];
	    &RSAT::error::FatalError("Invalid threshold crierion\t".$field)
		unless ($supported_threshold_field{$field});
            $lth{$field} = $value;
        } elsif ($ARGV[$a] eq "-uth") {
            my $field = $ARGV[$a+1];
            my $value = $ARGV[$a+2];
	    &RSAT::error::FatalError("Invalid threshold crierion\t".$field)
		unless ($supported_threshold_field{$field});
            $uth{$field} = $value;

	    ### slide sequences 
	} elsif ($ARGV[$a] eq "-slide") {
	    $slide = 1;
	    
	    ### strands
	} elsif ($ARGV[$a] eq "-2str") {
	    $both_strands = 1;
	    
	}
    }
}

################################################################
#### verbose message
sub Verbose {
    print $out "; count-matches ";
    &PrintArguments($out);
    if (defined(%infile)) {
	print $out "; Input files\n";
	while (($key,$value) = each %infile) {
	    print $out ";\t$key\t$value\n";
	}
    }
    if (defined(%outfile)) {
	print $out "; Output files\n";
	while (($key,$value) = each %outfile) {
	    print $out ";\t$key\t$value\n";
	}
    }
}
