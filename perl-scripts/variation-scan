#!/usr/bin/perl -w
############################################################
#
# $Id: variation-scan,v 1.10 2013/08/13 22:13:40 jvanheld Exp $
#
############################################################

## use strict;


=pod

=head1 NAME

retrieve-variation-seq

=head1 VERSION

$program_version

=head1 DESCRIPTION

Scan sequence with different matrice weigth-position of transcription factor


=head1 AUTHORS

Jeremy.Delerce@univ-amu.fr

=head1 CATEGORY

=over

=item util

=back

=head1 USAGE

 variation-scan [-i sequence_file] -m matrix_file -bg backgournd_file [-calc_distrib] [-o outputfile] [-v #] [...]

=head2 Example


=head1 INPUT FORMAT

=head2 Sequence file

See I<retrieve-variation-seq> output format.

=head2 Matrix file

A list  of matrix in transfanc format

=head2 Background file

Oligo-analysis format

=head1 OUTPUT FORMAT

A tab delimited file with the following column content.

=over

=item 1. matrix

Name of the matrice

=item 2. variation

Name of the variation

=item 3. SO

SO term of the variation.

=item 4. var_coord

Coordinate of the variation.

=item 5. B_weight

Best max weigth. 

=item 8. W_weight

Worst max weigth.

=item 7. Diff

Difference between the two max weigth.

=item 8. variant

Variant of the variation in the sequence.

=item 9. B_pval

Pvalue of the best max weigth.

=item 10. W_pval

Pvalue of the worst max weigth.

item 11. sigma

Log10 difference between the two p-value.

item 12. B_var

Variant(s) in the sequence with the best max weigth.

Multiple variant are return comma separate if the highest max weigth
 is the same in multiple sequence.

item 13. W_var

Variant(s) in the sequence with the worst max weigth.

Multiple variant are return comma separate if the lowest max weigth
 is the same in multiple sequence.

item 14. B_offset


item 15. W_offset


item 14. B_seq

Sequence with the highest max weigth.

Multiple sequence are return comma separate if the best max weigth
 is the same in multiple sequence.

item 15. W_seq

Sequence with the lowest max weigth.

Multiple sequence are return comma separate if the worst  max weigth
 is the same in multiple sequence.
 
=back

=head1 SEE ALSO

=head2 download-ensembl-genome

I<retrieve-variation-seq> uses the sequences downloaded
from Ensembl using the tool I<download-ensembl-genome>.

=head2 download-ensembl-variations

I<retrieve-variation-seq> uses variation coordinates downloaded
from Ensembl using the tool I<download-ensembl-variations>.

=head2 variation-scan

Scan variation sequences with one or several position-specific scoring
matrices.

=head1 WISH LIST

=cut

BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}

require "RSA.lib";


################################################################
## Main package
package	main;
{

  ###############################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.10 $ =~ /\d+/g); sprintf"%d."."%02d" x $#r, @r };
  our $output_lines = 0;

  our %infile	= ();
  $infile{'distrib_list'} = "";
  our %outfile = ();

  our $verbose = 0;
  our $in = STDIN;
  our $out = STDOUT;

  our %matrix_list = ();
  our %matrix_PWM = ();
  our $flank_len = 29;
  our $only_biggest = 0;
  our $pval_limit = 1;

  our $calc_distrib = 0;
  our $distrib_dir = "";

  our $html = 0;
  our $top_matrix =-1;
  our $top_variation = -1;

  our $nb_matrix = 0;
  our $nb_variation =0;
  our $nb_seq = 0;


  ################################################################
  ## Read argument values
  &ReadArguments();
  $out = &OpenOutputFile($outfile{output});

  ###############################################################
  ## Check arguments
  &RSAT::error::FatalError("You forgot to indicate a background file. Use -bg option") unless ($infile{'bg'});
  &RSAT::error::FatalError("You forgot to indicate a matrix file. Use -m option") unless ($infile{'matrixfile'});
  &RSAT::error::FatalError("Background file",$infile{'bg'},"does not exist") unless (-f $infile{'bg'});
  &RSAT::error::FatalError("Matrice file",$infile{'matrixfile'},"does not exist") unless (-f $infile{'matrixfile'});
  
  if ($calc_distrib) {
    &RSAT::error::FatalError("You forgot to indicate distribution directory. Use -distrib_dir option") unless ($distrib_dir);
    &RSAT::message::TimeWarn("Calculing distribution") if ($main::verbose >= 2);

    my @bg_name = split('/',$infile{'bg'});
    @bg_name = split('.',$bg_name[-1]);
    my $bg_name = $bg_name[-1];
    $outfile{'distrib_list'} = $bg_name."_list.tab";

    &Verbose() if ($main::verbose >= 1);

    my $split_dir = $distrib_dir."/split_dir/tmp";
    &RSAT::util::CheckOutDir($split_dir);

    &doit($ENV{'RSAT'}."/perl-scripts/convert-matrix -v 1 -from tf -to tf -split -i $infile{'matrixfile'} -o $split_dir", 0, 0, 0);


    my $outD = &OpenOutputFile($distrib_dir.'/'.$outfile{'distrib_list'});
    print $outD "#MATRIX_ID\tDISTRIB_FILE\tDB\tBG_PREFIX";

    my ($file) = &OpenInputFile($split_dir.'_matrix_list.tab');
    while (<$file>) {
      next if (/^#/); ## Skip comment lines
      next if (/^;/); ## Skip RSAT-like comment lines
      next unless (/\S/); ## Skip empty lines
      chomp();
      my @token = split("\t");
      my $distrib_file = $token[1]."_".$bg_name.".tab";

      &doit($ENV{'RSAT'}."matrix-distrib -m $token[2] -matrix_format tf -decimals 1 -bgfile $infile{'matrixfile'} -bg_pseudo 0.01 -bg_format oligos -pseudo 1 -o $distrib_dir/$distrib_file", 0, 0, 0);
      print $outD $token[1],"\t",$distrib_file,"\t.\t",$bg_name,"\n";
    }
    &RSAT::message::Info("Distrib_list :", $distrib_dir.'/'.$outfile{'distrib_list'}) if ($main::verbose >= 2);

    ################################################################
    ## Report execution time and close output stream
    my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
    print $out $exec_time  if ($main::verbose >= 1); ## only report exec time if verbosity is specified
    close $out;

    exit(0);
  }

  if ($infile{'distrib_list'}) {
    &RSAT::error::FatalError("Distrib list",$infile{'distrib_list'},"file does not exist") unless (-f $infile{'distrib_list'});
  }


  ################################################################
  ## Print verbose
  if ($main::verbose >= 1) {
    &Verbose() if ($main::verbose >= 1);
    print $out "; column content","\n";
    print $out ";\t",'1',"\t",'ac_motif',"\t",'Accession number of the matrices',"\n";
    print $out ";\t",'2',"\t",'motif',"\t",'Matrices current name',"\n";
    print $out ";\t",'3',"\t",'var_id',"\t",'Id of the variation',"\n";
    print $out ";\t",'4',"\t",'var_class',"\t",'SOterm of the variation',"\n";
    print $out ";\t",'5',"\t",'var_coord',"\t",'Coordinate of the variation',"\n";
    print $out ";\t",'6',"\t",'best_w',"\t",'Best weigth for the putative site',"\n";
    print $out ";\t",'7',"\t",'worst_w',"\t",'Worst weigth for the putative site',"\n";
    print $out ";\t",'8',"\t",'w_diff',"\t",'Difference between best and worst weigth',"\n";
    print $out ";\t",'9',"\t",'best_pval',"\t",'P_value of the best putative site',"\n";
    print $out ";\t",'10',"\t",'worst_pval',"\t",'P_value of the worst putative site',"\n";
    print $out ";\t",'11',"\t",'pval_ratio',"\t",'Ratio between worst and best pval ( pval_ratio = worst_pval/best_pval )',"\n";
    print $out ";\t",'12',"\t",'pval_lr',"\t",'Log ratio between worst and best pval (pval_lr = log10(worst_pval/best_pval) )',"\n";
    print $out ";\t",'13',"\t",'pval_lr_relatif',"\t",'Ratio between pval_lr and the pval_lr_max ( pval_lr_relatif = pval_lr/pval_lr_max)',"\n";
    print $out ";\t",'14',"\t",'best_variant',"\t",'Variant in the best putative site',"\n";
    print $out ";\t",'15',"\t",'worst_variant',"\t",'Variant in the worst putative site',"\n";
    print $out ";\t",'16',"\t",'best_offest',"\t",'Offset of the best putative site',"\n";
    print $out ";\t",'17',"\t",'worst_offset',"\t",'Offset of the worst putative site',"\n";
    print $out ";\t",'18',"\t",'min_offset_diff',"\t",'Difference minimal between best and worst putative site',"\n";
    print $out ";\t",'19',"\t",'best_strand',"\t",'Strand of the best putative site',"\n";
    print $out ";\t",'20',"\t",'worst_strand',"\t",'Strand of the worst putative site',"\n";
    print $out ";\t",'21',"\t",'str_change',"\t",'Indicate if strand have change between the offset of min_offset_diff',"\n";
    print $out ";\t",'22',"\t",'best_seq',"\t",'Sequence of the worst putative site',"\n";
    print $out ";\t",'23',"\t",'worst_seq',"\t",'Sequence of the worst putative site',"\n";
  }

  print $out "#",join("\t",qw(
                      ac_motif
                      motif
                      var_id
                      var_class
                      var_coord
                      best_w
                      worst_w
                      w_diff
                      best_pval
                      worst_pval
                      pval_ratio
                      pval_lr
                      pval_lr_relatif
                      best_variant
                      worst_variant
                      best_offset
                      worst_offset
                      min_offset_diff
                      best_strand
                      worst_strand
                      str_change
                      best_seq
                      worst_seq)),"\n";

  ################################################################
  #Read Matrix File
  &RSAT::message::TimeWarn("Reading Matrix File") if ($main::verbose >= 2);

  my $length = 0;
  my $need_count = 0;
  my $ac = "";

  my ($mat_file) = &OpenInputFile($main::infile{'matrixfile'});
  while (<$mat_file>) {
    next if (/^#/); ## Skip comment lines
    next if (/^;/); ## Skip RSAT-like comment lines
    next unless (/\S/); ## Skip empty lines
    chomp();

    my @token = split (" ",$_);

    if ( $token[0] eq "AC") {
      $ac = $token[-1];
      $length = 0;
    }

    if ( $token[0] eq "ID" ) {
      $matrix_list{$ac}{'id'} = $token[-1];
    }

    $need_count = 0 if ( $token[0] eq "XX" );

    if ($need_count) {
      $length += 1;

      for (my $i = 1;$i < scalar(keys(%{$matrix_list{$ac}{'tab'}})+1);$i++ ) {
        push ( @{ $matrix_list{$ac}{'tab'}{$i} }, $token[$i] );
      }
    }

    if ( $token[0] eq "P0" ||$token[0] eq "PO" ) {
      $need_count = 1;

      for (my $i = 1;$i < scalar(@token);$i++ ) {
        push ( @{ $matrix_list{$ac}{'tab'}{$i} }, lc($token[$i]) );
      }
    }

    if ( $token[0] eq "//") {
      $matrix_list{$ac}{'length'} = $length;
      $nb_matrix++;
    }

    if ($top_matrix) {
      last if ($top_matrix == $nb_matrix && $top_matrix > 0);
    }

  }
  $matrix_list{$ac}{'length'} = $length;
  $nb_matrix++;
  close $mat_file;

  ## Get distrib files
  my %distrib_file_list = ();
  if ( -f $infile{'distrib_list'} ) {
    my $distrib_file_name = "";
    ($distrib_dir, $distrib_file_name) = &SplitFileName($infile{'distrib_list'});

    ($file) = &OpenInputFile($infile{'distrib_list'});
    while (<$file>) {
      next if (/^#/); ## Skip comment lines
      next if (/^;/); ## Skip RSAT-like comment lines
      chomp();
      my @token = split("\t");
      $distrib_file_list{$token[0]} = $token[1];
    }
  }

  ################################################################
  my $fasta_file = &RSAT::util::make_temp_file("","variation-scan_fasta_seq", 1);
  my $bg_file = &RSAT::util::make_temp_file("","variation-scan_bg_file", 1);
  my $matrix_file_tab = &RSAT::util::make_temp_file("","variation-scan_matrices_tab", 1);
  my $variation_seq = &RSAT::util::make_temp_file("","variation-scan_variant_seq_tab", 1);

  ## Change bg_file format
  my $command = "$ENV{'RSAT'}/perl-scripts/convert-background-model -i $main::infile{'bg'} -from oligos -to inclusive -o $bg_file -bg_pseudo 0.01";
  &doit($command, 0, 0, 0);

  ## Write pipe input into fie for multipl read
  unless ($main::infile{input}) {
    my $outstream_var_seq = &OpenOutputFile($variation_seq); 
    while (<$main::in>) {
      next if (/^#/); ## Skip comment lines
      next if (/^;/); ## Skip RSAT-like comment lines
      next unless (/\S/); ## Skip empty lines
      next unless (/\t/); ## Skip lines containing no tab (likely to be starting comment lines)
      print $outstream_var_seq $_;
    }
    close $outstream_var_seq;
    $main::infile{input} = $variation_seq;
  }


  ## Scan
  our $matrix_length = 0;

  foreach my $matrix_ac (keys(%matrix_list)) {
    $matrix_length = $matrix_list{$matrix_ac}{'length'};
    next if ($matrix_length == 0);
    next if ($matrix_length > $flank_len+1);



    ## Make matrix file on tab format
    my $outM = &OpenOutputFile($matrix_file_tab);
    foreach my $line (sort {$a <=> $b} keys( %{ $matrix_list{$matrix_ac}{'tab'} } )) {
      print $outM join("\t",@{$matrix_list{$matrix_ac}{'tab'}{$line}})."\n";
    }
    close($outM);



    ## Get distribution
    &RSAT::message::TimeWarn("\tGet distrib") if ($main::verbose >= 3);

    %matrix_info = ();

    # Use precalculte distrib file
    if ($distrib_file_list{$matrix_ac}) {
      my %legend_col = ();

      my $distrib_file = $distrib_dir."/".$distrib_file_list{$matrix_ac};
      my ($d_file) = &OpenInputFile($distrib_file);
      while (<$d_file>) {
        next if (/;/);
        chomp;

        if (/^#/) {
          $_ = substr($_,1) ;
          my @legends = split("\t");
          for (my $i = 0; $i < scalar(@legends);$i++) {
            $legend_col{$legends[$i]} = $i;
          }
        } else {
          my @value = split("\t");
          $matrix_info{$matrix_ac}{'pval'}{$value[$legend_col{"weight"}]} = $value[$legend_col{"Pval"}];
        }
      }

      $matrix_info{$matrix_ac}{'pval'}{'0'} = $matrix_info{$matrix_ac}{'pval'}{'0.0'};
      $matrix_info{$matrix_ac}{'pval'}{'-0.0'} = $matrix_info{$matrix_ac}{'pval'}{'0.0'};

      my @sorted_pval = sort {$a <=> $b} keys (%{$matrix_info{$matrix_ac}{'pval'}});
      $matrix_info{$matrix_ac}{'sigma_max'} = log10($matrix_info{$matrix_ac}{'pval'}{$sorted_pval[0]}/$matrix_info{$matrix_ac}{'pval'}{$sorted_pval[-1]});

    # Calcul distrib file
    } else {
      my %legend_col = ();
      my $arg = "-m $matrix_file_tab -matrix_format tab";
      $arg .= " -decimals 1 -pseudo 1";
      $arg .= " -bgfile $main::infile{'bg'} -bg_format oligos";
      $arg .= " -bg_pseudo 0.01";

      my @result_distrib = qx{$ENV{'RSAT'}/perl-scripts/matrix-distrib $arg};

      foreach (@result_distrib) {
        chomp;

        if (/^#/) {
          $_ = substr($_,1) ;
          my @legends = split("\t");
          for (my $i = 0; $i < scalar(@legends);$i++) {
            $legend_col{$legends[$i]} = $i;
          }
          next;
        }

        my @value = split("\t");
        $matrix_info{$matrix_ac}{'pval'}{$value[$legend_col{"weight"}]} = $value[$legend_col{"Pval"}];
      }

      $matrix_info{$matrix_ac}{'pval'}{'0'} = $matrix_info{$matrix_ac}{'pval'}{'0.0'};
      $matrix_info{$matrix_ac}{'pval'}{'-0.0'} = $matrix_info{$matrix_ac}{'pval'}{'0.0'};

      my @sorted_pval = sort {$a <=> $b} keys (%{$matrix_info{$matrix_ac}{'pval'}});
      $matrix_info{$matrix_ac}{'sigma_max'} = log10($matrix_info{$matrix_ac}{'pval'}{$sorted_pval[0]}/$matrix_info{$matrix_ac}{'pval'}{$sorted_pval[-1]});
    }



    ## Scan sequences
    my $last_id = "";
    my $last_nb = 2000;

    $arg = " -i $fasta_file";
    $arg .= " -m $matrix_file_tab";
    $arg .= " -pseudo 1 -decimals 1 -2str -origin start";
    $arg .= " -bgfile $bg_file";
    $arg .= " -name $matrix_ac";

    &RSAT::message::TimeWarn("\tScan matrix") if ($main::verbose >= 3);
    my $out_fas = &OpenOutputFile($fasta_file);

    my ($var_seq) = &OpenInputFile($main::infile{input});
    while (<$var_seq>) {
      next if (/^#/); ## Skip comment lines
      next if (/^;/); ## Skip RSAT-like comment lines
      next unless (/\S/); ## Skip empty lines
      next unless (/\t/); ## Skip lines containing no tab (likely to be starting comment lines)
      chomp();

      my ($chrom, $start, $end,$strand,$id,$type,$ref,$variant,$seq) = split(/\t/);

      $ref = "-" if ($ref eq "");

      if ($last_id ne $id && $last_id ne "") {
        $nb_variation ++;
        last if ($nb_variation > $top_variation && $top_variation>0);

        if ($nb_variation >= $last_nb) {
          my @scanning = qx{$ENV{'RSAT'}/contrib/matrix-scan-quick/matrix-scan-quick $arg};
          &Analyse(@scanning) unless (scalar(@scanning) == 0);

          close($out_fas);
          $out_fas = &OpenOutputFile($fasta_file);
          $last_nb += 2000;
        }
      }

      print $out_fas ">$id;$ref;$variant;$type|$chrom:$start-$end\_$strand\n".substr($seq,$flank_len-$matrix_length+1,length($seq)-($flank_len-$matrix_length+1)*2)."\n";
      $nb_seq++;
      $last_id = $id;
    }
    close ($var_seq);

    close($out_fas);
    $nb_variation ++;
    my @scanning = qx{$ENV{'RSAT'}/contrib/matrix-scan-quick/matrix-scan-quick $arg};
    &Analyse(@scanning) unless (scalar(@scanning) == 0);
    @scanning = ();

    $out_fas = &OpenOutputFile($fasta_file); ##Just to make empty file
    close($out_fas);

  }

  ################################################################
  ## Report execution time and close output stream
  my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts

  if ($main::verbose >= 1) {
    print $out "; Total variations scan\t",$nb_variation/$nb_matrix,"\n";
    print $out "; Total sequences scan\t",$nb_seq,"\n";
    print $out "; Total matrices\t",$nb_matrix,"\n";
    print $out $exec_time; ## only report exec time if verbosity is specified
  }

  close $out;

  ################################################################
  ## Make html output
  if ($outfile{'output'} && $html) {
    $html_file = $outfile{'output'};
    $html_file =~ s/\.tab/\.html/g;
    $command = $ENV{'RSAT'}."/perl-scripts/text-to-html -i ".$outfile{'output'};
    $command .= " -no_sort -chunk 1000" if ($output_lines >= 5000);
    $command .= " -o ".$html_file;
#    $command = "$ENV{'RSAT'}/perl-scripts/text-to-html -i $outfile{'output'} -o $html_file";
    &doit($command, 0, 0, $verbose);
  }

  exit(0);
}




################################################################
################### SUBROUTINE DEFINITION ######################
################################################################

################################################################
## Display full help message
sub PrintHelp {
  system "pod2text -c $0";
  exit(0);
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}
################################################################
## Calclate log10
sub log10 {
  my $n = shift;
  return log($n)/log(10);
}

################################################################
##
sub getLineInfo {
  my ($var_info1,$site,$matrice,$stran,$pos_s,$pos_e,$seq,$score) = split ("\t",$_[0]);
  my ($var_info2, $coord) = split(/\|/,$var_info1);
  my ($chr,$start_end_strand) = split(/:/,$coord);
  my ($start,$end_strand) = split(/-/,$start_end_strand);
  my ($id,$ref,$var,$type) = split(';',$var_info2);

  $diff_pos = 0;
  $diff_pos ++ if ($var eq "-"); 

  $pos_s = $pos_s+$diff_pos-$matrix_length;
  $pos_e = $pos_e+$diff_pos-$matrix_length;

  return ($matrice,$coord,$id,$type,$ref,$var,$stran,$pos_s,$pos_e,$seq,$score)
}

################################################################
## Analyse result of scanning
sub Analyse() {
  @scanning = @_;

  my %last_line = ();
  my %score_variation = ();

  while ( my $line = shift @scanning ) {
    
    next if ($line =~ m/^#/);
    next if ($line =~ m/^;/);
    chomp($line);

    my @info = &getLineInfo($line);
    my $same_matrice   =  !$last_line{'matrice'} || $info[0] eq $last_line{'matrice'};
    my $same_variation =  !$last_line{'variation'} || $info[2] eq $last_line{'variation'};
    my $same_variant   =  !$last_line{'variant'} || $info[5] eq $last_line{'variant'} ;

    $info[10] = sprintf("%.1f",$info[10]);

    if ($same_matrice && $same_variation && $same_variant) {
      my $same_score = 0;
      my $highest_score = 1;

      if ($score_variation{$info[5]}{'score'}) {
        $same_score = $score_variation{$info[5]}{'score'} == $info[10];
        $highest_score = $score_variation{$info[5]}{'score'} < $info[10];
      }

      if ( $highest_score ) {
        $score_variation{$info[5]} = ();
        $score_variation{$info[5]}{'score'} = $info[10];
        push(@{$score_variation{$info[5]}{'offset'}}, $info[7]);
        push(@{$score_variation{$info[5]}{'strand'}}, $info[6]);
        push(@{$score_variation{$info[5]}{'seq'}}, $info[9]);

      } elsif ($same_score) {
        $score_variation{$info[5]}{'score'} = $info[10];
        push(@{$score_variation{$info[5]}{'offset'}}, $info[7]);
        push(@{$score_variation{$info[5]}{'strand'}}, $info[6]);
        push(@{$score_variation{$info[5]}{'seq'}}, $info[9]);
      }


    } elsif ( !$same_matrice || !$same_variation ) {
      &PrintResult($last_line{'matrice'},$last_line{'variation'},$last_line{'SOterm'},$last_line{'offset'},\%score_variation );
      %score_variation = ();
    }

    $last_line{'matrice'} = $info[0];
    $last_line{'variation'} = $info[2];
    $last_line{'SOterm'} = $info[3];
    $last_line{'offset'} = $info[1];
    $last_line{'variant'} = $info[5];
  }

  &PrintResult($last_line{'matrice'},$last_line{'variation'},$last_line{'SOterm'},$last_line{'offset'},\%score_variation );
}

################################################################
## Sent print request for each diff between score of variant
sub PrintResult {
  my ($matrice,$variation,$so_term,$coord,$score_variation) = @_;
  my %score_variation = %{ $score_variation };

  my %score_variant = ();
  foreach my $variant ( keys(%score_variation) ) {
    push (@{ $score_variant{ $score_variation{$variant}{'score'} }{'variant'} }, $variant);
    push (@{ $score_variant{ $score_variation{$variant}{'score'} }{'offset'} }, join(",",@{$score_variation{$variant}{'offset'}}));
    push (@{ $score_variant{ $score_variation{$variant}{'score'} }{'strand'} }, join(",",@{$score_variation{$variant}{'strand'}}));
    push (@{ $score_variant{ $score_variation{$variant}{'score'} }{'seq'} }, join(",",@{$score_variation{$variant}{'seq'}}));
  }

  my @sorted_score = sort {$b <=> $a} keys(%score_variant);
  foreach my $score (@sorted_score) {
    next if ( ($score == $sorted_score[-1]) && (scalar(@sorted_score) > 1) );
    my $diff1 = $sorted_score[0] - $score;
    my $diff2 = $score - $sorted_score[-1];

    if ($matrix_info{$matrice}{'pval'}{$sorted_score[0]} <= $pval_limit) {
      if ($diff1 > $diff2 ) {
        &Printline($matrice,$variation,$so_term,$coord,$sorted_score[0],$score,sprintf("%.1f", $diff1),$score_variant{$sorted_score[0]},$score_variant{$score});

      } elsif ( $diff1 == $diff2 ) {
        # Separate variant if no difference in scanning
        my %max_score_variant = ();
        push ( @{ $max_score_variant{'variant'} }, pop(@{$score_variant{$score}{'variant'}}) );
        push ( @{ $max_score_variant{'offset'} }, pop(@{$score_variant{$score}{'offset'}}) );
        push ( @{ $max_score_variant{'strand'} }, pop(@{$score_variant{$score}{'strand'}}) );
        push ( @{ $max_score_variant{'seq'} }, pop(@{$score_variant{$score}{'seq'}}) );

        &Printline($matrice,$variation,$so_term,$coord,$sorted_score[0],$score,sprintf("%.1f", $diff1),\%max_score_variant,$score_variant{$score});

      } else {
        &Printline($matrice,$variation,$so_term,$coord,$score,$sorted_score[-1],sprintf("%.1f", $diff2),$score_variant{$score}, $score_variant{$sorted_score[-1]} );
      }
    }

    last if ($only_biggest);
  }
}

################################################################
## Print
sub Printline {
  my ($matrice,$variation,$so_term,$coord,,$max_score,$min_score,$diff,$max_score_variant,$min_score_variant) = @_;

  $output_lines++;

  my $sig = log10($matrix_info{$matrice}{'pval'}{$min_score}/$matrix_info{$matrice}{'pval'}{$max_score});
  my $sig_rel = $sig/$matrix_info{$matrice}{'sigma_max'};

  ## Get minimun offset and str_change
  my $min_offset_diff = $flank_len;
  my $strand_change = 0;

  my @best_off_by_diff_variant = @{ ${ $max_score_variant }{'offset'} };
  
  for ($b=0; $b < scalar(@best_off_by_diff_variant); $b++) {
    my @best_off_by_same_variant = split(",",$best_off_by_diff_variant[$b]);

    for ($b2 = 0; $b2 < scalar(@best_off_by_same_variant); $b2++) {
      my @worst_off_by_diff_variant = @{ ${ $min_score_variant }{'offset'} };

      for ($w=0; $w < scalar(@worst_off_by_diff_variant); $w++) {
         my @worst_off_by_same_variant = split(",",$worst_off_by_diff_variant[$w]);

        for ($w2 = 0; $w2 < scalar(@worst_off_by_same_variant); $w2++) {

          if ( abs($worst_off_by_same_variant[$w2]-$best_off_by_same_variant[$b2]) < abs($min_offset_diff) ) {
            $min_offset_diff = $worst_off_by_same_variant[$w2]-$best_off_by_same_variant[$b2];

            my @best_strand_by_diff_variant = @{ ${ $max_score_variant }{'strand'} };
            my @worst_strand_by_diff_variant = @{ ${ $min_score_variant }{'strand'} };
            my @best_strand_by_same_variant = split(",",$best_strand_by_diff_variant[$b]);
            my @worst_strand_by_same_variant = split(",",$worst_strand_by_diff_variant[$w]);

            if ($worst_strand_by_same_variant[$w2] eq $best_strand_by_same_variant[$b2]) {
              $strand_change = 0;
            } else {
              $strand_change = 1;
            }
          }
        }
      }
    }
  }

  my $str = "";
  $str .= $matrice."\t";
  $str .= $matrix_list{$matrice}{'id'}."\t";
  $str .= $variation."\t".$so_term."\t".$coord."\t";
  $str .= $max_score."\t".$min_score."\t";  # weigth
  $str .= $diff."\t"; #w_diff
  $str .= $matrix_info{$matrice}{'pval'}{$max_score}."\t".$matrix_info{$matrice}{'pval'}{$min_score}."\t";  # pvalues
  $str .= sprintf("%.2f",$matrix_info{$matrice}{'pval'}{$min_score}/$matrix_info{$matrice}{'pval'}{$max_score})."\t";  # pvalues ratio
  $str .= sprintf("%.2e", $sig)."\t"; # sigma
  $str .= sprintf("%.2e", $sig_rel)."\t"; # sigma_relatif
  $str .= join(";",@{ ${ $max_score_variant }{'variant'} })."\t".join(";",@{ ${ $min_score_variant }{'variant'} })."\t"; # variants
  $str .= join(";",@{ ${ $max_score_variant }{'offset'} })."\t".join(";",@{ ${ $min_score_variant }{'offset'} })."\t"; # off
  $str .= $min_offset_diff."\t";
  $str .= join(";",@{ ${ $max_score_variant }{'strand'} })."\t".join(";",@{ ${ $min_score_variant }{'strand'} })."\t"; # off
  $str .= $strand_change."\t";
  $str .= join(";",@{ ${ $max_score_variant }{'seq'} })."\t".join(";",@{ ${ $min_score_variant }{'seq'} })."\n"; # seq

  print $out $str;
}

################################################################
## Read arguments
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
        $main::verbose = shift(@arguments);
      } else {
        $main::verbose = 1;
    }

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();

=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-i #>

Variation file RSAT format

=cut
    } elsif ($arg eq "-i") {
      $main::infile{input} = shift(@arguments);

=pod

=item B<-m #>

The matrix file transfac format

=cut
    } elsif ($arg eq "-m") {
      $main::infile{matrixfile} = shift(@arguments);

=pod

=item B<-bg>

Background file

=cut
    } elsif ($arg eq "-bg") {
      $main::infile{bg} = shift(@arguments);

=pod

=item B<-i #>

Input File

=cut
    } elsif ($arg eq "-i") {
      $main::infile{input} = shift(@arguments);
=pod

=item B<-mml #>

Length of the longest Matrix

=cut
    } elsif ($arg eq "-mml") {
      if (&IsNatural($arguments[0])) {
        $main::flank_len = shift(@arguments)-1;
      } else {
        &RSAT::error::FatalError("-mml argument : ",shift(@arguments)," is not natual");
      }

=pod

=item B<-top_matrix #>

Only work with the # top matrix

=cut
    } elsif ($arg eq "-top_matrix") {
      if (&IsNatural($arguments[0])) {
        $main::top_matrix = shift(@arguments);
      } else {
        &RSAT::error::FatalError("-top_matrix argument : ",shift(@arguments)," is not natual");
      }

=pod

=item B<-top_variationmatrix #>

Only work with the # top variation

=cut
    } elsif ($arg eq "-top_variation") {
      if (&IsNatural($arguments[0])) {
        $main::top_variation = shift(@arguments);
      } else {
        &RSAT::error::FatalError("-top_variation argument : ",shift(@arguments)," is not natural");
      }

=pod

=item B<-pval_limit #>

Only return desequilibre with highest pval lowest than pval_limit

=cut
    } elsif ($arg eq "-pval_limit") {
      if (&RSAT::util::IsReal($arguments[0])) {
        $main::pval_limit = shift(@arguments);
      } else {
        &RSAT::error::FatalError("-pval_limit argument : ",shift(@arguments)," is not natural");
      }

=pod

=item B<-html #>

Convert the tab-delimited file into an HTML file, which facilitates the inspection of the results with a Web browser.
The HTML file has the same name as the output file, but the extension (.tab, .txt) is replaced by the .html extension

=cut
    } elsif ($arg eq "-html") {
      $main::html = 1;

=pod

=item B<-calc_distrib>

Calcul and save distribution of matrices

=cut
    } elsif ($arg eq "-calc_distrib") {
      $main::calc_distrib = 1;


=pod

=item B<-distrib_dir #>

Directory of the distribution file 

=cut
    } elsif ($arg eq "-distrib_dir") {
      $main::distrib_dir = shift(@arguments);

=pod

=item B<-distrib_list #>

Name of the file contening the list of matrix distrib file name

/!\ This file must be in the same directory as the distrib file

=cut
    } elsif ($arg eq "-distrib_list") {
      $main::infile{'distrib_list'} = shift(@arguments);

=pod


=item B<-only_biggest>

Only return the biggest difference of score between two variant of a variation

=cut
    } elsif ($arg eq "-only_biggest") {
      $main::only_biggest = 1;

=pod


=item	B<-o outputfile>

The output file is in fasta format.

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
    } elsif ($arg eq "-o") {
      $outfile{output} = shift(@arguments);

=pod

=back

=cut

    } else {
      &FatalError(join("\t", "Invalid option", $arg));
    }
  }
}

################################################################
## Verbose message
sub Verbose {
  print $out "; variation-scan ";

  &PrintArguments($out);

  printf $out "; %-22s\t%s\n", "Program version", $program_version;
  if (%main::infile) {
    print $out "; Input files\n";
    while (my ($key,$value) = each %main::infile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  if (%main::outfile) {
    print $out "; Output files\n";
    while (my ($key,$value) = each %main::outfile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }
}
