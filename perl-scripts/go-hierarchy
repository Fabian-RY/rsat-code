#!/usr/bin/perl -w
############################################################
#
# $Id: go-hierarchy,v 1.4 2007/02/09 09:33:13 rsat Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

go-hierarchy

=head1 DESCRIPTION

Given a description file for the Gene Ontology (GO), return subsets or
the totality of the GO hierarchy.

If one specifies one or several classes, and the program returns all
the ancestral classes (super-classes).

Alternatively, one can specify a list of genes, and their class
memberships will be returned.

=head2 Resources

Official site for the distributio of the GO hierarchy :

  http://www.geneontology.org/ontology/

Description of GO classes in obo format

  http://www.geneontology.org/ontology/gene_ontology.obo


=head2 Input files

=item GO file

The GO hierarchy should be provided in "obo" format. This is the
text-formatted description of the classes and their hierarchical
relationships.

=head1 AUTHORS

Sylvain Brohee <sylvain@scmbb.ulb.ac.be>

=head1 CATEGORY

util

=head1 USAGE
    
go-hierarchy [-i inputfile] [-o outputfile] [-v #] [-q go_class1] [-q go_class2] [-classfile classfile] 

go-hierarchy [-i inputfile] [-o outputfile] [-v #] [-genefile genefile] 

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::go;



################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();
     @class_names = ();
     @known_classes = ();
     @unknown_classes = ();
     $query_by_class = 0;
     $query_by_gene = 0;
     #$format_name = 0;
     @required_output_fields = qw(parent_goid name);
     %supported_return_option = ("parent_goid" => 1,
     				"query_goid" => 1,
				"name" => 1, 
				"def" => 1,
				"namespace" => 1);
     %main::infile = ();
     %main::outfile = ();

     $main::verbose = 0;
#    $main::in = STDIN;
     $main::out = STDOUT;

    ################################################################
    ## Read argument values
    &ReadArguments();
    
    ################################################################
    ## Check argument values
    if ($query_by_gene && $query_by_class) {
      &FatalError(join("\t", "You cannot specify both a list of genes to annotate and a query go-class"));
    }

    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    
    ################################################################
    ## Initialize gene ontology object
    $go = new RSAT::go();
    $go->read_from_obo($infile{inputfile}); 

    ################################################################
    ## Determine the go classes for which the hierarchy is searched
    if ($query_by_class) {
      if ($infile{class_file}) {
        my $l = 0;
        &RSAT::message::TimeWarn("Reading classes from file", $infile{class_file}) if ($main::verbose >= 2);
        my ($class_file_handle) = &OpenInputFile($infile{class_file});
        while (my $line = <$class_file_handle>) {
          $l++;
          next if ($line =~ /^\#/); ## Skip header lines
          next if ($line =~ /^--/); ## Skip comment lines
          next if ($line =~ /^;/); ## Skip comment lines
          next unless ($line =~ /\S/); ## Skip empty lines
          chomp($line);
          my @fields = split /\s+/, $line;
          my $name =  $fields[0];
          if ($name) {
          
            push @class_names, $name;
          } else {
	    &RSAT::message::Warning("Line", $l, "starts with space. Skipped.");
          }
        }
        close $class_file_handle;
      }
      ## Identify class in the go object
      &RSAT::message::TimeWarn("Identifying",scalar(@class_names), "GO class in the file \t$infile{inputfile}") if ($main::verbose >= 2);
      foreach my $goid (@class_names) {
	my $exists = $go->exists($goid);

	if ($exists) {
	  push @known_classes, $goid;
	  &RSAT::message::Info("Identified class with id", $goid) if ($main::verbose >= 3);
        } else {
	  push @unknown_classes, $goid;
	  &RSAT::message::Warning("The GO obo file you submitted does not contain any class with id", $goid);
	}
      }
    }

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);
    
    ################################################################
    ## Retrieve the ancesters for the queried classes
    if ($query_by_class) {
      ## Header output
      print $out "#query_class_name";
      foreach my $field (@required_output_fields) {
        if ($field eq "name") {
          print $out "\tancester_class_name";
        }
        if ($field eq "namespace") {
          print $out "\tnamespace";
        }  
        if ($field eq "parent_goid") {
          print $out "\tancester_go_id";
        }
        if ($field eq "query_goid") {
          print $out "\tquery_goid";
        }
        if ($field eq "def") {
          print $out "\tdefinition";
        }
     }
     print $out "\n";
     ## Ancesters search
     foreach my $goid (@known_classes) {
        #print @class_names."\n";
        my $goclassesRef = $go->get_parents($goid);
        @goclasses = @{$goclassesRef};
        my $goid_name = $go->get_name($goid);
        foreach my $goclass (@goclasses) {
          print $out "$goid_name";
          foreach my $field (@required_output_fields) {
            if ($field eq "name") {
              print $out "\t".$go->get_name($goclass);
            }
            if ($field eq "namespace") {
              print $out "\t".$go->get_namespace($goclass);
            }  
            if ($field eq "parent_goid") {
              print $out "\t".$goclass;
            }
            if ($field eq "query_goid") {
              print $out "\t$goid";
            }   
            if ($field eq "def") {
              print $out "\t".$go->get_definition($goclass);
            }
          }
          print $out "\n";
        }
      }
    } 
    
    ################################################################
    ## Annotate the gene file by adding the ancesters. Output may be use
    ## in the compare-classes program
    
    if ($query_by_gene) {
      ## Header output
      print $out "#gene_name";
      foreach my $field (@required_output_fields) {
        if ($field eq "name") {
          print $out "\tgo_class_name";
        }  
        if ($field eq "namespace") {
          print $out "\tnamespace";
        }  
        if ($field eq "parent_goid") {
          print $out "\tparent_goid";
        }
        if ($field eq "def") {
          print $out "\tdefinition";
        }
        if ($field eq "query_goid") {
          print $out "\tquery_goid";
        }
      }
      print $out "\n";
      ## Ancesters search
      if ($infile{gene_file}) {
	my $l = 0;
	&RSAT::message::TimeWarn("Reading genes from file", $infile{gene_file}) if ($main::verbose >= 2);
	my ($gene_file_handle) = &OpenInputFile($infile{gene_file});
	while (my $line = <$gene_file_handle>) {
	  $l++;
	  next if ($line =~ /^\#/); ## Skip header lines
	  next if ($line =~ /^--/); ## Skip comment lines
	  next if ($line =~ /^;/); ## Skip comment lines
	  next unless ($line =~ /\S/); ## Skip empty lines
	  chomp($line);
	  my @fields = split /\t/, $line;
	  my $gene = $fields[0];
	  my $goid = $fields[1];
	  if ($gene && $goid) {
	    if ($go->exists($goid)) {
	      my $goclassesRef = $go->get_parents($goid);
              @goclasses = @{$goclassesRef};
              my $goid_name = $go->get_name($goid);
              foreach my $goclass (@goclasses) {
                print $out "$gene";
                foreach my $field (@required_output_fields) {
                  if ($field eq "name") {
                    print $out "\t".$go->get_name($goclass);
                  }
                  if ($field eq "namespace") {
                    print $out "\t".$go->get_namespace($goclass);
                  }  
                  if ($field eq "parent_goid") {
                    print $out "\t".$goclass;
                  }
                  if ($field eq "def") {
                    print $out "\t".$go->get_definition($goclass);
                  }
                  if ($field eq "query_goid") {
                    print $out "\t$goid";
                  }
                }
                print $out "\n";
              }
	    } else {
	      &RSAT::message::Warning("Class $goid unknown at line", $l, ". Skipped.");
	    }
	  } else {
	    &RSAT::message::Warning("Format error at line", $l, ". Skipped.");
	  }
	}
	close $gene_file_handle;
      }
    }
    
    
    
    
    
    ################################################################
    ## Print output
    
    
    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Input file
=pod

=item B<-i inputfile>

This file must be in the obo format. 
If no input file is specified, the standard input is used. 
This allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{inputfile} = shift(@arguments);

	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);

=pod

=item	B<-q query_go_class>

Specify one GO class for which you want to know the ancesters. This
option can be used iteratively to specify several query classes.

=cut
	} elsif ($arg eq "-q") {
	       push @class_names, shift(@arguments);
	       $query_by_class = 1;
=pod

=item	B<-classf query_file>

Query file. This file specifies a list of go classes.
The first word of each row specifies one class. The
rest of the row is ignored.

=cut
	} elsif ($arg eq "-classf") {
	    $main::infile{class_file} = shift(@arguments);
	    $query_by_class = 1;

=pod	    

=item	B<-genef gene_file>

Gene file. This two-columns tab-delimited file specifies a list of
genes and the GO class(es) to which each gene belongs.
	First column  : gene name or identifier
	Second column : gene ontology ID

=cut
	} elsif ($arg eq "-genef") {
	    $main::infile{gene_file} = shift(@arguments);
	    $query_by_gene = 1;	    
=pod

=item	B<-return fields>

List of fields to return : query_goid,parent_goid,name,def,namespace,all (default : parent_goid,name)

=cut
	} elsif ($arg eq "-return") {
	    my $fields = shift(@arguments);
	    my @all_fields = split(/,/, $fields);
	    @required_output_fields = ();
	    foreach my $field (@all_fields) {
	      if (defined($supported_return_option{$field})) {
  	        push @required_output_fields, $field;
  	      } elsif ($field eq 'all') {
  	        @required_output_fields = qw(goid name def namespace);
  	      } else {
  	        &FatalError($field, "Invalid return option. Supported:", join(",", sort(keys(%supported_return_option))));
  	      } 
	    }
	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; go-hierarchy ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=cut
