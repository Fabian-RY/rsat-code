#!/usr/bin/perl
############################################################
#
# $Id: gene-cluster-motifs,v 1.74 2004/02/28 17:07:49 jvanheld Exp $
#
# Time-stamp: <2003-10-21 01:19:12 jvanheld>
#
############################################################
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
    require "RSA.lib";
    require "RSA.seq.lib";
    require "RSA.help.pl";
    require "RSA.cgi.lib";
    require "RSA.classes";
    push @INC, "$RSA/perl-scripts/parsers/";
    require "lib/load_classes.pl";
    require "lib/util.pl";
    require "lib/parsing_util.pl";
    require "$RSA/perl-scripts/lib/RSA.classes";
}
    
use RSAT::matrix;

################################################################
## initialisations	    
$skip=0;
$sliding_window_size = 0;
$die_on_error = 1;
$analyze_purged_sequences = 1;
$repetitions=10000; ### Repetitions for the calibN
%dir = ();
$dir{main} = `pwd`;
$dir{calib1} = "calibrations_1gene"; 
chomp($dir{main});

## Supported tasks
@supported_tasks = qw (upstream
		       purge
		       calibrate
		       oligos
		       merge_oligos
		       oligo_maps
		       dyad_maps
		       maps
		       dyads
		       merge_patterns
		       slide
		       synthesis
		       sql
		       clean
		       all
		       report
		       consensus
		       gibbs
		       MotifSampler
		       meme);
foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
}
$supported_tasks = join ",", @supported_tasks;

## Keys for sorting the results in the summary table
%supported_sort_key = (
			 "score"=>1,
			 "name"=>1
			 );
$supported_sort_keys  = join ",", sort keys %supported_sort_key;


## Background models for string-based pattern discovery
%supported_background = (
			 "intergenic"=>1,
			 "upstream"=>1,
			 "upstreamL"=>1,
			 "upstream-noorf"=>1,
			 "calib1"=>1,
			 "calibN"=>1,
			 );
$supported_background  = join ",", sort keys %supported_background;

## input files
$family_file = "";
$sequene_file_list = "";

## feature-map options
$htmaps=0;
$draw_maps=1;
$scalestep = 100; 

## retrieve-seq options
$noorf = 1; 
$seq_format = "fasta";
$seq_dir = "";
$seq_ext = "fasta";

## pattern discovery options
$background = "upstream-noorf";
$noov = "-noov";
$sort_key = "score";
## oligo-analysis options
$min_oligo_len = 6;
$max_oligo_len = 6;
## dyad-analysis options
$monad_length = 3;
$min_sp = 0;
$max_sp = 20;

## matrix-based pattern discovery options
$matrix_width = 10;
$expected_sites_per_gene = 2;
$seed = undef;

## MotifSampler options
$MS_bg_order = 0;
$MS_b = "/home/nicolas/motifsampler/background_models/yeast_up800_nomit_noorf_o3.bg"; ### TEMPORARY
$MS_p = 0.2;
$MS_M = 0;
$MS_n = 4;
$MS_w = $matrix_width;
$MS_x = 1;
$MS_r = 5;

## Comparison between discovered and known motifs
$known_site_file = "";
$known_sites_provided = 0;
$min_matching_score = 4;

## miscellaneous
$start_date = `date`;
$verbose = 0;

#### data export options
$schema = "multifam";
$host="localhost";
$user = getlogin();
$password="";

################################################################
### MAIN

#### Read arguments
&ReadArguments();

#### Check parameters
&CheckParameters();


################################################################
## Read data
&ReadKnownSites($known_site_file);
#&ReadSiteLibrary("known_sites.tab");

if ($sequence_file_list) {
    $task{upstream} = 0; 
    &ReadSequenceList();
} else {

    ### read gene name and identifiers
    warn "; Reading ORF information ...\n" 
	 if ($verbose >= 1);
    &ReadFeatures($organism_name);
    &ReadSynonyms($organism_name);

    ### Read family file
    %family = &ReadClasses($family_file, 1);
    @families = sort keys %family;

}

### write composition of the families in the separated directories
&SetFileNames();

&CheckOutDir($dir{output});
chdir($dir{output});

&MakeDirectories();

#### verbose
$verbose_message = &Verbose() if ($verbose >= 1);


### perform analysis
&AnalyzeFamilies();
&MDCreport() if ($task{report});
&ExportSQL() if ($task{sql});
&SyntheticTable() if ($task{synthesis});

### Warn output dir and files
if ($main::verbose >= 1) {
    warn "; Results were stored in directory\t".$dir{output}."\n";
    warn "; Synthetic table\t", $dir{output}."/".$outfile{table}, "\n";
    if ($task{report}) {
	 warn "; Result report (MDC 2004)\t", $dir{output}."/".$outfile{results}, "\n";
	 warn "; Parameter report (MDC 2004)\t", $dir{output}."/".$outfile{parameters}, "\n";
    }
}

#### report execution time 
if ($verbose >= 1) {
  $done_date = `date`;
  print ";Job started\t$start_date";
  print ";Job done\t", `date`;
}

exit(0);


################################################################
#
#                 SUBROUTINE DEFINITION
#
################################################################

#### set the file names as a function of parameters
sub SetFileNames {
    $sp = "$min_sp-$max_sp";
    $dyad_options = "-v ";
    $dyad_options .= " -sort ";
    $dyad_options .= " ".$strands;
    $dyad_options .= " -type ".$dyad_type;
    $dyad_options .= " ".$noov;
    $dyad_options .= " -l ".$monad_length;
    $dyad_options .= " -thosig $thosig ";
    $dyad_options .= " -sp ".$sp;

    $dyad_suffix = "_dyads";
    if ($markov) {
	$dyad_suffix .= "_monad"; ### TEMP
    } elsif ($background) {
	$dyad_suffix .= "_bg_".$background; ### TEMP
    }
    $dyad_suffix .= "_l".$monad_length;
    $dyad_suffix .= "_sp".$sp;
    $dyad_suffix .= $strands;
    $dyad_suffix .= "_".$dyad_type;
    $dyad_suffix .= "_sig".$thosig;
    $dyad_suffix .= $noov;

    #### expected frequency model
    if ($markov) {
	## do nothing. Expected dyad frequencies will be calculated on the basis of monad frequencies
    } elsif ($exp_freq_file{dyads}) {
	$dyad_options .= " -expfreq $exp_freq_file{dyads}";
    } elsif ($background) {
	$dyad_options .= " -bg $background ";
	$dyad_options .= " -org $organism_name ";
#      $dyad_suffix .= "_ncf";
    } elsif ($background eq "mncf") {
	$dyad_options .= " -mncf ";
	$dyad_options .= " -org $organism_name ";
	$dyad_suffix .= "_mncf";
    }
#  $dyad_suffix .= "_ncf" if ($background); ### TEMP

    #### suffix for the oligo-analysis file
    $noorf_string = "_noorf" if ($noorf);
    $oligo_suffix = "_oligos";
    if ($markov) {
	$oligo_suffix .= "_mkv".$markov_order;
    } elsif ($background) {
	$oligo_suffix .= "_bg_".$background;
    }
    $oligo_suffix .= "_".$min_oligo_len."-".$max_oligo_len."nt";
    $oligo_suffix .= "$strands";
    $oligo_suffix .= "_sig".$thosig;
    $oligo_suffix .= $noov;

    foreach my $family_name (@families) {
	my $gene_nb = scalar(@{$family{$family_name}->{members}});
	warn join ("\t", "Number of genes", $family_name, $gene_nb), "\n";

	$expected_sites = $gene_nb*$expected_sites_per_gene;	
	$family{$family_name}->{family_file} = "$family_name/${family_name}.fam";
	$family{$family_name}->{known_site_file} = "$family_name/${family_name}_known_sites";
	$family{$family_name}->{file_prefix} = "${family_name}";
	$family{$family_name}->{file_prefix} .= "_up".$seq_length unless ($sequence_file_list);
	$family{$family_name}->{file_prefix} .= "${noorf_string}"; 
	unless ($sequence_file_list) {
	    $family{$family_name}->{seq_file} = $family_name."/".$family{$family_name}->{file_prefix}.".${seq_format}";
	    $family{$family_name}->{seq_file_purged} = $family_name."/".$family{$family_name}->{file_prefix}."_purged.${seq_format}";
	}
	if ($analyze_purged_sequences) {
	    $family{$family_name}->{input_seq_file} = $family{$family_name}->{seq_file_purged};
	} else {
	    $family{$family_name}->{input_seq_file} = $family{$family_name}->{seq_file};
	}
	$family{$family_name}->{seq_len_file} = $family_name."/".$family{$family_name}->{file_prefix}."_seq_len.tab";
#      $family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}."_oligos_${min_oligo_len}-${max_oligo_len}nt$strands_sig${thosig}${noov}";
	$family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix; ## TEMP
	$family{$family_name}->{oligo_assembly_file} = $family{$family_name}->{oligo_file}."_contigs";
	$family{$family_name}->{oligo_selection} = $family{$family_name}->{oligo_file}."_selection";
	$family{$family_name}->{oligo_ft_prefix} = $family{$family_name}->{oligo_file};
#	$family{$family_name}->{selection_ft_prefix} = $family{$family_name}->{oligo_ft_prefix}."_report";
	$family{$family_name}->{oligo_ft_file} = $family{$family_name}->{oligo_ft_prefix}.".ft";
	
	$family{$family_name}->{dyad_file} = "$family_name/dyads_${family_name}/".$family{$family_name}->{file_prefix}.$dyad_suffix;
	$family{$family_name}->{dyad_assembly_file} = $family{$family_name}->{dyad_file}."_contigs";
	$family{$family_name}->{dyad_ft_prefix} = $family{$family_name}->{dyad_file};
	$family{$family_name}->{dyad_ft_file} = $family{$family_name}->{dyad_ft_prefix}.".ft";
	
	$family{$family_name}->{fmap_file} = $family{$family_name}->{dyad_file}.".${IMG_FORMAT}";
	$family{$family_name}->{htmap_file} = $family{$family_name}->{dyad_file}.".html";
	
	$family{$family_name}->{merged_file} =  "${family_name}/merged_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix.$dyad_suffix;
	$family{$family_name}->{merged_ft_file} = $family{$family_name}->{merged_file}.".ft";
	
	
	################################################################
	## Andrew Neuwald's Gibbs options and files
	my $gibbs_options = "";
	my $gibbs_suffix = "";
	
	## input file
	$family{$family_name}->{gibbs_input_seq_file} = $family{$family_name}->{input_seq_file}.".gibbs";
	$gibbs_options .= " ".$family{$family_name}->{gibbs_input_seq_file};
	
	## Matrix width
	$gibbs_options .= " ".$matrix_width;
	$gibbs_suffix .= "-L".$matrix_width;

	## Expected number of sites
	my $gene_nb = scalar(@{$family{$family_name}->{members}});
	warn join ("\t", "Number of genes", $family_name, $gene_nb), "\n";
	$expected_sites = $gene_nb*$expected_sites_per_gene;	
	$gibbs_options .= " ".$expected_sites;
	$gibbs_suffix .= "-n".$expected_sites; 

	## DON'T use fragmentation (i.e., column sampler)	
	$gibbs_options .= " -d";
	$gibbs_suffix .= "-d";

	## Use nucleic acid alphabet
	$gibbs_options .= " -n";
	$gibbs_suffix .= "-n";

	## Random seed
	if (defined($seed)) {
	    $gibbs_options .= " -s".$seed;
	    $gibbs_suffix .= "-s".$seed;
	}

	## Assign gibbs options to the family
	$family{$family_name}->{gibbs_suffix} = $gibbs_suffix;
	$family{$family_name}->{gibbs_options} = $gibbs_options;
	$family{$family_name}->{gibbs_dir} = "${family_name}/gibbs_${family_name}";
	$family{$family_name}->{gibbs_file} = $family{$family_name}->{gibbs_dir}."/".$family{$family_name}->{file_prefix}.$gibbs_suffix;

	################################################################
	## Gert Thijs' MoifSampler options and files
	my $MS_options = "";
	my $MS_suffix = "";

	$family{$family_name}->{MotifSampler_dir} = "${family_name}/MotifSampler_${family_name}";

	## input file
	$MS_options = " -f ".$family{$family_name}->{input_seq_file};

	## background model
	if ($MS_b) {
	    $MS_options .= " -b ".$MS_b;
	} else {
	    $family{$family_name}->{MotifSamplerBackground} = $dir{output}."/".$family{$family_name}->{input_seq_file}."_MotifSampler_bg".$MS_bg_order;
	    $MS_options .= " -b ".$family{$family_name}->{MotifSamplerBackground};
	}

	## strand
	if ($strand eq "-1str") {
	    $MS_options .= " -s 0";
	    $MS_suffix .= "-s0";
	} else {
	    $MS_options .= " -s 1";
	    $MS_suffix .= "-s1";
	}
	
	## prior
	$MS_options .= " -p ".$MS_p;
	$MS_suffix .= "-p".$MS_p;	 

	## Maximal number of motif instances per sequence. (default unset = 0)
	$MS_options .= " -M ".$MS_M;
	$MS_suffix .= "-M".$MS_M;	 
	
	## Sets number of different motifs to search for (default 4).
	$MS_options .= " -n ".$MS_n;
	$MS_suffix .= "-n".$MS_n;	 

	## Sets length of the motif (default 8).
	$MS_options .= " -w ".$matrix_width;
	$MS_suffix .= "-w".$matrix_width;	 

	## Sets allowed overlap between different motifs. (default 1)
	$MS_options .= " -x ".$MS_x;
	$MS_suffix .= "-x".$MS_x;	 

	## Set number of times the MotifSampler should be repeated
	$MS_options .= " -r ".$MS_r;
	$MS_suffix .= "-r".$MS_r;	 

	## output file
	$family{$family_name}->{MotifSampler_file} = $family{$family_name}->{MotifSampler_dir}."/".$family{$family_name}->{file_prefix}.$MS_suffix;
	$MS_options .= " -o ".$family{$family_name}->{MotifSampler_file}.".sites";
	$MS_options .= " -m ".$family{$family_name}->{MotifSampler_file}.".matrix";


	## Assign MotifSampler options to the family
	$family{$family_name}->{MotifSampler_suffix} = $MS_suffix;
	$family{$family_name}->{MotifSampler_options} = $MS_options;


	################################################################
	## MEME
	my $meme_options = "";
	my $meme_suffix = "";

	## input file
	$meme_options .= " ".$family{$family_name}->{input_seq_file};

	## Sequence type
	$meme_options .= " -dna";

	## Distribution
	$meme_options .= " -mod tcm";
	$meme_suffix .= "_tcm";

	## Matrix width
	$meme_options .= " -w ".$matrix_width;
	$meme_suffix .= "-w".$matrix_width;

	## strands
	$meme_suffix .= $strands;
	unless ($strands eq "-1str") {
	    $meme_options .= " -revcomp";
	}
	
	## Background frequencies
	$meme_path = "/Users/jvanheld/installers/MEME/meme.3.0.4";
#	$meme_path = "~nicolas/meme.3.0.4";
	$meme_bg_file = $meme_path."/tests/yeast.nc.3.freq";
	$meme_options .= " -bfile ".$meme_bg_file;

	## Output type
	$meme_options .= " -text";

	## Output file
	$family{$family_name}->{meme_dir} = "${family_name}/meme_${family_name}";
	$family{$family_name}->{meme_file} = $family{$family_name}->{meme_dir}."/".$family{$family_name}->{file_prefix}.$meme_suffix;
	$meme_options .= " > ".$family{$family_name}->{meme_file};
	
	$family{$family_name}->{meme_options} = $meme_options;
	$family{$family_name}->{meme_suffix} = $meme_suffix;

	
	################################################################
	## Consensus options and files
	my $consensus_options = "";
	my $consensus_suffix = "";
	
	## strands
	if ($strands eq "-1str") {
	    $consensus_options .= " -c0"; ## Single-strand search
	    $consensus_suffix .= "-c0";
	} else {
	    $consensus_options .= " -c2"; ## Double-strand search
	    $consensus_suffix .= "-c2";
	}
	
	## Matrix width
	$consensus_options .= " -L ".$matrix_width;
	$consensus_suffix .= "-L".$matrix_width;
	
	## alphabet
	$consensus_options .= " -A a:t 0.325 c:g 0.175";
	
	## Use designated prior frequencies
#    $consensus_options .= " -d"; 
	
	## Expected number of sites
	$consensus_options .= " -n ".$expected_sites;
	$consensus_suffix .= "-n".$expected_sites; 
	
	$family{$family_name}->{consensus_suffix} = $consensus_suffix;
	$family{$family_name}->{consensus_options} = $consensus_options;
	$family{$family_name}->{consensus_dir} = "${family_name}/consensus_${family_name}";
	$family{$family_name}->{consensus_file} = $family{$family_name}->{consensus_dir}."/".$family{$family_name}->{file_prefix}.$consensus_suffix;
	
	
    }  


    ################################################################
    ## Suffix for the synthetic table
    if ($family_file) {
	$table_suffix = $family_file;
    } elsif ($sequence_file_list) {
	$table_suffix .= $sequence_file_list;
	$table_suffix =~  s/\.tab$//;
	$table_suffix =~  s/\.txt$//;
    } else {
	$table_suffix = $organism_name;
    }
    if ($markov) {
	$table_suffix .= "_mkv${markov_order}";
    } elsif ($background) {
	$table_suffix .= "_bg_${background}";
    }

    if ($family_file) {
	$table_suffix .= "_up".$from     if (defined($from));
	$table_suffix .= "_".$to     if (defined($to));
	$table_suffix .= $noorf_string;
    }
    if ($analyze_purged_sequences) {
	$table_suffix .= "-purge";
    } else {
	$table_suffix .= "-nopurge";
    }
    $table_suffix .= "_".$min_oligo_len."nt";
    $table_suffix .= "_".$max_oligo_len."nt";
    $table_suffix .= $noov;
    $table_suffix .= $strands;
    $table_suffix .= "_sig".$thosig;
    $table_suffix = `basename $table_suffix`;
    chomp $table_suffix;

    ################################################################
    ## Name of the report for the Motif Discovery Competition 2004
    $dir{mdc_report} = "mdc_report";
    $outfile{results} = $dir{mdc_report}."/".$table_suffix."_results.txt";
    $outfile{parameters} = $dir{mdc_report}."/".$table_suffix."_parameters.txt";
}

################### SUBROUTINE DEFINITION ###################"


################################################################
#### retrieve upstream sequences
sub UpstreamSequences {
   warn ";\tRetrieving upstream sequences for family $family_name\n" if ($verbose >= 1);
   $command = "retrieve-seq -type upstream -org $organism_name";
   $command .= " -noorf " if ($noorf);
   $command .= " -i $family{$family_name}->{family_file}";
   $command .= " -o $family{$family_name}->{seq_file}";
   $command .= " -from $from" if (defined($from));
   $command .= " -to $to " if (defined($to));
   $command .= " -label orf_gene ";
   $command .= " -feattype $feature_types " if ($feature_types);
   $command .= " -format $seq_format";
   &doit($command,$dry_run, $die_on_error);
}

################################################################
#### Purge input sequences
sub PurgeSequences {
   warn ";\tPurging sequences for family $family_name\n" if ($verbose >= 1);
   $command = "purge-sequence -ml 40 -mis 3";
   $command .= " -i $family{$family_name}->{seq_file}";
   $command .= " > $family{$family_name}->{seq_file_purged}";
   &doit($command,$dry_run, $die_on_error);
}


################################################################
### Calculate options and file names according to the selected
### parameters
sub CalcOligoOptions {
   my ($oligo_len) = @_;
   $oligo_options = "-v ";
   $oligo_options .= " -pseudo ".$pseudo if ($pseudo);
   $oligo_options .= " -sort ";
   $oligo_options .= " ".$strands;
   $oligo_options .= " -l ".$oligo_len;
   $oligo_options .= " -thosig ".$thosig;
   
   if ($markov) {
	### Markov chain model
	$oligo_options .= " -markov ".$markov_order;
	
   } elsif ($exp_freq_file{oligos}) {
	### Manually specified calibrated frequencies
	$oligo_options .= " -expfreq ".$exp_freq_file{oligos};
	
   } elsif ($background eq "calib1") {
	### Single-sequence based calibrated occurrences (mean and var per sequence)
	my $calib_length = $family{$family_name}->{calib_length};
	my $calib_file = &CalibrationPrefix($calib_length, $oligo_len);
	$calib_file .= "_negbin.tab";
	### Check whether the calibration file exists
	unless ((-e $calib_file) || (-e $calib_file.".gz")) {
	    &FatalError ("Calibration file not found\t".$calib.file);
	}
	$oligo_options .= " -calib1 ".$calib_file;
	warn join ("\t", "; Oligonucleotide calibration", $calib_length, $calib_file), "\n" if ($main::verbose >= 3);
	
   } elsif ($background eq "calibN") {
	### Set-based calibrated occurrences (mean and var per set of N sequences)
	my $calib_length = $family{$family_name}->{calib_length};
	my $N = scalar(@{$family{$family_name}->{members}});
	my $calib_file = &CalibrationPrefix($calib_length, $oligo_len, $N);
	$calib_file .= "_negbin.tab";
	
	### Check whether the calibration file exists
	unless ((-e $calib_file) || (-e $calib_file.".gz")) {
	    ### temporary: if there is no R10000 file, try R1000
	    $calib_file =~ s/10000/1000/g;
	    if ((-e $calib_file) || (-e $calib_file.".gz")) {
		&Warning("Using calibration with 1000 repetitions\t".$calib_file);
	    } else {
		### temporary: if there is no R1000 file, try R100
		$calib_file =~ s/1000/100/g;
		if ((-e $calib_file) || (-e $calib_file.".gz")) {
		    &Warning("Using calibration with 1000 repetitions\t".$calib_file);
		    
		} else {
		    &FatalError ("Calibration file not found\t".$calib_file);
		}
	    }
	}
	
	$oligo_options .= " -calibN ".$calib_file;
	warn join ("\t", "; Oligonucleotide calibration", $calib_length, $calib_file), "\n" if ($main::verbose >= 3);
	
   } else {
	### Pre-calculated expected frequenccy files
	$oligo_options .= " -org ".$organism_name;
	$oligo_options .= " -bg ".$background;
	
   }
   $oligo_options .= " -return occ,proba,mseq,rank";
   $oligo_options .= " ".$noov;
   
   $oligo_suffix = "_oligos";
   $oligo_suffix .= "_${oligo_len}nt";
   $oligo_suffix .= $strands;
   $oligo_suffix .= "_sig${thosig}";
   $oligo_suffix .= $noov;
   
   $oligo_file = "$family_name/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix;    
   $command = "oligo-analysis -i $family{$family_name}->{input_seq_file} -format $seq_format -o $oligo_file $oligo_options";

   return ($command, $oligo_file, $oligo_suffix, $oligo_options);
}


################################################################
### oligo-analysis
sub OligoAnalysis {
   warn join ("\t", 
	       ";\tAnalyzing oligonucleotides for family $family_name",
	       "min len: $min_oligo_len",
	       "max len: $max_oligo_len"), "\n" if ($verbose >= 1);
   my $dir = "${family_name}/oligos_${family_name}";
   
   &CheckOutDir($dir);
   die "Error : cannot read file $family{$family_name}->{input_seq_file}\n" unless (-r $family{$family_name}->{input_seq_file});
   
   ## initialize the oligo file
#    system "echo '' > $family{$family_name}->{oligo_file}"; # if ($verbose >=1);
   
   ## Analyze all oligo lengths
   for $oligo_len ($min_oligo_len..$max_oligo_len) {
	&CalcOligoOptions($oligo_len);
	&doit($command,$dry_run, $die_on_error);
#	system "cat $oligo_file >> $family{$family_name}->{oligo_file}";
   }

   ## Merge the results obtained with diffferent oligo lengths
   &MergeOligoLengths();
}

################################################################
### Merge the results of oligo-analysis for different oligo lengths
sub MergeOligoLengths {
   warn join ("\t", 
	       ";\tMerging oligonucleotides for family ".$family_name,
	       "min len: ".$min_oligo_len,
	       "max len:".$max_oligo_len,
	       $family{$family_name}->{oligo_file}), "\n" if ($verbose >= 1);
   my $dir = "${family_name}/oligos_${family_name}";

   &CheckOutDir($dir);
   die "Error : cannot read file $family{$family_name}->{input_seq_file}\n" unless (-r $family{$family_name}->{input_seq_file});
   
   ## initialize the oligo file
   system "echo '' > $family{$family_name}->{oligo_file}"; # if ($verbose >=1);    
   for $oligo_len ($min_oligo_len..$max_oligo_len) {
	($command, $oligo_file) = &CalcOligoOptions($oligo_len);
	system "cat $oligo_file >> $family{$family_name}->{oligo_file}";
   }
   
   ### fragment assembly
   $command = "pattern-assembly -i $family{$family_name}->{oligo_file} ${strands} -v -o $family{$family_name}->{oligo_assembly_file} -maxfl 1 -maxpat 200 -subst 1";
   
   &doit($command,$dry_run, 0);
}


################################################################
## Match discovered patterns
sub MatchPatterns {
   my ($oligo_file, $fmap_prefix, $options) = @_;

   ## check file names
   $oligo_file = $family{$family_name}->{oligo_file} unless ($oligo_file);
   $fmap_prefix = $oligo_file unless ($fmap_prefix);

   ### pattern matching
   die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
   $feature_file = $fmap_prefix.".ft";
   $fmap_file = $fmap_prefix.".".$IMG_FORMAT;
   $htmap_file = $fmap_prefix.".html";
   warn( ";\tDrawing feature-map",
	  "\n;\t", $oligo_file,
	  "\n;\t", $fmap_file,
	  "\n")  if ($main::verbose >= 1);
   
   $origin = "-0";
   my $command = "dna-pattern -i ".$family{$family_name}->{seq_file};
   $command .= " -format ".$seq_format;
   $command .= " -pl ".$oligo_file;
   $command .= " -origin ".$origin;
   $command .= $options;
   $command .= " | features-from-dnapat -o ".$feature_file;

   ## Check if pattern matching is OK (sometimes there are no patterns)
   my $error = &doit($command,$dry_run, 0);
   if ($error) {
	warn "; WARNING: Feature map skipped because dna-pattern returned an error\n";
	return;
   }
}

################################################################
#### draw feature-map for the result of oligo-analysis
sub DrawFeatureMap {
   my ($fmap_prefix, $title, $options) = @_;

   ## check file names
   $fmap_prefix = $family{$family_name}->{oligo_ft_prefix} unless ($fmap_prefix);
   $title = $fmap_prefix unless ($title);

   ### pattern matching
   die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
   $feature_file = $fmap_prefix.".ft";
   $fmap_file = $fmap_prefix.".".$IMG_FORMAT;
   $htmap_file = $fmap_prefix.".html";
   warn( ";\tDrawing feature-map",
	  "\n;\t", $oligo_file,
	  "\n;\t", $fmap_file,
	  "\n")  if ($main::verbose >= 1);
   

   ## feature-map drawing
   if ($family{$family_name}->{calib_length}) {
	$from = -$family{$family_name}->{calib_length};
	$to = -1;
   }
   $command = "feature-map -i ".$feature_file;
   $command .= " -minfthick 2";
   $command .= " -scalebar -scalestep $scalestep -legend ";
   $command .= " -title '".$title."'";
   $command .= " -from $from" if (defined($from));
   $command .= " -to $to" if (defined($to));
   $command .= " -o $fmap_file -scorethick ";
   $command .= " ".$options;
   if ($htmaps) {
	$command .= " -htmap > $htmap_file ";
   };
   
   &doit($command,$dry_run, 0);
}

################################################################
### dyad analysis
sub DyadAnalysis {
   warn join( "\t", 
	       ";\tAnalyzing dyads for family $family_name",
	       "monad length: $monad_length",
	       "min_sp: $min_sp",
	       "max_sp: $max_sp",
	       ), "\n" if ($verbose >= 1);
   $dir = "${family_name}/dyads_${family_name}";
   &CheckOutDir($dir);
   die "Error : cannot read file $family{$family_name}->{input_seq_file}\n" unless (-r $family{$family_name}->{input_seq_file});
   $command = "dyad-analysis -return occ,proba,rank -i $family{$family_name}->{input_seq_file} -format $seq_format -o $family{$family_name}->{dyad_file} $dyad_options";
   
   &doit($command,$dry_run, $die_on_error);
   
   ### fragment assembly
   $command = "pattern-assembly -v -i $family{$family_name}->{dyad_file} -o $family{$family_name}->{dyad_assembly_file} ${strands} -maxfl 1 -maxpat 200 ";
   
   &doit($command,$dry_run, 0);
   
}


################################################################
## Merge patterns detected by oligo-analysis and dyad-analysis
sub MergePatterns {
   my $filter_dyads = 1;
   warn join ("\t", 
	       ";\tMerging oligonucleotides and dyads for family ",
	       $family_name,
	       $family{$family_name}->{merged_file}
	       ), "\n" if ($verbose >= 1);

   my $dir = "${family_name}/merged_${family_name}";
   &CheckOutDir($dir);
   my $command = "cat $family{$family_name}->{oligo_file}";
#    $command .= " | grep -v '^;'";
   $command .= " > $family{$family_name}->{merged_file};";
   $command .= " cat $family{$family_name}->{dyad_file}";
#    $command .= " | grep -v '^;'";
   if ($filter_dyads) {
	$command .= " | grep -v '\{0\}'";
   } else {
	$command .= " | perl -pe 's/n\{0\}//g'";
   }
   $command .= " >> $family{$family_name}->{merged_file};";
   $command .= " wc $family{$family_name}->{merged_file}";
   &doit($command,$dry_run, $die_on_error);
   &DrawMergedFeatureMap() if ($task{map});
}


################################################################
#### draw feature-map for the result of merged oligonucleotides and dyads
sub DrawMergedFeatureMap {
   warn ";\tDrawing feature-map with results of merged oligonucleotides and dyads for family $family_name\n" if ($verbose >= 1);
   ### pattern matching
   die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
   $fmap_file = $family{$family_name}->{merged_file}.".${IMG_FORMAT}";
   $htmap_file = $family{$family_name}->{merged_file}.".html";
   $origin = "-0";
   my $command = "dna-pattern -i $family{$family_name}->{seq_file} -format $seq_format -pl $family{$family_name}->{merged_file} -origin $origin -N 4 ";
   $command .= " | features-from-dnapat -o $family{$family_name}->{merged_ft_file} ";
   my $error = &doit($command,$dry_run, 0);
   if ($error) {
	warn "; WARNING: Feature map skipped because dna-pattern returned an error\n";
	return;
   }

   ## feature-map drawing
   if  ($family{$family_name}->{calib_length}) {
	$from =  $family{$family_name}->{calib_length};
	$to = -1;
   }
   $command = " feature-map -i $family{$family_name}->{merged_ft_file} -scalebar -scalestep $scalestep -legend ";
   $command .= " -title $family{$family_name}->{merged_ft_file}";
   $command .= " -from $from" if (defined($from));
   $command .= " -to $to" if (defined($to));
   $command .= " -o $fmap_file -scorethick ";
   if ($htmaps) {
	$command .= " -htmap > $htmap_file ";
   };
   
   &doit($command,$dry_run, 0);
}


################################################################
## Run Gert Thijs' MotifSampler
sub MotifSampler {
   warn join ("; Running MotifSampler for family $family_name") if ($main::verbose >= 1);
   ## Check output directory
   my $dir = $family{$family_name}->{MotifSampler_dir};
   &CheckOutDir($dir);

   chdir($dir{output});

#   ## Create ackground model if required
#   unless ($MS_b) {
#	warn "; Creating background model for the input sequence\torder ".$MS_bg_order."\n" 
#	    if ($main::verbose >= 1);
#	## create bacakground model
#	my $command = " CreateBackgroundModel -f ".$family{$family_name}->{input_seq_file};
#	$command .= " -b ".$family{$family_name}->{MotifSamplerBackground};
#	$command .= " -o ".$MS_bg_order;
#	&doit($command,$dry_run, $die_on_error);
#   }

   ## run the command
   my $MS_command = "MotifSampler ".$family{$family_name}->{MotifSampler_options};
#   $MS_command .= " > ".$family{$family_name}->{MotifSampler_file};
#    unless ($main::verbose >= 4) {
#	$MS_command .= ">& /dev/null";
#    }
   &doit($MS_command, $dry_run, $die_on_error);

}


################################################################
## Run Andrew Neuwald's gibbs program 
sub Gibbs {
   chdir($dir{output});
   &CheckOutDir($family{$family_name}->{gibbs_dir});


   if ($strand = "-2str") {
	$addrc = " -addrc";
   }
   ## This can be useful in case the file is compressed
   my $gibbs_command = "convert-seq ".$addrc;
   $gibbs_command .= " -from fasta -to fasta ";
   $gibbs_command .= " -i ".$family{$family_name}->{input_seq_file};
   $gibbs_command .= " -o ".$family{$family_name}->{gibbs_input_seq_file};


   ## run the command
   $gibbs_command .= " ; gibbs ".$family{$family_name}->{gibbs_options};
   $gibbs_command .= " > ".$family{$family_name}->{gibbs_file};
#    unless ($main::verbose >= 4) {
#	$gibbs_command .= ">& /dev/null";
#    }
   &doit($gibbs_command, $dry_run, $die_on_error);
}

################################################################
## Run MEME program 
sub MEME {
   &CheckOutDir($family{$family_name}->{meme_dir});
   chdir($dir{output});

   ## run the command
   $meme_command = "meme ".$family{$family_name}->{meme_options};
   &doit($meme_command, $dry_run, 0);
}

################################################################
## Run Jerry Hertz' consensus program 
sub Consensus {
   chdir($dir{output});
   &CheckOutDir($family{$family_name}->{consensus_dir});

   ## input file has to be converted to consensus format
   $consensus_command = "convert-seq -dna -from fasta -to wc -i ".$family{$family_name}->{input_seq_file};

   ## run the command
   $consensus_command .= " | consensus ".$family{$family_name}->{consensus_options};
   $consensus_command .= " > ".$family{$family_name}->{consensus_file};
   &doit($consensus_command, $dry_run, 0);
}

################################################################
### Read known known_site for each family
sub ReadKnownSites {
   my ($known_site_file) = @_;
   %known_site = ();
   %known_site_source = ();
   if (-e $known_site_file) {
	$known_sites_provided = 1;
	open KNOWN_SITE, $known_site_file;
	while (<KNOWN_SITE>) {
	    next if (/^;/);
	    next if (/^\#/);
	    next unless (/\S/);
	    chomp;
	    @fields = split "\t";
	    $family_name = $fields[0];
	    $known_site = uc($fields[1]);
	    $source = $fields[2];
	    #$known_site = uc(&compress_pattern($known_site,"n"));
	    $known_site =~ s/N/n/g;
	    push @{$known_site{$family_name}}, $known_site;
	    push @{$known_site_source{$family_name}}, $source;
	}
	close KNOWN_SITE;
   }
}


#  ################################################################
#  ## Read known sites from a tab-delimited file
#  ## Obsolete : has been replaced by ReadKnownSites
#  sub ReadSiteLibrary {
#      my ($library_file) = @_;
#      @site_library = ();
#      if (-e $library_file) {
#  	open LIBRARY, $library_file;
#  	while (<LIBRARY>) {
#  	    next if (/^;/);
#  	    next if (/^\#/);
#  	    next unless (/\S/);
#  	    chomp;
#  	    my @fields = split "\t";
#  	    my $source = $fields[2] || $library_file;
#  	    my $id = uc($fields[1]);
#  	    my $sequence = uc($fields[0]);
#  	    $sequence =~ s/N/n/g;
	    
#  	    $pattern = RSAT::pattern->new(id=>$id,
#  					 sequence=>$sequence,
#  					 source=>source);
#  	    push @site_library, $pattern;
#  	}
#  	close LIBRARY;
#      }
#  }


################################################################
### Generate a synthetic table
sub SyntheticTable {
   my $dir = "synthetic_tables";
   
   $outfile{table} = $dir."/".$table_suffix;
   $outfile{table} .= "_tr" if ($transpose);
   $outfile{table} .= ".html";

   warn "; Generating synthetic table ", $outfile{table}, "\n" if ($verbose >= 1);
   
   unless (-d $dir) {
	mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
   }
   
   ### synthesize the results of all families into a single file
   
   ### headers
   $row = 0;
   $row{f} = $row++;
   $row{family} = $row++;
   $row{size} = $row++;
   $row{genes} = $row++;
   $row{total_length} = $row++ if ($seq_length_calculated);
   $row{known} = $row++ if ($known_sites_provided);
   $row{oligos} = $row++;
   $row{dyads} = $row++;
   $row{selection} = $row++ if ($task{report});
   $row{consensus} = $row++;
   $row{gibbs} = $row++;
   $row_num = $row-1;
   while (($header,$row) = each %row) {
	$table[$row][0] = "<B>$header</B>";
   }
   my $col = 0;
   
   foreach $family_name (@families) {
	$col++;
	
	#### Index columns associated to each family
	$column{$family_name} = $col;
	
	### check directory
	$dir = "${family_name}/dyads_${family_name}";
	unless (-d $dir) {
	    &Warning ("Cannot find directory $dir\n");
	}
	
	### family number
	$table[$row{f}][$col] = "<B>$col</B>";
	
	### family name
	$table[$row{family}][$col] = "<B><a href='../".$family_name."'>".$family_name."</a></B>";
	
	#### number of genes
	$table[$row{size}][$col] = scalar(@{$family{$family_name}->{members}});
	
	#### sequence length
	$table[$row{total_length}][$col] = $family{$family_name}->{total_length} if ($seq_length_calculated);
	
	### list of genes
	$table[$row{genes}][$col] = "<a href='../".$family{$family_name}->{family_file}."'>";
	$table[$row{genes}][$col] .= join " ", @{$family{$family_name}->{members}};
	$table[$row{genes}][$col] .= "</a>";
	
	### known patterns
	if ($known_sites_provided) {
	    $table[$row{known}][$col] = "";
	    for $c (0..$#{$known_site{$family_name}}) {
		$table[$row{known}][$col] .= "${known_site{$family_name}}[$c]";
		$table[$row{known}][$col] .= "<BR>("."${known_site_source{$family_name}}[$c]".")" if ("${known_site_source{$family_name}}[$c]");
		$table[$row{known}][$col] .= "<P>";
	    }
	} 
	
       ################################################################
	#### Index results from oligo-analysis
#	open OLIGOS, "$family{$family_name}->{oligo_assembly_file}";
       if ($htmaps) {
	    $map_link = "../$family{$family_name}->{oligo_file}.html";
       } else {
	    $map_link = "../$family{$family_name}->{oligo_file}.${IMG_FORMAT}";
       }
       my $pattern_file = $family{$family_name}->{oligo_assembly_file};
       &IndexPatterns($family_name, $pattern_file, $map_link, $row{oligos}, $col, assembly=>1);
	
       ################################################################
	### index results of dyad analysis
       if ($htmaps) {
	    $map_link = "../$family{$family_name}->{dyad_file}.html";
       } else {
	    $map_link = "../$family{$family_name}->{dyad_file}.${IMG_FORMAT}";
       }
       my $pattern_file = $family{$family_name}->{dyad_assembly_file};
       &IndexPatterns($family_name, $pattern_file, $map_link, $row{dyads}, $col, assembly=>1);
	
       ################################################################
	### index results of manual pattern selection
	if ($task{report}) {
	    if ($htmaps) {
		$map_link = "../$family{$family_name}->{oligo_selection}.html";
	    } else {
		$map_link = "../$family{$family_name}->{oligo_selection}.${IMG_FORMAT}";
	    }
	    my $pattern_file = $family{$family_name}->{oligo_selection};
	    &IndexPatterns($family_name, $pattern_file, $map_link, $row{selection}, $col, assembly=>0);
	}

	################################################################
	#### Index results of consensus
#	if ($htmaps) {
#	    $map_link = "../$family{$family_name}->{consensus_file}.html";
#	} else {
#	    $map_link = "../$family{$family_name}->{consensus_file}.${IMG_FORMAT}";
#	}
	$map_link = "../$family{$family_name}->{consensus_file}\n";
	&IndexConsensus($family_name,  $family{$family_name}->{consensus_file}, $map_link, $row{consensus}, $col);

	################################################################
	#### Index results of gibbs
#	if ($htmaps) {
#	    $map_link = "../$family{$family_name}->{gibbs_file}.html";
#	} else {
#	    $map_link = "../$family{$family_name}->{gibbs_file}.${IMG_FORMAT}";
#	}
	$map_link = "../$family{$family_name}->{gibbs_file}";
	&IndexGibbs($family_name,  $family{$family_name}->{gibbs_file}, $map_link, $row{gibbs}, $col);
   }
   

   ###############################################################
   ## Print the header of the  synthetic table
   $syn = &OpenOutputFile($outfile{table});
   print $syn "<html>\n";
   print $syn "<title>",$table_suffix, "</title>","\n";
   print $syn "<body>\n";
   print $syn "<h1>".$table_suffix."</h1>\n";
   
   print $syn join( "\n",
		      "<pre>",
		      $verbose_message,
		      "</pre>"
		      ), "\n";
   
   
   print $syn "<table border=1>\n";

   ################################################################
   ## Add a link to the MDC report files
#    if ($task{report}) {
	print $syn "<h4>Reports for the motif discovery competition</h4>";
	print $syn "<ul>";
	print $syn "<li><a href=../".$outfile{results}.">Results</a></li>";
	print $syn "<li><a href=../".$outfile{parameters}.">Parameters</a></li>";
	print $syn "</ul>";
#    }


   ################################################################
   ## Sort families according to the selected criterion
   if ($sort_key eq "score") {
	#### sort families by score
	#### decreasing order
	@sorted_families = sort {$max_score{$b} <=> $max_score{$a}} @families; 

   } else {
	#### sort families by family name
	@sorted_families = sort @families;
   }


   ################################################################
   ## Transpose the result table
   if ($transpose) {
	foreach $r (0..$row_num) {
	    print $syn "<tr valign=top>\n";
	    foreach $f (@sorted_families) {
		my $c = $column{$f};
		print $syn "<td>", $table[$r][$c], "</td>\n";
	    }
	    print $syn "</tr>\n";
	}
   } else {
	#### print table header
	foreach $r (0..$row_num) {
	    print $syn "<th>", $table[$r][0], "</th>\n";
	}
	#### print table content
	foreach $f (@sorted_families) {
	    my $c = $column{$f};
	    print $syn "<tr valign=top>\n";
	    foreach $r (0..$row_num) {
		print $syn "<td>", $table[$r][$c], "</td>\n";
	    }
	    print $syn "</tr>\n";
	}
   }
   
   print $syn "</table>\n";
   print $syn "<hr>", &AlphaDate;
   print $syn "</body>\n";
   print $syn "</html>\n";
   close $syn;
#    chdir "synthetic_tables";
#    chdir "../";
}




################################################################
## Index the matrix from a consensus file
sub IndexConsensus {
   &IndexMatrix(@_, format=>"consensus");
}

################################################################
## Index a matrix
sub IndexMatrix {
   my ($family_name, $consensus_file, $map_link, $row, $col, %args) = @_;
   my $format = $args{format};
   my @attributes = ();
#     if ($format eq "consensus") {
#         push @attributes, qw (unadjusted.information
#  			     adjusted.information
#  			     Pval
#  			     ln.Pval
#  			     exp
#  			     ln.exp
#  			     );
#     } elsif ($format eq "gibbs") {
#         push @attributes, qw (
#  			     model.map
#  			     betaprior.map
#  			     MAP
#  			     seed
#  			     );
#     } else {
#         &FatalError("Invalid format for a matrix $format");
#     }
   warn join ("\t", "; Indexing $format matrix for family", $family_name, $consensus_file, $row, $col), "\n" if ($verbose >= 2);
   my $matrix = new RSAT::matrix();
   my $matrix_result = "";

   ## This piece of code has to be evaluated because it can raise an
   ## error, if the output file does not contain any matrix. This is
   ## the case for some output files of consensus, due to a bug.
   eval {
       $matrix->readFromFile($consensus_file, $format);
       $matrix->calcConsensus();
       $matrix->calcInformation();
       $matrix_result = $matrix->toString(sep=>" ", col_width=>4, type=>"alignment");
       $matrix_result .= $matrix->toString(sep=>" ", col_width=>4, type=>"parameters");
   };
   if ($@) {
       $matrix_result = "<font color=red>No matrix could be found in the output file</font>";
       &Warning("No matrix found. Skipped.");
   }
   $table[$row][$col] = "<a href=".$map_link.">Results</a>\n";
   $table[$row][$col] .= "<table cellpadding=3>\n";
   $table[$row][$col] .= "<TR>\n";
   $table[$row][$col] .= "<td colspan=2><pre>";
   $table[$row][$col] .= $matrix_result;
   $table[$row][$col] .= "</pre></td>\n";
   $table[$row][$col] .= "</TR>\n";
   $table[$row][$col] .= "</table>\n";
}

################################################################
## Index the matrix from a gibbs file
sub IndexGibbs {
   &IndexMatrix(@_, format=>"gibbs");
#      my ($family_name, $gibbs_file, $map_link, $row, $col, %args) = @_;
#      warn join ("\t", "; Indexing gibbs matrix for family", $family_name, $gibbs_file, $row, $col), "\n" if ($verbose >= 2);
#      my $matrix = new RSAT::matrix();
#      $matrix->readFromFile($gibbs_file, "gibbs");
#      $table[$row][$col] = "<table cellpadding=3>\n";
#      $table[$row][$col] .= "<TR>\n";
#      $table[$row][$col] .= "<td colspan=2><pre>".$matrix->toString(" ", 4)."</pre></td>\n";
#      $table[$row][$col] .= "</TR>\n";

#      $table[$row][$col] .= "<tr><td align=right>unadjusted.information</td><td>".$matrix->get_attribute("unadjusted.information")."</td></tr>\n";
#      $table[$row][$col] .= "<tr><td align=right>adjusted.information</td><td>".$matrix->get_attribute("adjusted.information")."</td></tr>\n";
#      $table[$row][$col] .= "<tr><td align=right>Pval</td><td>".$matrix->get_attribute("Pval")."</td></tr>\n";
#      $table[$row][$col] .= "<tr><td align=right>ln.Pval</td><td>".$matrix->get_attribute("ln.Pval")."</td></tr>\n";
#      $table[$row][$col] .= "<tr><td align=right>exp</td><td>".$matrix->get_attribute("exp")."</td></tr>\n";
#      $table[$row][$col] .= "<tr><td align=right>ln.exp</td><td>".$matrix->get_attribute("ln.exp")."</td></tr>\n";
#      $table[$row][$col] .= "</table>\n";
}




################################################################
## Index the patterns discovered for the HTML synthetic table
sub IndexPatterns {
   my ($family_name, $pattern_file, $map_link, $row, $col, %args) = @_;
   warn join ("\t", "; Indexing patterns for family", $family_name, $pattern_file), "\n" if ($verbose >= 2);
   undef @patterns;
   undef @sorted_patterns;
   undef %rc;
   undef %score;
   undef %type;

   ## read the patterns
   if (-e $pattern_file) {
	if ($args{assembly}) {
	    ## Parse an assembly file (only retain contigs and isolated)
	    ($error, @patterns) = &ReadAssemblyFile($pattern_file);
	} else {
	    ## Parse a pattern file (retain all patterns)
	    @patterns = &ReadPatterns(pattern_file=>$pattern_file);
	}
   } else {
	$table[$row][$col] = "<font color=red>File not found</font>\n";
	$pwd = `pwd`;
	&Warning(join ( "\t", 
			$pwd,
			"Family $family_name",  
			"pattern file ", 
			$pattern_file, 
			" does not exist. Skipped.",
			));
	return;
   }
   
   if ($error) {
	$table[$row][$col] = "<font color=red>$error</font>\n";
   } else {
	@sorted_patterns = sort { $score{$b} <=> $score{$a} } @patterns;
	$table[$row][$col] = "<table>\n";
	$table[$row][$col] .="<tr><td align=right>max.score</td><td>".$max_score{$family_name}."</td></tr>\n";
	$table[$row][$col] .="</table>\n";
	$table[$row][$col] .= "<table>\n";
	$table[$row][$col] .= "<TR>\n";
	
	### print oligo sequence
	$table[$row][$col] .= "<TD>\n";
	for $p (@sorted_patterns) {
	    $table[$row][$col] .= "<B>" if ($p->get_attribute("score") >= 1);
	    my $sequence = $p->get_attribute("sequence"); 
	    $compressed = &compress_pattern($sequence, "n");
	    $compressed =~ s/N/n/g;
	    $table[$row][$col] .= $compressed;
	    $table[$row][$col] .= "</B>" if ($p->get_attribute("score") >= 1);
	    $table[$row][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row][$col] .= "</TD>\n";
	
	### print reverse complementary oligo
	if ($strands eq "-2str") {
	    $table[$row][$col] .= "<TD>\n";
	    for $p (@sorted_patterns) {
		$table[$row][$col] .= "<B>" if ($p->get_attribute("score") >= 1);
#		my $sequence =  $p->get_attribute("rc");
		my $rc =  &SmartRC($p->get_attribute("sequence"));
		$compressed = &compress_pattern($rc, "n");
		$compressed =~ s/N/n/g;
		$table[$row][$col] .= $compressed;
		$table[$row][$col] .= "</B>" if ($p->get_attribute("score") >= 1);
		$table[$row][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row][$col] .= "</TD>\n";
	}
	
	### print pattern scores
	$table[$row][$col] .= "<TD><a target=_blank href=".$map_link.">\n";
	for $p (@sorted_patterns) {
	    $table[$row][$col] .= "<B>" if ($p->get_attribute("score") >= 1);
	    $table[$row][$col] .= $p->get_attribute("score");
	    $table[$row][$col] .= "</B>" if ($p->get_attribute("score") >= 1);
	    $table[$row][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row][$col] .= "</A></TD>\n";

	
	
	### print matching patterns
	if ($known_sites_provided) {
	    $table[$row][$col] .= "<TD>\n";
	    for $p (@sorted_patterns) {
		my @matches = ();
		foreach $site (@site_library) {
		    if (($p->contains($site, min_score=>$min_matching_score)) ||
			($site->contains($p->get_attribute("sequence"), min_score=>$min_matching_score))) {
			#my $match = $site->get_attribute("sequence");
			my $match = $site->get_id();
			push @matches, $match;
		    }
		}
		$table[$row][$col] .= join(";",@matches);
		$table[$row][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row][$col] .= "</TD>\n";
	}
	
	$table[$row][$col] .= "</TR>\n";
	$table[$row][$col] .= "</TABLE>\n";




#	    close $olig;
   }
}

################################################################
#### Draw feature maps
sub DrawDyadFeatureMap {
   warn ";\tDrawing feature-map with results of dyad-analysis for family $family_name\n" if ($verbose >= 1);
   die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});

   ## pattern matching
   $origin = "-0";
   my $command = "dna-pattern -pl $family{$family_name}->{dyad_file} -format $seq_format -i $family{$family_name}->{seq_file} -origin $origin -N 4 ";
   $command .= "| features-from-dnapat -o $family{$family_name}->{dyad_ft_file} ";
   my $error = &doit($command,$dry_run, 0);
   if ($error) {
	warn "; WARNING: Feature map skipped because dna-pattern returned an error\n";
	return;
   }

   ## feature-map drawing
   $command = "feature-map -i $family{$family_name}->{dyad_ft_file} -o $family{$family_name}->{fmap_file} ";;
   $command .= " -from $from" if (defined($from));
   $command .= " -to $to " if (defined($to));
   $command .= "-legend ";
   $command .= "-scalebar -scalestep $scalestep ";
   $command .= "-scorethick ";
   $command .= "-mlen 520 ";
   $command .= "-title '${family_name}$dyad_suffix' ";
   if ($htmaps) {
	$command .= "-htmap >  $family{$family_name}->{htmap_file}";
   }
   #  $command .= " ;  xv -o $family{$family_name}->{fmap_file} &";
   &doit($command,$dry_run, 0);
}


################################################################
#### check parameters
sub CheckParameters {

   #### accepted feature types
   unless (defined %accepted_feature_types) {
	$accepted_feature_types{cds} = 1;
   }
   $feature_types = join ",", keys (%accepted_feature_types);


   #### check selected tasks
   unless (defined(%task)) {
	&FatalError("You should select at least one task.");
   }
   if ($task{all}) {
	foreach my $t (@supported_tasks) {
	    $task{$t} = 1;
	}
	unless ($draw_maps) {
	    $task{maps} = 0;
	    $task{oligo_maps} = 0;
	    $task{dyad_maps} = 0;
	}
   }
   if ($task{maps}) {
	$task{oligo_maps} = 1;
	$task{dyad_maps} = 1;
   }
   
   
   ### family file ###
   unless (($family_file) || ($sequence_file_list)) {
	die "Error: you should specify either a family file or a sequence file list\n";  
   } 
   
   ### organism ###
   unless ($organism_name) {
	die "Error: you should specify an organism\n$supported_organisms\n";  
   } 
   unless ($supported_organism{$organism_name}) {
	die ("Error: organism $organism_name is not supported\n",
	     "Supported organisms:\n$supported_organisms\n");
   }

   
#    $from = $default{from} unless defined($from);
#    $to = $default{to} unless defined($to);

   $from = $supported_organism{$organism_name}->{'up_from'}  unless defined($from);
   $to = $supported_organism{$organism_name}->{'up_to'}  unless defined($to);

   $seq_length = abs($to - $from) + 1;
   $dyad_type = "any" unless ($dyad_type);

   if (defined($force{strands})) {
	$strands = $force{strands}; ### force
   } else {
	$strands = "-2str";
   }
   if (defined($force{exp})) {
	$exp = $force{exp}; ### force
   }
   if (&IsReal($force{th})) {
	$thosig = $force{th}; ### force
   } elsif ($#families > 0) {
	$thosig = &round(10*abs(log($#families + 1)/log(10)))/10;
   } else {
	$thosig = 0;
   } 
}


################################################################
## Analyze all the families    
sub AnalyzeFamilies {
   my $fam_count=0;
   my $fam_nb = $#families+1;

   ### Calibrate oligonucleotides for each sequence length
   if (($task{calibrate}) || 
	($sequence_file_list) ||
	($background eq "calib1") ||
	($background eq "calibN")
	) {
	my @calib_lengths = &CalcCalibrationLengths();
	&CalibrateOligos(@calib_lengths) if ($task{calibrate});
#    } else {
#	foreach $family_name (@families) {
#	    $family{$family_name}->{seq_length} = $seq_length*scalar(@{$family{$family_name}->{members}});
#	}
	$seq_length_calculated = 1;
   }

   foreach $family_name (@families) {
	$fam_count++;
	if ($fam_count <= $skip) {
	    warn "; Skipping family\t$fam_count\t$family_name\n" if ($main::verbose >= 1);
	    next;
	}

	warn ";\n; Treating family $family_name ($fam_count of $fam_nb)\t", `date` if ($verbose >=1);
	
	### retrieve upstream sequences of the family
	&UpstreamSequences() if ($task{upstream});

	### purge upstream sequences of the family
	&PurgeSequences() if ($task{purge});
	
	### oligo-analysis
	if ($task{oligos}) {
	    &OligoAnalysis();
	} elsif ($task{merge_oligos}) {
	    &MergeOligoLengths();
	}

	### oligo feature-maps
	if ($task{oligo_maps}) {
	    &MatchPatterns($family{$family_name}->{oligo_file},  
			   $family{$family_name}->{oligo_file},
			   " -N 4");
	    &DrawFeatureMap();
	}

	### dyad analysis
	&DyadAnalysis() if ($task{dyads});

	### dyad feature-maps
	&DrawDyadFeatureMap() if ($task{dyad_maps});
	
	### Jerry Hertz' consensus
	&Consensus() if ($task{consensus});
	
	### Andrew Neuwald's gibbs
	&Gibbs() if ($task{gibbs});
	
	### Gert Thijs' MotifSampler
	&MotifSampler() if ($task{MotifSampler});
	
	### MEME
	&MEME() if ($task{meme});

#	### merge oligo-analysis and dyad-analysis results
#	&MergePatterns() if ($task{merge_patterns});

#	### dyad feature-maps
#	&DrawFeatureMap() if ($task{maps});

#	### Match all patterns together with a sliding window
#	&SlidingWindow() if ($task{slide});
		
	### delete upstream sequence file
	if ($task{clean}) {
	    warn ";\tCleaning files from the hard drive for family $family_name\n" if ($verbose >=1);
	    foreach my $file ($family{$family_name}->{seq_file},
			      $family{$family_name}->{seq_file_purged},
			      $family{$family_name}->{oligo_ft_file},
			      $family{$family_name}->{dyad_ft_file}
			      ) {
		warn ";\t\t$file\n" if ($verbose >=1);
		system "rm -f $file" ;
	    }
	}
	
   }
}

################################################################
## Execute a command, with optional echo
#sub doit {
#    my ($command) = @_;
#    print "\n$command\n" if ($verbose >= 2);
#    system $command unless $dry_run;
#}


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
   $HELP_FAMILY_FILE = &help_message("family file");
   open HELP, "| more";
   print HELP <<End_of_help;
NAME
	multiple-family-analysis

       1999 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
       multiple-family-analysis [-i inputfile] [-v]

DESCRIPTION
	Runs a combination of programs in order to discover significant
	patterns in the upstream regions of several gene families.

	This script is a way to auto;atize the systematic analysis of
	multiple clusters of co-regulated genes, such as those
	obtained with DNA chip experiments.

	The program reads the composition of several families in a
	single text file, then executes different program discovery
	programs, and generates a summary report.

	Results are subdifided in directories created on the fly, one
	directory per family plus one summary directory.
	
CATEGORY
	sequences
	pattern discovery

OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-i	family file (incompatible with -seq)
	-seq	sequence file (incompatible with -i)
	-skip # skip the forst # data sets when performing the
		analyses (this si useful when the program has been
		interrupted after a considerable amount of work).
	-outdir	output directory


   Sequence retrieval options
	-org	organism
	-noorf	exclude upstream ORFs from upstream sequences
	-from	upstream region left limit
	-to	upstream region right limit
       -feattype
		feature type (e.g. CDS, mRNA)
	-purge	use purged sequences for pattern discovery
		(default)
	-nopurge	
		use non-purged sequences for pattern discovery

   oligo-analysis and dyad-analysis options
	-1str   strand-sensitive analysis
	-2str   strand-insensitive analysis
	-htmaps	draw html maps (dynamic map with pointers to the features)
		These html files take space on the hard drive, so I
		suppressed them from the default output.
	-noov	prevent overlapping matches for self-overlapping patterms
		(default)
	-ovlp	allow overlapping matches for self-overlapping patterms
	-nomap	do not draw feature maps (for saving time and hard disk space)
	-bg	background frequency model
		This parameter indicates which background model has to
		be used for the estimation of expected pattern
		frequencies.
		Supported: $supported_background
	-calib_dir
		Directory containing the calibration files. The
		calibration file name is then calculated automatically
		from the conditions (seq lengths, seq number, ...)
	-thosig threshold on occurrence significance

   oligo-analysis options
	-maxol	maximum oligonucleotide length
	-minol	minimum oligonucleotide length
	-oligo_exp_freq
		name of a file containing the expected frequencies for
		oligo-analysis.
	-pseudo	pseudo-weight (see oligo-analysis manual)
	-markov #	
		calculate expected frequencies on the basis of a
		Markov chain model of order #

   dyad-analysis options
	-monad  monad length for dyad-analysis
	-minsp	maximum spacing for dyad-analysis
	-maxsp	maximum spacing for dyad-analysis
	-dyad_exp_freq
		name of a file containing the expected frequencies for
		dyad-analysis.

   Matrix-based pattern discovery options (consensus, gibbs, meme)
       -width  matrix width
	-sps	expected number of sites per sequence
		(default $expected_sites_per_gene)

   Gibbs sampler (Neuwald, 1995)
	-seed	 seed number for the random generator

   MotifSampler (This, 200X)
	-MS_b	backgound file
	-MS_p	prior probability of 1 motif copy (default $MS_p)
	-MS_M   Maximal number of motif instances per sequence. (default $MS_M; unset=0)
	-MS_n	number of different motifs to search for (default $MS_n).
	-MS_x	allowed overlap between different motifs. (default $MS_x)
	-MS_r	number of times the MotifSampler should be repeated (default = $MS_r).

   Output options
	-transp	transpose synthetic result table (columns become rows)
	-sort sort_key
	        sort key for the synthetic table
		Supported: $supported_sort_keys

  Options for the automaticaly generated SQL scripts
	-schema database schema (default: $schema)
	-host	database host (default: $host)
	-user	database user (default: $user)
	-password	
		database password (default: $password)

   Other options
	-task selected_task
		Select the tasks to be performed.
		Supported tasks: $supported_tasks

		Can be used iteratively on the same command line to 
		select multiple tasks.  

		Example:
		    -task upstream -task oligos -task synthesis
		For a full analysis, simply type 
		    -task all
		
		See details below (TASK DESCRIPTION)

	-known	known_site_file
		A file containing a list of known sites/motifs for
		each of the gene families. These known sites are NOT
		used during the pattern discovery. They are simply
		displayed besides the discovered patterns, for the
		sake of comparison.
		
		Format: the known site file is a tab-delimited text
		files, with the collofing column content :
		       1) family
		       2) site/motif
		       3) source (optional)

FILE FORMAT
   $HELP_FAMILY_FILE
QUICK START
   1) create a directory for the set of families

   2) witin this directory, create a text file contaning the
      description of family composition, as described above
   
   3) run the command. For example, with a bacterial genome :

      multiple-family-analysis -org organism -i family_file \
          -v -from -200 -to 49 -task all

   4) With a web browser (e.g. Netscape), open the folder
      'synthetic_tables'. There should be a HTML file with the name
      of your family ile as prefix, and the suffix indicating the
      other analysis parameters. Open this file and analyze the
      result.

TASK DESCRIPTION

   all		Perform all the tasks below.

   upstream	Retrieve upstream sequences for the families.
		(retrieve-seq)

   purge	Purge upstream sequences for the family.
		(purge-sequences)

   calibrate   Perform a family-secific calibration of expected
		frequencies, by calculating oligonucleotide
		distributions in the whole genome set of upstream
		sequences of the same size. Beware: this takes time,
		but it gives much less false positives with when
		analyzing higher organisms.
  
   oligos	Run oligo-analysis on each family.

   dyads	Run dyad-analysis on each family.

   maps	Draw feature maps with the results of oligo-analysi and
		dyad-analysis.
		(feature-map)

   merge	Merge the results of oligo-analysis and dyad-analysis.

   slide	Match discovered patterns with a sliding window.
		(dna-pattern)

   synthesis	Generate a HTML report in the directory sythetic_tables.

   sql		Export the discovered patterns in tab-delimited files, 
		and export SQL scripts for loading these tables in a
		relational database.  

   clean	Delete upstream sequences after processing, in order 
		to save disk space.  
End_of_help
 close HELP;
 exit;
}

################################################################
#### display short help message
sub PrintOptions {
 open HELP, "| more";
 print HELP <<End_short_help;
multiple-family-analysis options
--------------------------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-v		verbose
-i		family file (incompatible with -seq)
-seq		sequence file (incompatible with -i)
-skip #		skip the # first data sets
-purge		use purged sequences for pattern discovery (default)
-nopurge	use non-purged sequences for pattern discovery
-outdir		output directory
-org		organism
-from		upstream region left limit
-to		upstream region right limit
-noorf		exclude upstream ORFs from upstream sequences
-feattype	feature type for sequence retrieval (e.g. CDS, mRNA)
-1str   	strand-sensitive analysis
-2str   	strand-insensitive analysis
-maxol		maximum oligonucleotide length
-minol		minimum oligonucleotide length
-monad		monad length for dyad-analysis
-minsp		maximum spacing for dyad-analysis
-maxsp		maximum spacing for dyad-analysis
-n      	dry run: print commands without executing them
-exp		expected frequency file
-transp		transpose synthetic result table (columns become rows)
-sort		sort key (supported: $supported_sort_keys)
-task		selected task (supported: $supported_tasks)
-htmaps		draw html maps (dynamic map with pointers to the features)
-dyad_exp_freq	expected frequencies for dyad-analysis
-oligo_exp_freq	expected frequencies for oligo-analysis
-noov		prevent overlapping matches for self-overlapping patterms
-ovlp		allow overlapping matches for self-overlapping patterms
-pseudo		pseudo-weight (see oligo-analysis manual)
-nomap		do not draw feature maps (for saving time and hard disk space)
-bg		background frequency modelEnd_short_help
-calib_dir	calibration directory
-thosig         threshold on occurrence significance
-markov #	exp. freq. calcualted with Markov chain model of order #
-known		file containing a list of known sites/motifs
-schema		database schema (default: $schema)
-host		database host (default: $host)
-user		database user (default: $user)
-password	database password (default: $password)
## Matrix-based pattern dscovery
-width		matrix width
-sps		expected number of sites per sequence (default $expected_sites_per_gene)
## Gibbs sampler
-seed		seed number for the random generator
## MotifSampler 
-MS_b		backgound file
-MS_p		prior probability of 1 motif copy (default $MS_p)
-MS_M   	Maximal number of motif instances per sequence. (default $MS_M; unset=0)
-MS_n		number of different motifs to search for (default $MS_n).
-MS_x		allowed overlap between different motifs. (default $MS_x)
-MS_r		number of times the MotifSampler should be repeated (default = $MS_r).
End_short_help
 close HELP;
 exit;
}

################################################################
#### Read arguments
sub ReadArguments {
   foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    $verbose = $ARGV[$a+1];
	    unless (&IsNatural($verbose)) {
		$verbose = 1;
	    }
	    
	    #### dry run
	} elsif ($ARGV[$a] eq "-n") {
	    $dry_run = 1;
	    
	    #### analyze purged or non-purged sequences
	} elsif ($ARGV[$a] eq "-nopurge") {
	    $analyze_purged_sequences = 0;
	} elsif ($ARGV[$a] eq "-purge") {
	    $analyze_purged_sequences = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions;
	    
	    ### family file
	} elsif (($ARGV[$a] eq "-i") ||
		 ($ARGV[$a] eq "-fam") # for compatibility with previous versions
		 ) {
	    $family_file = $ARGV[$a+1];

	    ### skip some data sets
	} elsif ($ARGV[$a] eq "-skip") {
	    $skip = $ARGV[$a+1];
	    &FatalError("Invalid number with option -skip\t$skip") unless &IsNatural($skip);
	    
	    ### sequence file list
	} elsif ($ARGV[$a] eq "-seq") {
	    $sequence_file_list = $ARGV[$a+1];

	    ### output directory
	} elsif ($ARGV[$a] eq "-outdir") {
	    $dir{output} = $ARGV[$a+1];

	    ### upstream sequence lmits
	} elsif (($ARGV[$a] eq "-from") &&
		 (&IsInteger($ARGV[$a+1]))) {
	    $from = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-to") &&
		 (&IsInteger($ARGV[$a+1]))){
	    $to = $ARGV[$a+1];

	    ### strands 
	} elsif ($ARGV[$a] eq "-1str") {
	    $force{strands} = "-1str";
	} elsif ($ARGV[$a] eq "-2str") {
	    $force{strands} = "-2str";

	    ### oligo-analysis parameters
	} elsif ($ARGV[$a] eq "-minol") {
	    $min_oligo_len = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-maxol") {
	    $max_oligo_len = $ARGV[$a+1];;
	    
	    ### dyad-analysis parameters
	} elsif ($ARGV[$a] eq "-monad") {
	    $monad_length = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-minsp") {
	    $min_sp = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-maxsp") {
	    $max_sp = $ARGV[$a+1];;

	    ### matrix-based pattern discovery
	} elsif ($ARGV[$a] eq "-width") {
	    $matrix_width = $ARGV[$a+1];
	} elsif ($ARGV[$a] eq "-sps") {
	    $expected_sites_per_gene = $ARGV[$a+1];
	    
	    ### Gibbs sampler options
	} elsif ($ARGV[$a] eq "-seed") {
	    $seed = $ARGV[$a+1];

	    ### MotifSampler options
	} elsif ($ARGV[$a] =~ /-(MS_\S)/) {
	    $$1 =  $ARGV[$a+1];

	    ### organism
	} elsif ($ARGV[$a] eq "-org") {
	    $organism_name = $ARGV[$a+1];

	    ### file with a collection of known motifs, for comparison between discovered and known motifs
	} elsif ($ARGV[$a] eq "-known") {
	    $known_site_file = $ARGV[$a+1];

	    #### task selection
	} elsif ($ARGV[$a] eq "-task") {
	    my @requested_tasks = split ",", $ARGV[$a+1];
	    foreach my $task (@requested_tasks) {
		next unless $task;
#	    $task = $ARGV[$a+1];
		if ($supported_task{$task}) {
		    $task{$task} = 1;
		} else {
		    &FatalError("Unsupported task '$task'. \n\tSupported: $supported_tasks");
		}
	    }

	    #### transpose synthetic table
	} elsif ($ARGV[$a] =~ /^-transp/) {
	    $transpose = 1;

	    #### sort key
	} elsif ($ARGV[$a] =~ /^-sort/) {
	    $sort_key = $ARGV[$a+1];
	    unless ($supported_sort_key{$sort_key}) {
		&FatalError("$sort_key is not supported as sort key");
	    }

	    #### clip upstream ORFs fom upstream regions
	} elsif ($ARGV[$a] =~ /^-noorf/) {
	    $noorf = 1;

	    #### threshold
	} elsif ($ARGV[$a] =~ /^-thosig/) {
	    $force{th} = $ARGV[$a+1];

	    #### dyad type
	} elsif ($ARGV[$a] =~ /^-type/) {
	    $force{type} = $ARGV[$a+1];

	    #### feature types
	} elsif ($ARGV[$a] eq "-feattype") {
	    my @types = split ",", $ARGV[$a+1];
	    foreach my $type (@types) {
		if ($supported_feature_types{lc($type)}) {
		    $accepted_feature_types{lc($type)}++;
		} else {
		    &FatalError("$type invalid feature type. Supported: $supported_feature_types");
		}
	    }

	    #### expected frequency file for dyad-analysis 
	} elsif ($ARGV[$a] =~ /^-dyad_exp_freq/) {
	    $exp_freq_file{dyads} = $ARGV[$a+1];

	    #### expected frequency file for oligo-analysis 
	} elsif ($ARGV[$a] =~ /^-oligo_exp_freq/) {
	    $exp_freq_file{oligos} = $ARGV[$a+1];

	    #### Calibration directory
	} elsif ($ARGV[$a] =~ /^-calib_dir/) {
	    $dir{calib1} = $ARGV[$a+1];
	    $dir{calibN} = $ARGV[$a+1];

	    #### background model for expected frequency. 
	    #### Supported: "upstream", "upstam-noorf", "intergenic", "mncf"
	} elsif (($ARGV[$a] =~ /^-exp/) 
		 || ($ARGV[$a] =~ /^-bg/)) {
	    $background = $ARGV[$a+1];
	    $background =~ s/^ncf$/intergenic/;

	    unless ($supported_background{$background}) {
		&FatalError("$background\tInvalid value for background. Supported : $supported_background");
	    }

	    #### Markov chain estimation of expected oligo frequencies
	} elsif ($ARGV[$a] =~ /^-markov/) {
	    $markov_order = $ARGV[$a+1];
	    $markov=1;
	    
	    #### prevent self-overlap
	} elsif ($ARGV[$a] eq "-noov") {
	    $noov = "-noov";

	    #### allow self-overlap
	} elsif ($ARGV[$a] eq "-ovlp") {
	    $noov = "-ovlp";

	    #### prevent feature-map drawing
	} elsif ($ARGV[$a] eq "-nomap") {
	    $draw_maps = 0;

	    #### draw htmaps
	} elsif ($ARGV[$a] =~ /^-htmap/) {
	    $draw_maps = 1;
	    $htmaps = 1;

	    #### pseudo-weight
	} elsif ($ARGV[$a] =~ /^-pseudo/) {
	    $pseudo = $ARGV[$a+1];
	    unless ((&IsReal($pseudo)) && ($pseudo > 0)) {
		&FatalError("pseudo-weight must be a positive real number");
	    }

	    #### Optoins for the SQL scripts
	} elsif ($ARGV[$a] eq "-schema") {
	    $schema = $ARGV[$a+1];
	} elsif ($ARGV[$a] eq "-host") {
	    $host = $ARGV[$a+1];
	} elsif ($ARGV[$a] eq "-user") {
	    $user = $ARGV[$a+1];
	} elsif ($ARGV[$a] eq "-password") {
	    $password = $ARGV[$a+1];

	}
   }
}



################################################################
# Verbosity
#
sub Verbose {
   my $verbose_message = "";
   $verbose_message .= "; multiple-family-analysis ";
   $verbose_message .= &PrintArguments()."\n";
   printf "; families     \t%d\n", $#families + 1;
   foreach my $family_name (@families) {
	printf ";\t%s\t%d elements\n", $family_name, $family{$family_name}->get_size();
   }
   if ($family_file) {
	$verbose_message .= sprintf "; Family file\t%s\n", $family_file ;
	$verbose_message .= sprintf "; Upstream regions\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "Strands", $strands;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "From", $from;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "To", $to;
   } elsif ($sequence_file_list) {
	$verbose_message .= sprintf "; Sequence file list\t%s\n", $sequence_file_list;
   }
   $verbose_message .= sprintf "; %-13s\t%s\n", "Organism", $organism_name;

   if ($task{oligos}) {
	$verbose_message .= sprintf "; oligo-analysis\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "max oligo length", $max_oligo_len;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "min oligo length", $min_oligo_len;
   }
   
   if ($task{dyads}) {
	$verbose_message .= sprintf "; dyad-analysis\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "monad length", $monad_length;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "min spacing", $min_sp;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "max spacing", $max_sp;
	$verbose_message .= sprintf ";\t%-22s\t%s\n", "dyad type", $dyad_type;
	$verbose_message .= sprintf ";\t%-22s\t%g\n", "sig threshold", $thosig;
   }

   if ($markov) {
	$verbose_message .= sprintf "; %-13s\t%s\n", "Markov chains, order", $markov_order;
   } elsif ($background) {
	$verbose_message .= sprintf "; %-13s\t%s\n", "background model", $background;
   }

   $verbose_message .= "; No overlap with upstream ORFs\n" if ($noorf);
   if ($noov eq "-noov") {
	$verbose_message .= "; Overlapping matches are discarded for self-overlapping patterns\n" ;
   } else {
	$verbose_message .= "; Overlapping matches are allowed for self-overlapping patterns\n" ;
   }
   warn $verbose_message;
   return($verbose_message);
}


################################################################
### initialize one directory for each family
sub MakeDirectories {
   foreach $family_name(@families) {
	$dir = "${family_name}/";
	unless (-d $dir) {
	    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
	}
	open FAM, ">$family{$family_name}->{family_file}" ||
	    die "Error: cannot write family file $family{$family_name}->{family_file}\n";
	foreach $id ($family{$family_name}->get_members()) {
	    print FAM "$id\t$name{$id}\n";
	    
	}
	close FAM;
   }
}


################################################################
### Generate tab files and SQL scripts for storing the results in a
### relational database
sub ExportSQL {
   warn "; Generating SQL\n" if ($verbose >= 1);
   my $test = new RSAT::Family;
   my $time_prefix = time();
   my $family_factory = classes::ClassFactory->new_class(object_type=>"RSAT::Family",
							  prefix=>$time_prefix);
   
   
#    my $pattern_prefix = "pat_".&AlphaDate()."_";
   my $pattern_factory = classes::ClassFactory->new_class(object_type=>"RSAT::Pattern",
							   prefix=>$time_prefix);
   
   my %export_columns = ();
   
   foreach my $family_name (@families) {
	
	#### general family attributes
	my $family_object = $family_factory->new_object(id=>$family_name);
	my $family_id = $family_object->get_attribute("id");
	$family_object->set_attribute("name", $family_name);
	$family_object->set_attribute("size", scalar(@{$family{$family_name}->{members}}));
	$family_object->set_attribute("organism", $organism_name);
	$family_object->set_attribute("suffix", $table_suffix);
	
	warn join ("\t", ";\tSQL export for family", $family_name, $organism_name), "\n" if ($main::verbose >= 2);
	
	#### family members
	my @members = @{$family{$family_name}->{members}};
	foreach my $m (@members) {
	    $family_object->push_attribute("genes", $m);
	}
	
	#### discovered oligos
	my $oligo_file = $family{$family_name}->{oligo_file};
	if (-e $oligo_file) {
	    my %export_columns = ();
	    ($oligo_handle, $dir) = &OpenInputFile($oligo_file);
	    while (<$oligo_handle>) {
		chomp;
		if (/^;/) {
		    if ((/;\s+(\d+)\t(\S+)/) && ($2 ne "id")){
			$export_columns{$2} = $1 - 1;
		    }
		    next;
		}
		next unless (/\S/);
		my @fields = split;
		my $sequence = uc($fields[0]);
#		my %export_columns = ();
		my $oligo_object = $pattern_factory->new_object();
		warn join ("\t", "; Created object", $sequence, $oligo_object), "\n" if ($main::verbose >= 3);
		foreach $k (sort keys %export_columns) {
		    warn join ("\t", ";", "specifying attribute", 
			       $k, 
			       $export_columns{$k},
			       $fields[$export_columns{$k}],
			       ), "\n" if ($main::verbose >= 5);
		    $oligo_object->set_attribute($k, $fields[$export_columns{$k}]);
		}
		warn join ("\t", ";", "specifying sequence", $sequence), "\n" if ($main::verbose >= 5);
		$oligo_object->force_attribute("sequence", $sequence);
		$oligo_object->set_attribute("type", "oligo");
		$oligo_object->set_attribute("family_id", $family_id);
		$oligo_object->set_attribute("family", $family_name);
		if ($strands eq "-2str") {
		    $oligo_object->force_attribute("rev_compl", &ReverseComplement($oligo_object->get_attribute("sequence")));
		}
	    }
	    close $oligo_handle;
	} else {
	    my $pwd = `pwd`;
	    chomp $pwd;
	    &Warning("$family_name\t$pwd\toligo file $oligo_file does not exist\tSKIPPED\n");
	}

	#### discovered dyads
	my $dyad_file = $family{$family_name}->{dyad_file};
	if (-e $dyad_file) {
	    my %export_columns = ();
	    open DYADS, $dyad_file;
	    while (<DYADS>) {
		chomp;
		if (/^;/) {
		    if ((/;\s+(\d+)\t(\S+)/) && ($2 ne "id")){
			$export_columns{$2} = $1 - 1;
		    }
		    next;
		}
		next unless (/\S/);
		my @fields = split;
		my $sequence = uc($fields[0]);
		$sequence =~ s/N/n/g;
#		$sequence =~ s/n\{0\}//g;
		my $dyad_object = $pattern_factory->new_object();
		warn join ("\t", "; Created object", $sequence, $oligo_object), "\n" if ($main::verbose >= 3);
		foreach $k (sort keys %export_columns) {
		    warn join ("\t", ";", "specifying attribute", 
			       $k, 
			       $export_columns{$k},
			       $fields[$export_columns{$k}],
			       ), "\n" if ($main::verbose >= 5);
		    $dyad_object->set_attribute($k, $fields[$export_columns{$k}]);
		}
		warn join ("\t", ";", "specifying sequence", $sequence), "\n" if ($main::verbose >= 5);
		$dyad_object->force_attribute("sequence", $sequence);
		$dyad_object->set_attribute("type", "dyad");
		$dyad_object->set_attribute("family_id", $family_id);
		$dyad_object->set_attribute("family", $family_name);
		if ($strands eq "-2str") {
		    my $rc_sequence = uc( &ReverseComplement($dyad_object->get_attribute("sequence")));
		    $rc_sequence =~ s/N/n/g;
		    $dyad_object->force_attribute("rev_compl",$rc_sequence);
		}
	    }
	    close DYADS;
	} else {
	    &Warning("$family_name\tdyad file $dyad_file does not exist\tSKIPPED\n");
	}
	
	
   }

   ## Specify output fields
   $family_factory->set_out_fields(qw(id organism size name suffix genes));
   @pattern_out_fields = qw(id
			     family_id
			     family 
			     type 
			     sequence 
			     rev_compl
			     occ 
			     exp_occ
			     occ_P
			     occ_E
			     occ_sig
			     rank
			     );
   $pattern_factory->set_out_fields(@pattern_out_fields);

   #### export directory
   $dir{sql} = "sql_export";
   &CheckOutDir($dir{sql});

   ### temporary output directory
   $dir{output_bk} = $dir{output};
   $dir{output} = $dir{sql};
   my $pwd = `pwd`;
   chomp $pwd;
   warn join ("\t", $pwd , $dir{output}, $dir{output_bk}), "\n";
   #### export the result tables
   foreach my $factory ($family_factory, $pattern_factory) {
	$factory->dump_tables();
	$factory->generate_sql(schema=>$schema, 
			       host=>$host, 
			       password=>$password, 
			       user=>$user);
   }
   &ExportMakefile("family", "pattern");
#    $dir{output} = $dir{output_bk};
#    chdir($dir{output});
}

## ##############################################################
## The input is a list of sequence files instead of a family file
sub ReadSequenceList {
   ($dir{sequences}, $short_sequence_file_list) = &SplitFileName($sequence_file_list);

   ## Convert relative to absolute directory
   if ($dir{main}) {
	$dir{sequences} = $dir{main}."/".$dir{sequences};
   }

#    die $dir{sequences};

   warn "; Reading sequence file list\t", $sequence_file_list, "\n" if ($verbose >= 1);
   my ($files) = &OpenInputFile($sequence_file_list);
   my $f = 0;
   while (<$files>) {
	next if (/^;/);
	next unless (/\S/);
	chomp;
	$f++;
	my @fields = split /\s+/;
	my $sequence_file = shift @fields; ## the first word of each row is a file
	my $short_file = &ShortFileName($sequence_file);
	my $family_name = $short_file;
	$family_name =~ s|\.${seq_ext}$||;
       my $comment = join "; ", @fields;
	
#	push @families, $family_name;
#	push @sequence_files, $sequence_file;

	#### create a new family if required
	unless ($family{$family_name}) {
	    $family{$family_name} = new RSAT::family(name=>$family_name);
	}

       #### Sequence file
	if ($dir{sequences}) {
	    $family{$family_name}->{seq_file} = $dir{sequences}."/".$sequence_file;
	} else {
	    $family{$family_name}->{seq_file} = $sequence_file;
	}
	$family{$family_name}->{seq_file_purged} = $family{$family_name}->{seq_file};
	$family{$family_name}->{seq_file_purged} =~ s/\.${seq_ext}$//;
	$family{$family_name}->{seq_file_purged} .= "_purged.".${seq_ext};
        
       #### Comment
       $family{$family_name}->{comment} = $comment;

	warn join ("\t", "; File $f", 
		   $sequence_file, 
		   $short_file, 
		   $family_name, 
		   $comment, 
#		   "\n", $family{$family_name}->{seq_file},
#		   "\n", $family{$family_name}->{seq_file_purged}
		   ), "\n" if ($verbose >= 2); 
	
	push @comments, $comment;
   }
   close $files;

   @families = sort keys %family;


   #### Family members are read from the sequence file (sequence IDs are used as member IDs)
   foreach my $family_name (@families) {
       my ($in, $input_dir) =  &OpenInputFile($family{$family_name}->{seq_file});
       my $seq_type = "dna";
       while ((($current_seq, $current_id, @comments) = &ReadNextSequence($in, $seq_format, $input_dir, $seq_type)) &&
	   (($current_seq) || ($current_id))) {
           $family{$family_name}->new_member($current_id);
           warn join ("\t", 
		       ";\tFile", $family{$family_name}->{seq_file}, 
		       "Family", $family_name, 
		       "member", $current_id), "\n" if ($main::verbose >= 2);
       }
       close $in;
   }
}


################################################################
## Index one sequence length per family
sub CalcCalibrationLengths {
   my %calib_lengths = ();
   warn ";\n; Calculating sequence lengths\n" if ($verbose >=1);
   foreach $family_name (@families) {
	$fam_count++;
	
	## Calculate sequence lengths
	warn join("\t", ";\tSequence lengths", 
		  $family_name, 
		  $family{$family_name}->{seq_len_file}), "\n" if ($verbose >= 3);
	my $command = "sequence-lengths -i ".$family{$family_name}->{seq_file};
	$command .= " -o ".$family{$family_name}->{seq_len_file};
	&doit($command, $dry_run, $die_on_error);
	
	## Index sequence lengths
	my ($in, $indir) = &OpenInputFile($family{$family_name}->{seq_len_file});
	while (<$in>) {
	    chomp;
	    @fields = split "\t";	    
	    my $current_len = $fields[1];
	    $family{$family_name}->{total_length} += $current_len;
	    ## check that all sequences of one family have the same length
	    if (defined($family{$family_name}->{calib_length})) {
		unless ($family{$family_name}->{calib_length} == $current_len) {
		    &FatalError("Sequences of family $family_name have different lengths.\nThis is not incompatible with the option calibrate");
		}
	    } else {
		$family{$family_name}->{calib_length} = $current_len;
		$calib_lengths{$current_len}++;
	    }
	}
	close $in;
	warn ";\tcalibration length for family ", $family_name, "\t", $calib_lengths{$family_name}, "\n" if ($main::verbose >= 1);
   }  
   my @calib_lengths = keys %calib_lengths;
   warn "; Calibration lengths\n;\t", join( "\n;\t", @calib_lengths), "\n";
   return @calib_lengths;
}

################################################################
## Calibrate oligonucleotide occurrences (mean and variance) for each
## sequence length
sub CalibrateOligos {
   my @calib_lengths = @_;
   warn ";\n; Calibrating oligonucleotide occurrences\n" if ($verbose >=1);

   ### Analyse upstream occurrence distributions for each sequence length
   &CheckOutDir($dir{calib1});
   warn "; Calculating oligonucleotide distributions in all upstream sequences\n" if ($verbose >= 1);
   foreach my $calib_length (sort {$a <=> $b} @calib_lengths) {

	## retrieve all upstream sequence if required
	my $allup_file = $dir{calib1}."/tmp_all_up_".$calib_length.".fasta";
	if (-e $allup_file) {
	    warn ";\tAll upstream sequence file already exists. Skipping retrieval\t", $allup_file, "\n" if ($main::verbose >= 1);
	} else {
	    $command = "retrieve-seq -org $organism_name -all -from -$calib_length -to -1 -o $allup_file";
	    warn ";\tRetrieving all upstream sequences\t", $allup_file, "\n" if ($main::verbose >= 1);
	    &doit($command, $dry_run, $die_on_error);
	}

	## Calibrate oligonucleotides
	for my $oligo_len ($min_oligo_len..$max_oligo_len) {

	    ## Names of the calibration files
	    my $calib_prefix = &CalibrationPrefix($calib_length, $oligo_len);
	    my $distrib_file = $calib_prefix."_distrib.tab";
	    my $fitting_file = $calib_prefix."_negbin.tab";

	    ## Skip the calibration if the file already exists
	    if ((-e $fitting_file.".gz") && !($force_calib)) {
		warn "Calibration file already exists. Skipping calibration.\t${fitting_file}.gz\n";
		next;
	    } else {
		warn "Calculating oligo calibration\t${fitting_file}.gz\n";
	    }

	    ## Calculate occurrence distributions
	    $command = "oligo-analysis -v 3 -l $oligo_len $noov $strands  -i $allup_file -return occ -distrib -o $distrib_file";
	    warn ";\tAnalysing ",$oligo_len,"nt distributions\t",$distrib_file, "\n" if ($main::verbose >= 1);
	    &doit($command, $dry_run, 0);
	    
	    ## Calculate stats and fit negbin on the distributions
	    $command = "fit-distribution -v 1 -i $distrib_file -distrib negbin -o $fitting_file";
	    &doit($command, $dry_run, $die_on_error);

	    ## Compress distrib and fitting file
	    $command = "gzip -f $distrib_file $fitting_file";
	    &doit($command, $dry_run, $die_on_error);
	}

	## Delete the file with all upstream sequences
	$command = "rm -f $allup_file";
	warn ":\tCleaning all upstream sequences\t", $allup_file, "\n" if ($main::verbose >= 1);
	&doit($command, $dry_run, 0);
   }

}

## ##############################################################
## Calculate the prefix of the calibration file
sub CalibrationPrefix {
   my ($calib_length, $oligo_len, $N) = @_;

   my $calib_prefix = "";

   if ($N) {
	## set-based calibration (simulations)

	## Dirtectories containing the calibration files
	unless ($dir{calibN}) {
	    $dir{calibN} = $supported_organism{$organism_name}->{'data'}."/rand_gene_selections";
	    ## Temporary
	    $dir{calibN} = "~/motif_discovery_competition_2003/results/".$organism_name."/rand_gene_selections/";
	}


	## directory for the current calibration
	$calib_prefix = $dir{calibN}."/";
	$calib_prefix .= $oligo_len."nt";
	$calib_prefix .= $strands;
	$calib_prefix .= $noov;
	$calib_prefix .= "_N".$N;
	$calib_prefix .= "_L".$calib_length;
	$calib_prefix .= "_R".$repetitions;

	## file name
	$calib_prefix .= "/";
	$calib_prefix .= $organism_name."_";
	$calib_prefix .= $oligo_len."nt_";
	$calib_prefix .= $strands;
	$calib_prefix .= $noov;
	$calib_prefix .= "_n".$N;
	$calib_prefix .= "_l".$calib_length;
	$calib_prefix .= "_r".$repetitions;

   } else {
	## single-gene-based calibration (all upstream)
	$calib_prefix = $dir{calib1}."/";
	$calib_prefix .= $oligo_len."nt";
	$calib_prefix .= "_upstream_L".$calib_length;
	$calib_prefix .= "_".$organism_name;
	$calib_prefix .= $noov;
	$calib_prefix .= $strands;
   }
   return $calib_prefix;
}



################################################################
## Generate report fiels for the motif disovery competition 2004
sub MDCreport {
   &CheckOutDir($dir{mdc_report});
   warn ";\n; Generating report\t", $outfile{results}, "\n" if ($verbose >=1);
   
   ################################################################
   ## Open a file for the report of results
   ($results) = &OpenOutputFile($outfile{results});
#      print $results join ("\n", 
#  			 ">name of contact",
#  			 "Jacques van Helden",
#  			 ">email",
#  			 "jvanheld\@scmbb.ulb.ac.be",
#  			 ">program name",
#  			 "multiple-family-analyis"), "\n";
   close $results;
   
   ################################################################
   ## Open a file for the report of parameters
   ($parameters) = &OpenOutputFile($outfile{parameters});
#      print $parameters join ("\n", 
#  			    ">name of contact",
#  			    "Jacques van Helden",
#  			    ">email",
#  			    "jvanheld\@scmbb.ulb.ac.be",
#  			    ">program name",
#  			    "multiple-family-analyis"), "\n";

   ################################################################
   ## Generate the report for each family
   my $command = "";
   foreach $family_name (@families) {
	$fam_count++;
	if ($fam_count <= $skip) {
	    warn "; Skipping family\t$fam_count\t$family_name\n" if ($main::verbose >= 1);
	    next;
	}

	my $selection_file = $family{$family_name}->{oligo_selection};
	unless (-e $selection_file) {
#	    $selection_file = $family{$family_name}->{oligo_file};
#	    &Warning("No manual selection: using default file $selection_file") if ($main::verbose >= 0);
	    &Warning("No manual selection file does not exist $selection_file") if ($main::verbose >= 0);
	    next;
	}
	warn ("; Pattern file for the report $selection_file\n") if ($main::verbose >= 1);

	my $selection_ft_prefix =  $family{$family_name}->{oligo_selection};
	my $feature_file = $selection_ft_prefix.".ft";
 	my $matching_options = " -N 0"; ## Make sure flanking sequences are not considered
	$matching_options = " -merge"; ## merge overlapping matches

#  	## Threshold for reporting a match
#  	my $threshold = 0;

#  	### Sliding window options
#  	if ($sliding_window_size >= 1) {
#  	    my @patterns = &ReadPatterns(pattern_file=>$selection_file);
#  	    my @scores = ();
#  	    foreach my $pattern (@patterns) {
#  		push @scores, $pattern->get_attribute("score");
#  	    }
#  	    if (scalar(@patterns) >= 1) {
#  		$threshold = &max(@scores) + 0.01;
#  	    } elsif (scalar(@patterns) == 1) {
#  		$threshold = &max(@scores);
#  	    }
#  	    $matching_options .= " -window ".$sliding_window_size;
#  	}
#  	$matching_options .= " -th ".$threshold;



	################################################################
	## initialize postprocessing and parameter description
	my $postprocessing_text = ">postprocessing\n";
	my $parameters_text = ">parameters\n";
	my $multi_params = join " ", @ARGV;
	$multi_params =~ s/\ -/\n-/g;
	$parameters_text .= $multi_params."\n";

	### Read the pattern file in order to select
	### manually-specified parameters threshold
	($in) = &OpenInputFile($selection_file);
	my $parameters_started = 0;
	my $postprocessing_started = 0;
	while ($line = <$in>) {
	    if ($line =~ />parameters/) {
		$parameters_started = 1;
		next;
	    }
	    next unless ($parameters_started);
	    if ($line =~ />postprocessing/) {
		$postprocessing_started = 1;
		next;
	    }
	    next unless ($parameters_started);
	    $line =~ s/^;\s*//;
	    if ($postprocessing_started) {
		$postprocessing_text .= $line;
	    } elsif ($parameters_started) {
		$parameters_text .= $line;
		$matching_options .= " ".$line;
		warn "manually specified parameter $line\n" if ($main::verbose >= 3);
	    }
	}
	close($in);
	$matching_options =~ s/\n/ /g;
	$matching_options =~ s/\r/ /g;

	warn "Family $family_name\tParameters\t", $parameters_text, "\n" if ($main::verbose >= 2);
	warn "Family $family_name\tPostprocessing\t", $postprocessing_text, "\n" if ($main::verbose >= 2);
	warn "Matching options\t", $matching_options, "\n" if ($main::verbose >= 0);

	## Make sure there is a carriage return after postprocessing and parameters
	chomp($parameter_text);
	$parameter_text .= "\n";
	chomp($postprocessing_text);
	$postprocessing_text .= "\n";

	## Write parameters and postprocessing
	print $parameters ">data set\n";
	print $parameters $family_name, "\n";
	print $parameters $parameters_text;
	print $parameters $postprocessing_text;
	
	## Draw the feature map of the selected oligos
	&MatchPatterns($selection_file, $selection_ft_prefix,  $matching_options);
	&DrawFeatureMap($selection_ft_prefix, $selection_ft_prefix, " -minfthick 5");

	## Convert the features in MDC format
	warn ";\tReporting\t",$feature_file, "\n" if ($verbose >=2);
	$command = "MDCreport-from-dnapat -d ".$family_name;
	$command .= " -i ".$feature_file;
	$command .= ">> ".$outfile{results} if ($outfile{results});
	&doit($command);
   }    

   close $parameters;

   warn ";\n; Generated report\t", $outfile{results}, "\n" if ($verbose >=1);
}


################################################################
## Extract contigs and isolated patterns from an assembly file
sub ReadAssemblyFile {
   my ($assembly_file) = @_;
   my ($pattern_handle, $input_dir) = &OpenInputFile($assembly_file);
   my @assembled_patterns = ();
   my $error = "";

   while (<$pattern_handle>) {
	chomp;
	if (/Too many patterns to assemble/i) {
	    $error = $_;
	    while (<$pattern_handle>) {
		$error .= "\n", $_;
	    } 
	    return($error);
	}
	next if (/^;/);
	next if (/^\#/);
	next unless (/\S/);
	
	if ((/contig/) || (/consensus/) || (/isol/)) {
	    @fields = split "\t";
	    my $pattern_seq = &trim(shift (@fields));
	    $pattern_seq =~ s/^\.+//g;
	    $pattern_seq =~ s/\.+$//g;
	    $pattern = new RSA::pattern();
	    $pattern->set_attribute("sequence", $pattern_seq);
	    push @assembled_patterns, $pattern;
	    if ($strands eq "-2str") {
#		my $rc = &SmartRC($pattern_seq);
		my $rc = &trim(shift @fields);
		$pattern->set_attribute("rc", $rc);
#			$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
	    }
	    my $score = shift @fields;
	    $pattern->set_attribute("score", $score);
	    $score{$pattern} = $score; ## index pattern scores for sorting
	    
	    my $type = shift @fields;
	    $pattern->set_attribute("type", $type);
	    $max_score{$family_name} = &max($max_score{$family_name}, $score{$pattern});
	    warn "Pattern\t", $_, "\n", join("\t", $family_name, 
					     $pattern->get_attribute('sequence'),
					     $pattern->get_attribute('rc'),
					     $pattern->get_attribute('score'),
					     $pattern->get_attribute('type'),
					     $score{$pattern},
					     ), "\n" if ($main::verbose >= 10);
	}
   }
   close $pattern_handle;
   return ($error, @assembled_patterns);
}

