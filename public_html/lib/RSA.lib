#!/usr/bin/perl
use CGI;
#require "cgi-lib.pl";

local $verbose = 0;
require "RSA.seq.lib";
require "RSA.stat.lib";
require RSAT::organism;
require RSAT::contig;
require RSAT::error;
require RSAT::util;

umask 0022;

## CVS: created separate objects for handling different methods
## RSAT::organism (check_name, is_supported)
## RSAT::error (FatalError, cgiError)
## RSAT::util (IsNatureal, IsReal, IsInteger, trim, round)
## ReadFeatures became RSAT::organism::LoadFeatures

############################################################################
############################################################################
############################################################################
############################################################################
############################################################################
####                                                                    ####
####                            RSA.lib                                 ####
####                                                                    ####
#### Regulatory Sequence Analysis Tools (RSA-tools)
####  Project started in 1997 by Jacques van Helden (jvanheld@scmbb.ulb.ac.be)
####  a Perl library with diverse procedures
####  used by rsa-tools perl scripts


############################################################################
########################## PATH DEFINITION ##############################
############################################################################


#### read config files #####
if ($0 =~ /([^(\/)]+)$/) {
    $config_file = "$`../RSA.config";
    require $config_file;
    if ($ENV{'RSA_LOCAL_CONFIG'}) {
	if (-e $ENV{'RSA_LOCAL_CONFIG'}) {
	    if (-r $ENV{'RSA_LOCAL_CONFIG'}) {
		require $ENV{'RSA_LOCAL_CONFIG'};
	    } else {
		warn (";WARNING: cannot read local config file ", 
		      $ENV{'RSA_LOCAL_CONFIG'}, 
		      "\n"), 
	    }
	} else {
	    warn (";WARNING: local config file ", 
		  $ENV{'RSA_LOCAL_CONFIG'}, 
		  " does not exist\n"), 
	}
    }
} else {
    &RSAT::error::FatalError("Error: problem when opening config file. Please contact jvanheld\@scmbb.ulb.ac.be");
}

$BIN = "$RSA/bin";
$LIB = "$RSA/lib";
$TMP = "$RSA/public_html/tmp";
$LOGS = "$RSA/logs";
$SCRIPTS = "$RSA/perl-scripts";

my $login = getlogin();

################################################################
## Redirect queries to a remote server
## 
if ($REMOTE_SERVER) {
    if (($login eq "webserv") || !($login)) {
	$NICE = "nice +5";
	$RSH = "rsh -l jvanheld ${REMOTE_SERVER} $NICE";
	$SCRIPTS = "$RSH /home/rsa/rsa-tools/perl-scripts";
	$BIN = "$RSH /home/rsa/rsa-tools/bin";
    }
}


$HTML = "$RSA/public_html"; 
$WWW_TMP = "$WWW_RSA/tmp";
$ENV{SERVER_ADMIN} = "jvanheld\@scmbb.ulb.ac.be";

$counter_file = "$LOGS/count-file";
($sec, $min, $hour,$day,$month,$year) = localtime(time);
$log_file = sprintf "$LOGS/log-file_${config_site}_%04d_%02d", $year+1900,$month+1;

$script_name = &RSAT::util::ShortFileName($0);

$date = &AlphaDate();

############################################################################
############################ GLOBAL VARIABLES ##############################
############################################################################


############################################################################
##################### PERL SUBROUTINE DEFINITION ###########################
############################################################################



################################################################
## echo a command and send it to the system
sub doit {
    my ($command, $dry, $die_on_error, $verbose,$pc_cluster) = @_;
    my $wd = `pwd`;
    chomp $wd;
    warn join("\t", &AlphaDate(), $wd, $command), "\n" if ($verbose >= 1);


    if ($pc_cluster) {
	## Store the command in a sh script (the job)
	my $job_dir = "jobs";
	my $job_prefix = "multi";
	&RSAT::util::CheckOutDir($job_dir);
	my $job = `mktemp ${job_dir}/${job_prefix}.XXXXXX`;
	chomp $job;
	open JOB, ">$job";
	print JOB "( cd ".$wd." ; ";
	print JOB $command;
	print JOB " )", "\n";
	close JOB;
	&RSAT::message::Info(join("\t", "; Job queued. Job file", $job)) if ($main::verbose >= 0);

	## Send the command to a batch queue on a PC cluster
	system "qsub -m e -q rsa\@merlin.scmbb.ulb.ac.be -N ${job} -j oe -o ${job}.log ${job}";

    } else {
	## Run the command immediately
	my $error = system $command unless ($dry);
	if ($die_on_error) {
	    if ($error == -1) {
		&RSAT::error::FatalError("Could not execute the command\n\t$command");
	    } elsif ($error) {
		&RSAT::error::FatalError("Error $error occurred during execution of the command\n\t$command");
	    }
	} else {
	    return ($error);
	}
    }
}



################################################################
## Name of the expected frequency file, 
## given the organism, oligo length and background model
##
sub ExpectedFreqFile {
    my ($organism_name, $oligo_length, $background, %args) = @_;
    my $exp_freq_file = "";
    my $str = $args{str} || "-2str";
    my $noov = $args{noov} || "-noov";
    
    #### organism
    &CheckOrganism($organism_name);
    
    #### check oligo length
    unless ($oligo_length) {
	&FatalError("You must specify the oligonucleotide length for the background model (expected frequency file)");
    }

    unless (&IsNatural($oligo_length)) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be a natural number");
    }    
    if ($oligo_length < 1) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be >= 1");
    }
    if ($oligo_length > 8) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be <= 8");
    }

    my $data_dir = $supported_organism{$organism_name}->{'data'};
    $exp_freq_file = $data_dir."/oligo-frequencies/";
    if ($background eq "upstreamL") {
	$exp_freq_file .= "_".$organism_name;
	$exp_freq_file .= "_allup500";
	$exp_freq_file .= $oligo_length."nt";
	$exp_freq_file .= $str;
	$exp_freq_file .= $noov;
	$exp_freq_file .= "_freq.tab";

    } else {
	$exp_freq_file .= $oligo_length."nt";
	$exp_freq_file .= "_".$background;
	$exp_freq_file .= "_".$organism_name;
	#### build the name of the expected frequency file 
	if ($noov eq "-noov") {
	    $noov_suffix = "-noov";
	} else { 
	    $noov_suffix = "-ovlp";
	}
	$exp_freq_file .= $noov_suffix;
	$exp_freq_file .= $str;
	$exp_freq_file .= ".freq";
    }

    ## Check the existence of the exp freq file
    unless ((-e $exp_freq_file) || 
	    (-e $exp_freq_file.".gz")) {
	&RSAT::error::FatalError("Cannot find expected frequency file $exp_freq_file");
    }

    warn "; Expected frequency file\t", $exp_freq_file, "\n" if ($main::verbose >= 2);
    return $exp_freq_file;
}


################################################################
# Read expected occurrences and variance from a calibration file
sub ReadCalibration {
    my ($calibration_file, $sum_rc) = @_;
    
    my ($cal) = &OpenInputFile($calibration_file);
    my $l=0;
    while (<$cal>) {
	$l++;
	chomp();
	next if (/^;/);
	next unless (/\S/);
	my @fields =  split /\s+/;
	my $pattern_seq = lc(shift(@fields));
	my $pattern_id = $pattern_seq;

	## Check if the 1st field contains a pair of reverse complements
	if ($pattern_seq =~ /(\S+)\|/) {
	    $pattern_seq = $1;
	}
	
	## Check if the second field contains the ID
	if ($fields[0] =~ /(\S+)\|/) {
	    $pattern_id = shift(@fields);
	}

	## Expected occurrences
	my $exp_occ = $fields[0];
	&RSAT::error::FatalError("Invalid expected occurrences\t${exp_occ}") unless ((&IsReal($exp_occ)) && ($exp_occ >= 0));
	$patterns{$pattern_seq}->{exp_occ} = $exp_occ;

	## Expected variance
	my $exp_var = $fields[2];
	&RSAT::error::FatalError("Invalid expected variance") unless ((&IsReal($exp_var)) && ($exp_ocvar >= 0));
	$patterns{$pattern_seq}->{exp_var} = $exp_var;

	warn join("\t", "; calibration", $pattern_seq, 
		  $patterns{$pattern_seq}->{exp_occ},
		  $patterns{$pattern_seq}->{exp_var}), "\n" if ($main::verbose >= 5);

    }
    close $cal if ($calibration_file);
    
    #### check if reverse complements were included in the expected freq file;
    #### if not, infer them from the direct strand 
    foreach my $pattern_seq (sort keys %patterns) {
  	my $rc = lc(&SmartRC($pattern_seq));
  	if (($patterns{$rc}->{exp_occ} <= 0) &&
  	    ($patterns{$pattern_seq}->{exp_occ})) {
  	    $patterns{$rc}->{exp_occ} = $patterns{$pattern_seq}->{exp_occ};
  	    $patterns{$rc}->{exp_var} = $patterns{$pattern_seq}->{exp_var};
	    #print STDERR join "\t", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n";
  	}
    }
}


################################################################
# Read pattern expected frequencies from a file
#
sub ReadExpectedFrequencies {
    my ($exp_freq_file, $sum_rc, $rescale_freq) = @_;
    warn join ("\t", "; Reading expected frequency file", $exp_freq_file), "\n" if ($main::verbose >= 2);
    my ($exp) = &OpenInputFile($exp_freq_file);
    my $l=0;
    while (<$exp>) {
	$l++;
	chomp();
	next if (/^;/);
	next unless (/\S/);

	my @fields =  split /\s+/;
	$pattern_seq = lc($fields[0]);
	next unless $pattern_seq;

	warn join "\t", "fields", join ("\t", @fields), "\n" if ($main::verbose >= 10);

	#### check the format and extract expected frequency
	if (&IsReal($fields[1])) {
	    ### second field contains the expected frequency (old format)
	    $patterns{$pattern_seq}->{exp_freq} = $fields[1];
	    $file_type="undef";

  	} elsif (($fields[1] =~ /(\S+)\|(\S+)/) && (&IsReal($fields[2]))) {
	    #### second field contains the ID as a pair of reverse complements
	    $file_type = "2str";
  	    $fw = lc($1);
  	    $rc = lc($2);
  	    $patterns{$rc}->{exp_freq} = $fields[2];
  	    $patterns{$fw}->{exp_freq} = $fields[2];

  	} elsif	(($fields[1] eq $fields[0]) &&(&IsReal($fields[2]))) {
	    #### second field contains the ID which is identical to the pattern (single strand pattern)
	    $file_type = "1str";
  	    $patterns{$fields[0]}->{exp_freq} = $fields[2];

	} else {
	    ### unrecognized format
	    &RSAT::error::FatalError("Invalid expected frequency in file $exp_freq_file at line $l\n");
	}
	
	if ($patterns{$pattern_seq}->{exp_freq} < 0) {
	    &RSAT::error::FatalError("Expected frequency cannot be negative\t$pattern_seq\t".$patterns{$pattern_seq}->{exp_freq});
	}
    }
    close $exp if ($exp_freq_file);
    

    #### check if reverse complements were included in the expected freq file;
    #### if not, infer them from the direct strand 
    foreach my $pattern_seq (sort keys %patterns) {
  	my $rc = lc(&SmartRC($pattern_seq));
  	if ((!defined($patterns{$rc}->{exp_freq})) &&
  	    ($patterns{$pattern_seq}->{exp_freq})) {
  	    $patterns{$rc}->{exp_freq} = $patterns{$pattern_seq}->{exp_freq};
#	    warn join "\t", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n" if ($main::verbose >= 10);
  	}
    }


    #### sum expected frequencies by reverse complements
    if (($sum_rc) && ($file_type eq "1str")) {
	&SumExpectedFrequencies(%patterns);
    }

    #### make sure that the sum of frequencies is positive
    my $freq_sum = 0;
    foreach my $pattern_seq (keys %patterns) {
	$freq_sum += $patterns{$pattern_seq}->{exp_freq};
    }
    if ($freq_sum <= 0) {
	&RSAT::error::FatalError("Error with the expected frequency file : the sum must be strictly positive\t$freq_sum");
    }
    
    #### rescale expected frequencies to have a sum of 1
    if ($rescale_freq) {
	warn "; Rescaling expected frequencies\n" if ($verbose >=1);
	foreach my $pattern_seq (keys %patterns) {
	    $patterns{$pattern_seq}->{exp_freq} /= $freq_sum;
	}
    }
    
}


################################################################
## Sum expected frequencies
##
sub SumExpectedFrequencies {
    my (%patterns) = @_;
    my %freq_2str = ();
    foreach my $pattern_seq (sort keys %patterns) {
	my $rc = lc(&SmartRC($pattern_seq));
	if ($rc eq $pattern_seq) {
	    #### palindromic sequence
	    $freq_2str{$pattern_seq} =   $patterns{$pattern_seq}->{exp_freq};
	} else {
	    #### non-palindromic sequence : the expected frequency is the sum of the sequence + its reverse complement 
	    $freq_2str{$pattern_seq} =  $freq_2str{$rc} = $patterns{$rc}->{exp_freq} + $patterns{$pattern_seq}->{exp_freq};
	}
	warn join ("\t", 
		   $pattern_seq,  
		   $patterns{$pattern_seq}->{exp_freq}, 
		   $freq_2str{$pattern_seq},
		   $rc, 
		   $patterns{$rc}->{exp_freq}, 
		   $freq_2str{$rc},
		   ), "\n" if ($verbose >= 5);
    }

    foreach my $pattern_seq (sort keys %patterns) {
	my $rc = &SmartRC($pattern_seq);
	$patterns{$pattern_seq}->{exp_freq} = $freq_2str{$pattern_seq};
	$patterns{$rc}->{exp_freq} = $freq_2str{$pattern_seq};
    }

}


################################################################
# Calculate conditional residue probabilities on the basis of specified
# oligonucleotide frequencies
sub CalcConditionalProbabilities {
    my ($exp_freq_file) = @_;

    &ReadExpectedFrequencies($exp_freq_file) ;

    warn "; Calculating conditional probabilities\n" if ($main::verbose >= 2);
    
    foreach my $pattern_seq (keys %patterns) {
	$expected_freq{$pattern_seq} = $patterns{$pattern_seq}->{exp_freq};
    }

    #### calculate alphabet from expected frequency keys
    foreach my $pattern_seq (keys %patterns) {
	my @residues = split "|", $pattern_seq;
	foreach my $r (@residues) {
	    $letter{$r} = 1;
	}
    }
    @letters = keys (%letter);

    #### calculate subword frequencies
    %subword_freq = ();
    foreach my $oligo_seq (keys %expected_freq) {
	my $subword = substr($oligo_seq,0,-1);
	$subword_freq{$subword} += $expected_freq{$oligo_seq};
    }

    foreach $subword (keys %subword_freq) {
	for $l (0..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    if ($subword_freq{$subword} > 0) {
		$conditional_proba{$subword}[$l] =  $expected_freq{$word}/$subword_freq{$subword};
	    } else {
		$conditional_proba{$subword}[$l] =  "NA";
	    }
	}
    }

    #### calculate cumulative conditional residue probabilities
    foreach $subword (keys %subword_freq) {
	$word = lc($subword.$letters[0]);
	$cum_letter_freq{$subword}[0] = $expected_freq{$word};
	$cum_letter_freq{$subword}[0]/=$subword_freq{$subword} if $expected_freq{$word};
# 	warn (join ("\t", 
# 		    $subword, 
# 		    $subword_freq{$subword},
# 		    $word, 
# 		    $expected_freq{$word},
# 		    $cum_letter_freq{$subword}[0]
# 		    ), "\n");
	for $l (1..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    $cum_letter_freq{$subword}[$l] = $cum_letter_freq{$subword}[$l-1];
	    $cum_letter_freq{$subword}[$l] += $expected_freq{$word}/$subword_freq{$subword} if $expected_freq{$word};
#	    warn (join ("\t", 
#			$subword, 
#			$subword_freq{$subword},
#			$word, 
#			$expected_freq{$word},
#			$cum_letter_freq{$subword}[$l]
#			), "\n");
	}
    }
    @subword_keys = sort keys %subword_freq;
}

################################################################
#### increment the counter file for monitoring web access
sub UpdateCounterFile {
    my $nb_visitors = 1;

    ### read previous counter value
    if (-e $counter_file) {
	open(COUNTER, "<$counter_file");
	#flock(COUNTER, 2);
	$nb_visitors = <COUNTER>;
	#flock(COUNTER,8);
	close(COUNTER);
	$nb_visitors++;
    }
    
    ### save new counter value
    open(COUNTER, ">$counter_file");
    #flock(COUNTER,2);
    print COUNTER $nb_visitors;
    #flock(COUNTER,8);
    close(COUNTER);
    
    return $nb_visitors;
}


################################################################
### store info into a log file in a conveninent way for 
### subsequent login statistics
### Usage:
###     &UpdateLogFile;
sub UpdateLogFile {
  if (open LOG, ">>$log_file") {
    #flock(LOG,2);
    $date = &AlphaDate;
    #$date = `date '+%y%m%d.%H%M%S'`;
    $date =~ s/\n//;
    print LOG join ("\t", 
		    $date,
		    $config_site, 
		    "$ENV{'REMOTE_USER'}\@$ENV{'REMOTE_ADDR'} ($ENV{'REMOTE_HOST'})",
		    $script_name,
		    $query->param('user_email')
		    ), "\n";
    #flock(LOG,8);
    close LOG;
  }
  chmod 0777, $log_file;
}



################################################################
#### send a unix command to remove a file the next day
#### Usage:
#### &DelayedRemoval($file_to_remove, $delay);
####
sub DelayedRemoval {
    my ($file_to_remove, $delay) = @_;
    $delay = "12 hours" unless ($delay);

    unless (-e $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove does not exist");
	return();
    }
    unless (-r $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove is not readable");
	return();
    }
    unless (-w $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove is not writable");
	return();
    }

    &MessageToAdmin("DelayedRemoval: file $file_to_remove will be removed in $delay") if ($ECHO >= 2);

    #### TEMPORARILY INACTIVATED BECAUSE IT MOBILIZES A LOT OF MEMORY
    return();

    open REMOVE, "| at now + $delay";
    print REMOVE "rm -f $file_to_remove \n";
    close REMOVE;
}


################################################################
### prints a list of elements, one per line
sub PrintList {
    my $spacer = "\n";
    foreach $element (@_) {
	print $element;
	print $spacer;
    }

}

################################################################
#### print the command-line arguments
sub PrintArguments {
    my $local_out = $_[0];
#    unless ($local_out)  {
#	$local_out = STDOUT;
#    }
    my $argument_string = "";

    foreach my $a (@main::ARGV) {
	if (($a =~ /\s+/)  ||
	    ($a !~ /\S+/) ||
	    ($a =~ /[\(\)\>\<\&]/)) {
	    $argument_string .= " '$a'";
	} else {
	    $argument_string .= " $a";
	}
    }
    print $local_out $argument_string, "\n" if ($local_out);
    return $argument_string;
}


############################################################
###############  Genome data ###############################
############################################################

@supported_feature_types = qw (CDS mRNA tRNA rRNA scRNA);
%supported_feature_types = ();
foreach my $type (@supported_feature_types) {
    $supported_feature_types{lc($type)} = 1;
}
$supported_feature_types = join ",", @supported_feature_types;


################################################################
## Check if the specified organism name is supported on this server
sub CheckOrganismName {
    my ($organism_name) = @_;
     unless ($supported_organism{$organism_name}) {
	&RSAT::error::FatalError("Organism $organism_name is not supported.",
		    "Supported on this site : \n".&ListSupportedOrganisms());
    }
}

################################################################
#### Check if an organism is supported on the current installation,
#### and open streams to read its genome sequence.
####
#### Usage
#### -----
#### Automatic selection of genome and feature file : 
####    &CheckOrganism($organism_name); 
####
#### Manual specification of input files :
#### &CheckOrganism($organism_name, 
####                $annotation_table, 
####                $input_sequence_file,  
####                $input_sequence_format);
sub CheckOrganism {
    my ($organism_name, $annotation_table, $input_sequence_file, $input_sequence_format) = @_;
    my $organism_object = new RSAT::organism();
    $organism_object->OpenContigs($organism_name, 
				  $annotation_table, 
				  $input_sequence_file, 
				  $input_sequence_format);
    return $organism_object;
}


# ################################################################
# <<<<<<< RSA.lib
# ## usage : &ListSupportedOrganisms($format);
# ## $supp =  &ListSupportedOrganisms("text");
# ## $supp =  &ListSupportedOrganisms("html_list");
# ## $supp =  &ListSupportedOrganisms("html_table");
# ## @keys =  &ListSupportedOrganisms("keys");
# ## @names =  &ListSupportedOrganisms("names");
# ## %organisms =  &ListSupportedOrganisms("hash");
# =======
# #### read ORF positions for a given organism
# #### usage: &ReadFeatures($organism_name, $feature_table_name, $feature_types)
# sub ReadFeatures {
#     my ($organism_name, 
# 	$feature_table_file,
# 	$feature_types)= @_;

#     warn "; ", &AlphaDate(), "\tReading feature table for $organism_name\n" if ($verbose >= 1);

#     my @feature_types = ();
#     my %accepted_feature_types = ();
#     if ($feature_types) {
# 	@feature_types = split ",", $feature_types;
#     } else {
#   	@feature_types = qw (cds);
#     }
#     foreach my $feature_type (@feature_types) {
# 	warn join ("\t", "accepting feature type", $feature_type), "\n" if ($main::verbose >= 2);
#   	$accepted_feature_types{$feature_type}++;
#     }

#     warn join ("\t", "; Accepted feature types", 
# 	       join( ",", keys %accepted_feature_types)), "\n" 
# 	if ($main::verbose >= 2);
    
#     unless ($feature_table_file) {
# 	$feature_table_file = $supported_organism{$organism_name}->{'features'};
#     }
#     $col{'orf_id'} = 0;
#     $col{'type'} = 1;
#     $col{'name'} = 2;
#     $col{'chr'} = 3;
#     $col{'left'} = 4;
#     $col{'right'} = 5;
#     $col{'strand'} = 6;
#     $col{'descr'} = 7;
#     $col{'location'} = 8;
    
    
#     ### read ORF positions
#     my ($orfs) = &OpenInputFile($feature_table_file);
#     my $linenb = 0;
#     while (<$orfs>) {
# 	$linenb++;
# 	next unless (/\S/);
# 	next if ((/^;/) || (/^\#/) || (/^--/));
# 	next if (/^--/);
# 	chomp;

# 	## Split the columns of the input row
# 	@fields = split "\t";
# 	foreach $f (keys %col) {
# 	    $$f = $fields[$col{$f}];
# 	}

# 	## Check if the type of this feature is accepted
# 	unless ($accepted_feature_types{lc($type)}) {
# 	    warn join( "\t","skipping feature", $orf_id, "Non-selected feature type",$type), "\n" 
# 		if ($main::verbose >= 5);
# 	    next;
# 	}
	
# 	#### check mandatory attributes
# 	unless ($orf_id) {
# 	    warn "; WARNING: invalid orf identifier specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
# 	    next;
# 	}
# 	unless ($chr) {
# 	    warn "; WARNING: invalid chromosome specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
# 	    next;
# 	}
# 	unless ($left) {
# 	    warn "; WARNING: left position not specified in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
# 	    next;
# 	}
# 	unless ($right) {
# 	    warn "; WARNING:right position not specified in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
# 	    next;
# 	}
	
# 	unless (&IsNatural($left) ) {
# 	    warn "; WARNING: invalid left position specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
# 	    next;
# 	}
# 	unless (&IsNatural($right) ) {
# 	    warn "; WARNING: invalid right position specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
# 	    next;
# 	}
	
# 	unless ($strand) {
# 	    warn "; WARNING: invalid strand specification in the feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($warn);
# 	    next;
# 	}
# 	unless ($left < $right) {
# 	    warn "; WARNING: left should be smaller than right position specification in in  feature table line $linenb\n;\t",join "\t", @fields, "\n" if ($main::verbose >= 0);

# 	    ## Patch: swap ORF limits  if inverted (in half of the genes from ENSEMBL files)
# 	    my $tmp = $left;
# 	    $left =  $right;
# 	    $right = $tmp;
# 	    warn join ("\t", "; Swapping ORF limits", $id, $chrom, $left, $right, $strand), "\n" if ($main::verbose >= 0);
# 	}
	
# 	#### make sure the strand format is correct
# 	$strand = &ConvertStrand($strand);
	
# 	### assign attributes to the gene
# 	$left{$orf_id} = $left;
# 	$right{$orf_id} = $right;
# 	$strand{$orf_id} = $strand;
# 	$chr{$orf_id} = $chr;
# 	$type{$orf_id} = $type;
# 	$descr{$orf_id} = $descr;
# 	$orf_id{uc($orf_id)} = $orf_id;
# 	$orf_id{uc($name)} = $orf_id if ($name =~ /\S/);
# 	$orf_info{$orf_id} = $_;
# 	#$name{$orf_id} = $name;
# 	if ($name eq "") {
# 	    $name{$orf_id} = $orf_id;
# 	} else {
# 	    $name{$orf_id} = $name;
# 	}
# 	unless (defined($chromosome{$chr})) {
# 	    $chromosome{$chr} = new RSA::Chromosome(id=>$chr);
# 	    $chromosome{$chr}->set_organism($organism_name);
# 	}
# 	$chromosome{$chr}->add_gene($orf_id);
# 	warn join( "\t",
# 		   $orf_id,
# 		   $chr,
# 		   $strand,
# 		   $left,
# 		   $right,
# 		   $descr{$orf_id},
# 		   $chromosome{$chr}->count_genes()), "\n" if ($main::verbose >= 10);
#     }
#     close $orfs if ($feature_table_file);
    
#     ## Check the number of features
#     if (scalar(keys(%orf_id)) < 1) {
# 	&FatalError("There is no annotated feature of type ".$feature_types." in the genome of ".$organism_name);
#     }


#     ## Print stats on the features
#     if ($main::verbose >= 2) {
# 	warn "; Features loaded\n";
# 	my %stats = ();
# 	foreach my $orf_id (keys %type) {
# 	    $stats{$type{$orf_id}}++;
# 	}
# 	foreach my $type (sort keys %stats) {
# 	    warn join ("\t", ";", $type, $stats{$type}), "\n";
# 	}
#     }
# }


# ################################################################
# #### read a list of synonyms for gene names, given an organism name
# sub ReadSynonyms {  
#     #### read synonym file ###
#     ### usage : &ReadSynonyms($organism_name);
#     my ($organism_name) = @_;

#     unless ( $supported_organism{$organism_name}->{'synonyms'}) {
# 	return;
#     }

#     ($syn) = &OpenInputFile( $supported_organism{$organism_name}->{'synonyms'});
#     if (($organism_name eq "") || 
# 	($organism_name eq "yeast")
# 	){
# 	while(<$syn>) {
# 	    chomp;
# 	    tr/a-z/A-Z/;
# 	    @fields = split;
# 	    if ((defined($orf_id{$fields[0]})) &&
# 		($orf_info{$orf_id{$fields[0]}})) {
# 		$orf_id = $orf_id{$fields[0]};
# 		unless (($fields[1] eq  $orf_id) || ($orf_info{$fields[1]})) {
# 		    $orf_id{$fields[1]} = $orf_id;
# 		    push @{$synonyms{$orf_id}}, $fields[1] if ($fields[1] =~ /\S/);
# 		}
# 	    } elsif ((defined($orf_id{$fields[1]})) &&
# 		     ($orf_info{$orf_id{$fields[1]}})) {
# 		$orf_id = $orf_id{$fields[1]};
# 		unless (($fields[0] eq  $orf_id) ||($orf_info{$fields[0]})) {
# 		    $orf_id{$fields[0]} = $orf_id;
# 		    push @{$synonyms{$orf_id}}, $fields[0] if ($fields[0] =~ /\S/);
# 		}
# 	    }
# 	}
#     } else {
# 	while(<$syn>) {
# 	    next if ((/^;/) || (/^\#/) || (/^--/));
# 	    next unless (/\S/);
# 	    chomp;
# 	    @fields = split "\t";
# 	    my $id = uc($fields[0]);
# 	    my $name = $fields[1];
# #	    print join "\t", $id, $name, $fields[0], $fields[1], "\n"; 
# 	    if (defined($orf_id{$id})) {
# 		$orf_id{uc($name)} = $orf_id{$id};
# 		push @{$synonyms{$orf_id{$id}}}, $name;
# 	    }
# 	}
#     }
#     close $syn if ($supported_organism{$organism_name}->{'synonyms'});
# } ### ReadSynonyms


# ################################################################
# #### Calculate the limits of the non-coding region on both sides of
# #### each gene
# sub CalcNeighbourLimits {
#     foreach my $chr (sort keys %chromosome) {
# 	my @genes = sort { $left{$a} <=> $left{$b} } $chromosome{$chr}->get_genes();
# 	@chrom_lefts = sort {$a <=> $b} @left{@genes};
# 	@chrom_rights = sort {$a <=> $b} @right{@genes};
	

# 	for my $g (0..$#genes) {
# 	    my $gene = $genes[$g];
# 	    my $ln = $g -1; ### first guess for left neighbour
# 	    my $rn = $g +1; ### first guess for right neighbour

# 	    #### calculate left upstream limit 
# 	    my $found = 0;
# 	    do {
# 		if (($chrom_rights[$ln] > $left{$gene}) && ($chrom_lefts[$ln] > $left{$gene})) {
# 		    $ln--;
# 		} elsif ($chrom_rights[$ln+1] < $left{$gene}) {
# 		    $ln++;
# 		} else {
# 		    $found = 1;
# 		}
# 	    } until (($found) || ($ln < 0) || ($ln > $#chrom_rights));
# 	    if ($found) {
# 		$neighb_left_limit{$gene} = $chrom_rights[$ln]; 
# 	    } elsif ($ln < 0) {
# 		$neighb_left_limit{$gene} = 0; 
# 	    } else {
# 		$neighb_left_limit{$gene} = undef; 
# 	    }
# 	    $neighb_left_size{$gene} = &max(0, $left{$gene} - $neighb_left_limit{$gene} -1);
	    
# 	    #### calculate right upstream limit 
# 	    $found = 0;
# 	    do {
# 		if (($chrom_lefts[$rn] < $right{$gene}) && ($chrom_rights[$rn] < $right{$gene})) {
# 		    $rn++;
# 		} elsif ($chrom_lefts[$rn-1] > $right{$gene}) {
# 		    $rn--;
# 		} else {
# 		    $found = 1;
# 		}
# 	    } until (($found) || ($rn < 0) || ($rn > $#chrom_lefts));
# 	    if ($found) {
# 		$neighb_right_limit{$gene} = $chrom_lefts[$rn];
# 	    } elsif ($rn < 0) {
# 		$neighb_right_limit{$gene} = undef; 
# 	    } elsif ($rn > $#chrom_lefts) {
# 		$neighb_right_limit{$gene} = $chromosome_seq{$chr}->get_length() + 1; 
# 	    }
# 	    $neighb_right_size{$gene} = &max(0, $neighb_right_limit{$gene} - $right{$gene} -1);
	    
# 	    if ($strand{$gene} eq "R") {
# 		$upstr_limit{$gene} = $neighb_right_limit{$gene};
# 		$upstr_size{$gene} = $neighb_right_size{$gene};
# 		$downstr_limit{$gene} = $neighb_left_limit{$gene};
# 		$downstr_size{$gene} = $neighb_left_size{$gene};
# 	    } else {
# 		$upstr_limit{$gene} = $neighb_left_limit{$gene};
# 		$upstr_size{$gene} = $neighb_left_size{$gene};
# 		$downstr_limit{$gene} = $neighb_right_limit{$gene};
# 		$downstr_size{$gene} = $neighb_right_size{$gene};
# 	    }    

# #  	print join ("\t", "HELLO", $g, $gene, 
# #  		    $left{$gene},$right{$gene}, 
# #  		    "ln", $ln, $chrom_lefts[$ln],$chrom_rights[$ln], 
# #  		    "rn", $rn, $chrom_lefts[$rn],$chrom_rights[$rn], 
# #  		    "left", $neighb_left_limit{$gene}, $neighb_left_size{$gene},
# #  		    "right", $neighb_right_limit{$gene}, $neighb_right_size{$gene},
# #  		    "upstr", $upstr_limit{$gene}, $upstr_size{$gene},
# #  		    "down", $downstr_limit{$gene}, $downstr_size{$gene},
# #  		    "\n");
# 	}
# #    die "HELLO";
	
#     }

# }

# >>>>>>> 1.48


sub ListSupportedOrganisms {
  my $out_format = $_[0] || "text";

  foreach my $key (keys %main::supported_organism) {
      $names{$key} = $main::supported_organism{$key}->{'name'};
#      print "HELLO $key\t",$main::supported_organism{$key}->{'name'}, "\t", $names{$key}, "\n";;
  }
  @sorted_names = sort values %names;
  @sorted_keys = sort keys %supported_organism;

  if ($out_format eq "html_list") {
      my $result = "<UL>\n";
      foreach my $name (@sorted_names) {
	  $result .= "<LI>";
	  $result .= $name;
	  $result .= "\n";
      }
      $result .= "</UL>\n";
      return $result;
  } elsif ($out_format eq "html_table") {
      my $result = "<TABLE>\n";
      foreach my $key (@sorted_keys) {
	  $result .= "<TR>\n";
	  $result .= "<TD>$key</TD>\n";
	  $result .= "<TD>";
	  $result .= $names{$key};
	  $result .= "</TD>\n";
	  $result .= "</TR>\n";
      }
      $result .= "</TABLE>\n";
      return $result;
  } elsif (($out_format eq "names") ||
	   ($out_format eq "array")) {
      return @sorted_names;
  } elsif ($out_format eq "keys") {
      return @sorted_keys;
  } elsif ($out_format eq "hash") {
      my %result = ();
      foreach my $ket (@sorted_keys) {
	  $result{$key} = $main::supported_organism{$key}->{name};
      }
      return %result;
  } elsif ($out_format eq "sizes") {
      #### collect the default limits for each organism
      my $result = sprintf ";\t%-35s\t%7s\t%7s\t%s\n", "Organism", "upstream from", "upstream to", "taxonomy";
      foreach my $key (sort @sorted_keys) {
	  $result .= sprintf ("\t%-35s\t%7s\t%7s\t%s\n", 
			      $key, 
			      $supported_organism{$key}->{'up_from'},
			      $supported_organism{$key}->{'up_to'}
			      );
      }
      return $result;
  } elsif ($out_format eq "full") {
      #### collect the default limits for each organism
      my $result = join ("\t", 
			 "; organism",
			 "taxonomy", 
			 "last update", 
			 "upstream from", 
			 "upstream to")."\n";
      foreach my $key (sort @sorted_keys) {
	  $result .= join ("\t", 
			   $key,  
			   $supported_organism{$key}->{'taxonomy'},
			   $supported_organism{$key}->{'last_update'},
			   $supported_organism{$key}->{'up_from'},
			   $supported_organism{$key}->{'up_to'}
			   )."\n";
      }
      return $result;
  } else {
      my $result = "";
      foreach $key (@sorted_keys) {
	  $result .= sprintf "\t\t%-30s", $key;
	  $result .= "\t";
	  $result .= $names{$key};
	  $result .= "\n";
      }
      return $result;
  }
}

$supported_organisms = &ListSupportedOrganisms();





# ################################################################
# ## Methods below have been transferred to RSAT::util

sub ConvertStrand {
    return &RSAT::util::ConvertStrand(@_);
}

sub OpenInputFile {
    return &RSAT::util::OpenInputFile(@_);
}

sub OpenOutputFile {
    return &RSAT::util::OpenOutputFile(@_);
}

sub IsNatural {
    return &RSAT::util::IsNatural(@_);
}

sub IsInteger {
    return &RSAT::util::IsInteger(@_);
}

sub IsReal {
    return &RSAT::util::IsReal(@_);
}

sub round {
    return &RSAT::util::round(@_);
}

sub trim {
    return &RSAT::util::trim(@_);
}

sub AlphaDate {
    return &RSAT::util::AlphaDate(@_);
}

sub SplitFileName {
    return &RSAT::util::SplitFileName(@_);
}

sub ShortFileName {
    return &RSAT::util::ShortFileName(@_);
}

sub ExtractPath {
    return &RSAT::util::ExtractPath(@_);
}

################################################################
#### Treatment of warnings and  errors
################################################################


################################################################
### Messages and errors are now passed to RSAT::message and RSAT::error
sub FatalError {
    &RSAT::error::FatalError(@_);
}

sub cgiError {
    &RSAT::error::cgiError(@_);
}


sub Warning {
    &RSAT::message::Warning(@_);
}

sub cgiWarning {
    &RSAT::message::cgiWarning(@_);
}

sub Info {
    &RSAT::message::Info(@_);
}

sub cgiMessage {
    &RSAT::message::cgiMessage(@_);
}

sub TimeWarn {
    &RSAT::message::timeWarn(@_);
}

sub MessageToAdmin {
    &RSAT::message::MessageToAdmin(@_);
}


################################################################
## Changed the name of this method
sub ReadFamilies {
    &ReadClasses(@_);
}

################################################################
#### read classification file
#### The file is supposed to contain at least two columns 
#### - element (e.g. a gene ID)
#### - class (e.g. a functional class, or a regulon, or a clustering result)
#### additional columns are allowed, but they are ignored
sub ReadClasses {
    my ($family_file, $get_orf_id, $organism, $no_subst) = @_;
    warn "; Reading family file\t$family_file\n" 
	if ($verbose >=2);

    my %family = ();
    my ($fam) = &OpenInputFile($family_file);

    my $line = 0;
    while (<$fam>) {
	$line++;
	next if (/^;/);
	next if (/^\#/);
	next unless (/\S/);
	chomp;
	s/\r$//;
	my @fields = split /\t/;
	
	### family member
	$member_name = &trim(uc($fields[0]));
	unless ($member_name =~ /\S/) {
	    &RSAT::message::Warning("Error family file", 
				 $family_file,  "line", 
				 $line, "member not specified") if ($main::verbose >= 1);
	    next;
	}

	### family name
	$family_name = &trim($fields[1]);
	unless ($no_subst) {
	    $subst_char = ".";
	    $family_name =~ s/ +/${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\//${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\:/${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\(/${subst_char}/g; ## paretheses interfere with Unix commands
	    $family_name =~ s/\)/${subst_char}/g; ## paretheses interfere with Unix commands
	}
	unless ($family_name =~ /\S/) {
	    &RSAT::message::Warning("Error family file", 
				 $family_file,  "line", 
				 $line, "family not specified") if ($main::verbose >= 1);
	    next;
	}

	#### create a new family if required
	unless ($family{$family_name}) {
	    $family{$family_name} = new RSA::family(name=>$family_name);
	}

	################################################################
	### identify the gene on the basis of its name
	my $member_key = "";
	if (($get_orf_id) && ($organism)) {
	    ### identify the gene on the basis of its name
	    my $feature = $organism->get_feature_for_name($member_name);
	    if ($feature) {
		$member_key = $feature->get_attribute("id");
	    } else {
		&RSAT::message::Warning(join ("\t", "organism", $organism->get_attribute("name"), 
					      "has no feature with name", $member_name));
	    }
#	    $member_key = $orf_id{$member_name};
	} else {
	    $member_key = $member_name;
	}
	if ($member_key) {
	    $family{$family_name}->new_member($member_key);
	    &RSAT::message::Warning( join ("\t",  ";", $family_name,
					   $member_name,
					   $member_key,
					   $name{$id}) ) if ($verbose >= 5);
	} else {
	    &RSAT::message::Warning ($member_name." unknown gene name");
	}
	
    }
    close $fam if ($family_file);
    return %family;
}

################################################################
#### when grouping occurrences with their reverse complement, 
#### only retain one of each pair. 
sub GroupRC {
    warn ("; Grouping pairs of reverse complements\n"), "\n" if ($verbose >= 2);
    foreach $pattern_seq (keys %patterns) {
	$rc_pattern_seq = &SmartRC($pattern_seq);
	warn ("; Grouping reverse complements\t", $pattern_seq, "\t", $rc_pattern_seq, "\n") if ($verbose >= 4);
	if ($rc_pattern_seq gt $pattern_seq) { ### only suppress one oligo from the pair
	    delete $patterns{$rc_pattern_seq};
	}
    }
}


################################################################
## Do the opposite as GroupRC: starting from the grouped RC, re-create
## one pattern for the RC of each pattern
sub UngroupRC {
    warn ("; Reporting both elements of reverse complements pairs\n"), "\n" if ($verbose >= 2);
    foreach $pattern_seq (keys %patterns) {
	$rc_pattern_seq = &SmartRC($pattern_seq);
	warn ("; Ungrouping reverse complements\t", $pattern_seq, "\t", $rc_pattern_seq, "\n") if ($verbose >= 4);
	if ($rc_pattern_seq gt $pattern_seq) { ### only suppress one oligo from the pair
	    $patterns{$rc_pattern_seq} = $patterns{$pattern_seq} ;
	}
    }
}

#### end of the library #####

1; # return true



