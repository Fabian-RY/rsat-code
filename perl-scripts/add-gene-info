#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";

## Initialization
$start_time = `date`;
$calc_neighbours = 0;
$info_before = 0;
$ORF_column = 1;
$null = "<NULL>";

@supported_info_types = qw(id ctg strand left right name descr names 
                           upstr_neighb_name upstr_neighb_id upstr_limit upstr_size
                           downstr_neighb_name downstr_neighb_id downstr_limit downstr_size
                           right_neighb_name right_neighb_id right_limit right_size
                           left_neighb_name left_neighb_id left_limit left_size
                           );

%supported_info_types = ();
foreach my $type (@supported_info_types) {
    $supported_info_types{lc($type)} = 1;
}
$supported_info_types{all} = 1;
$supported_info_types = join ",", @supported_info_types;

&ReadArguments();

#### output file ####
$out = &OpenOutputFile($outputfile);

#### organism
&CheckOrganism($organism_name);

#### Supported feature types
$feature_types = sort keys %supported_feature_types;

#### Information types
if (scalar(@info_types < 1)) {
    @info_types = "descr";
}

@null = ();

## Check if all the info types were requested
foreach my $type (@info_types) {
    if ($type eq "all") {
	@info_types = @supported_info_types;
	last;
    }
}

## Check the requested info types
foreach my $type (@info_types) {
    &RSAT::error::FatalError("Invalid information type $type. Supported: $supported_info_types") 
      unless ($supported_info_types{$type});
    if (($type =~ /^upstr_/) ||
	($type =~ /^down_/) ||
	($type =~ /^right_/) ||
	($type =~ /^left_/) ) {
	$calc_neighbours = 1;
    }
    push @null, $null;
    push @header, $type;
}

################################################################
## Instantiate organism
$organism = new RSAT::organism();
$organism->check_name($organism_name);
$organism->set_attribute("name", $organism_name);
$organism->OpenContigs($organism_name, $annotation_table);
$organism->LoadFeatures($annotation_table);
$organism->LoadSynonyms();
if ($calc_neighbours) {
    &RSAT::message::TimeWarn("Calculating neighbour ORF limits") if ($verbose >= 1);
    $organism->CalcNeighbourLimits();
}


#### verbose ####
if ($verbose) {
    print $out "; add-gene-info ";
    &PrintArguments($out);
    print $out "; Input file	$inputfile\n" if ($inputfile);
    print $out "; Output file	$outputfile\n" if ($outputfile);
}

#### input file ####
($in) = &OpenInputFile($inputfile);

###### execute the command #########
my $l = 0;
while ($current_line = <$in>) {
    $l++;
    chomp($current_line);
    $current_line =~ s/\r//g; ## Suppress Windows-specific carriage return

    ## Skip empty lines
    unless ($current_line =~ /\S/) {
	print $out $current_line, "\n";
	next;
    }

    ## Print header line + info column names
    if ($current_line =~ /^#/) {
	if ($info_before) {
	    $current_line =~ s/^#//;
	    print $out "#", join ("\t", @header, $current_line), "\n";
	} else {
	    print $out join ("\t", $current_line, @header), "\n";
	}
      next;
    }

    ## Print comment line as such
    if ($current_line =~ /^;/) {
	print $out join ("\t", $current_line), "\n";
	next;
    }

    if ($ORF_column > 0) {
	@columns = split("\t", $current_line);
	$query = uc($columns[$ORF_column - 1]);
	$query = &RSAT::util::trim($query);

	my $feature = $organism->get_feature_for_name($query);
	&RSAT::message::Debug("identified feature", $query, $feature) if ($main::verbose >= 3);
	my @info = ();
	if ($feature) {
	    foreach my $type (@info_types) {
		my $info = join( ";", $feature->get_attribute($type));
		&RSAT::message::Warning(join("\t", "Info for query",$query, $info)) if ($main::verbose >= 6);
		push @info, $info;
	    }
	    &RSAT::message::Info(join ("\t", "Line", $l, "Info found", $query, join("\t", @info))) if ($main::verbose >= 3);
	} else {
	    @info = @null;
	    &RSAT::message::Warning(join ("\t", "Line", $l, "No info found for query", $query)) if ($main::verbose >= 1);
	}

	if ($info_before) {
	  print $out join ("\t", @info, $current_line), "\n";
	} else {
	  print $out join ("\t", $current_line, @info), "\n";
	}
    }
}


###### verbose ######
if ($verbose) {
    $done_time = `date`;
    print $out ";Job started $start_time";
    print $out ";Job done    $done_time";
}


###### close input/output files
close $in if $inputfile;
close $out if $outputfile;



exit(0);


########################## subtroutine definition ############################

#### display full help message #####
sub PrintHelp {
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
	add-gene-info

DESCRIPTION
	Takes as input a tab-delimited file where the first word of
	each row is an ORF identifier, and adds a column with a
	description of the ORFs.
	
CATEGORY
	genomics

USAGE
        add-gene-info [-i inputfile] [-o outputfile] [-v] 
        [-col orf_column] -org organism
	
OPTIONS
	-h	display full help message

	-help	display options

	-v	verbose

	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.

	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.

	-org organism

	-info	information type (supported: $supported_info_types)

	-before add the informaiton before the input line (by default,
         	the info is added at the end of each input line).
	
INPUT FORMAT
	Any text file containing ORF identifiers or gene names.

	The first word of each row is considered as a query name
	(identifier). Additional text on the same row is not analyzed
	(it appears unchanged in the output).
	
OUTPUT FORMAT
	After each line containing reference to an ORF, a 
        column with ORF function is added. 
	
End_of_help
    close HELP;
    exit;
}


#### display short help message #####
sub PrintOptions {
    open HELP, "| more";
    print HELP <<End_short_help;
add-gene-info options
---------------------
-h      (must be first argument) display full help message
-help   (must be first argument) display options
-i      input file
-o      output file
-v      verbose
-col #  ORF column
-org	organism
-info	information type (supported: $supported_info_types)
-before	add info before rather than afte the input line
End_short_help
  close HELP;
  exit;
}



################################################################
#### Read arguments 
sub ReadArguments() {
    foreach $a (0..$#ARGV) {

	### verbose  
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp();
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions();
	    
	    
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-col") {
	    $ORF_column = $ARGV[$a+1];
	    
	    #### organism
	} elsif ($ARGV[$a] eq "-org") {
	    $organism_name =$ARGV[$a+1];

	    #### information type
	} elsif ($ARGV[$a] eq "-info") {
	    @info_types = split ",", lc($ARGV[$a+1]);

	    #### add info before the input line
	} elsif ($ARGV[$a] eq "-before") {
	    $info_before = 1;
	}
    }
}
