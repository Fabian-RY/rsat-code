#!/usr/bin/perl -w
############################################################
#
# $Id: matrix-scan,v 1.22 2006/04/18 14:51:43 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

## TO DO
## - calcualte and display residue priors for each matrix, according to the background

## use strict;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "RSA.seq.lib";

use RSAT::matrix;
use RSAT::MarkovModel;

=pod

=head1 NAME

matrix-scan

=head1 DESCRIPTION

Scan sequences with a position-specific scoring matrix (PSSM) to
identify putative sites for the motif described by the PSSM.

The background model is either provided in the form of a background
file (option -bgfile) or calculated from the input sequence, by
computing a Markov model of a given order (-bgorder) on a sliding
window of a given size (-bgwind), and adaptively updating the model
during the scanning process.

=head1 AUTHORS

=item Jean Valery Turatsinze jturatsi@scmbb.ulb.ac.be

=item Jacques van Helden jvanheld@scmbb.ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE
    
matrix-scan -m matrixfile [-i inputfile] [-o outputfile] [-v]
    [-bgfile backgroundfile|-bgorder #]

=head1 INPUT FORMATS

=over

=head2 Sequence file

All the formats supported in RSAT can be used as input (default: fasta).  


=head2 Matrix file

The matrix format is specified with the option -matrix_format.  Supported :
consensus,gibbs,meme,tab. Default : tab.

=back

=head1 OUTPUT FORMAT

=cut


################################################################
## Main package
package main;
{

    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();

    
    %main::infile = ();
    %main::outfile = ();

    @main::matrix_files = ();
    @matrices = ();

    $markov = -1; ## To make the distinction with 0, which is a valid value for the markov order
    $window = -1; 
    $bg_input = 0; ## Calculate bg model from the whole set of input sequences
    $sequence_number = 0;
    $sum_seq_len = 0;
    $main::base=exp(1); ## Base for the logarithms
    $main::both_strands = 0;
    $main::sum_seq_len = 0;
    $main::origin = 0;
    $main::pseudo_counts = 1;
    $main::matrix_format = "tab";
    $main::seq_format = "fasta";
    $main::verbose = 0;
#    $main::in = STDIN;
#    $main::out = STDOUT;
    
    ## Threshold parameters
    local %lth = (); # lower threshold values
    local %uth = (); # upper threshold values
    @supported_thresholds = qw( score normw );
    $supported_thresholds = join ",", @supported_thresholds;
    %supported_threshold = ();
    foreach my $thr (@supported_thresholds) {
	$supported_threshold{$thr} = 1;
    }

    ## Return fields
    %supported_return_fields = (
	sites=>1,
	limits=>1,
	bg_model=>1,
	normw=>1,
    );
    $supported_return_fields = join (",", sort(keys( %supported_return_fields)));

    &ReadArguments();
    
    ################################################################
    #### check argument values

    ## Calculate only once the denominator for the logarithms
    $main::log_base = log($base);

    ## Return fields
    if (scalar(keys(%return_fields)) < 1) {
	$return_fields{sites} = 1;
    } else {
	foreach my $field (keys(%return_fields)) {
	    $return_fields{$field} = 1;
	}
    }

    unless (scalar(@matrix_files >= 1)) {
	&RSAT::error::FatalError("You must specify at least one matrix file.");
    }

    ################################################################
    ### open output stream
    $main::out = &OpenOutputFile($main::outfile{output});
    
    ################################################################
    ## Background model specification
    local $bg_model = new RSAT::MarkovModel();

    if ($main::both_strands) {
	$bg_model->set_attribute("strand", "insensitive");
    } else {
	$bg_model->set_attribute("strand", "sensitive");
    }

    if ($infile{bg}) {
	## Read background model from a file
	&RSAT::message::TimeWarn(join("\t", "Reading background model from file", $infile{bg})) 
	    if ($main::verbose >= 2);
	$bg_model->load_from_file($infile{bg});
    } elsif ($main::markov >= 0) {
	$bg_model->set_attribute("order", $main::markov);
	if (($main::window >= 0) && ($main::window < $main::markov+1)) {
	    &RSAT::error::FatalError(join("", 
					  "Window size (",
					  $main::window,
					  ") must be larger than Markov order + 1 (",
					  $main::markov."+1)."));
	}
    } else {
	&RSAT::error::FatalError("you should either define the Markov order (-markov) or specify a file (-bgfile) for the background model.");
    }

    ################################################################
    ## Read the position-specific scoring matrices
    foreach my $matrix_file (@matrix_files) {
	my ($matrix_name) = &RSAT::util::ShortFileName($matrix_file);
	$matrix_name =~ s/\.\S+$//; ## suppress the extensin from the file name
	my $matrix = new RSAT::matrix();
	$matrix->readFromFile($matrix_file, $matrix_format);
	$matrix->set_attribute("matches", 0); ## Initialize the match counter
	$matrix->set_attribute("pseudo", $pseudo_counts);
	$matrix->set_attribute("file", $matrix_file);
	$matrix->set_attribute("name", $matrix_name);
	$matrix->push_attribute("parameters", "pseudo");
	$matrix->index_alphabet();

	## Check that the matrix width is smaller than markov order + 1
	my $matrix_width = $matrix->ncol();
	my $markov_order = $bg_model->get_attribute("order");
	if ($matrix_width < $markov_order + 1) {
	    &RSAT::error::FatalError(join (" ", 
					   "Markov order (".$markov_order.")",
					   "is too large for matrix",
					   $matrix->get_attribute("name"),
					   "of width ".$matrix_width."."));
	}
	
	## Calculate frequency matrix
	$matrix->calcFrequencies();
	
	## Calculate min and max values for P(S|M) 
	$matrix->proba_range();
	$matrix->weight_range();
	push @matrices, $matrix;

	&RSAT::message::TimeWarn(join("\t", "read matrix", 
				  scalar(@matrices), 
				  $matrix->get_attribute("name"),
				  $matrix->get_attribute("file")
				  )) if ($main::verbose >= 2);
    }
    
    ################################################################
    ## If the model is taken from the whole set of input sequences, read them
    ## first without scanning, just to calculate the model
    if ($main::bg_input) {
	unless ($main::infile{input}) {
	    &RSAT::error::FatalError("The optin -bg_input requires to specify an input file.");
	}
	my ($in, $input_dir) = &OpenInputFile($main::infile{input});
	while ((($current_seq, $seq_id) = &ReadNextSequence($in, $seq_format, $input_dir, "",$mask)) &&
	       (($current_seq ne "") || ($seq_id ne ""))) {
	    
	    ## Sequence length
	    $current_seq = lc($current_seq);
	    $bg_model->calc_from_seq($current_seq, add=>1);
	}
	close $in;
    }

    ################################################################
    ## Set prior matrix frequencies from the bg model
    ## PROBLEM : with the adpative option, this does not work since
    ## the BG model has not yet been calculated
    ## This is thus only done with the options -bginput and -bgfiles. 
    if (($bg_input) || ($infile{bg})) {
	my %prior = $bg_model->get_attribute("suffix_proba");
	&RSAT::message::TimeWarn(join("\t", "PRIOR", join(" ", %prior))) if ($main::verbose >= 2);
	foreach my $matrix (@matrices) {
	    
	    ## Set prior residue frequencies
	    $matrix->setPrior(%prior);
	    &RSAT::message::TimeWarn(join("\t", "Setting matrix priors for matrix", 
					  $matrix->get_attribute("name"),
					  join(" ", %prior),
					 )) if ($main::verbose >= 2);
	    
	    ## Calculate min and max weight values
	    my ($Wmin, $Wmax, $Wrange) = $matrix->weight_range();
	    &RSAT::message::TimeWarn(join("\t", "Calculated weight range for matrix", 
					  $matrix->get_attribute("name"), 
					  $Wmin, $Wmax, $Wrange,
					 )) if ($main::verbose >= 2);
	}
    }

    ################################################################
    #### print verbose
    &Verbose() if ($main::verbose);

    if ($main::verbose >= 4) {
	foreach my $matrix (@matrices) {
	    print $out "; Weight matrix\t", $matrix->get_attribute("name"), "\n";
	    print $out $matrix->toString(col_width=>(7), 
					 decimals=>3, 
					 type=>"weights",
					 format=>"tab");
      }
    }

    ## Print header
    print $out "#", join ("\t", 
			  "seq_id",
			  "ft_type",
			  "ft_name",
			  "strand",
			  "start",
			  "end",
			  "sequence",
			  "weight",
			  "P(S|M)",
			  "P(S|B)",
			 );
    print $out "\tnormW" if ($return_fields{normW});
    print $out "\n";
    
    
    ################################################################
    ##### Scan the sequences
    my ($in, $input_dir) = &OpenInputFile($main::infile{input});
    while ((($current_seq, $seq_id) = &ReadNextSequence($in, $seq_format, $input_dir, "",$mask)) &&
       (($current_seq ne "") || ($seq_id ne ""))) {

	## Sequence length
	$current_seq = lc($current_seq);
        $sequence_number++;
        my $seq_len = length($current_seq);
	$sum_seq_len += $seq_len;

	## Calculate the origin
	$orig_pos = 0;
	if (($main::origin <  0) || ($main::origin eq "-0")) {
	    $orig_pos = $seq_len + $main::origin + 1; 
	} else {
	    $orig_pos = $main::origin;
	}

	################################################################
	## Report sequence limits
	&PrintSequenceLimits($seq_id, $seq_len, $orig_pos) if ($return_fields{"limits"});

	################################################################
	## Calculate background model from the current sequence
	my $window_offset = 0;
	if (($main::markov >= 0) && (!$bg_input)){
	    if ($main::window >= $main::markov + 1) {
		if ($main::window > $seq_len) {
		    &RSAT::message::Warning(join("\t",
						 $seq_id,
						 "sequence length",
						 $seq_len,
						 "smaller than sliding window size",
						 $main::window,
						 ));
		    $bg_model->calc_from_seq($current_seq);
		} else {
		    ## initialize the model with the first window
		    $bg_model->calc_from_seq(substr($current_seq,0,$main::window));
		}
	    } else {
		## calculate the model from the entire current sequence
		$bg_model->calc_from_seq($current_seq);
	    }
	}
	
	################################################################
	## Detect sites
	&RSAT::message::TimeWarn(join ("\t", "Scanning sequence", $sequence_number,  "len=".$seq_len, "orig=".$orig_pos,  $seq_id))
            if ($main::verbose >= 2);
	if ($return_fields{"sites"}) {
	    for my $pos (1..$seq_len) {
		
		## Update background model if required
		if (($main::window > 0) &&
		    ($pos > $main::window/2) &&
		    ($pos + $main::window <= $seq_len)) {
		    my $added_word = substr($current_seq, $window_offset + $main::window - $main::markov, $markov+1);
		    my $deleted_word = substr($current_seq, $window_offset, $markov+1);
		    $bg_model->two_words_update($added_word, $deleted_word, $window_offset);
		    $window_offset++;
		}

		## Detect sites
		foreach my $matrix (@matrices) {
		    my $ncol = $matrix->{ncol};
		    next if ($seq_len - $pos +1 < $ncol);
		    my $segment = substr($current_seq, $pos-1, $ncol);
		    &score_segment($segment, $matrix, $seq_id, $pos, "D");
		    if ($main::both_strands) {
			&score_segment( &ReverseComplement($segment),$matrix, $seq_id, $pos, "R");
		    };
		}
	    }
	}
       
    }
    close $in if ($main::infile{input});
    
    
    ################################################################
    ###### execute the command
    
    ################################################################
    ###### print output
    
    
    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	printf $main::out "; %-21s\t%s\n", "Number os sequences scanned", $sequence_number;
	printf $main::out "; %-21s\t%s\n", "Sum of sequence lengths", $sum_seq_len;
	print $main::out "; Matches per matrix\n";

	my $total_matches = 0;
	foreach my $matrix (@matrices) {
	    my $matches = $matrix->get_attribute("matches");
	    $total_matches += $matches;
	    printf $main::out ";\t%-15s\t%d\n", $matrix->get_attribute("name"), $matches;
	}
	printf $main::out ";\t%-15s\t%d\n", "Total matches", $total_matches;
	
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    

    ## Report background model
    if ($return_fields{bg_model}) {
	print $out $bg_model->to_string(comment_string=>"; ");
    }
     
    ################################################################
    ###### close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
#    foreach my $a (0..$#ARGV) {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Background model file
=pod

=item B<-bgfile background_file>

Background model file. 

=cut
	} elsif ($arg eq "-bgfile") {
	    $main::infile{bg} = shift(@arguments);
	    &RSAT::error::FatalError("The options -markov and -bgfile are mutually exclusive.") 
		if ($main::markov >= 0);
	    
	    ## Background calculated from the input sequence set
=pod

=item B<-bginput>

Calculate background model from the input sequence set.

=cut
	} elsif ($arg eq "-bginput") {
	    $main::bg_input = 1;
	    &RSAT::error::FatalError("The options -bginput and -window are mutually exclusive.") 
		if ($main::window >= 0);
	    &RSAT::error::FatalError("The options -bginput and -bgfile are mutually exclusive.") 
		if defined($main::infile{bg});
	    
	    ## Calculate background model from the input sequence
=pod

=item B<-markov>

Order of the markov chain for the background model. 

This option is incompatible with the option -bgfile. 

=cut
	} elsif ($arg eq "-markov") {
	    $main::markov = shift(@arguments);
	    &RSAT::error::FatalError("Markov order must be a natural number.") 
		unless &RSAT::util::IsNatural($main::markov);
	    &RSAT::error::FatalError("The options -markov and -bgfile are mutually exclusive.") 
		if defined($main::infile{bg});

=pod

=item B<-window>

Size of the sliding window for the background model calculation. 

=cut
	} elsif ($arg eq "-window") {
	    $main::window = shift(@arguments);
	    &RSAT::error::FatalError("Window size must be a natural number.") 
		unless &RSAT::util::IsNatural($main::window);
	    &RSAT::error::FatalError("The options -window and -bgfile are mutually exclusive.") 
		if defined($main::infile{bg});

	    
	    ## Matrix file
=pod

=item B<-m matrixfile>

Matrix file. 

This argument can be used iteratively to scan the sequence with
multiple matrices.

=cut
	} elsif ($arg eq "-m") {
	    push @matrix_files, shift(@arguments);
#	    $main::infile{matrix} = shift(@arguments);
	    
# 	    ## Matrix name
# =pod
#
# =item B<-mname matrix_name>
#
# Matrix name. 
#
# =cut
# 	} elsif ($arg eq "-mname") {
# 	    $main::matrix_name = shift(@arguments);
	    
	    ## Sequence format
=pod

=item B<-seq_format sequence_format>

Sequence format. 

=cut
	} elsif ($arg eq "-seq_format") {
	    $seq_format = shift(@arguments);
	    
	    ## Matrix format
=pod

=item B<-matrix_format matrix_format>

Matrix format. 

=cut
	} elsif ($arg eq "-matrix_format") {
	    $matrix_format = shift(@arguments);
	    
	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);

	    ## mask
=pod

=item B<-mask upper|lower>

Mask lower or uppercases, respecively, i.e. replace selected case by N
characters.

=cut

	} elsif ($arg eq "-mask") {
	    $main::mask = shift(@arguments);
	    &CheckMask($main::mask);	    


	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ## Pseudo weight
=pod

=item B<-pseudo pseudo_counts>

Pseudo-weight.

=cut
	} elsif ($arg eq "-pseudo") {
	    $main::pseudo_counts = shift(@arguments);
	    &RSAT::error::FatalError(join("\t", $main::pseudo_counts, 
					  "Invalid value for a pseudo-weight. Must be a positive real number."))
		unless ((&RSAT::util::IsReal($main::pseudo_counts) )
			&& ($main::pseudo_counts >= 0));


	## Origin
=pod

=item B<origin pos>

Define pos as the origin for the calculation of positions.

-origin -0 defines the end of each sequence as the origin. The matching
positions are then negative values, providing the distance between the match
and the end of the sequence.

=cut

	} elsif ($arg eq "-origin") {
	    $main::origin = shift(@arguments);
	    &RSAT::error::FatalError("$main::origin. Invalid origin, should be a natural number.")
		unless (($main::origin eq "-0") || (&RSAT::util::IsNatural($main::origin)));


	    ## base for the logarihtms
=pod

=item	B<-base #>

Base for the logarithms (default: $base)

=cut
	} elsif ($arg eq "-base") {
	    $base = shift @arguments;
	    &RSAT::error::FatalError("base should be a real number") unless (&IsReal($base));
	    &RSAT::error::FatalError("base should be larger than 1") if ($base <= 1);


	    ## Thresholds
=pod
    
=item	B<-lth param lower_threshold>

=item	B<-uth param upper_threshold>

Threshold on some parameter (-lth: lower, -uth: upper threshold). 

Supported threshold fields : score

=cut
	    
	    ### Lower threshold
	} elsif ($arg eq "-lth") {
	    my $thr_field = shift(@arguments);
	    my $thr_value =  shift(@arguments);
	    unless ($supported_threshold{$thr_field}) {
		&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
	    }
	    $lth{$thr_field} = $thr_value;
	    
	    ### Upper threshold
	} elsif ($arg eq "-uth") {
	    my $thr_field = shift(@arguments);
	    my $thr_value = shift(@arguments);
	    unless ($supported_threshold{$thr_field}) {
		&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
	    }
	    $uth{$thr_field} = $thr_value;


	    ## Scan both strands
=pod

=item B<-2str>

Scan both strands for DNA sequences.

=cut
	} elsif ($arg eq "-2str") {
	    $main::both_strands = 1;

	    ## Scan direct strand only
=pod

=item B<-1str>

single-strand search for DNA sequences.

=cut
	} elsif ($arg eq "-1str") {
	    $main::both_strands = 0;


	    ## Return fields
=pod

=item B<-return return_fields>

List of fields to return. 

Supported fields: sites, limits.normw

=over

=item B<sites:> position of matching sites.

=item B<limits:> limits (start, end) of the input sequences. This is useful for drawing feature maps with sequences of different lengths. 

=item B<normw:> normalized weights. Normailzed weights are calculated according to Thijs' formula : normW = (W -Wmin)/(Wmax - Wmin).

=back

=cut
        } elsif ($arg eq "-return") {
	    $arg = shift (@arguments);
            chomp($arg);
            my @fields_to_return = split ",", $arg;
            foreach my $field (@fields_to_return) {
		$field = lc($field);
                if ($supported_return_fields{$field}) {
                    $return_fields{$field} = 1;
                } else {
                    &RSAT::error::FatalError(join("\t", $field, "Invalid return field. Supported:", $supported_return_fields));
		}
	    }



	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


}

################################################################
#### verbose message
sub Verbose {

    ## Report the command line
    print $main::out "; matrix-scan ";
    &PrintArguments($main::out);

    ## Input files
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    printf $main::out "; %-21s\t%s\n", "Sequence format", $seq_format;

    ## Output files
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }

    ## Matrices
    print $main::out "; Matrices\n";
    print $out join ("\t", ";", 
		     "name",
		     "ncol",
		     "nrow",
		     "pseudo",
		     "Pmin",
		     "Pmax",
		     "Wmin",
		     "Wmax",
		     "Wrange",
		     "prior",
		    ), "\n";
    foreach my $matrix (@matrices) {
	print $out join ("\t", ";", 
			 $matrix->get_attribute("name"),
			 $matrix->get_attribute("ncol"),
			 $matrix->get_attribute("nrow"),
			 $matrix->get_attribute("pseudo"),
			 sprintf("%5.2g", $matrix->get_attribute("min(P(S|M))")),
			 sprintf("%5.2g", $matrix->get_attribute("max(P(S|M))")),
			 sprintf("%.3f", $matrix->get_attribute("Wmin")),
			 sprintf("%.3f", $matrix->get_attribute("Wmax")),
			 sprintf("%.3f", $matrix->get_attribute("Wrange")),
			);
	my %prior = $matrix->getPrior();
	print $out "\t";
	foreach my $letter (keys %prior) {
	    printf $out "%s:%.3f ", $letter, $prior{$letter};
	}
	print $out "\n";
    }

    ## Pseudo counts
    printf $main::out "; %-21s\t%s\n", "Pseudo counts", $pseudo_counts;

    ## Background model
    printf $main::out "; Background model\n";
    my $order = $bg_model->get_attribute("order");
    if ($order == 0) {
	printf $main::out ";\t%-14s\n", "Bernoulli model (order=0)";
    } else {
	printf $main::out ";\t%-14s\t%d\n", "Markov order", $order;
    }
    printf $main::out ";\t%-14s\t%s\n", "Strand", $bg_model->get_attribute("strand");
    if ($window > 0) {
	printf $main::out ";\t%-14s\t%d\n", "Background window", $window;
    }

    ## Thresholds
    my %th_keys = (%lth, %uth);
    print $main::out "; Thresholds\tlower\tupper\n";
    foreach $f (sort keys %th_keys) {
	print $main::out ";\t$f";
	if (defined($lth{$f})) {
	    printf $main::out "\t%-5g", $lth{$f};
	} else {
	    print $main::out "\tNA";
	}
	if (defined($uth{$f})) {
	    printf $main::out "\t%-5g", $uth{$f};
	} else {
	    print $main::out "\tNA";
	}
	print $main::out "\n";
    }


}


################################################################
=pod

=item B<score_segment>

Assign a score to a sequence segment and report it if it passes the
thresholds.

Return value is 1 if the segment passed the thresholds. 

=cut
sub score_segment {
    my ($segment, $matrix, $seq_id, $pos, $strand) = @_;

#    &RSAT::message::Debug("scoring segment", $seq_id, $segment, $strand) if ($main::verbose >= 10);

    my $ncol = $matrix->{ncol};

    my $proba_M = 1;
    my $proba_B = 1;

    $proba_M = $matrix->segment_proba($segment);
    $proba_B = $bg_model->segment_proba($segment);


    ## Calculate segment weight and  normalized weight
    my $score = "NA";
    my $normW = "NA";
    if (($proba_M > 0) && ($proba_B > 0)) {
	$score = sprintf("%.3f", log($proba_M/$proba_B))/$log_base;

	if ($return_fields{normw}) {
	    $normW = sprintf("%6.4f", ($score - $matrix->{'Wmin'})/($matrix->{'Wrange'}));
	}
    }
    return(0) unless (&check_thresholds("score", $score));
    return(0) unless (&check_thresholds("normW", $normW));

    ## Calculate information
#    my $info = $score * $proba_B;
#    return(0) unless (&check_thresholds("info", $info));

    ## Calculate start and end position
    my $start_pos = $pos - $orig_pos;
    my $end_pos = $start_pos + $ncol -1;

    if ($main::return_fields{sites}) {
	print $out join ("\t", 
			 $seq_id,
			 "site",
			 $matrix->{name},
			 $strand,
			 $start_pos,
			 $end_pos,
			 $segment,
			 $score,
			 sprintf("%5.2g\t%5.2g",
				 $proba_M,
				 $proba_B,
				)
			);
      
	print $out "\t", $normW if ($return_fields{normw});
	print $out "\n";
    }
    $matrix->{matches}++;

    return(1);
}

################################################################
=pod

=itm B<check_thresholds>

Check the lower and upper threshold for a given score. 

=cut

sub check_thresholds {
    my ($key, $value) = @_;
    if ((defined($lth{$key})) && 
	(($value eq "NA") || ($value < $lth{$key}))
       ) {
	return 0;
    }
    if ((defined($uth{$value})) && 
	(($value eq "NA") || ($value > $uth{$key}))
       ) {
	return 0;
    }
    return 1;
}


################################################################
## Print the start and end positions of the sequence
sub PrintSequenceLimits {
    my ($seq_id, $seq_len, $orig_pos) = @_;

    print $main::out join ("\t", 
			   $seq_id,
			   "limit",
			   "SEQ_START",
			   "DR",
			   1-$orig_pos,
			   1-$orig_pos,
			   ".",
			  ), "\n";
    print $main::out join ("\t", 
			   $seq_id,
			   "limit",
			   "SEQ_END",
			   "DR",
			   $seq_len-$orig_pos,
			   $seq_len-$orig_pos,
			   ".",
			  ), "\n";
}


__END__
    
=pod

=head1 SEE ALSO

=over

=item convert-matrix

=back

=cut
