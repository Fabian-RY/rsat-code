#!/usr/bin/perl
if ($config_site eq "dbm") {
    use lib '/a/YRT/lib', '/a/YRT/lib/arch';
}
if ($config_site eq "ebi") {
    use lib '/homes/jvanheld/rsa-tools/perl-scripts/lib',  
            '/homes/jvanheld/rsa-tools/perl-scripts/lib/arch';
}
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib.pl";

use GD;

$start_time = `date`;

if ($ARGV[0] eq "-h") {
  &PrintHelp;
  exit(0);
}
if ($ARGV[0] eq "-help") {
  &PrintShortHelp;
  exit(0);
}



##### initialize default parameters #####
$data_fields = "columns";
$bg = "white";
$verbose = 0;
$x_grids = 10;
$y_grids = 10;
$border = 10;
$x_scale_border = 40;
$y_scale_border = 20;
$x_axis_size = 400;
$y_axis_size = 400;
$point_size = 2;
@y_col_list = (1);
$x_col = 0;
$lines = 0;
$legend = 0;
$legend_size = 0;
$x_axis_max = "ND";
$y_axis_max = "ND";
$x_axis_min = "ND";
$y_axis_min = "ND";
$x = 0;
$y = 0;


#### font sizes ####
$small_font_width = 6;
$small_font_height = 8;
$large_font_width = 8;
$large_font_height = 16;

#### read arguments ####
foreach $a (0..$#ARGV) {
  
  ### input, output files ###
  if ($ARGV[$a] eq "-i") {
    $inputfile = $ARGV[$a+1];
  } elsif ($ARGV[$a] eq "-o") {
    $outputfile = $ARGV[$a+1];
    
    ### verbose ###
  } elsif ($ARGV[$a] eq "-v") {
    $verbose = 1;
    
    ### legends and titles ###
  } elsif (($ARGV[$a] eq "-title") || ($ARGV[$a] eq "-title1")) {
    $title1 = $ARGV[$a+1];
  } elsif ($ARGV[$a] eq "-title2") {
    $title2 = $ARGV[$a+1];
  } elsif ($ARGV[$a] eq "-xleg1") {
    $x_legend1 = $ARGV[$a+1];
  } elsif ($ARGV[$a] eq "-xleg2") {
    $x_legend2 = $ARGV[$a+1];
  } elsif ($ARGV[$a] eq "-yleg1") {
    $y_legend1 = $ARGV[$a+1];
  } elsif ($ARGV[$a] eq "-yleg2") {
    $y_legend2 = $ARGV[$a+1];
    
    ### grid steps ###
  } elsif (($ARGV[$a] eq "-gstep1") && ($ARGV[$a+1] =~ /^\d+(\.\d+){0,1}$/)){
    $y_grid_step1 = $ARGV[$a+1];
    $x_grid_step1 = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-xgstep1") && ($ARGV[$a+1] =~ /^\d+(\.\d+){0,1}$/)){
    $x_grid_step1 = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-ygstep1") && ($ARGV[$a+1] =~ /^\d+(\.\d+){0,1}$/)){
    $y_grid_step1 = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-gstep2") && ($ARGV[$a+1] =~ /^\d+(\.\d+){0,1}$/)){
    $y_grid_step2 = $ARGV[$a+1];
    $x_grid_step2 = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-xgstep2") && ($ARGV[$a+1] =~ /^\d+(\.\d+){0,1}$/)){
    $x_grid_step2 = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-ygstep2") && ($ARGV[$a+1] =~ /^\d+(\.\d+){0,1}$/)){
    $y_grid_step2 = $ARGV[$a+1];
    
    
    ### min and max values to represent ###
  } elsif (($ARGV[$a] eq "-max") && ($ARGV[$a+1] =~ /^[+-]{0,1}\d+(\.\d+){0,1}(E[+-]{0,1}\d+){0,1}$/i)){
    $x_axis_max = $ARGV[$a+1];
    $y_axis_max = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-xmax") && ($ARGV[$a+1] =~ /^[+-]{0,1}\d+(\.\d+){0,1}(E[+-]{0,1}\d+){0,1}$/i)){
    $x_axis_max = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-ymax") && ($ARGV[$a+1] =~ /^[+-]{0,1}\d+(\.\d+){0,1}(E[+-]{0,1}\d+){0,1}$/i)){
    $y_axis_max = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-min") && ($ARGV[$a+1] =~ /^[+-]{0,1}\d+(\.\d+){0,1}(E[+-]{0,1}\d+){0,1}$/i)){
    $x_axis_min = $ARGV[$a+1];
    $y_axis_min = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-xmin") && ($ARGV[$a+1] =~ /^[+-]{0,1}\d+(\.\d+){0,1}(E[+-]{0,1}\d+){0,1}$/i)){
    $x_axis_min = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-ymin") && ($ARGV[$a+1] =~ /^[+-]{0,1}\d+(\.\d+){0,1}(E[+-]{0,1}\d+){0,1}$/i)){
    $y_axis_min = $ARGV[$a+1];
    
    ### axis size (in pixels) ###
  } elsif (($ARGV[$a] eq "-xsize") && ($ARGV[$a+1] =~ /^\d+$/)){
    $x_axis_size = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-ysize") && ($ARGV[$a+1] =~ /^\d+$/)){
    $y_axis_size = $ARGV[$a+1];
  } elsif (($ARGV[$a] eq "-size") && ($ARGV[$a+1] =~ /^\d+$/)){
    $x_axis_size = $ARGV[$a+1];
    $y_axis_size = $ARGV[$a+1];
    
    
    ### backgreound color ####
  } elsif ($ARGV[$a] eq "-bg") {
    $bg = $ARGV[$a+1];
    
    ### monochrome output
  } elsif ($ARGV[$a] =~ /-mono/i) {
    $monochrome = 1;
    
    ### monochrome output
  } elsif ($ARGV[$a] =~ /-symb/i) {
    $symbols = 1;
    
    ### logarithmic representation
  } elsif ($ARGV[$a] eq "-xlog") {
    $xlog= 1;
  } elsif ($ARGV[$a] eq "-ylog") {
    $ylog= 1;
    
    
    ### histogram ###
  } elsif ($ARGV[$a] eq "-histo") {
    $histogram = 1;
    
    ### join points by lines ###
  } elsif ($ARGV[$a] eq "-lines") {
    $lines = 1;
    
    ### join points of a specific column by lines ###
  } elsif (($ARGV[$a] eq "-line") && (&IsNatural($ARGV[$a+1]))) {
    $lines[$ARGV[$a+1]-1] = 1;
    
    ### first input line contains Y data legends ###
  } elsif ($ARGV[$a] eq "-header") {
    $header = 1;
  } elsif ($ARGV[$a] eq "-legend") {
    $header = 1;
    $legend = 1;
    
    ### point size ###
  } elsif (($ARGV[$a] eq "-pointsize") && ($ARGV[$a+1] =~ /^\d+$/)){
    $point_size = $ARGV[$a+1];
    
    ### data columns ###  
  } elsif ($ARGV[$a] eq "-xcol") {
    $x_col = $ARGV[$a+1] -1; #indexes begin at 0
    
  } elsif ($ARGV[$a] eq "-ycol") {
    $y_col_string = $ARGV[$a+1];
    ### single column
    if (&IsNatural($ARGV[$a+1])) {
      @y_col_list = ();
      push @y_col_list, $ARGV[$a+1]-1;

      ### range of column
    } elsif (($ARGV[$a+1] =~ /(.*)\-(.*)/) &&
	     (&IsNatural($1)) &&
	     (&IsNatural($2)) && 
	     ($2 >= $1)) {
      @y_col_list = ();
      for $col ($1-1..$2-1) {
	push  @y_col_list, $col;
      }

      ### comma-separated list of columns
    } elsif ($ARGV[$a+1] =~ /\,/) {
      @y_col_list = split(/,/,$y_col_string);
      foreach $col (0..$#y_col_list) {
	if ($y_col_list[$col] =~ /\d+/) {
	  $y_col_list[$col]--; #indexes begin at 0
	} else {
	  print "	Invalid Y column specification.\n";
	  print "	Type XYgraph -h for help.\n";
	  exit;
	}
      }
    } else {
      print "	Invalid Y column specification.\n";
      print "	Type XYgraph -h for help.\n";
      exit;
    }
    
    ### highlight box ###
  } elsif (($ARGV[$a] eq "-hbox") && ($ARGV[$a+1] =~ /^(\d+),(\d+),(\d+),(\d+)$/)){
    $hbox_left = $1;
    $hbox_top = $2;
    $hbox_right = $3;
    $hbox_bottom = $4;
    
    ### threshold box ###
  } elsif (($ARGV[$a] eq "-tbox") && ($ARGV[$a+1] =~ /^(\d+),(\d+),(\d+),(\d+)$/)){
    $tbox_low_x = $1;
    $tbox_high_x = $2;
    $tbox_low_y = $3;
    $tbox_high_y = $4;
    
    ### data fields ####
  } elsif ($ARGV[$a] eq "-rows") {
    $data_fields = "rows";
  } elsif ($ARGV[$a] eq "-columns")  {
    $data_fields = "columns";
    
    ### HTML map ###
  } elsif ($ARGV[$a] eq "-htmap") {
    $HTML_map = 1;

    ### label column
  } elsif (($ARGV[$a] eq "-lc") && (&IsNatural($ARGV[$a+1]))) {
    $label_col = $ARGV[$a+1];
    
  }
  
}


#### check parameter values ####
if ($HTML_map) {
  $verbose = 0;
}		 

#### if log representation, check user=entered axis values  ###
if ($xlog) {
  if (x_axis_max ne "ND") {
    if ($x_axis_max > 0) {
      $x_axis_max = log($x_axis_max);
    } else {
      $x_axis_max = "ND";
    }
  }
  if (x_axis_min ne "ND") {
    if ($x_axis_min > 0) {
      $x_axis_min = log($x_axis_min);
    } else {
      $x_axis_min = "ND";
    }
  }
}

if ($ylog) {
  if (y_axis_max ne "ND") {
    if ($y_axis_max > 0) {
      $y_axis_max = log($y_axis_max);
    } else {
      $y_axis_max = "ND";
    }
  }
  if (y_axis_min ne "ND") {
    if ($y_axis_min > 0) {
      $y_axis_min = log($y_axis_min);
    } else {
      $y_axis_min = "ND";
    }
  }
}

#### open output file ####
$out = &OpenOutputFile($outputfile);
&InitHTMLmap if ($HTML_map);  

&ReadData;
&CalcLimits;
  
#### convert tbox into an hbox ###
if ($tbox_low_x ne "") {
  $hbox_left = XPixelPos($tbox_low_x);
  $hbox_right = XPixelPos($tbox_high_x);
  $hbox_top = YPixelPos($tbox_high_y); 
  $hbox_bottom = YPixelPos($tbox_low_y); 
}

### check hbox dimensions ###
if ($hbox_left ne "") {
  if ($hbox_left < $left) {
    $hbox_left = $left
  } elsif ($hbox_left > $right) {
    $hbox_left = $right;
  }
  if ($hbox_right < $left) {
    $hbox_right = $left
  } elsif ($hbox_right > $right) {
    $hbox_right = $right;
  }
  if ($hbox_top < $top) {
    $hbox_top = $top
  } elsif ($hbox_top > $bottom) {
    $hbox_top = $bottom;
  }
  if ($hbox_bottom < $top) {
    $hbox_bottom = $top
  } elsif ($hbox_bottom > $bottom) {
    $hbox_bottom = $bottom;
  }
#### convert hbox into a tbox ###
  $tbox_low_x = ($hbox_left - $border)/$x_scale + $x_axis_min;
  $tbox_high_x = ($hbox_right - $border)/$x_scale + $x_axis_min;
  $tbox_high_y = ($hbox_top - $graph_y_size + $border)/$y_scale + $y_axis_min; 
  $tbox_low_y = ($hbox_bottom - $graph_y_size + $border)/$y_scale + $y_axis_min; 
}

#### report graph parameters ####
if ($verbose) {
    print "; XYgraph";
    foreach $a (@ARGV) {
	if (($a =~ /\S+\s+\S+/) || ($a !~ /\S/)){
	    print " '$a'";
	} else {
	    print " $a";
        }
    }
    print "\n";
    print ";Files\n";
    print ";	input file 	$inputfile\n";
    print ";	output file 	$outputfile\n";
    print ";General options\n";
    print ";	1st title	$title1\n";
    print ";	2nd title	$title2\n";
    print ";	border		$border\n";
    print ";	point size	$point_size\n";
    if ($hbox_left ne "") {
	print ";	highlight box	left: $hbox_left, top: $hbox_top, right: $hbox_right, bottom: $hbox_bottom\n";
    }
    if ($tbox_low_x ne "") {
	print ";	threshold box	X data between $tbox_low_x and $tbox_high_x\n";
	print ";			Y data between $tbox_low_y and $tbox_high_y\n";
    }
    print ";X data\n";
    print ";	first X legend  ", $x_legend1, "\n";
    print ";	second X legend ", $x_legend2, "\n";
    print ";	X data column	", $x_col+1, "\n";
    print ";	nb of x values  ", $#X_values+1, "\n";
    print ";	min x value	$min_x_value\n";
    print ";	max x value	$max_x_value\n";
    print ";	X axis min	$x_axis_min\n";
    print ";	X axis max	$x_axis_max\n";
    print ";	X axis size	$x_axis_size\n";
    print ";	X scale		$x_scale\n";
    print ";	graph X size	$graph_x_size\n";
    print ";	left		$left\n";
    print ";	right		$right\n";
    print ";	1st X grid step	$x_grid_step1\n";
    print ";	2nd X grid step	$x_grid_step2\n";
    print ";Y data\n";
    print ";	first Y legend  ", $y_legend1, "\n";
    print ";	second Y legend ", $y_legend2, "\n";
    print ";	Y data colum(s)\t";
    foreach $c (0..$#y_col_list -1) {
	print $y_col_list[$c] +1, ", ";
    }
    print $y_col_list[$#y_col_list]+1, "\n";
    print ";	Y data legend(s) ";
    for $series (0..$#y_col_list-1) {
	print "$legend_fields[$y_col_list[$series]], ";
    }
    print "$legend_fields[$y_col_list[$#y_col_list]]\n";

    print ";	min y value	$min_y_value\n";
    print ";	max y value	$max_y_value\n";
    print ";	Y axis min	$y_axis_min\n";
    print ";	Y axis max	$y_axis_max\n";
    print ";	Y axis size	$y_axis_size\n";
    print ";	Y scale		$y_scale\n";
    print ";	graph Y size	$graph_y_size\n";
    print ";	1st Y grid step	$y_grid_step1\n";
    print ";	2nd Y grid step	$y_grid_step2\n";
}

### create new image ####
$image = new GD::Image($graph_x_size, $graph_y_size);
&AssignColors;
$image->filledRectangle(0,0,$graph_x_size, $graph_y_size, $bg_color);  

#### draw grid and limits ####


### second X grid
if ($x_grid_step2 > 0) {
    for ($g = $x_axis_min; $g <= $x_axis_max; $g += $x_grid_step2) {
	$grid_pos = $left + ($g-$x_axis_min)*$x_scale;
        $image->line($grid_pos, $bottom, $grid_pos, $top, $grid2_color);
    }
}

### second Y grid
if ($y_grid_step2 > 0) {
  for ($g = $y_axis_min; $g <= $y_axis_max; $g += $y_grid_step2) {
    $grid_pos = YPixelPos($g);
    $image->line($left, $grid_pos, $right, $grid_pos, $grid2_color);
  }
}


### first X grid
if ($x_grid_step1 > 0) {
  for ($g = $x_axis_min; $g <= $x_axis_max; $g += $x_grid_step1) {
    $grid_pos = $left + ($g-$x_axis_min)*$x_scale;
     if ($xlog) {
     $grid_value = exp($g);
    } else {
      $grid_value = $g;
    }
    $grid_text = $grid_value;
   $image->line($grid_pos, $bottom, $grid_pos, $top, $grid1_color);
     $image->string(gdSmallFont, $grid_pos - $small_font_width*length($grid_text)/2, $bottom + 5, $grid_text, $text_color);
  }
}

### first Y grid
if ($y_grid_step1 > 0) {
  for ($g = $y_axis_min; $g <= $y_axis_max; $g += $y_grid_step1) {
    $grid_pos = YPixelPos($g);
    if ($ylog) {
      $grid_value = exp($g);
    } else {
      $grid_value = $g;
    }
    $grid_text = sprintf("%6g", $grid_value);
    $image->line($left, $grid_pos, $right, $grid_pos, $grid1_color);
    $image->string(gdSmallFont, $left - $small_font_width * length($grid_text) - 5, $grid_pos - $small_font_height/2, $grid_text, $text_color);
  }
}

### draw axes
$image->line($left, $bottom, $left, $top, $axis_color);
$image->line($left, $bottom, $right, $bottom, $axis_color);


#### draw highlight box ####
unless ($hbox_left eq ""){
  $image->filledRectangle($hbox_left, $hbox_top, $hbox_right, $hbox_bottom, $highlight_box_color);
}


#### draw dots ####
for $series (0..$#y_col_list) {
  $prev_x = "ND";
  $prev_y = "ND";
  $current_color = $color_list[$series%($#color_list+1)];
  $current_symbol =  $symbol_list[$series%($#symbol_list+1)];

  for $p (0..$#X_values) {
    if (($X_values[$p] eq "ND") || ($Y_values[$series][$p] eq "ND")) {
      $bar_left = "ND";
      $bar_right = "ND";
      $x = "ND";
      $y = "ND";
    } else {
    
      ### position of the next point ###
      if ($histogram) {
        if ($p == 0) {
          $bar_left = $left;
        } else {
          $bar_left = XPixelPos(($X_values[$p] + $X_values[$p-1])/2);
        }
        if ($p == $#X_values-1) {
          $bar_right = $right;
        } else {
          $bar_right = &XPixelPos(($X_values[$p] + $X_values[$p+1])/2);
        }
      } else {
        $x = XPixelPos($X_values[$p]);
      }
      $y = YPixelPos($Y_values[$series][$p]);

      ### check whether next point lies in the highlight box ###
      if (($hbox_left ne "") && 
            ($x >= $hbox_left) &&
            ($x <= $hbox_right) &&
            ($y >= $hbox_top) &&
            ($y <= $hbox_bottom))  {
        $current_color = $hilight_color;
        print "$data_lines[$p]";
      }
      
      ### draw the point (and the line if required) ###
      if ($histogram) {
        if (($bar_left ne "ND") && ($bar_right ne "ND")) {
          $image->line($bar_left, $y, $bar_right, $y, $current_color);
          if (($prev_bar_right ne "ND") && ($prev_y ne "ND")) {
             $image->line($prev_bar_right, $prev_y, $bar_left, $y, $current_color);
           }
         }
      } else {
        if (($x ne "ND") && ($y ne "ND")) {
	    DrawSymbol($current_symbol,$x-$point_size/2,$y-$point_size/2,$x+$point_size/2,$y+$point_size/2,$current_color);
#          $image->arc($x,$y,$point_size,$point_size,0,360,$current_color);
	    if (($HTML_map) && ($p < $max_map_elements)) {
	      my $series_legend = $legend_fields[$y_col_list[$series]];
	      
	      my $point_label = $data_lines[$p];
	      $point_label =~ s/\'/prime/g;	      
	      $point_label =~ s/\t/    /g;	      
	      $point_label =~ s/\n/ /g;	      

	      my $coord = sprintf "($X_values[$p],$Y_values[$series][$p])";

	      my $map_message = "$series_legend\t$p\t$coord\t$point_label";

	      #### area over the point
	      print "\t<area ";
	      print "href=\"$href\" ";
	      print "onMouseOver=\"window.status=\'$map_message\' ;return true\" ";
	      print "shape=rect ";
	      print "coords=\"",int($x-$point_size/2) , ",", int($y-$point_size/2), ",",int($x+$point_size/2), ",",int($y+$point_size/2), "\">\n";
	    }
	    if ((($lines) || ($lines[$y_col_list[$series]])) 
		&& ($prev_x ne "ND") && ($prev_y ne "ND")) {
	      $image->line($prev_x, $prev_y, $x, $y, $current_color);
	    }
	  } 
      } #if historgram
    } # values are determined
    
    if ($histogram) {
      $prev_bar_right = $bar_right;
    } else {
      $prev_x = $x;
    }
    $prev_y = $y;
  } # for p
} # for series

#### draw graph legends and titles ####
$title1_x_pos = ($graph_x_size - $large_font_width * length($title1))/2;
if ($title1_x_pos < 0) {
  $title1_x_pos = 0;
}
$title1_y_pos = $border;
$title2_x_pos = ($graph_x_size - $large_font_width * length($title2))/2;
if ($title2_x_pos < 0) {
  $title2_x_pos = 0;
}
$title2_y_pos = $title1_y_pos + $large_font_height + 2;
$x_legend1_x_pos = $left + ($x_axis_size - length($x_legend1) * $small_font_width)/2;
$x_legend1_y_pos = $top + $y_axis_size + 12 + $small_font_height;
$x_legend2_x_pos = $left + ($x_axis_size - length($x_legend2) * $small_font_width)/2;
$x_legend2_y_pos = $x_legend1_y_pos + 3 + $small_font_height;
$y_legend1_x_pos = $border;
$y_legend1_y_pos = $top + ($y_axis_size + length($y_legend1) * $small_font_width)/2;
$y_legend2_x_pos = $y_legend1_x_pos + 3 + $small_font_height;
$y_legend2_y_pos = $top + ($y_axis_size + length($y_legend2) * $small_font_width)/2;
$image->string(gdLargeFont, $title1_x_pos, $title1_y_pos, $title1, $text_color);
$image->string(gdLargeFont, $title2_x_pos, $title2_y_pos, $title2, $text_color);
$image->string(gdSmallFont, $x_legend1_x_pos, $x_legend1_y_pos, $x_legend1, $text_color);
$image->string(gdSmallFont, $x_legend2_x_pos, $x_legend2_y_pos, $x_legend2, $text_color);
$image->stringUp(gdSmallFont, $y_legend1_x_pos, $y_legend1_y_pos, $y_legend1, $text_color);
$image->stringUp(gdSmallFont, $y_legend2_x_pos, $y_legend2_y_pos, $y_legend2, $text_color);


#### draw the legend ####
if ($legend) {
    $legend_point_size = &max(5,$point_size);
    $legend_x_pos = $right + $legend_point_size + 20;
    $point_x_pos = $right + 10;
    $line_spacing = &max($small_font_height, $legend_point_size) + 6;
    
    $series = 0; 
    $legend_y_pos = 0;
    while ($series <= $#y_col_list) {
	$current_color = $color_list[$series%($#color_list+1)];
	$current_symbol =  $symbol_list[$series%($#symbol_list+1)];
	if ($legend_fields[$y_col_list[$series]] ne "") {
	    $legend_y_pos = $top + $series*$line_spacing;
	    last if ($legend_y_pos >= $graph_y_size - $small_font_height);
	    $point_y_pos = $legend_y_pos + $small_font_height/2 + 3 - $legend_point_size/2;
	    DrawSymbol($current_symbol,$point_x_pos,$point_y_pos,$point_x_pos+$legend_point_size,$point_y_pos+$legend_point_size,$current_color);
	    $image->string(gdSmallFont, $legend_x_pos, $legend_y_pos, $legend_fields[$y_col_list[$series]], $text_color);
	}
	$series++;
    }
}


#### print output ####
print $out $image->gif;
if ($outputfile ne "") {
  close $out;
}
&CloseHTMLmap if ($HTML_map);

if ($verbose) {
  print ";Job started $start_time";
  print ";Job done    ", `date`;

}

exit(0);



####################################################################
######################## SUBROUTINE DEFINITION #####################
####################################################################


#### calculation of pixel position
sub XPixelPos {
    local($x_pos) = $_[0];
    local($x_pixel_pos);
    if (($x_pos < $x_axis_min) or ($x_pos > $x_axis_max)) {
	$x_pixel_pos = "ND";
    } else {
	$x_pixel_pos = $left + ($x_pos - $x_axis_min)*$x_scale;
    }
    return $x_pixel_pos;
}

sub YPixelPos {
    local($y_pos) = $_[0];
    local($y_pixel_pos);
    if (($y_pos < $y_axis_min) or ($y_pos > $y_axis_max)) {
	$y_pixel_pos = "ND";
    } else {
	$y_pixel_pos = $bottom - ($y_pos - $y_axis_min)*$y_scale;
    }
    return $y_pixel_pos;
}

#### color allocation ####
sub AssignColors {
    ### gray scale
#    $black = $image->colorAllocate(0,0,0);
#    $white = $image->colorAllocate(255,255,255);
#
#    $gray_032 = $image->colorAllocate(32,32,32);
#    $gray_064 = $image->colorAllocate(64,64,64);
#    $gray_096 = $image->colorAllocate(96,96,96);
#    $gray_125 = $image->colorAllocate(128,128,128);
#    $gray_150 = $image->colorAllocate(150,150,150);
#    $gray_175 = $image->colorAllocate(175,175,175);
#    $gray_200 = $image->colorAllocate(200,200,200);
#    $gray_225 = $image->colorAllocate(225,225,225);
#
#    $green = $image->colorAllocate(0,255,0);
#    $green_175 = $image->colorAllocate(0,175,0);
#    $green_128 = $image->colorAllocate(0,128,0);
#
#    $red = $image->colorAllocate(255,0,0);
#    $red_128 = $image->colorAllocate(128,0,0);
#
#    $blue_064 =  $image->colorAllocate(0,0,64);
#    $blue_096 =  $image->colorAllocate(0,0,96);
#    $blue_128 = $image->colorAllocate(0,0,128);
#    $blue_175 = $image->colorAllocate(0,0,175);
#    $blue_200 =  $image->colorAllocate(0,0,200);
#    $blue_225 =  $image->colorAllocate(0,0,225);
#    $blue = $blue = $image->colorAllocate(0,0,255);
#
#    $cyan = $image->colorAllocate(0,255,255);
#    $cyan_pale_064 = $image->colorAllocate(64,255,255);
#    $cyan_pale_096 = $image->colorAllocate(96,255,255);
#    $cyan_pale_128 = $image->colorAllocate(128,255,255);
#    $cyan_dark = $image->colorAllocate(0,128,128);
#
#    $magenta = $image->colorAllocate(255,0,255);
#    $magenta_pale_064 = $image->colorAllocate(255,64,255);
#    $magenta_pale_096 = $image->colorAllocate(255,96,255);
#    $magenta_pale_128 = $image->colorAllocate(255,128,255);
#    $magenta_dark = $image->colorAllocate(128,0,128);
#
#    $yellow_pale_064 = $image->colorAllocate(255,255,64);
#    $yellow_pale_096 = $image->colorAllocate(255,255,96);
#    $yellow_pale_128 = $image->colorAllocate(255,255,128);
#    $yellow_pale = $image->colorAllocate(255,255,200);
#    $yellow_light = $image->colorAllocate(255,255,150);
#   $yellow = $image->colorAllocate(255,255,0);
#    $yellow_dark = $image->colorAllocate(191,191,0);
#
#    $brown = $image->colorAllocate(128,128,0);
#    $pink = $image->colorAllocate(255,150,180);
#    $champagne = $image->colorAllocate(255,240,200);
#
#    $hilight_color = $red;
#    $highlight_box_color = $yellow;

    &StandardPalette;

    @color_list = ();
    if ($bg eq "black") {
	$bg_color = $black;
	$grid1_color = $gray_150;
	$grid2_color = $gray_064;
	$text_color = $white;
	$axis_color = $white;
	if ($monochrome) {
	    push(@color_list, $white);
	} else {
	    push(@color_list, $cyan_pale_064);
	    push(@color_list, $magenta_pale_096);
	    push(@color_list, $yellow_pale_096);
	    push(@color_list, $white);
	    push(@color_list, $champagne);
	    push(@color_list, $magenta);
	    push(@color_list, $green);
	    push(@color_list, $red);
	    push(@color_list, $yellow_light);
	}
    } elsif ($bg eq "blue") {
	$bg_color = $blue_128;
	$grid1_color = $blue;
	$grid2_color = $blue_175;
	$text_color = $white;
	$axis_color = $blue;
	push(@color_list, $yellow_pale_096);
	push(@color_list, $cyan_pale_064);
	push(@color_list, $magenta_pale_064);
	push(@color_list, $yellow_light);
	push(@color_list, $champagne);
	push(@color_list, $white);
	push(@color_list, $magenta);
	push(@color_list, $green);
	push(@color_list, $red);
    } else { #### light background, dark foreground
	$text_color = $black;
	$axis_color = $black;
	if ($bg eq "gray") {
	    $bg_color = $gray_200;
	    $grid1_color = $white;
	    $grid2_color = $gray_225;
	} else {
	    $bg_color = $white;
	    $grid1_color = $gray_175;
	    $grid2_color = $gray_225;
	}
	if ($monochrome) {
	    push(@color_list, $black);
	} else {
### here
	    push @color_list, $blue;
	    push @color_list, $red;
	    push @color_list, $green_175;
	    push @color_list, $pink;
	    push @color_list, $cyan_200;
	    push @color_list, $orange;
	    push @color_list, $violet;
	    push @color_list, $gray_125;
	    push @color_list, $brown;
	    push @color_list, $black;
	    push @color_list, $yellow_225;
	    push @color_list, $cyan;
	    push @color_list, $pistache;
	    push @color_list, $magenta;
	    push @color_list, $green;
	    push @color_list, $green_128;
	    push @color_list, $gray_150;
	    push @color_list, $red_191;
	    push @color_list, $blue_128;
	    push @color_list, $cyan_096;
	    
	    push @color_list, $blue_096;
	    push @color_list, $red_096;
	    push @color_list, $blue_064;
	    push @color_list, $gray_064;

#	    push(@color_list, $blue);
#	    push(@color_list, $red);
#	    push(@color_list, $magenta);
#	    push(@color_list, $green_175);
#	    push(@color_list, $brown);
#	    push(@color_list, $black);
#	    push(@color_list, $cyan_dark);
#	    push(@color_list, $magenta_dark);
#	    push(@color_list, $gray_064);
#	    push(@color_list, $blue_175);
#	    push(@color_list, $green_128);
#	    push(@color_list, $gray_125);
#	    push(@color_list, $cyan);
	}
    }

    if (($monochrome) || ($symbols)){
	#### define symbol list ####
	push(@symbol_list, "filled_circle");
	push(@symbol_list, "filled_rectangle");
	push(@symbol_list, "filled_butterfly");
	push(@symbol_list, "filled_triangle1");
	push(@symbol_list, "rectangle");
	push(@symbol_list, "circle");
	push(@symbol_list, "cross1");
	push(@symbol_list, "cross2");
	push(@symbol_list, "filled_triangle2");
	push(@symbol_list, "filled_triangle3");
	push(@symbol_list, "filled_triangle4");
	push(@symbol_list, "vbars");
	push(@symbol_list, "hbars");
	push(@symbol_list, "triangle1");
	push(@symbol_list, "triangle2");
	push(@symbol_list, "triangle3");
	push(@symbol_list, "triangle4");
	push(@symbol_list, "butterfly");
	push(@symbol_list, "crossrect1");
	push(@symbol_list, "crossrect2");
	push(@symbol_list, "crosscircle1");
	push(@symbol_list, "crosscircle2");
    } else {
	push(@symbol_list, "filled_circle");
    }
}


#### Draw symbol ####
sub DrawSymbol {
### usage
### DrawSymbol($symbol_type,$symbol_left,$symbol_top,$symbol_right,$symbol_bottom,$symbol_color);
    local($s_type) = $_[0];
    local($s_left) = $_[1];
    local($s_top) = $_[2];
    local($s_right) = $_[3];
    local($s_bottom) = $_[4];
    local($s_color) = $_[5];
    local($s_x_center) = ($s_left + $s_right)/2;
    local($s_y_center) = ($s_top + $s_bottom)/2;
    local($s_width) = abs($s_right - $s_left) + 1;
    local($s_height) = abs($s_top - $s_bottom) + 1;

    if ($s_type eq "rectangle") {
      $image->rectangle($s_left, $s_top, $s_right, $s_bottom, $s_color);

    } elsif ($s_type eq "filled_rectangle") {
      $image->filledRectangle($s_left, $s_top, $s_right, $s_bottom, $s_color);

    } elsif ($s_type eq "filled_butterfly") {
      $image->line($s_left, $s_top, $s_right, $s_bottom, $s_color);
      $image->line($s_left, $s_bottom, $s_right, $s_top, $s_color);
      $image->line($s_right, $s_top, $s_right, $s_bottom, $s_color);
      $image->line($s_left, $s_top, $s_left, $s_bottom, $s_color);
      $image->fillToBorder($s_left+1,$s_y_center,$s_color,$s_color);
      $image->fillToBorder($s_right-1,$s_y_center,$s_color,$s_color);

    } elsif ($s_type eq "butterfly") {
      $image->line($s_left, $s_top, $s_right, $s_bottom, $s_color);
      $image->line($s_left, $s_bottom, $s_right, $s_top, $s_color);
      $image->line($s_right, $s_top, $s_right, $s_bottom, $s_color);
      $image->line($s_left, $s_top, $s_left, $s_bottom, $s_color);

    } elsif ($s_type eq "triangle2") {
      $image->line($s_left, $s_y_center, $s_right, $s_bottom, $s_color);
      $image->line($s_right, $s_bottom, $s_right, $s_top, $s_color);
      $image->line($s_left, $s_y_center, $s_right, $s_top, $s_color);

    } elsif ($s_type eq "filled_triangle2") {
      $image->line($s_left, $s_y_center, $s_right, $s_bottom, $s_color);
      $image->line($s_right, $s_bottom, $s_right, $s_top, $s_color);
      $image->line($s_left, $s_y_center, $s_right, $s_top, $s_color);
      $image->fillToBorder($s_x_center,$s_y_center,$s_color,$s_color);

    } elsif ($s_type eq "triangle1") {
      $image->line($s_left, $s_bottom, $s_right, $s_y_center, $s_color);
      $image->line($s_left, $s_bottom, $s_left, $s_top, $s_color);
      $image->line($s_right, $s_y_center, $s_left, $s_top, $s_color);

    } elsif ($s_type eq "filled_triangle1") {
      $image->line($s_left, $s_bottom, $s_right, $s_y_center, $s_color);
      $image->line($s_left, $s_bottom, $s_left, $s_top, $s_color);
      $image->line($s_right, $s_y_center, $s_left, $s_top, $s_color);
      $image->fillToBorder($s_x_center,$s_y_center,$s_color,$s_color);

    } elsif ($s_type eq "triangle3") {
      $image->line($s_left, $s_bottom, $s_right, $s_bottom, $s_color);
      $image->line($s_left, $s_bottom, $s_x_center, $s_top, $s_color);
      $image->line($s_x_center, $s_top, $s_right, $s_bottom, $s_color);

    } elsif ($s_type eq "filled_triangle3") {
      $image->line($s_left, $s_bottom, $s_right, $s_bottom, $s_color);
      $image->line($s_left, $s_bottom, $s_x_center, $s_top, $s_color);
      $image->line($s_x_center, $s_top, $s_right, $s_bottom, $s_color);
      $image->fillToBorder($s_x_center,$s_y_center,$s_color,$s_color);

    } elsif ($s_type eq "triangle4") {
      $image->line($s_left, $s_top, $s_right, $s_top, $s_color);
      $image->line($s_left, $s_top, $s_x_center, $s_bottom, $s_color);
      $image->line($s_x_center, $s_bottom, $s_right, $s_top, $s_color);

    } elsif ($s_type eq "filled_triangle4") {
      $image->line($s_left, $s_top, $s_right, $s_top, $s_color);
      $image->line($s_left, $s_top, $s_x_center, $s_bottom, $s_color);
      $image->line($s_x_center, $s_bottom, $s_right, $s_top, $s_color);
      $image->fillToBorder($s_x_center,$s_y_center,$s_color,$s_color);

    } elsif ($s_type eq "circle") {
      $image->arc($s_x_center,$s_y_center,$s_width,$s_height,0,360,$s_color);

    } elsif ($s_type eq "filled_circle") {
      $image->arc($s_x_center,$s_y_center,$s_width,$s_height,0,360,$s_color);
      $image->fillToBorder($s_x_center,$s_y_center,$s_color,$s_color);

    } elsif ($s_type eq "crossrect1") {
      $image->rectangle($s_left, $s_top, $s_right, $s_bottom, $s_color);
      $image->line($s_left, $s_bottom, $s_right, $s_top, $s_color);
      $image->line($s_left, $s_top, $s_right, $s_bottom, $s_color);

    } elsif ($s_type eq "crossrect2") {
      $image->rectangle($s_left, $s_top, $s_right, $s_bottom, $s_color);
      $image->line($s_left, $s_y_center, $s_right, $s_y_center, $s_color);
      $image->line($s_x_center, $s_top, $s_x_center, $s_bottom, $s_color);

    } elsif ($s_type eq "crosscircle2") {
      $image->arc($s_x_center,$s_y_center,$s_width,$s_height,0,360,$s_color);
      $image->line($s_left, $s_bottom, $s_right, $s_top, $s_color);
      $image->line($s_left, $s_top, $s_right, $s_bottom, $s_color);

    } elsif ($s_type eq "crosscircle1") {
      $image->arc($s_x_center,$s_y_center,$s_width,$s_height,0,360,$s_color);
      $image->line($s_left, $s_y_center, $s_right, $s_y_center, $s_color);
      $image->line($s_x_center, $s_top, $s_x_center, $s_bottom, $s_color);

    } elsif ($s_type eq "cross1") {
      $image->line($s_left, $s_bottom, $s_right, $s_top, $s_color);
      $image->line($s_left, $s_top, $s_right, $s_bottom, $s_color);

    } elsif ($s_type eq "cross2") {
      $image->line($s_left, $s_y_center, $s_right, $s_y_center, $s_color);
      $image->line($s_x_center, $s_top, $s_x_center, $s_bottom, $s_color);

    } elsif ($s_type eq "vbars") {
      for ($h = $s_left; $h <= $s_right; $h += 2) {
        $image->line($h, $s_top, $h, $s_bottom, $s_color);
      }

    } elsif ($s_type eq "hbars") {
      for ($h = $s_top; $h <= $s_bottom; $h += 2) {
        $image->line($s_left, $h, $s_right, $h, $s_color);
      }
    }
}



sub AutoGrid {
### usage
### ($grid_min, $grid_step, $grid_max) = &AutoGrid($min_value, $max_value);
    local($min_value) = $_[0];
    local($max_value) = $_[1];

    local($range);
    local($range_order);
    local($grid_step);
    local($grid_min);
    local($grid_max);

    $range = abs($min_value -$max_value);
    $range_order = int(log($range)/log(10));
    if ($range_order < 0) {
		$range_order -= 1;
    }
    $grid_step = 10**$range_order;
    while ($range < 5*$grid_step) {
		$grid_step /=2;
		$grid_step =~ s/25/20/;
		$grid_step =~ s/2\.5/2\.0/;
    }

    if ($min_value >= 0) {
		$grid_min = int($min_value/$grid_step) * $grid_step;
    } else {
		$grid_min = (int($min_value/$grid_step) -1)* $grid_step;
    }
	
	$grid_max = (int($max_value/$grid_step)+1)*$grid_step;
	
    return($grid_min, $grid_step, $grid_max);
}


sub StandardPalette {
    ### black and white
    $white = $image->colorAllocate(255,255,255);
    $black = $image->colorAllocate(0,0,0);

    ### gray series
    $gray_032 = $image->colorAllocate(32,32,32);
    $gray_064 = $image->colorAllocate(64,64,64);
    $gray_096 = $image->colorAllocate(96,96,96);
    $gray_125 = $image->colorAllocate(125,125,125);
    $gray_150 = $image->colorAllocate(150,150,150);
    $gray_175 = $image->colorAllocate(175,175,175);
    $gray_200 = $image->colorAllocate(200,200,200);
    $gray_225 = $image->colorAllocate(225,225,225);

    ### yellow series
    $yellow = $image->colorAllocate(255,255,0);
    $yellow_225 = $image->colorAllocate(225,225,0);
    $yellow_200 = $image->colorAllocate(200,200,0);
    $yellow_128 = $image->colorAllocate(128,128,0);
    $yellow_light = $image->colorAllocate(255,255,150);
    $yellow_pale = $image->colorAllocate(255,255,200);
    $yellow_pale_064 = $image->colorAllocate(255,255,64);
    $yellow_pale_096 = $image->colorAllocate(255,255,96);
    $yellow_pale_128 = $image->colorAllocate(255,255,128);


    ### green series
    $green = $image->colorAllocate(0,255,0);
    $green_200 = $image->colorAllocate(0,200,0);
    $green_175 = $image->colorAllocate(0,175,0);
    $green_128 = $image->colorAllocate(0,128,0);
    $green_096 = $image->colorAllocate(0,96,0);
    $green_064 = $image->colorAllocate(0,64,0);

    ### cyan series
    $cyan = $image->colorAllocate(0,255,255);
    $cyan_200 = $image->colorAllocate(0,200,200);
    $cyan_128 = $image->colorAllocate(0,128,128);
    $cyan_096 = $image->colorAllocate(0,96,96);
    $cyan_pale_064 = $image->colorAllocate(64,255,255);
    $cyan_pale_096 = $image->colorAllocate(96,255,255);
    $cyan_pale_128 = $image->colorAllocate(128,255,255);

    ### blue series
    $blue = $image->colorAllocate(0,0,250);
    $blue_064 = $image->colorAllocate(0,0,64);
    $blue_096 = $image->colorAllocate(0,0,96);
    $blue_128 = $image->colorAllocate(0,0,128);
    $blue_175 = $image->colorAllocate(0,0,175);
    $blue_191 = $image->colorAllocate(0,0,191);
    $blue_200 = $image->colorAllocate(0,0,200);

    ### magenta
    $magenta = $image->colorAllocate(255,0,255);
    $magenta_191 = $image->colorAllocate(191,0,191);
    $magenta_pale_064 = $image->colorAllocate(255,64,255);
    $magenta_pale_096 = $image->colorAllocate(255,96,255);
    $magenta_pale_128 = $image->colorAllocate(255,128,255);


    ### red series
    $red = $image->colorAllocate(255,0,0);
    $red_191 = $image->colorAllocate(191,0,0);
    $red_128 = $image->colorAllocate(128,0,0);
    $red_096 = $image->colorAllocate(96,0,0);
    $red_064 = $image->colorAllocate(64,0,0);

    ### mscellaneous
    $pink = $image->colorAllocate(255,70,120);
    $orange = $image->colorAllocate(255,100,0);
    $violet = $image->colorAllocate(120,0,200);
    $brown = $image->colorAllocate(100,31,31);
    $pistache = $image->colorAllocate(100,225,150);
    $violet_pale = $image->colorAllocate(230, 215, 255);
    $pink_pale = $image->colorAllocate(255,230,210);
    $champagne = $image->colorAllocate(255,240,200);
    $pistache_pale = $image->colorAllocate(200,255,200);
}



#### read data ####
sub ReadData {
  $in = &OpenInputFile($inputfile);

  if ($data_fields eq "columns") {
    #### read legend ####
    if ($header) {
      $legend_line = <$in>;
      unless ($legend_line =~ /\t/) {   # if there are no tabs,
	$legend_line =~ s/ {1,}/\t/g; # single or multiple spaces are considered as a singlew tab
      }
      @legend_fields = split(/[\t\n\r]/, $legend_line);
      ### calculate legend width ###
      $legend_length = 0;
      for $series (0..$#y_col_list) {
	$new_length = length($legend_fields[$y_col_list[$series]]);
	$legend_length = &max($legend_length,$new_length);
      }
      $legend_size = $legend_length * $small_font_width + $point_size + 20;
    }
    
    ### read X and Y values ###
    while ($new_data_line = <$in>) {
      next if ($new_data_line =~ /^;/);
      next unless ($new_data_line =~ /\S/);
      
      
      if ($new_data_line =~ /\t/) {  # if column delimiter is the tab character
	$new_data_line =~ s/ //g; # remove all blank spaces
      } else { # if there are no tabs,
	$new_data_line =~ s/ +/\t/g; # single or multiple spaces are considered as a single tab
      }
      
      $new_data_line =~ s/\,//g; # remove all commas
      @data_fields = split(/[\t\n\r]/, $new_data_line);
      
      if (IsReal($data_fields[$x_col])) {
	if ($xlog)  {
	  if ($data_fields[$x_col] > 0) {
	    $new_x = log($data_fields[$x_col]);
	  } else {
	    $new_x = "ND";
	  }
	} else {
	  $new_x = $data_fields[$x_col];
	}
	push (@X_values, $new_x);
	if ($label_col > 0) {
	  push @data_lines, @data_fields[$label_col -1];
	} else {
	  push @data_lines, $new_data_line;
	}
	for $series (0..$#y_col_list) {
	  if ((IsReal($data_fields[$y_col_list[$series]]))) {
	    if ($ylog) {
	      if ($data_fields[$y_col_list[$series]] > 0) {
		$Y_values[$series][$#X_values] = log($data_fields[$y_col_list[$series]]); 
	      } else {
		$Y_values[$series][$#X_values] = "ND";
	      }
	    } else {
	      $Y_values[$series][$#X_values] = $data_fields[$y_col_list[$series]]; 
	    }    
	  } else {
	    $Y_values[$series][$#X_values] = "ND";
	  } 
	} 
      }
    }    
  } else { ### data fields in rows
    $line_nb = -1;
    
    $xline = $x_col;
    foreach $c (0..$#y_col_list) {
      $yline{$y_col_list[$c]} = $c;
    }
    
    
    while ($new_data_line = <$in>) {
      next if ($new_data_line =~ /^;/);
      next unless ($new_data_line =~ /\S/);
      $line_nb++;
      
      next unless (($line_nb == $xline) || (defined($yline{$line_nb})));
      
      ### split data line
      if ($new_data_line =~ /\t/) {  # if column delimiter is the tab character
	$new_data_line =~ s/ //g; # remove all blank spaces
      } else { # if there are no tabs,
	$new_data_line =~ s/ +/\t/g; # single or multiple spaces are considered as a single tab
      }
      $new_data_line =~ s/\,//g; # remove all commas
      @data_fields = split(/[\t\n\r]/, $new_data_line);
      
      ### read legend ###
      if ($header) {
	$line_legend = shift @data_fields;    ### take first word as legend
	$legend_fields[$line_nb] =  $line_legend;
	$legend_length = &max($legend_length,length($line_legend));
	$legend_size = $legend_length * $small_font_width + $point_size + 20;
      }
      
      ### read X values
      if ($line_nb == $x_col) {
	for $c (0..$#data_fields) {
	  if ($xlog)  {
	    if ($data_fields[$c] > 0) {
	      $new_x = log($data_fields[$c]);
	    } else {
	      $new_x = "ND";
	    }
	  } else {
	    $new_x = $data_fields[$c];
	  }
	  push (@X_values, $new_x);
	}
      }
      
      ### read Y values
      if (defined($yline{$line_nb})) {
	for $c (0..$#data_fields) {
	  if ($ylog)  {
	    if ($data_fields[$c] > 0) {
	      $new_y = log($data_fields[$c]);
	    } else {
	      $new_y = "ND";
	    }
	  } else {
	    $new_y = $data_fields[$c];
	  }
	  $Y_values[$yline{$line_nb}][$c] = $new_y;
	}
      }
    }
  }
  
  close $in unless ($inputfile eq "");
} #### ReadData


sub CalcLimits {
  #### calculate data limits ####
  $max_x_value = "ND";
  $min_x_value = "ND";
  $max_y_value = "ND";
  $min_y_value = "ND";
  
  $min_x_value = &min(@X_values);
  $max_x_value = &max(@X_values);
  
  unless ((&IsReal($max_x_value)) && 
	  (&IsReal($min_x_value))) {
    print "	Error: X axis data (column ", $x_col+1, ") are not numeric\n";
    print "	Type XYgraph -help for more info\n";
    exit;
  }
  
  for $series (0..$#y_col_list) {
    $min_y_value = &checked_min($min_y_value,@{$Y_values[$series]});
    $max_y_value = &max($max_y_value,@{$Y_values[$series]});
    
  }
  
  unless ((&IsReal($max_y_value)) &&
	  (&IsReal($min_y_value))) {
    print "	Error: Y axis data (column ";
    for $col (0..$#y_col_list -1) {
      print $y_col_list[$col]+1, ", ";
    }
    print $y_col_list[$#y_col_list]+1;
    print ") are not numeric\n";
    print "	Type XYgraph -help for more info\n";
    exit;
  }
  
  

  #### min and max axis values ####
  ($tmp_xmin,$tmp_xgrid,$tmp_xmax) = &AutoGrid($min_x_value,$max_x_value);
  if ($x_axis_min eq "ND") {
    $x_axis_min = $tmp_xmin;
  }
  if ($x_axis_max eq "ND") {
    $x_axis_max = $tmp_xmax;
  }
  if ($x_grid_step1 eq "") {
    ($x_grid_min, $x_grid_step1,$x_grid_max) = &AutoGrid($x_axis_min,$x_axis_max);
  }
  
  ($tmp_ymin,$tmp_ygrid,$tmp_ymax) = &AutoGrid($min_y_value,$max_y_value);
  if ($y_axis_min eq "ND") {
    $y_axis_min = $tmp_ymin;
  }
  if ($y_axis_max eq "ND") {
    $y_axis_max = $tmp_ymax;
  }
  if ($y_grid_step1 eq "") {
    ($y_grid_min, $y_grid_step1,$y_grid_max) = &AutoGrid($y_axis_min,$y_axis_max);
  }
  
  
  #### graph dimensions
  $top = $border;
  $left = $border + 2*$small_font_height + 6 + $x_scale_border;
  $right = $left + $x_axis_size;
  if ($title1 ne "") {
    $top += $large_font_height;
  }
  if ($title2 ne "") {
    $top += $large_font_height + 4;
  }
  $bottom = $top + $y_axis_size;
  $graph_x_size = $right + $border + $legend_size + $point_size + 20;
  $graph_y_size = $bottom + $border + $y_scale_border + 2*$small_font_height + 6;
  
  ### scale ###
  if ($x_axis_max > $x_axis_min) {
    $x_scale = $x_axis_size/($x_axis_max - $x_axis_min);
  } else {
    $x_scale = $x_axis_size;
  }
  if ($y_axis_max > $y_axis_min) {
    $y_scale = $y_axis_size/($y_axis_max - $y_axis_min);
  } else {
    $y_scale = $y_axis_size;
  }
}  


##### Initialize HTML map #####
sub InitHTMLmap {
  $max_map_elements = 2000;
  $href = ShortFileName($inputfile);
  
  ###### header of the HTML file #####
  print "<HTML>\n";
  print "<HEAD>\n";
  print "<TITLE>XYgraph ";
  print ShortFileName($inputfile);
  print "</TITLE>\n";
  print "</HEAD>\n";
  print "<BODY>\n";
  print "<img src=\"";
  print ShortFileName($outputfile);
  print "\" border=0 usemap=\"#map1\">\n";
  print "<map name=\"map1\">\n";
}

##### terminate the HTML map #####
sub CloseHTMLmap {
  print "</map>";
  print "</BODY>\n";
  print "</HTML>\n";
}



sub PrintShortHelp {
  open SHORTHELP, "| more";
  print SHORTHELP <<End_of_options;
XYgraph options
---------------
-i	inputfile
-o	outpufile
-v	verbose. 
-title1 "t1"	first graph title. 
-title2 "t2"	second graph title. 	
-xleg1 "legend"	First X legend. 
-xleg2 "legend"	Second X legend.
-yleg1 "legend"	First Y legend. 
-yleg2 "legend"	Second Y legend.
-xmax #	        maximal value represented on X axis.
-ymax #	        maximal value represented on Y axis.	
-xmin #	        minimal value represented on X axis.
-ymin #	        minimal value represented on Y axis.
-min #	        minimal value represented on both X and Y axis
-max #	        maximal value represented on both X and Y axis.
-xgstep1 #      1st step value for the grid across X axis.
-ygstep1 #      1st step value for the grid across Y axis.
-gstep1 #       1st step value for the grid across both X and Y axis.
-xgstep2 #      2nd step value for the grid across X axis.
-ygstep2 #      2nd step value for the grid across Y axis.
-gstep2 #       2nd step value for the grid across both X and Y axis.
-xsize #        size of the X axis (in pixels). Default is 400.
-ysize #        size of the Y axis (in pixels). Default is 400.
-size #		size of X and Y axes (in pixels). 
-pointsize #    point size (in pixels).
-columns	data fields are in columns (default)
-rows		data fields are in rows
-xcol #	        column containing data for the X axis. 
-ycol #,#,#     columns containing data for the Y axis. 
-xlog		X data are displayed on a logarithmic scale
-ylog		Y data are displayed on a logarithmic scale
-lines	        points are jointed by lines 
-line #		points of the #th column are jointed by lines
-header		first line of the data file contains a column header 
-legend		use the first line as legend for Y data.
-histo		histogram. 
-hbox #,#,#.#   Highlight box. 
-tbox #,#,#.#   Threshold box. 
-bg		background color (white, blue, black or gray).
-mono		monochrome output.
-symbols	represent points by symbols
-htmap		HTML map
-lc		label column
End_of_options
  close SHORTHELP;
}


sub PrintHelp {
  open HELP, "| more";
  print HELP <<End_of_Help;
NAME
	XYgraph

	1997-98 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)

USAGE
	XYgraph [-i inputfile] [-o outputfile] [-v] 
		[-title1 "title1"][-title2 "title2"]
		[-xmax #] [-xmin #] [-ymax #] [-ymin #]
		[-xleg1 "legend"] [-xleg2 "legend"]
		[-yleg1 "legend"] [-yleg2 "legend"]
		[-xsize #][-ysize #] [-ycol #,#,#]
		[-lines][-legend][-header] [-histo] 
                [-xgstep1 #][-ygstep1 #][-xgstep2 #][-ygstep2 #]
		
		
	draws a XY graph with the numbers of the 2 first columns of 
	input file and exports this graph as a GIF file. 
	
OPTIONS
	-i inputfile    The input file should contain columns with 
			numeric data.
			Each line contains info about one point of the graph. 
			By default, the first column is considered to contain
			X data, and the second column Y data. 
			X and Y columns can be changed with -xcol and -ycol 
			options.
			Columns should be separated by tabs.
			If no input file is specified, the data are taken 
			from the standard input (keyboard).
	-o outpufile    The name under which the graph will be saved, in 
			the form of a GIF document. 
			If no output file is specified, the result is sent 
			to the standard output (screen).
	-v		verbose. Comments about data and graph parameters
			are printed on the screen.
	-title1 "t1"	first graph title. The title string should be 
			embedded in double quotes if is contains spaces or 
			special chars.
	-title2 "t2"	second graph title.
 	-xleg1 "legend"	First X legend. 
	-xleg2 "legend"	Second X legend.
	-yleg1 "legend"	First Y legend. 
	-yleg2 "legend"	Second Y legend.
	-xmax #	        maximal value represented on X axis.
	-ymax #	        maximal value represented on Y axis.	
	-xmin #	        minimal value represented on X axis.
	-ymin #	        minimal value represented on Y axis.
	-min #	        minimal value represented on both X and Y axis
			(combinates the effects of -xmin and -ymin).
	-max #	        maximal value represented on both X and Y axis.
			(combinates the effects of -xmax and -ymax).
	-xgstep1 #      1st step value for the grid across X axis.
	-ygstep1 #      1st step value for the grid across Y axis.
	-gstep1 #       1st step value for the grid across both X and Y axis.
			(combinates the effects of -xgstep1 and -ygstep1).
	-xgstep2 #      2nd step value for the grid across X axis.
	-ygstep2 #      2nd step value for the grid across Y axis.
	-gstep2 #       2nd step value for the grid across both X and Y axis.
			(combinates the effects of -xgstep2 and -ygstep2).
	-xsize #        size of the X axis (in pixels). Default is 400.
	-ysize #        size of the Y axis (in pixels). Default is 400.
	-size #		size of X and Y axes (in pixel).
			(combinates the effects of -xsize and -ysize). 
	-pointsize #    point size (in pixels).

	-columns	data fields are in columns (default)
			(one column for X and one or several for Y values)
	-rows		data fields are in row
			(one row for X and one or several for Y values)
	-xcol #	        column containing data for the X axis. 
	-ycol #		column containing data for the Y axis. 
			Several columns can be specified by:
				-ycol #,#,#
			A range of columns can be specified by:
				-ycol #-#
			They have to be separated by commas without spaces. 
	-xlog		X data are displayed on a logarithmic scale
	-ylog		Y data are displayed on a logarithmic scale
	-lines	        points are jointed by lines 
	-line #		same as lines, but for the #th column only
			can be used recursively to specify several columns for 
			which a line must be drawn between points.
	-header		first line of the data file contains a column header 
			if option -legend is active, this header is used as 
			legend, else it is ignored.
	-legend		use the content of the first line from input file as 
			legend for Y data.
	-histo		histogram. The X data should in this case contain the 
			middle position of ach class, and Y data the 
			frequencies.
	-hbox #,#,#.#   Highlight box. All points located within this box are 
			highlighted, and the data corresponding to these 
			points are are printed on the standard output 
			device (screen).  
			#,#,#,# are the coordinates of the highlighted 
			box in pixels (left, top, right, bottom respectively).
	-tbox #,#,#.#   Threshold box. All points located within these 
			thresholds are highlighted, and the corresponding data
			are printed on the standard output device (screen).  
			#,#,#,# are in units of X and Y data 
			(low_x, high_x, low_y, high_y respectively).
	-bg bg_color	background color. 
			The following colors are currently supported:
			- white (default),
			- gray,
			- blue
			- black.
			The foreground colors are automatically adapted to 
			provide a good contrast with the bg color.
	-mono		monochrome. All dots are drawn in black, and a 
			specific symbol is associated to each.

	-htmap	HTML map
		An HTML document is automatically generated, which includes 
		the XYgraph GIF file as an HTML map. In other words,
		this document displays a figure with sensitive areas. 
		Each time the mouse is positioned above a point of the XYgraphs, 
		information about this particuliar point is displayed 
		at the bottom of the browser window.
	-lc	label column
		this column contains the label associated to each point
		(this info is used when the -htmap option is active).
WEB VERSION
	http://copan.cifn.unam.mx/~yeast/XYgraph.html

End_of_Help
  close HELP;
}
