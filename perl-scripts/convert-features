#!/usr/bin/perl -w
############################################################
#
# $Id: convert-features,v 1.12 2009/11/08 22:36:47 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################
#use strict;;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
    require "RSA.lib";
}
use RSAT::feature;

################################################################
#### initialise parameters
my $start_time = &AlphaDate();

local %infile = ();
local %outfile = ();

local $verbose = 0;
local $in = STDIN;
local $out = STDOUT;
local $null = "";

%supported_input_format =(
    ft=>1,
    gft=>1,
    gff=>1,
    gff3=>1,
    dnapat=>1,
);
$supported_input_formats = join (",", keys %supported_input_format);

local $output_format = "ft";
%supported_output_format =(
			   ft=>1,
			   fasta=>1,
			   gft=>1,
			   gff=>1,
			   gff3=>1,
			   dnapat=>1,
			   bed=>1,
			  );
$supported_output_formats = join (",", keys %supported_output_format);


&ReadArguments();

################################################################
#### check argument values
unless ($input_format) {
    &RSAT::error::FatalError("You should define the input format");
}


################################################################
### open output stream
$out = &OpenOutputFile($outfile{output});
$header = &RSAT::feature::header($output_format);
print $out $header if ($header);

################################################################
##### read input
($in) = &OpenInputFile($infile{input});
while (<$in>) {
  ## Comment lines
  next if (/^;/);
  next if (/^--/);
  next if (/^#/);
  next unless (/\S/);
  chomp();
  my $feature = new RSAT::feature();
  $feature->parse_from_row($_, $input_format);
  print $out $feature->to_text($output_format, $null);
}

close $in if ($infile{input});

################################################################
#### print verbose
&Verbose() if ($verbose);

################################################################
###### finish verbose
if ($verbose >= 1) {
    my $done_time = &AlphaDate();
    print $out "; Job started $start_time\n";
    print $out "; Job done    $done_time\n";
}


################################################################
###### close output stream
close $out if ($outfile{output});


exit(0);


################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	convert-features

        2002 by Jacques van Helden (jvanheld\@bigre.ulb.ac.be)

DESCRIPTION
	Interconversions between various formats of feature
	description.

CATEGORY
	util

USAGE
        convert-features [-i inputfile] [-o outputfile] [-v]

OPTIONS
	-h	display full help message
	-help	display options
	-v	verbose
	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-from	input format (Supported: $supported_input_formats)
	-to	output format (Supported: $supported_output_formats)

INPUT FORMATS
       ft: RSAT feature-map (extension .ft)

       dnapat: RSAT dna-pattern (extension .tab)

       gft: RSAT Genome features (file Feature.tab in the directory data/genomes)

       gff: General Feature Format as specified by the Sanger insitute (extension .gff)
       	    http://www.sanger.ac.uk/Software/formats/GFF/GFF_Spec.shtml
       
       gff3: Generic feature format version 3
       	     An adaptation of GFF by Lincoln Stein
       	     http://flybase.net/annot/gff3.html

OUTPUT FORMATS
       ft
       gff
       gff3

FORMAT DESCRIPTIONS

       Feature formats are generally tab-delimited files. For
       historical reasons, different formats have been used at
       different sites. Originally, these formats were conceived to
       represent different types of information, and, for this reason,
       the contents of their column slightly differs. However, the
       main information is similar, and the differing columns can be
       easily extrapolated or skipped.  

       ft: RSAT feature-map
		col 1   map label (eg gene name)
		col 2 	feature type
		col 3 	feature identifier (ex: GATAbox, Abf1_site)
		col 4 	strand (D for Direct, R for Reverse),
		col 5 	feature start position
		col 6 	feature end position
		col 7 	(optional) description 
		col 8 	(optional) score

       gft: RSAT Genome features (file Feature.tab in the directory data/genomes)
		col 1	id
		col 2	type
		col 3	name
		col 4	contig
		col 5	start
		col 6	end
		col 7	strand
		col 8	description
		col 9	chrom_position
		col 10	organism

       gff: Sanger general feature file (extension .gff)
           Information: http://www.sanger.ac.uk/Software/formats/GFF/GFF_Spec.shtml
		col 1	seqname (contig or sequence ID)
		col 2	source
		col 3	feature (feature type)
		col 4	start
		col 5	end
		col 6	score
		col 7	strand (+, - or .)
		col 8	frame (0, 1, 2 or .)
		col 9	attribute (from version gff2 onward)

	    Example of gff1:
		SEQ1	EMBL	atg	103	105	.	+	0
	    	SEQ1	EMBL	exon	103	172	.	+	0
	    	SEQ1	EMBL	splice5	172	173	.	+	.
	    	SEQ1	netgene	splice5	172	173	0.94	+	.
	    	SEQ1	genie	sp5-20	163	182	2.3	+	.
	    	SEQ1	genie	sp5-10	168	177	2.1	+	.
	    	SEQ2	grail	ATG	17	19	2.1	-	0

	    Example of gff2:
		seq1     BLASTX  similarity   101  235 87.1 + 0	Target "HBA_HUMAN" 11 55 ; E_value 0.0003
		dJ102G20 GD_mRNA coding_exon 7105 7201   .  - 2 Sequence "dJ102G20.C1.1"

       gff3: Generic Feature Format version 3
           Information: http://www.sequenceontology.org/gff3.shtml
		col 1	seqid (contig or sequence ID)
		col 2	source
		col 3	feature type
		col 4	start
		col 5	end
		col 6	score
		col 7	strand (+, - or .)
		col 8	frame (=phase) (0, 1 or 2)
		col 9	attributes
		    	ID:		name of the feature
			Name: 		display name for the feature
			Alias:		secondary name for the feature
			Parent:		parent of the feature
			Target:		target (of an alignment)
			Gap:		alignment of the feature to the target
			Note:		A free text note
			Dbxref:		database cross reference
			Ontology_term:	cross-reference to an ontology term

		Example of gff3
		##gff-version 3 
		##sequence-region ctg123 1 1497228 
		ctg123	.	gene	1000	9000	.	+	.	ID=gene00001;Name=EDEN	
		ctg123	.	TF_binding_site	1000	1012	.	+	.	ID=tfbs00001;Parent=gene00001	
		ctg123	.	mRNA	1050	9000	.	+	.	ID=mRNA00001;Parent=gene00001;Name=EDEN.1	
		ctg123	.	mRNA	1050	9000	.	+	.	ID=mRNA00002;Parent=gene00001;Name=EDEN.2
		ctg123	.	mRNA	1300	9000	.	+	.	ID=mRNA00003;Parent=gene00001;Name=EDEN.3	
		ctg123	.	exon	1300	1500	.	+	.	ID=exon00001;Parent=mRNA00003	
		ctg123	.	exon	1050	1500	.	+	.	ID=exon00002;Parent=mRNA00001,mRNA00002	
		ctg123	.	exon	3000	3902	.	+	.	ID=exon00003;Parent=mRNA00001,mRNA00003	
		ctg123	.	exon	5000	5500	.	+	.	ID=exon00004;Parent=mRNA00001,mRNA00002,mRNA00003	
		ctg123	.	exon	7000	9000	.	+	.	ID=exon00005;Parent=mRNA00001,mRNA00002,mRNA00003	
		ctg123	.	CDS	1201	1500	.	+	0	ID=cds00001;Parent=mRNA00001;Name=edenprotein.1	
		ctg123	.	CDS	3000	3902	.	+	0	ID=cds00001;Parent=mRNA00001;Name=edenprotein.1	
		ctg123	.	CDS	5000	5500	.	+	0	ID=cds00001;Parent=mRNA00001;Name=edenprotein.1	
		ctg123	.	CDS	7000	7600	.	+	0	ID=cds00001;Parent=mRNA00001;Name=edenprotein.1	
		ctg123	.	CDS	1201	1500	.	+	0	ID=cds00002;Parent=mRNA00002;Name=edenprotein.2	
		ctg123	.	CDS	5000	5500	.	+	0	ID=cds00002;Parent=mRNA00002;Name=edenprotein.2	
		ctg123	.	CDS	7000	7600	.	+	0	ID=cds00002;Parent=mRNA00002;Name=edenprotein.2	
		ctg123	.	CDS	3301	3902	.	+	0	ID=cds00003;Parent=mRNA00003;Name=edenprotein.3	
		ctg123	.	CDS	5000	5500	.	+	2	ID=cds00003;Parent=mRNA00003;Name=edenprotein.3	
		ctg123	.	CDS	7000	7600	.	+	2	ID=cds00003;Parent=mRNA00003;Name=edenprotein.3	
		ctg123	.	CDS	3391	3902	.	+	0	ID=cds00004;Parent=mRNA00003;Name=edenprotein.4	
		ctg123	.	CDS	5000	5500	.	+	2	ID=cds00004;Parent=mRNA00003;Name=edenprotein.4	
		ctg123	.	CDS	7000	7600	.	+	2 	ID=cds00004;Parent=mRNA00003;Name=edenprotein.4

	bed
	   Genomic features in the UCSC format
	   Ref: http://genome.ucsc.edu/goldenPath/help/hgTracksHelp.html#BED

	   1. chrom - The name of the chromosome (e.g. chr3, chrY,
	      chr2_random) or scaffold (e.g. scaffold10671).

	   2. chromStart - The starting position of the feature in the
 	      chromosome or scaffold. The first base in a chromosome
 	      is numbered 0.

	   3. chromEnd - The ending position of the feature in the
	      chromosome or scaffold. The chromEnd base is not
	      included in the display of the feature. For example, the
	      first 100 bases of a chromosome are defined as
	      chromStart=0, chromEnd=100, and span the bases numbered
	      0-99.

	   4. name - Defines the name of the BED line. This label is
	      displayed to the left of the BED line in the Genome
	      Browser window when the track is open to full display
	      mode or directly to the left of the item in pack mode.

	   5. score - A score between 0 and 1000.

   	   6. strand - Defines the strand - either '+' or '-'.

   	   7. thickStart - The starting position at which the feature
   	      is drawn thickly (for example, the start codon in gene
   	      displays).

	   8. thickEnd - The ending position at which the feature is
	      drawn thickly (for example, the stop codon in gene
	      displays).
   
	   9. itemRgb An RGB value of the form R,G,B
   	      (e.g. 255,0,0). If the track line itemRgb attribute is
   	      set to "On", this RBG value will determine the display
   	      color of the data contained in this BED line. NOTE: It
   	      is recommended that a simple color scheme (eight colors
   	      or less) be used with this attribute to avoid
   	      overwhelming the color resources of the Genome Browser
   	      and your Internet browser.

	   10. blockCount - The number of blocks (exons) in the BED
   	       line.

   	   11. blockSizes - A comma-separated list of the block
	       sizes. The number of items in this list should
	       correspond to blockCount.

	   12. blockStarts - A comma-separated list of block
   	       starts. All of the blockStart positions should be
   	       calculated relative to chromStart. The number of items
   	       in this list should correspond to blockCount.

  	   Example:

	      browser position chr7:127471196-127495720
	      browser hide all
	      track name="ItemRGBDemo" description="Item RGB demonstration" visibility=2 
	      itemRgb="On" 
	      chr7	127471196  127472363  Pos1  0  +  127471196  127472363  255,0,0
	      chr7	127472363  127473530  Pos2  0  +  127472363  127473530  255,0,0
	      chr7	127473530  127474697  Pos3  0  +  127473530  127474697  255,0,0
	      chr7	127474697  127475864  Pos4  0  +  127474697  127475864  255,0,0
	      chr7	127475864  127477031  Neg1  0  -  127475864  127477031  0,0,255
	      chr7	127477031  127478198  Neg2  0  -  127477031  127478198  0,0,255
	      chr7	127478198  127479365  Neg3  0  -  127478198  127479365  0,0,255
	      chr7	127479365  127480532  Pos5  0  +  127479365  127480532  255,0,0
	      chr7	127480532  127481699  Neg4  0  -  127480532  127481699  0,0,255

End_of_help
  close HELP;
  exit;
}


################################################################
#### display short help message
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
convert-features options
----------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-i		input file
-o		output file
-v		verbose
-from		input format (Supported: $supported_input_formats)
-to		output format (Supported: $supported_output_formats)
End_short_help
  close HELP;
  exit;
}

################################################################
#### read arguments 
sub ReadArguments {
    foreach my $a (0..$#ARGV) {
	### verbose  
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp();
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions();
	    
	    ### input file  
	} elsif ($ARGV[$a] eq "-i") {
	    $infile{input} = $ARGV[$a+1];
	    
	    ### output file  
	} elsif ($ARGV[$a] eq "-o") {
	    $outfile{output} = $ARGV[$a+1];
	    
	    ### input format  
	} elsif ($ARGV[$a] eq "-from") {
	    $input_format = $ARGV[$a+1];
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supoprted: $supported_input_formats")
		unless ($supported_input_format{$input_format});

	    ### output format  
	} elsif ($ARGV[$a] eq "-to") {
	    $output_format = $ARGV[$a+1];
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supoprted: $supported_output_formats")
		unless ($supported_output_format{$output_format});
	}
    }
}

################################################################
#### verbose message
sub Verbose {
    print $out "; convert-features ";
    &PrintArguments($out);
    if (defined(%infile)) {
	print $out "; Input files\n";
	while (($key,$value) = each %infile) {
	    print $out ";\t$key\t$value\n";
	}
    }
    if (defined(%outfile)) {
	print $out "; Output files\n";
	while (($key,$value) = each %outfile) {
	    print $out ";\t$key\t$value\n";
	}
    }
    print $out "; Input format\t", $input_format, "\n";
    print $out "; Output format\t", $output_format, "\n";
}
