#!/usr/bin/perl

## Ce script est une usine a gaz

############################################################
#
# $Id: multiple-family-analysis,v 1.212 2007/08/11 06:49:04 jvanheld Exp $
#
# Time-stamp: <2003-10-21 01:19:12 jvanheld>
#
############################################################
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
    require "RSA.lib";
    require "RSA.seq.lib";
    require "RSA.disco.lib";
    require "RSA.help.pl";
    require "RSA.cgi.lib";
    push @INC, "$RSA/perl-scripts/parsers/";
    require "lib/load_classes.pl";
    require "lib/util.pl";
    require "lib/parsing_util.pl";
#    require "$RSA/perl-scripts/lib/RSA.classes";
}
require RSAT::util;
require RSAT::matrix;
require RSAT::pattern;
require RSAT::Analysis;
require RSAT::Family;
use RSAT::MatrixReader;

################################################################
## initialize global variables
$toppat = 50;
$organism = "";
$org_fam = 0;
$taxon = "";
$force_calib=1;
$null="NA"; ## Null character for the exports
$skip=0; ## Skip the first families
$last=-1; ## Stop after a few families
$batch = 0; ## Run task in batch mode (on a PC cluster)
@batch_commands = (); ## Set of commands to run in batch mode
#$batch_script = ""; ## Script collecting the commands to be run on the same node of the PC cluster
$min_genes = 1; ## Min number of genes per family
$rel_w = 1; ## Threshold on relative weight for compare-patterns
$sliding_window_size = 0; 
$die_on_error = 1;
$analyze_purged_sequences = 1;
$calibN_repet=100; ### Repetitions for the calibN
$db_site_name="";
%dir = ();
%lth = ();
$lth{occ} = 1;
%uth = ();
$dir{main} = `pwd`;
#$dir{main} = "BOUM";
chomp($dir{main});
%family = (); ## Index of families per name
@families = (); ## Families
@selected = (); ## Families selected with the option -select

$dir{calib1} = "calibrations_1gene"; 
%max_score = ();

## Supported tasks
@supported_tasks = qw (upstream
		       purge

		       calibrate
		       calibN
		       oligos
		       merge_oligos
		       oligo_maps
		       db_match_oligos
		       sig_distrib_oligos
		       validate_oligos

		       dyads
		       dyad_maps
		       db_match_dyads
		       sig_distrib_dyads
		       validate_dyads

		       ormbg
		       orm
		       assemble_orm
		       orm_maps
		       sig_distrib_orm
		       validate_orm

		       merge_patterns
		       maps

		       slide

		       consensus
		       consensus_maps

		       gibbs
		       gibbs_maps

		       AlignACE
		       AlignACE_maps

		       MotifSampler

		       meme
		       meme_maps

		       report
		       synthesis
		       sql
		       clean
		       all
		       );
foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
}
$supported_tasks = join ",", @supported_tasks;


## Keys for sorting the results in the summary table
%supported_sort_key = (
		       "score"=>1,
		       "name"=>1
		      );
$supported_sort_keys  = join ",", sort keys %supported_sort_key;

## Maximum number of matrices per family in the synthetic table
$max_matrices = 1;

## Background models for string-based pattern discovery
%supported_background = (
			 "intergenic"=>1,
			 "upstream"=>1,
			 "upstreamL"=>1,
			 "upstream-noorf"=>1,
			 "calib1"=>1,
			 "calibN"=>1,
			 "upstream-rm"=>1,
			 "upstream-noorf-rm"=>1
			 );
$supported_background  = join ",", sort keys %supported_background;

## input files
$family_file = "";
$sequence_file_list = "";

## feature-map options
$htmaps=0;
$draw_maps=1;
$scalestep = 100; 

## retrieve-seq options
$noorf = "-noorf"; 
$repeat_masked = 0;
$seq_format = "fasta";
$seq_dir = "";
$seq_ext = "fasta";

## purge-seq options
$purge_ml = 40;
$purge_mis = 3;

## pattern discovery options
$background = "upstream-noorf";
$noov = "-noov";
$sort_key = "score";
## oligo-analysis options
$min_oligo_len = 6;
$max_oligo_len = 6;
## dyad-analysis options
$monad_length = 3;
$min_sp = 0;
$max_sp = 20;

## Default matrix-based pattern discovery options
$matrix_width = 16;
$expected_sites_per_gene = 2;
$nmotifs = 5;
$seed = undef;

## Program-specific keys for sorting matrices (PSSM)
## Values are defined below for each matrix-based pattern discovery program
%pssm_sort_key = ();
%pssm_sort_order = ();

## Default MotifSampler options
$MS_bg_order = 0;
if (defined($ENV{MOTIF_SAMPLER_DIR})) {
  $MS_b =$ENV{MOTIF_SAMPLER_DIR}."/background_models/yeast_up800_nomit_noorf_o3.bg"; ### TEMPORARY
}
$MS_p = 0.2;
$MS_M = 0;
$MS_n = $nmotifs;
$MS_w = $matrix_width;
$MS_x = 1;
$MS_r = 5;
$pssm_sort_key{MotifSampler} = 'MS.ic';
$pssm_sort_order{MotifSampler} = 'desc';

## Default MEME options
$MEME_optiont{text} = ""; push @MEME_options, "text"; ## Ouptut format = text
$MEME_optiont{dna} = ""; push @MEME_options, "dna"; ## Sequence type == dna
$MEME_options{mod} = "anr"; push @MEME_options, "mod"; ## Accept any number of occurrences per sequence
$MEME_options{minw} = 6; push @MEME_options, "minw"; ## Minimal motif width
$MEME_options{maxw}=25; push @MEME_options, "maxw"; ## Maximal motif width
$MEME_options{nmotifs}=$nmotifs; push @MEME_options, "nmotifs"; ## Number of motifs
$MEME_options{evt}=1; push @MEME_options, "evt"; ## upper threshold on E-value
$pssm_sort_key{meme} = 'meme.E-value';
$pssm_sort_order{meme} = 'asc';

#$MEME_options{bfile}="";

## Default ORM options
$ormbg_options = ""; ## must be global
$ormbg_suffix = ""; ## must be global
$ORM_lth_width = 100; ## Minimal window width for variable window size
$ORM_uth_wrank = 1; ## Max rank per word
$ORM_uth_rank=50; ## max rank (all words)
$ORM_lth_occ_sig=0; ## lower thresold on occurrence significance
#$ORM_fixedsizewindow=0; ## Fixed window size
$ORM_overlap=0; ## Allow overlapping occurrences for self-overlapping words
$ORM_strand="+-"; ## Strands
$ORM_word_length=6; ## Word length
$ORM_window=100; ## Window size for the background model
$ORM_markov_order=-1; ## markov order for the background model

## Default consensus options
$pssm_sort_key{consensus} = 'cons.ln.exp';
$pssm_sort_order{consensus} = 'asc';

## Default gibbs options
$pssm_sort_key{gibbs} = 'MAP.per.site';
$pssm_sort_order{gibbs} = 'desc';

## Default AlignACE options
$AlignACE_gcback=0.4332384392880;
$pssm_sort_key{AlignACE} = 'MAP.per.site';
$pssm_sort_order{AlignACE} = 'desc';

## Comparison between discovered and known motifs
$known_site_file = "";
$known_sites_provided = 0;
$min_matching_score = 4;
$known_site_max_len=50; ## ignore known sites larger than 50bp

## miscellaneous
$start_date = `date`;
$verbose = 0;

#### data export options
$schema = "multifam";
$host="localhost";
$user = getlogin();
$password="";

################################################################
### MAIN

#### Read arguments
&ReadArguments();

if ($background eq 'upstream-noorf') {
    unless ($noorf) {
	$background = 'upstream';
    }
}
if ($repeat_masked) {
    $background .= '-rm';
}

#### Check parameters
&CheckParameters();

################################################################
## Create class factories

## Unique prefix for each analysis, to allow merging them in a database

local $run_date = &AlphaDate();
local $run_prefix = `mktemp XXXXX`;
chomp($run_prefix);
system "rm $run_prefix" if (-f $run_prefix);

## Class holder for the analysis
local $analysis_factory = classes::ClassFactory->new_class(object_type=>"RSAT::Analysis");
$current_analysis = $analysis_factory->new_object(id=>$run_prefix);

## Class holder for families
local $family_factory = classes::ClassFactory->new_class(object_type=>"RSAT::Family",
						      prefix=>$run_prefix."_fam");
$family_factory->set_out_fields(qw(id analysis organism size name  genes));

## Class holder for patterns (oligos and dyads)
local $pattern_factory = classes::ClassFactory->new_class(object_type=>"RSAT::pattern",
							  prefix=>$run_prefix."_pat");
@pattern_out_fields = qw(id
			 family_id
			 family 
			 type 
			 sequence 
			 rev_compl
			 occ 
			 exp_occ
			 occ_P
			 occ_E
			 occ_sig
			 rank
			);
$pattern_factory->set_out_fields(@pattern_out_fields);

## Class holder for the matrices (gibbs, AlignACE, meme, consensus, MotifSampler)
local $matrix_factory = classes::ClassFactory->new_class(object_type=>"RSAT::matrix",
							 prefix=>$run_prefix."_mat");
@matrix_scalar_out_fields = qw(id
			       family_id
			       family
			       program
			       sites
			       matrix.nb
			       ncol
			       nrow
			       type
			       alphabet.size

			       consensus.IUPAC
			       consensus.IUPAC.rc
			       consensus.strict
			       consensus.strict.rc
			       consensus.regexp
			       consensus.regexp.rc

			       total.information
			       info.log.base
			       information.per.column
			       max.bits
			       max.possible.info.per.col
			       min.prior

			       cons.Pval
			       cons.ln.Pval
			       cons.Eval
			       cons.ln.Eval
			       cons.adjusted.information
			       cons.unadjusted.information

			       MAP
			       MAP.per.site
			       gibbs.betaprior.map
			       gibbs.model.map
			       seed

			       meme.llr
			       meme.E-value

			       MS.ic
			       MS.ll
			       MS.cs
			       MS.consensus
			       MS.sequences

			       input_file
			       command
			       );

@matrix_array_out_fields = qw(site_ids
			      sequences
			      alphabet
			      prior
			      parameters
			      column.information
			     );
$matrix_factory->set_out_fields(@matrix_scalar_out_fields, @matrix_array_out_fields);

local %matrix_by_file = (); ## index for the matrices already treated

################################################################
## Read data

## Known sites
if ($known_site_file) {
    &ReadKnownSites($known_site_file);
}

## List of sequence files
if ($sequence_file_list) {
  $task{upstream} = 0; 
  &ReadSequenceList();
  ## Family file
} else {
  ### read gene name and identifiers
  &RSAT::message::TimeWarn ("Reading ORF information") 
    if ($verbose >= 1);
  #### Check organism name
  if ($organism_name) {
    $organism = new RSAT::organism();
    $organism->check_name($organism_name);
    $organism->set_attribute("name", $organism_name);
    $organism->DefineAcceptedFeatureTypes(sort keys %accepted_feature_types);
    $organism->LoadFeatures($annotation_table);
    $organism->LoadSynonyms();

  } elsif ($org_fam) {
    &RSAT::message::Info("Organisms will be read from the second column of the family file") if ($main::verbose >= 1);
  } else {
    &RSAT::error::FatalError("You must either specify an organism (-org), or an input sequence file (-seq)");
  }

  ### Read family file
  if ($org_fam) {
    %family = &ReadClasses($family_file, 0);
  } else {
    %family = &ReadClasses($family_file, 1, $organism);
  }

  ## Check selected families
  if (scalar(@selected) > 0) {
    my %selected = ();
    foreach my $family_name (@selected) {
      $selected{$family_name}++;
      &FatalError(join ("\t", "Selected family", $family_name, "is not found in the family file", $family_file)) unless ($family{$family_name});
    }

    ## Delete non-selected families
    foreach my $family_name (keys (%family)) {
      delete $family{$family_name} unless ($selected{$family_name});
    }
  } else {
    @families = sort keys %family;
  }

}

## Apply the options -skip (suppress first families) and -last (suppress last families)
if ($skip > 0) {
    for my $f (1..$skip) {
	$family_name = $families[$f-1];
	delete $family{$family_name};
    }
}
if ($last > 0) {
    for my $f (($last+1)..scalar(@families)) {
	$family_name = $families[$f-1];
	delete $family{$family_name};
    }
}
@families = sort keys %family;

## Check minimum number of genes
foreach my $family_name (@families) {    
    my $gene_nb = scalar(@{$family{$family_name}->{members}});
    if ($gene_nb < $min_genes) {
      &RSAT::message::Warning("Removing family", 
			      $fam_count, $family_name,
			      $gene_nb." genes",
			      "< min = ".$min_genes), "\n" if ($main::verbose >= 1);
      delete $family{$family_name};
    }
}

## Update the list of families
@families = sort keys %family;
&RSAT::message::Info(join("\t", "Remaining families after filtering", scalar(@families))) if ($main::verbose >= 1);

## Set all the file names
&SetFileNames();

## Create output directories
&RSAT::util::CheckOutDir($dir{output}); 
chdir($dir{output});
&MakeDirectories();

#### verbose
$verbose_message = &Verbose() if ($verbose >= 1);


################################################################
### perform analysis
&AnalyzeFamilies();
&MDCreport() if ($task{report});
&Validate() if ($task{validate});
&SigDistrib() if (($task{sig_distrib_oligos}) || ($task{sig_distrib_dyads}) || ($task{sig_distrib_orm}));
&ExportSQL() if ($task{sql});
&SyntheticTable() if ($task{synthesis});
&DatabaseMatch() if ($task{db_match});

### Warn output dir and files
if ($main::verbose >= 1) {
    warn "; Results were stored in directory\t".$dir{output}."\n";
    warn "; Synthetic table\t", $dir{output}."/".$outfile{table}, "\n";
    if ($task{report}) {
	 warn "; Result report (MDC 2004)\t", $dir{output}."/".$outfile{results}, "\n";
	 warn "; Parameter report (MDC 2004)\t", $dir{output}."/".$outfile{parameters}, "\n";
    }
}

#### report execution time 
if ($verbose >= 1) {
  $done_date = `date`;
  print ";Job started\t$start_date";
  print ";Job done\t", `date`;
}

exit(0);


################################################################
#
#                 SUBROUTINE DEFINITIONS
#
################################################################

################################################################

#### set the file names as a function of parameters
sub SetFileNames {
    $sp = "$min_sp-$max_sp";
    $dyad_options = "-v";
#    $dyad_options .= " -lth occ 1"; ## This is to avoid calculating P-value for patterns not rpesent in the dataset, and for having a correct correction for multi-testing. 
    $dyad_options .= " -sort";
    $dyad_options .= " ".$strands;
    $dyad_options .= " -type ".$dyad_type;
    $dyad_options .= " ".$noov;
    $dyad_options .= " -l ".$monad_length;
    $dyad_options .= &ThresholdOptions();
#    $dyad_options .= " -lth occ_sig $lth{occ_sig} ";
    $dyad_options .= " -sp ".$sp;

    $dyad_suffix = "_dyads";
    if ($markov) {
	$dyad_suffix .= "_monad"; ### TEMP
    } elsif ($background) {
#	if ($repeat_masked) {        ### Should be here?
#	    $background .= "-rm";    ### Should be here?
#	}                            ### Should be here?
	$dyad_suffix .= "_bg_".$background; ### TEMP
    }
    $dyad_suffix .= "_l".$monad_length;
    $dyad_suffix .= "_sp".$sp;
    $dyad_suffix .= $strands;
    $dyad_suffix .= "_".$dyad_type;
    $dyad_suffix .= &ThresholdSuffix();
#    $dyad_suffix .= "_sig".$lth{occ_sig};
    $dyad_suffix .= $noov;

    #### expected frequency model
    if ($markov) {
	## do nothing. Expected dyad frequencies will be calculated on the basis of monad frequencies
    } elsif ($exp_freq_file{dyads}) {
       ## Convert relative path in absolute path
       unless ($exp_freq_file{dyads} =~ /^\//) {
	   $exp_freq_file{dyads} = $dir{main}."/".$exp_freq_file{dyads};
       }
	### Manually specified expected frequencies
	$dyad_options .= " -expfreq $exp_freq_file{dyads}";
    } elsif ($background) {
	$dyad_options .= " -bg $background ";
	$dyad_options .= " -org ".$organism_name if ($organism_name);
#      $dyad_suffix .= "_ncf";
    } elsif ($background eq "mncf") {
	$dyad_options .= " -mncf ";
	$dyad_options .= " -org ".$organism_name if ($organism_name);
	$dyad_suffix .= "_mncf";
    }
#  $dyad_suffix .= "_ncf" if ($background); ### TEMP

    #### suffix for the oligo-analysis file
    $noorf_string = "_noorf" if ($noorf);
    $oligo_suffix = "_oligos";
    if ($markov) {
	$oligo_suffix .= "_mkv".$markov_order;
    } elsif ($background) {
	$oligo_suffix .= "_bg_".$background;
    }
    $oligo_suffix .= "_".$min_oligo_len."-".$max_oligo_len."nt";
    $oligo_suffix .= $strands;
    $oligo_suffix .= &ThresholdSuffix();
#    $oligo_suffix .= "_sig".$lth{occ_sig};
#    if (&IsReal($lth{ms_freq})) {$oligo_suffix .= "_msf".$lth{ms_freq} ; }
#    if (&IsReal($lth{ms_sig})) {$oligo_suffix .= "_mssig".$lth{ms_sig} ; }
    $oligo_suffix .= $noov;


    ################################################################
    ## Options for ormbg (calculate bckground model for orm)

    $ormbg_options = "";
    $ormbg_suffix = "";

    ## Word length
    $ormbg_options .= " --word_length=".$ORM_word_length;
    $ormbg_suffix .= "_w".$ORM_word_length;

    ## Location
    my $ORM_location = $from.":".$to;
    $ormbg_options .= " --location=".$ORM_location;
    $ormbg_suffix .= $from."_".$to;

    ## Window size
    $ormbg_options .= " --window=".$ORM_window;
    $ormbg_suffix .= "_W".$ORM_window;

    ## Strand
    $ormbg_options .= " --strand=".$ORM_strand;
    $ormbg_suffix .= $ORM_strand;

    ## Self-overlapping words
    if ($ORM_overlap) {
	$ormbg_options .= " --overlap";
	$ormbg_suffix .= "-ovlp";
    } else {
	$ormbg_suffix .= "-noov";
    }

    ## Markov model
    if ($ORM_markov_order >= 0) {
	$ormbg_options .= " --markov_order=".$ORM_markov_order;
	$ormbg_suffix .= "_m".$ORM_markov_order;
    }
    
    ## Background model file
    $dir{ormbg} = "bg_models/orm_models";
    my $ormbg_file = $dir{ormbg}."/".$ormbg_suffix;
    $ormbg_options .= " --output=".$ormbg_file;
    
    foreach my $family_name (@families) {
	my $gene_nb = scalar(@{$family{$family_name}->{members}});
#	warn join ("\t", "Number of genes", $family_name, $gene_nb), "\n";

	$expected_sites = $gene_nb*$expected_sites_per_gene;	
	$family{$family_name}->{family_file} = $family_name."/".$family_name."_".$feature_types.".fam";
	$family{$family_name}->{known_site_file} = $family_name."/".$family_name."_known_sites";
	$family{$family_name}->{file_prefix} = $family_name;
	$family{$family_name}->{file_prefix} .= "_up".$seq_length unless ($sequence_file_list);
	$family{$family_name}->{file_prefix} .= "_".$feature_types;
	$family{$family_name}->{file_prefix} .= $noorf_string; 
	if ($taxon) {
	    $family{$family_name}->{file_prefix} .= "_".$taxon; 
	    $family{$family_name}->{ortho_file} = $family_name."/".$family_name."_".$feature_types."_orthologs_".$taxon.".fam";
	}
	
	## Sequence files	unless ($sequence_file_list) {
	unless ($sequence_file_list) {
	    $family{$family_name}->{seq_file} = $family_name."/".$family{$family_name}->{file_prefix}.".".$seq_format;
	    $family{$family_name}->{seq_file_purged} = $family_name."/".$family{$family_name}->{file_prefix}."_purged.${seq_format}";
	}
	if ($analyze_purged_sequences) {
	    $family{$family_name}->{input_seq_file} = $family{$family_name}->{seq_file_purged};
	} else {
	    $family{$family_name}->{input_seq_file} = $family{$family_name}->{seq_file};
	}
	$family{$family_name}->{seq_len_file} = $family_name."/".$family{$family_name}->{file_prefix}."_seq_len.tab";
	
	## Known sites for this family
	if ($task{validate}) {
#	    $family{$family_name}->{known_sites} = $family_name."/".$family{$family_name}->{file_prefix}."_known_sites.tab";
	    $family{$family_name}->{known_sites} = $family_name."/".$family_name."_known_sites.tab";
	}
	
	################################################################
	## oligo-analysis results
	$family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix; 
	$family{$family_name}->{oligo_assembly_file} = $family{$family_name}->{oligo_file}.".asmb";
	$family{$family_name}->{oligo_pssm_file} = $family{$family_name}->{oligo_file}."_pssm";
	$family{$family_name}->{oligo_selection} = $family{$family_name}->{oligo_file}."_selection";
	$family{$family_name}->{oligo_ft_prefix} = $family{$family_name}->{oligo_file};
#	$family{$family_name}->{selection_ft_prefix} = $family{$family_name}->{oligo_ft_prefix}."_report";
	$family{$family_name}->{oligo_ft_file} = $family{$family_name}->{oligo_ft_prefix}.".ft";
	$family{$family_name}->{oligo_vs_known} = $family{$family_name}->{oligo_file}."__vs__known_relw".$rel_w.".tab";
	$family{$family_name}->{oligo_vs_known_weight_table} = $family{$family_name}->{oligo_file}."__vs__known_weigth_table.tab";
	$family{$family_name}->{oligo_vs_known_relw_table} = $family{$family_name}->{oligo_file}."__vs__known_relw_table.tab";
	$family{$family_name}->{oligo_vs_db} = $family{$family_name}->{oligo_file}."__vs__db_".$db_site_name."_relw".$rel_w.".tab";
	$family{$family_name}->{oligo_vs_db_weight_table} = $family{$family_name}->{oligo_file}."__vs__db_".$db_site_name."_weigth_table.tab";
	$family{$family_name}->{oligo_vs_db_relw_table} = $family{$family_name}->{oligo_file}."__vs__db_".$db_site_name."_relw_table.tab";

	################################################################
	## dyad-analysis results
	$family{$family_name}->{dyad_file} = "$family_name/dyads_${family_name}/".$family{$family_name}->{file_prefix}.$dyad_suffix;
	$family{$family_name}->{dyad_assembly_file} = $family{$family_name}->{dyad_file}.".asmb";
	$family{$family_name}->{dyad_pssm_file} = $family{$family_name}->{dyad_file}."_pssm";
	$family{$family_name}->{dyad_ft_prefix} = $family{$family_name}->{dyad_file};
	$family{$family_name}->{dyad_ft_file} = $family{$family_name}->{dyad_ft_prefix}.".ft";	
	$family{$family_name}->{fmap_file} = $family{$family_name}->{dyad_file}.".${IMG_FORMAT}";
	$family{$family_name}->{htmap_file} = $family{$family_name}->{dyad_file}.".html";
        $family{$family_name}->{dyad_vs_known} = $family{$family_name}->{dyad_file}."__vs__known_relw".$rel_w.".tab";
        $family{$family_name}->{dyad_vs_known_weight_table} = $family{$family_name}->{dyad_file}."__vs__known_weight_table.tab";
        $family{$family_name}->{dyad_vs_known_relw_table} = $family{$family_name}->{dyad_file}."__vs__known_relw_table.tab";
	$family{$family_name}->{dyad_vs_db} = $family{$family_name}->{dyad_file}."__vs__db_".$db_site_name."relw".$rel_w.".tab";
	$family{$family_name}->{dyad_vs_db_weight_table} = $family{$family_name}->{dyad_file}."__vs__db_".$db_site_name."weigth_table.tab";
	$family{$family_name}->{dyad_vs_db_relw_table} = $family{$family_name}->{dyad_file}."__vs__db_".$db_site_name."relw_table.tab";

	################################################################
	## oligos + dyads
	$family{$family_name}->{merged_file} =  "${family_name}/merged_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix.$dyad_suffix;
	$family{$family_name}->{merged_ft_file} = $family{$family_name}->{merged_file}.".ft";

	################################################################
	## Andrew Neuwald's Gibbs 95 options and files
	my $gibbs_options = "";
	my $gibbs_suffix = "";

	## input file
	$family{$family_name}->{gibbs_input_seq_file} = $family{$family_name}->{input_seq_file}.".gibbs";
	$gibbs_options .= " ".$family{$family_name}->{gibbs_input_seq_file};

	## Matrix width
	my @gibbs_widths = ();
	my @gibbs_expected_sites = ();
	my $gene_nb = scalar(@{$family{$family_name}->{members}});
	my $expected_sites = $gene_nb*$expected_sites_per_gene;
	for my $i (1..$nmotifs) {
	  push @gibbs_widths, $matrix_width;
	  push @gibbs_expected_sites, $expected_sites;
	}
	$gibbs_options .= " ".join(",",  @gibbs_widths);
	$gibbs_suffix .= "-nmotifs".$nmotifs;
	$gibbs_suffix .= "-L".$matrix_width;

	## Expected number of sites
	$gibbs_options .= " ".join(",", @gibbs_expected_sites);
	$gibbs_suffix .= "-n".$expected_sites;

	## DON'T use fragmentation (i.e., column sampler)
	$gibbs_options .= " -d";
	$gibbs_suffix .= "-d";

	## Use nucleic acid alphabet
	$gibbs_options .= " -n";
	$gibbs_suffix .= "-n";

	## Random seed
	if (defined($seed)) {
	    $gibbs_options .= " -s".$seed;
	    $gibbs_suffix .= "-s".$seed;
	}

	## Assign gibbs options to the family
	$family{$family_name}->{gibbs_suffix} = $gibbs_suffix;
	$family{$family_name}->{gibbs_options} = $gibbs_options;
	$family{$family_name}->{gibbs_dir} = ${family_name}."/gibbs_".${family_name};
	$family{$family_name}->{gibbs_file} = $family{$family_name}->{gibbs_dir}."/".$family{$family_name}->{file_prefix}.$gibbs_suffix;

	################################################################
	## Roth's AlignACE
	my $AlignACE_options = "";
	my $AlignACE_suffix = "";

	$family{$family_name}->{AlignACE_input_seq_file} = $family{$family_name}->{input_seq_file}.".AlignACE";

	## input file
	$AlignACE_options .= " -i ".$family{$family_name}->{AlignACE_input_seq_file};

	## Matrix width
	$AlignACE_options .= " -numcols ".$matrix_width;
	$AlignACE_suffix .= "-L".$matrix_width;

	## Expected number of sites
	my $gene_nb = scalar(@{$family{$family_name}->{members}});
	$expected_sites = $gene_nb*$expected_sites_per_gene;
	$AlignACE_options .= " -expect ".$expected_sites;
	$AlignACE_suffix .= "-n".$expected_sites;

	## background fractional GC content of input sequence (0.38)
	$AlignACE_options .= " -gcback ".$AlignACE_gcback;
	$AlignACE_suffix .= "-gcback".sprintf("%.2f",$AlignACE_gcback);

	## Random seed
	if (defined($seed)) {
	    $AlignACE_options .= " -s".$seed;
	    $AlignACE_suffix .= "-s".$seed;
	}

	## Assign AlignACE options to the family
	$family{$family_name}->{AlignACE_suffix} = $AlignACE_suffix;
	$family{$family_name}->{AlignACE_options} = $AlignACE_options;
	$family{$family_name}->{AlignACE_dir} = ${family_name}."/.AlignACE_".${family_name};
	$family{$family_name}->{AlignACE_file} = $family{$family_name}->{AlignACE_dir}."/".$family{$family_name}->{file_prefix}.$AlignACE_suffix;

	################################################################
	## Gert Thijs' MoifSampler options and files
	my $MS_options = "";
	my $MS_suffix = "";

	## input file
	$MS_options = " -f ".$family{$family_name}->{input_seq_file};

	## background model
	if ($MS_b) {
	    $MS_options .= " -b ".$MS_b;
	} else {
	    $family{$family_name}->{MotifSamplerBackground} = $dir{output}."/".$family{$family_name}->{input_seq_file}."_MotifSampler_bg".$MS_bg_order;
	    $MS_options .= " -b ".$family{$family_name}->{MotifSamplerBackground};
	}

	## strand
	if ($strand eq "-1str") {
	    $MS_options .= " -s 0";
	    $MS_suffix .= "-s0";
	} else {
	    $MS_options .= " -s 1";
	    $MS_suffix .= "-s1";
	}

	## prior
	$MS_options .= " -p ".$MS_p;
	$MS_suffix .= "-p".$MS_p;	 

	## Maximal number of motif instances per sequence. (default unset = 0)
	$MS_options .= " -M ".$MS_M;
	$MS_suffix .= "-M".$MS_M;	 

	## Sets number of different motifs to search for (default 1).
	$MS_options .= " -n ".$MS_n;
	$MS_suffix .= "-n".$MS_n;

	## Sets length of the motif (default 8).
	$MS_options .= " -w ".$matrix_width;
	$MS_suffix .= "-w".$matrix_width;

	## Sets allowed overlap between different motifs. (default 1)
	$MS_options .= " -x ".$MS_x;
	$MS_suffix .= "-x".$MS_x;

	## Set number of times the MotifSampler should be repeated
	$MS_options .= " -r ".$MS_r;
	$MS_suffix .= "-r".$MS_r;

	## output file

	$family{$family_name}->{MotifSampler_dir} = "${family_name}/MotifSampler_${family_name}";
	$family{$family_name}->{MotifSampler_file} = $family{$family_name}->{MotifSampler_dir}."/".$family{$family_name}->{file_prefix}.$MS_suffix.".sites";
	$MS_options .= " -o ".$family{$family_name}->{MotifSampler_file};

	$family{$family_name}->{MotifSampler_matrix} = $family{$family_name}->{MotifSampler_dir}."/".$family{$family_name}->{file_prefix}.$MS_suffix.".matrix";
	$MS_options .= " -m ".$family{$family_name}->{MotifSampler_matrix};

	## Assign MotifSampler options to the family
	$family{$family_name}->{MotifSampler_suffix} = $MS_suffix;
	$family{$family_name}->{MotifSampler_options} = $MS_options;


	################################################################
	## MEME
	my $meme_options = "";
	my $meme_suffix = "";

	## input file
	$meme_options .= " ".$family{$family_name}->{input_seq_file};

	## strands
	$meme_suffix .= $strands;
	unless ($strands eq "-1str") {
	    $meme_options .= " -revcomp";
	}

	## Background frequencies
	$meme_dir = $ENV{MEME_DIR} || $RSA."/bin/meme/";
	if ($MEME_bfile) { 
	    $meme_options .= " -bfile ".$MEME_bfile;
	}

	foreach my $option (@MEME_options) {
	    $meme_options .= " -".$option." ".$MEME_options{$option};
	    unless ($option eq "bfile") {
	      $meme_suffix .= "_".$option.$MEME_options{$option};
	    }
	}

	## Output file
	$family{$family_name}->{meme_dir} = ${family_name}."/"."meme_".${family_name};
	$family{$family_name}->{meme_file} = $family{$family_name}->{meme_dir}."/".$family{$family_name}->{file_prefix}.$meme_suffix;
	$meme_options .= " > ".$family{$family_name}->{meme_file};

	$family{$family_name}->{meme_options} = $meme_options;
	$family{$family_name}->{meme_suffix} = $meme_suffix;

	################################################################
	## ORM
	my $orm_options = "";


	##
	## Options for ormbg
#	$ormbg_suffix .= $organism_name;

	## Options for orm
	my $orm_suffix = $ormbg_suffix;

	## Location
	$orm_options .= " --location=".$ORM_location;

	## Number of top motifs
	$orm_options .= " -u rank ".$ORM_uth_rank;
	$orm_suffix .= "_rank".$ORM_uth_rank;

	## Occurrence significance
	$orm_options .= " -d occ_sig ".$ORM_lth_occ_sig;
	$orm_suffix .= "_occ_sig".$ORM_lth_occ_sig;
	$orm_options .= " --sort=-occ_sig";

	## Window width
	$orm_options .= " -d width ".$ORM_lth_width;
	$orm_suffix .= "_minwidth".$ORM_lth_width;

	## Word rank
	$orm_options .= " -u w_rank ".$ORM_uth_wrank;
	$orm_suffix .= "_wrank".$ORM_uth_wrank;

	## Fixed window size
#	if ($ORM_fixedsizewindow) {
#	    $orm_options .= " --fixedsizewindow";
#	    $orm_suffix .= "_z";
#	}

	## input file
	$orm_options .= " --input=".$family{$family_name}->{input_seq_file};


	$orm_options .= " --background=".$ormbg_file;

	## Output file
	$family{$family_name}->{orm_dir} = ${family_name}."/"."orm_".${family_name};
	$family{$family_name}->{orm_file} = $family{$family_name}->{orm_dir}."/".$family{$family_name}->{file_prefix}."_".$orm_suffix;
	$orm_options .= " --output=".$family{$family_name}->{orm_file};
	$family{$family_name}->{orm_options} = $orm_options;
	$family{$family_name}->{orm_suffix} = $orm_suffix;

	$family{$family_name}->{orm_assembly_file} = $family{$family_name}->{orm_file}.".asmb";
	$family{$family_name}->{orm_pssm_file} = $family{$family_name}->{orm_file}."_pssm";
#	$family{$family_name}->{orm_selection} = $family{$family_name}->{orm_file}."_selection";
	$family{$family_name}->{orm_ft_prefix} = $family{$family_name}->{orm_file};
#	$family{$family_name}->{selection_ft_prefix} = $family{$family_name}->{orm_ft_prefix}."_report";
	$family{$family_name}->{orm_ft_file} = $family{$family_name}->{orm_ft_prefix}.".ft";
	$family{$family_name}->{orm_vs_known} = $family{$family_name}->{orm_file}."__vs__known_relw".$rel_w.".tab";
	$family{$family_name}->{orm_vs_known_weight_table} = $family{$family_name}->{orm_file}."__vs__known_weigth_table.tab";
	$family{$family_name}->{orm_vs_known_relw_table} = $family{$family_name}->{orm_file}."__vs__known_relw_table.tab";

	################################################################
	## Consensus options and files
	my $consensus_options = "";
	my $consensus_suffix = "";
	
	## Number of matrices to print
	$consensus_options .= " -pf 1 -pt 1";

	## strands
	if ($strands eq "-1str") {
	    $consensus_options .= " -c0"; ## Single-strand search
	    $consensus_suffix .= "-c0";
	} else {
	    $consensus_options .= " -c2"; ## Double-strand search
	    $consensus_suffix .= "-c2";
	}
	
	## Matrix width
	$consensus_options .= " -L ".$matrix_width;
	$consensus_suffix .= "-L".$matrix_width;
	
	## alphabet
	$consensus_options .= " -A a:t 0.325 c:g 0.175";
	
	## Use designated prior frequencies
#    $consensus_options .= " -d"; 

	## Expected number of sites
	$consensus_options .= " -n ".$expected_sites;
	$consensus_suffix .= "-n".$expected_sites; 
	$family{$family_name}->{consensus_suffix} = $consensus_suffix;
	$family{$family_name}->{consensus_options} = $consensus_options;
	$family{$family_name}->{consensus_dir} = "${family_name}/consensus_${family_name}";
	$family{$family_name}->{consensus_file} = $family{$family_name}->{consensus_dir}."/".$family{$family_name}->{file_prefix}.$consensus_suffix;
    }


    ################################################################
    ## Suffix for the synthetic table
    if ($family_file) {
	$table_suffix = $family_file;
    } elsif ($sequence_file_list) {
	$table_suffix .= $sequence_file_list;
	$table_suffix =~  s/\.tab$//;
	$table_suffix =~  s/\.txt$//;
    } else {
	$table_suffix = $organism_name;
    }
    if ($markov) {
	$table_suffix .= "_mkv${markov_order}";
    } elsif ($background) {
	$table_suffix .= "_bg_${background}";
    }

    if ($family_file) {
	$table_suffix .= "_up".$from     if (defined($from));
	$table_suffix .= "_".$to     if (defined($to));
	$table_suffix .= "_".$feature_types  if (defined($feature_types));
	$table_suffix .= $noorf_string;
    }
    if ($analyze_purged_sequences) {
	$table_suffix .= "-purge";
    } else {
	$table_suffix .= "-nopurge";
    }
    $table_suffix .= "_".$min_oligo_len."nt";
    $table_suffix .= "_".$max_oligo_len."nt";
    $table_suffix .= $noov;
    $table_suffix .= $strands;
    $table_suffix .= &ThresholdSuffix();
#    $table_suffix .= "_sig".$lth{occ_sig};
    $table_suffix = `basename $table_suffix`;
    chomp $table_suffix;

    ################################################################
    ## Name of the report for the Motif Discovery Competition 2004
    $dir{mdc_report} = "mdc_report";
    $outfile{results} = $dir{mdc_report}."/".$table_suffix."_results.txt";
    $outfile{parameters} = $dir{mdc_report}."/".$table_suffix."_parameters.txt";
}

################################################################
##################### SUBROUTINE DEFINITION ####################


################################################################
#### retrieve upstream sequences
sub UpstreamSequences {
    &RSAT::message::TimeWarn ("Retrieving upstream sequences for family ".$family_name, $organism_name) if ($verbose >= 1);
    my $command;
    if ($taxon) {
	$command = "get-orthologs";
	$command .= " -org ". $organism_name;
	$command .= " -taxon ". $taxon;
	$command .= " -i ".$family{$family_name}->{family_file};
	$command .= " -o ".$family{$family_name}->{ortho_file};
	$command .= "; retrieve-seq-multigenome";
	$command .= " -label organism_name,id,name ";
	$command .= " -i ".$family{$family_name}->{ortho_file};
    } else {
	$command = "retrieve-seq";
	$command .= " -label id,name ";
	$command .= " -i ".$family{$family_name}->{family_file};
	$command .= " -org ". $organism_name;
    }
    $command .= " -imp_pos -type upstream";
    $command .= " -noorf " if ($noorf);
    $command .= " -rm " if ($repeat_masked);
    $command .= " -o ".$family{$family_name}->{seq_file};
    $command .= " -from ".$from if (defined($from));
    $command .= " -to ".$to if (defined($to));
    $command .= " -feattype $feature_types " if ($feature_types);
    $command .= " -format $seq_format";
    if ($batch) {
	push @main::batch_commands, $command;
    } else {
	&doit($command, $dry_run, $die_on_error, $verbose);
    }
}

################################################################
#### Purge input sequences
sub PurgeSequences {
   warn ";\tPurging sequences for family $family_name\n" if ($verbose >= 1);

   ## Remove sequences of length 0
   $command = "convert-seq -dna -from fasta -to fasta -lw 0 -noempty";
   $command .= " -i ".$family{$family_name}->{seq_file};
   $command .= " | purge-sequence -format fasta -ml ".$purge_ml." -mis ".$purge_mis." -noempty";
   $command .= " -o ".$family{$family_name}->{seq_file_purged};
   if ($batch) {
       push @main::batch_commands, $command;
   } else {
       &doit($command, $dry_run, $die_on_error, $verbose);
   }
}


################################################################
### Calculate options and file names according to the selected
### parameters
sub CalcOligoOptions {
   my ($oligo_len) = @_;
   $oligo_options = "-v";
#   $oligo_options .= " -lth occ 1 "; ## This is to avoid calculating P-value for patterns not rpesent in the dataset, and for having a correct correction for multi-testing. 
   $oligo_options .= " -pseudo ".$pseudo if ($pseudo);
   $oligo_options .= " -sort ";
   $oligo_options .= " ".$strands;
   $oligo_options .= " -l ".$oligo_len;
   $oligo_options .= &ThresholdOptions();
#   $oligo_options .= " -lth occ_sig ".$lth{occ_sig};
#   if (&IsReal($lth{ms_freq})) {$oligo_options .= " -thmsf ".$lth{ms_freq} ; }
#   if (&IsReal($lth{ms_sig})) {$oligo_options .= " -thmssig ".$lth{ms_sig} ; }

   if ($mask) {
       $oligo_options .= " -mask ".$mask;
   }
   
   if ($markov) {
	### Markov chain model
	$oligo_options .= " -markov ".$markov_order;
	
   } elsif ($exp_freq_file{oligos}) {
       ## Convert relative path in absolute path
       unless ($exp_freq_file{oligos} =~ /^\//) {
	   $exp_freq_file{oligos} = $dir{main}."/".$exp_freq_file{oligos};
       }
	### Manually specified expected frequencies
	$oligo_options .= " -expfreq ".$exp_freq_file{oligos};
	
   } elsif ($background eq "calib1") {
	### Single-sequence based calibrated occurrences (mean and var per sequence)
	my $calib_length = $family{$family_name}->{calib_length};
	my $calib_file = &CalibrationPrefix($calib_length, $oligo_len);
	$calib_file .= "_negbin.tab";
	### Check whether the calibration file exists
	unless ((-e $calib_file) || (-e $calib_file.".gz")) {
	    &RSAT::error::FatalError ("Calibration file not found\t".$calib.file);
	}
	$oligo_options .= " -calib1 ".$calib_file;
	warn join ("\t", "; Oligonucleotide calibration", $calib_length, $calib_file), "\n" if ($main::verbose >= 3);
	
   } elsif ($background eq "calibN") {
	### Set-based calibrated occurrences (mean and var per set of N sequences)
	my $calib_length = $family{$family_name}->{calib_length};
	my $N = scalar(@{$family{$family_name}->{members}});
	my $calib_file = &CalibrationPrefix($calib_length, $oligo_len, $N);
	$calib_file .= "_negbin.tab";

	### Check whether the calibration file exists
	unless ((-e $calib_file) || (-e $calib_file.".gz")) {
	    ### temporary: if there is no R10000 file, try R1000
	    $calib_file =~ s/10000/1000/g;
	    if ((-e $calib_file) || (-e $calib_file.".gz")) {
		&RSAT::message::Warning("Using calibration with 1000 repetitions\t".$calib_file);
	    } else {
		### temporary: if there is no R1000 file, try R100
		$calib_file =~ s/1000/100/g;
		if ((-e $calib_file) || (-e $calib_file.".gz")) {
		    &RSAT::message::Warning("Using calibration with 100 repetitions\t".$calib_file);
		    
		} else {
		    &RSAT::error::FatalError ("Calibration file not found\t".$calib_file);
		}
	    }
	}
	
	$oligo_options .= " -calibN ".$calib_file;
	warn join ("\t", "; Oligonucleotide calibration", $calib_length, $calib_file), "\n" if ($main::verbose >= 3);
	
   } else {
	### Pre-calculated expected frequency files
	$oligo_options .= " -bg ".$background;
	$oligo_options .= " -org ".$organism_name if ($organism_name);
   }
   $oligo_options .= " -return occ,mseq,freq,proba,rank";
   $oligo_options .= " ".$noov;
   
   my $oligo_suffix = "_oligos";
   if ($markov) {
       $oligo_suffix .= "_mkv".$markov_order;
   } elsif ($background) {
       $oligo_suffix .= "_bg_".$background;
   }
   $oligo_suffix .= "_${oligo_len}nt";
   $oligo_suffix .= $strands;
   $oligo_suffix .= &ThresholdSuffix();
#   $oligo_suffix .= "_sig".$lth{occ_sig};
#   $oligo_suffix .= "_thmsf".$lth{ms_freq} if (&IsReal($lth{ms_freq}));
#   $oligo_suffix .= "_thmssig".$lth{ms_sig} if (&IsReal($lth{ms_sig}));
   $oligo_suffix .= $noov;
   
   $oligo_file = "$family_name/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix;    
   $command = "oligo-analysis -i $family{$family_name}->{input_seq_file} -format $seq_format -o $oligo_file $oligo_options";

   return ($command, $oligo_file, $oligo_suffix, $oligo_options);
}


################################################################
### oligo-analysis
sub OligoAnalysis {
  &RSAT::message::TimeWarn("Analyzing oligonucleotides for family $family_name",
			   "min len: $min_oligo_len",
			   "max len: $max_oligo_len") if ($verbose >= 1);
  my $dir = "${family_name}/oligos_${family_name}";
   
   chdir($dir{output}); &RSAT::util::CheckOutDir($dir);
   &RSAT::error::FatalError( "Cannot read file $family{$family_name}->{input_seq_file}") unless (($batch)  || ($dry_run) || ($dry_run) || (-r $family{$family_name}->{input_seq_file}));
  
   ## initialize the oligo file
#    system "echo '' > $family{$family_name}->{oligo_file}"; # if ($verbose >=1);

   ## Analyze all oligo lengths
   my @oligo_commands = ();
   for $oligo_len ($min_oligo_len..$max_oligo_len) {
	my ($one_oligo_command, $one_oligo_file) = &CalcOligoOptions($oligo_len);
	push @oligo_commands, $one_oligo_command;
#	&doit($command, $dry_run, $die_on_error, $verbose);
#	system "cat $oligo_file >> $family{$family_name}->{oligo_file}";
   }

   ## Merge the results obtained with different oligo lengths
   my $merge_command = &MergeOligoLengths();
   push @oligo_commands, $merge_command;

   if ($batch) {
       push @main::batch_commands, @oligo_commands;
   } else {
       my $command = join "; \\\n", @oligo_commands;
       &doit($command, $dry_run, $die_on_error, $verbose);
   }
}

################################################################
### Merge the results of oligo-analysis for different oligo lengths
sub MergeOligoLengths {
   &RSAT::message::TimeWarn("Merging oligonucleotides for family ".$family_name,
			    "min len: ".$min_oligo_len,
			    "max len:".$max_oligo_len,
			    $family{$family_name}->{oligo_file}) if ($verbose >= 1);
   my $dir = "${family_name}/oligos_${family_name}";

   chdir($dir{output}); &RSAT::util::CheckOutDir($dir);
   &RSAT::error::FatalError("Cannot read file ".$family{$family_name}->{input_seq_file}) unless (($batch) || ($dry_run) ||(-r $family{$family_name}->{input_seq_file}));

   ## initialize the oligo file
   my @merge_commands = "echo '' > $family{$family_name}->{oligo_file}"; # if ($verbose >=1);    
   for $oligo_len ($min_oligo_len..$max_oligo_len) {
	($command, $oligo_file) = &CalcOligoOptions($oligo_len);
	push @merge_commands, "cat ".$oligo_file." >> ".$family{$family_name}->{oligo_file};
   }

   ### pattern assembly
   &RSAT::message::TimeWarn("Assembling oligo patterns", $family{$family_name}->{oligo_assembly_file}) 
       if ($main::verbose >= 2);
   my $assembly_command = "pattern-assembly -v 1";
   $assembly_command .= " -maxfl 1 -toppat ".$toppat." -subst 1 ".$strands;
   $assembly_command .= " -i ".$family{$family_name}->{oligo_file};
   $assembly_command .= " -o ".$family{$family_name}->{oligo_assembly_file};
   push @merge_commands, $assembly_command;

   ### extract PSSM from pattern assembly
#   my $pssm_command = "convert-matrix -v 1 ";
#   $pssm_command .= " -i ".$family{$family_name}->{oligo_assembly_file};
#   $pssm_command .= " -from assembly -out_format patser -return counts,profile,parameters";
#   $pssm_command .= " -o ".$family{$family_name}->{oligo_pssm_file};
#   push @merge_commands, $pssm_command;

   &RSAT::message::TimeWarn("Matrix from oligo patterns", $family{$family_name}->{oligo_pssm_file}) 
       if ($main::verbose >= 2);
   my $pssm_command = "matrix-from-patterns -v 1 ";
   $pssm_command .= " -seq ".$family{$family_name}->{seq_file};
   $pssm_command .= " -asmb ".$family{$family_name}->{oligo_assembly_file};
   $pssm_command .= " -bginput -markov 0 ";
   $pssm_command .= " -o ".$family{$family_name}->{oligo_pssm_file};
   push @merge_commands, $pssm_command;

   my $merge_command = join "; \\\n", @merge_commands;
   if ($task{oligos}) {
       return $merge_command;
   } else {
       if ($batch) {
	   push @main::batch_commands, @merge_commands;
       } else {
	   &doit($merge_command, $dry_run, 0, $verbose);
       }
   }
}


################################################################
## Match discovered patterns (oligos and dyads only)
sub MatchPatterns {
   my ($oligo_file, $fmap_prefix, $options) = @_;

   ## check file names
   $oligo_file = $family{$family_name}->{oligo_file} unless ($oligo_file);
   $fmap_prefix = $oligo_file unless ($fmap_prefix);

   ### pattern matching
   &RSAT::error::FatalError("Cannot read file $family{$family_name}->{seq_file}") unless (($batch) || ($dry_run) || (-r $family{$family_name}->{seq_file}));
   $feature_file = $fmap_prefix.".ft";
   &RSAT::message::Info("Matching patterns",
			"\n;\t", $oligo_file,
			"\n;\t", $feature_file,
		       )  if ($main::verbose >= 1);

   $origin = "-0";
   my $command = "dna-pattern -i ".$family{$family_name}->{seq_file};
   $command .= " -format ".$seq_format;
   $command .= " -pl ".$oligo_file;
   $command .= " -origin ".$origin;
   $command .= " -return sites,limits ";
   $command .= $options;
   $command .= " | features-from-dnapat -o ".$feature_file;

   ## Check if pattern matching is OK (sometimes there are no patterns)
   if ($batch) {
       push @main::batch_commands, $command;
   } else {
       my $error = &doit($command, $dry_run, 0, $verbose);
       if ($error) {
	   &RSAT::message::Warning("Feature map skipped because dna-pattern returned an error");
	   return;
       }
   }
}


################################################################
## Scan the sequences with a position-specific scoring matrix
sub ScanSequences {
   my ($matrix_file, $matrix_format, $fmap_prefix, $options) = @_;

   ## check file names
   &RSAT::error::FatalError("ScanSequences require to specify a matrix file") unless ($matrix_file);
   &RSAT::error::FatalError("ScanSequences require to specify a matrix format") unless ($matrix_format);
   &RSAT::error::FatalError("ScanSequences require to specify a prefix for the scanning result") unless ($fmap_prefix);

   ### pattern matching
   &RSAT::error::FatalError("Cannot read file $family{$family_name}->{seq_file}") unless (($batch) || ($dry_run) || (-r $family{$family_name}->{seq_file}));
   $feature_file = $fmap_prefix.".ft";
   &RSAT::message::Info("Scaning sequences with matrix",
			"\n;\t", $matrix_file,
			"\n;\t", $feature_file,
		       )  if ($main::verbose >= 1);

   $origin = "-0";
   my $command = "matrix-scan -v 1 -bginput -markov 1 -i ".$family{$family_name}->{seq_file};
   $command .= " -seq_format ".$seq_format;
   $command .= " -matrix_format ".$matrix_format;
   $command .= " ".$strands;
   $command .= " -m ".$matrix_file;
   $command .= " -consensus_name";
   $command .= " -origin ".$origin;
   $command .= " -return limits,sites,pval,normw ";
   $command .= " -o ".$feature_file;
   $command .= $options;

#   die $command, "\n";

   ## Check if scanning is OK (sometimes there are no matrices)
   if ($batch) {
       push @main::batch_commands, $command;
   } else {
       my $error = &doit($command, $dry_run, 0, $verbose);
       if ($error) {
	   &RSAT::message::Warning("Feature map skipped because matrix-scan returned an error");
	   return;
       }
   }
}

################################################################
#### draw feature-map for the result of dna-pattern
sub DrawFeatureMap {
   my ($fmap_prefix, $title, $options) = @_;

   ## check file names
   $fmap_prefix = $family{$family_name}->{oligo_ft_prefix} unless ($fmap_prefix);
   $title = &ShortFileName($fmap_prefix) unless ($title);

   ### pattern matching
   &RSAT::error::FatalError("Cannot read file $family{$family_name}->{seq_file}") unless (($batch) || ($dry_run) || (-r $family{$family_name}->{seq_file}));
   $feature_file = $fmap_prefix.".ft";
   $fmap_file = $fmap_prefix.".".$IMG_FORMAT;
   $htmap_file = $fmap_prefix.".html";
   &RSAT::message::Info("Drawing feature-map",
			"\n;\t", $feature_file,
			"\n;\t", $fmap_file,
			"\n;\t", $htmap_file,
		       )  if ($main::verbose >= 1);

   ## feature-map drawing
   if ($family{$family_name}->{calib_length}) {
	$from = -$family{$family_name}->{calib_length};
	$to = -1;
   }
   $command = "feature-map -i ".$feature_file;
   $command .= " -minfthick 2";
   $command .= " -scalebar -scalestep $scalestep -legend ";
   $command .= " -title '".$title."'";
#   $command .= " -from $from" if (defined($from));
#   $command .= " -to $to" if (defined($to));
   $command .= " -o $fmap_file -scorethick ";
   $command .= " ".$options;
   if ($htmaps) {
	$command .= " -htmap > $htmap_file ";
   };
   
   if ($batch) {
       push @main::batch_commands, $command;
   } else {
       &doit($command, $dry_run, 0, $verbose);
   }
}

################################################################
### dyad analysis
sub DyadAnalysis {
    &RSAT::message::TimeWarn("Analyzing dyads for family $family_name",
			     "monad length: $monad_length",
			     "min_sp: $min_sp",
			     "max_sp: $max_sp",
	) if ($verbose >= 1);
    $dir = "${family_name}/dyads_${family_name}";
    chdir($dir{output}); &RSAT::util::CheckOutDir($dir);
    &RSAT::error::FatalError("Cannot read file $family{$family_name}->{input_seq_file}") unless (($batch) || ($dry_run) || (-r $family{$family_name}->{input_seq_file}));
    $command = "dyad-analysis";
    $command .= " -return occ,proba,rank";
    $command .= " -i ".$family{$family_name}->{input_seq_file};
    $command .= " -format ".$seq_format;
    $command .= " -o ".$family{$family_name}->{dyad_file};
    $command .= " ".$dyad_options;
    $command .= " -org ".$organism_name if ($org_fam);

   if ($mask) {
       $command .= " -mask ".$mask;
   }

   ### pattern assembly
   &RSAT::message::TimeWarn("Assembling dyad patterns", $family{$family_name}->{dyad_assembly_file}) 
       if ($main::verbose >= 2);
   $command .= "; pattern-assembly -v 1";
   $command .=  " -maxfl 1 -toppat ".$toppat;
   $command .=  " ".${strands};
   $command .= " -i ".$family{$family_name}->{dyad_file};
   $command .= " -o ".$family{$family_name}->{dyad_assembly_file};

   ### extract PSSM from pattern assembly
   &RSAT::message::TimeWarn("Matrix from dyad patterns", $family{$family_name}->{dyad_pssm_file}) 
       if ($main::verbose >= 2);
   $command .= "; matrix-from-patterns -v 1 ";
   $command .= " -seq ".$family{$family_name}->{seq_file};
   $command .= " -asmb ".$family{$family_name}->{dyad_assembly_file};
   $command .= " -bginput -markov 0 ";
   $command .= " -o ".$family{$family_name}->{dyad_pssm_file};

   if ($batch) {
       push @main::batch_commands, $command;
   } else {
       &doit($command, $dry_run, $die_on_error, $verbose);
   }
}


################################################################
## Merge patterns detected by oligo-analysis and dyad-analysis
sub MergePatterns {
   my $filter_dyads = 1;
   &RSAT::message::TimeWarn("Merging oligonucleotides and dyads for family ",
			    $family_name,
			    $family{$family_name}->{merged_file}
			   ) if ($verbose >= 1);
   my $dir = "${family_name}/merged_${family_name}";
   chdir($dir{output}); &RSAT::util::CheckOutDir($dir);
   my $command = "cat $family{$family_name}->{oligo_file}";
#    $command .= " | grep -v '^;'";
   $command .= " > $family{$family_name}->{merged_file};";
   $command .= " cat $family{$family_name}->{dyad_file}";
#    $command .= " | grep -v '^;'";
   if ($filter_dyads) {
	$command .= " | grep -v '\{0\}'";
   } else {
	$command .= " | perl -pe 's/n\{0\}//g'";
   }
   $command .= " >> $family{$family_name}->{merged_file};";
   $command .= " wc $family{$family_name}->{merged_file}";
   if ($batch) {
       push @main::batch_commands, $command;
   } else {
       &doit($command, $dry_run, $die_on_error, $verbose);
   }
   &DrawMergedFeatureMap() if ($task{map});
}


################################################################
#### draw feature-map for the result of merged oligonucleotides and dyads
sub DrawMergedFeatureMap {
  &RSAT::message::TimeWarn("Drawing feature-map with results of merged oligonucleotides and dyads for family $family_name")
    if ($verbose >= 1);
  ### pattern matching
  &RSAT::error::FatalError("Cannot read file $family{$family_name}->{seq_file}") unless (($batch) || ($dry_run) || (-r $family{$family_name}->{seq_file}));
  $fmap_file = $family{$family_name}->{merged_file}.".${IMG_FORMAT}";
  $htmap_file = $family{$family_name}->{merged_file}.".html";
  $origin = "-0";
  my $command = "dna-pattern -i $family{$family_name}->{seq_file} -format $seq_format -pl $family{$family_name}->{merged_file} -origin $origin -N 4 -return sites,limits ";
  $command .= " | features-from-dnapat -o $family{$family_name}->{merged_ft_file} ";
  
  if ($batch) {
    push @main::batch_commands, $command;
  } else {
    my $error = &doit($command, $dry_run, 0, $verbose);
    if ($error) {
      &RSAT::message::Warning("Feature map skipped because dna-pattern returned an error");
      return;
    }
  }
  
  ## feature-map drawing
  if  ($family{$family_name}->{calib_length}) {
    $from =  $family{$family_name}->{calib_length};
    $to = -1;
  }
  $command = " feature-map -i $family{$family_name}->{merged_ft_file} -scalebar -scalestep $scalestep -legend ";
  $command .= " -title ";
  $command .= &ShortFileName($family{$family_name}->{merged_ft_file});
  #   $command .= " -from $from" if (defined($from));
  #   $command .= " -to $to" if (defined($to));
  $command .= " -o $fmap_file -scorethick ";
  if ($htmaps) {
    $command .= " -htmap > $htmap_file ";
  };

  ## Delete the feature file to save disk space (the feature space
  ## occupy half od the result directory)
  $command = "; rm -f ".$family{$family_name}->{merged_ft_file};

  if ($batch) {
    push @main::batch_commands, $command;
  } else {
    &doit($command, $dry_run, 0, $verbose);
  }
}


################################################################
## Run Gert Thijs' MotifSampler
sub MotifSampler {
  &RSAT::message::TimeWarn ("Running MotifSampler for family $family_name") if ($main::verbose >= 1);
  ## Check output directory
  my $dir = $family{$family_name}->{MotifSampler_dir};
  chdir($dir{output}); &RSAT::util::CheckOutDir($dir);

  ## run the command
  my $MS_command = "MotifSampler ".$family{$family_name}->{MotifSampler_options};
  unless (($batch) || ($main::verbose >= 3)) {
    ## Suppress verbosity
    $MS_command = "(".$MS_command.") >& MS_log.txt";
  }
  $MS_command .= "; MotifRanking -m 2";
  $MS_command .= " -i ".$family{$family_name}->{MotifSampler_file};
  $MS_command .= " -o ".$family{$family_name}->{MotifSampler_file}."_ICsorted";
  $MS_command .= "; ";
  $MS_command .= &ConvertMatrixCommand($family{$family_name}->{MotifSampler_file}."_ICsorted", "MotifSampler");
  if ($batch) {
    push @main::batch_commands, $MS_command;
  } else {
    &doit($MS_command, $dry_run, $die_on_error, $verbose);
  }
}


################################################################
## Run Andrew Neuwald's gibbs program 
sub Gibbs {
  chdir($dir{output}); &RSAT::util::CheckOutDir($family{$family_name}->{gibbs_dir});


  if ($strand = "-2str") {
    $addrc = " -addrc";
  }
  ## This can be useful in case the file is compressed
  my $gibbs_command = "convert-seq ".$addrc;
  $gibbs_command .= " -from fasta -to fasta ";
  $gibbs_command .= " -i ".$family{$family_name}->{input_seq_file};
  $gibbs_command .= " -o ".$family{$family_name}->{gibbs_input_seq_file};
  $gibbs_command .= " ; gibbs ".$family{$family_name}->{gibbs_options};
  $gibbs_command .= " > ".$family{$family_name}->{gibbs_file}; 
  unless (($batch) || ($main::verbose >= 3)) {
    ## Suppress verbosity
    $gibbs_command = "(".$gibbs_command.") >& gibbs_log.txt";
  }

  $gibbs_command .= "; ";
  $gibbs_command .= &ConvertMatrixCommand($family{$family_name}->{gibbs_file}, "gibbs");

  if ($batch) {
    push @main::batch_commands, $gibbs_command;
  } else {
    &doit($gibbs_command, $dry_run, $die_on_error, $verbose);
  }
}


################################################################
## Run Roth's AlignACE program
sub AlignACE {
  chdir($dir{output}); &RSAT::util::CheckOutDir($family{$family_name}->{AlignACE_dir});


  if ($strand = "-2str") {
    $addrc = " -addrc";
  }

  ## This can be useful in case the file is compressed, and to covert
  ## n characters (masked nucleotide) into dots
  my $AlignACE_command = "convert-seq ";
  $AlignACE_command .= " -from fasta -to fasta -dotmask";
  $AlignACE_command .= " -i ".$family{$family_name}->{input_seq_file};
  $AlignACE_command .= " -o ".$family{$family_name}->{AlignACE_input_seq_file};
  $AlignACE_command .= " ; AlignACE ".$family{$family_name}->{AlignACE_options};
  $AlignACE_command .= " > ".$family{$family_name}->{AlignACE_file};

  $AlignACE_command .= "; ";
  $AlignACE_command .= &ConvertMatrixCommand($family{$family_name}->{AlignACE_file}, "AlignACE");

  if ($batch) {
    push @main::batch_commands, $AlignACE_command;
  } else {
    &doit($AlignACE_command, $dry_run, $die_on_error, $verbose);
  }
}


################################################################
## Run MEME program 
sub MEME {
  chdir($dir{output}); &RSAT::util::CheckOutDir($family{$family_name}->{meme_dir});

  ## run the command
  $meme_command = "meme ".$family{$family_name}->{meme_options};
  unless (($batch) || ($main::verbose >= 3)) {
    ## Suppress verbosity
    $meme_command = "(".$meme_command.") >& meme_log.txt";
  }
  $meme_command .= "; ";
  $meme_command .= &ConvertMatrixCommand($family{$family_name}->{meme_file}, "meme");
  if ($batch) {
    push @main::batch_commands, $meme_command;
  } else {
    &doit($meme_command, $dry_run, 0, $verbose);
  }
}


################################################################
## Run orm program 
sub orm {
  chdir($dir{output}); &RSAT::util::CheckOutDir($family{$family_name}->{orm_dir});

  ## run the command
  my $orm_command = ""; 
  if ($ENV{ORM}) {
    $orm_command = $ENV{ORM};
  } else {
    $orm_command = "orm.py";
  }
  $orm_command .= " -v1 ".$family{$family_name}->{orm_options};
  if ($task{assemble_orm}) {
    &RSAT::message::TimeWarn("Assembling orm patterns", $family{$family_name}->{orm_assembly_file}) 
      if ($main::verbose >= 2);
    $orm_command .= "; pattern-assembly -v 1";
    $orm_command .= " -maxfl 1 -subst 1 -toppat ".$toppat." ".$strands;
    $orm_command .= " -i ".$family{$family_name}->{orm_file};
    $orm_command .= " -o ".$family{$family_name}->{orm_assembly_file};

    ### extract PSSM from pattern assembly
    &RSAT::message::TimeWarn("Matrix from orm patterns", $family{$family_name}->{orm_pssm_file}) 
      if ($main::verbose >= 2);
    $orm_command = "matrix-from-patterns -v 1 ";
    $orm_command .= " -seq ".$family{$family_name}->{seq_file};
    $orm_command .= " -asmb ".$family{$family_name}->{orm_assembly_file};
    $orm_command .= " -bginput -markov 0 ";
    $orm_command .= " -o ".$family{$family_name}->{orm_pssm_file};
  }

  if ($batch) {
    push @main::batch_commands, $orm_command;
  } else {
    &doit($orm_command, $dry_run, 0, $verbose);
  }
}

################################################################
## Run ormbg program 
sub ormbg {
  chdir($dir{output}); &RSAT::util::CheckOutDir($dir{ormbg});

  #### retrieve upstream sequences
  $ormbg_command = "retrieve-seq -all -imp_pos -type upstream -org ".$organism_name;
  $ormbg_command .= " -noorf " if ($noorf);
  $ormbg_command .= " -from $from" if (defined($from));
  $ormbg_command .= " -to $to " if (defined($to));
  $ormbg_command .= " -label id,name ";
  $ormbg_command .= " -feattype $feature_types " if ($feature_types);
  $ormbg_command .= " -format fasta";

  ## ormbg command
  if ($ENV{ORMBG}) {
    $ormbg_command .= " | " .$ENV{ORMBG};
  } else {
    $ormbg_command .= " | ormbg.py";
  }
  $ormbg_command .= " -v 1 ".$ormbg_options;

  #   if ($batch) {
  #       push @main::batch_commands, $ormbg_command;
  #   } else {
  &doit($ormbg_command, $dry_run, $die_on_error, $verbose);
  #   }
}


################################################################
## Run Jerry Hertz' consensus program 
sub Consensus {
  chdir($dir{output}); &RSAT::util::CheckOutDir($family{$family_name}->{consensus_dir});

  ## input file has to be converted to consensus format
  $consensus_command = "convert-seq -dna -from fasta -to wc -i ".$family{$family_name}->{input_seq_file};

  ## run the command
  #   $consensus_command .= " | tr n ."; ## Transpose N residues in . because N is not recognized by consensus
  $consensus_command .= " | consensus ".$family{$family_name}->{consensus_options};
  $consensus_command .= " > ".$family{$family_name}->{consensus_file};
  $consensus_command .= "; ";
  $consensus_command .= &ConvertMatrixCommand($family{$family_name}->{consensus_file}, "consensus");
  if ($batch) {
    push @main::batch_commands, $consensus_command;
  } else {
    &doit($consensus_command, $dry_run, 0, $verbose);
  }
}

################################################################
### Read known known_site for each family
sub ReadKnownSites {
  my ($known_site_file) = @_;
  %known_site = ();
  %known_site_source = ();
  if (-e $known_site_file) {
    $known_sites_provided = 1;
    open KNOWN_SITE, $known_site_file;
    while (<KNOWN_SITE>) {
      next if (/^;/);
      next if (/^\#/);
      next unless (/\S/);
      chomp;
      my @fields = split "\t";
      my $site_sequence = &RSAT::util::trim(shift(@fields));
      $site_sequence =~ s/N/n/g;
      #$site_sequence = &compress_pattern($site_sequence,"n");
      my $family_name = &RSAT::util::trim(shift(@fields));
      next if (length($site_sequence) > $known_site_max_len);
      my $source =  &RSAT::util::trim(shift(@fields));
      push @{$known_site{$family_name}}, $site_sequence;
      push @{$known_site_source{$family_name}}, $source;
      #	    &RSAT::message::Debug(join ("\t", "; known site", "family:".$family_name, "site:".$site_sequence, $source)) if ($main::verbose >= 10);
    }
    close KNOWN_SITE;
  }
}


################################################################
### Generate a synthetic table
sub SyntheticTable {
  my $dir = "synthetic_tables";

  $outfile{table} = $dir."/".$table_suffix;
  $outfile{table} .= "_tr" if ($transpose);
  $outfile{table} .= ".html";

  &RSAT::message::TimeWarn ("Generating synthetic table ", $outfile{table}) if ($verbose >= 1);

  unless (-d $dir) {
    mkdir $dir, 0755 || &RSAT::error::FatalError("Cannot create directory", $dir);
  }
   
  ### synthesize the results of all families into a single file
   
  ### headers
  $row = 0;
  $row{f} = $row++;
  $row{family} = $row++;
  $row{size} = $row++;
  $row{genes} = $row++;
  if ($seq_length_calculated) {
    $row{total_length} = $row++;
    $row{avg_length} = $row++;
  }
  $row{known} = $row++ if ($known_sites_provided);
  $row{oligos} = $row++;
  $row{dyads} = $row++;
  $row{orm} = $row++;
  $row{selection} = $row++ if ($task{report});
  $row{consensus} = $row++;
  $row{gibbs} = $row++;
  $row{AlignACE} = $row++;
  $row{meme} = $row++;
  $row{MotifSampler} = $row++;
  $row_num = $row-1;
  while (($header,$row) = each %row) {
    $table[$row][0] = "<B>$header</B>";
  }
  my $col = 0;
   
  foreach my $family_name (@families) {
    my @members = @{$family{$family_name}->{members}};
    $gene_nb = scalar(@members);

    ## Check minimum number of genes
    if ($gene_nb < $min_genes) {
      &RSAT::message::Warning("Skipping family", 
			      $fam_count, $family_name,
			      $gene_nb." genes",
			      "< min = ".$min_genes), "\n" if ($main::verbose >= 1);
      next;
    }

    $col++;

    #### Index columns associated to each family
    $column{$family_name} = $col;

    ### check directory
    $dir = "${family_name}/dyads_${family_name}";
    unless (-d $dir) {
      &RSAT::message::Warning ("Cannot find directory $dir\n");
    }
	
    ### family number
    $table[$row{f}][$col] = "<B>$col</B>";
	
    ### family name
    $table[$row{family}][$col] = "<B><a href='../".$family_name."'>".$family_name."</a></B>";
	
    #### number of genes
    $table[$row{size}][$col] = scalar(@{$family{$family_name}->{members}});
	
    #### sequence length
    if ($seq_length_calculated) {
      my $members = scalar(@{$family{$family_name}->{members}});
      if ($members > 0) {
	$family{$family_name}->{avg_length} = $family{$family_name}->{total_length}/$members;
      } else {
	$family{$family_name}->{avg_length} = "NA";
      }
      $table[$row{total_length}][$col] = $family{$family_name}->{total_length};
      $table[$row{avg_length}][$col] = sprintf("%.1f", $family{$family_name}->{avg_length});
    }

    ### list of genes
    $table[$row{genes}][$col] = "<a href='../".$family{$family_name}->{family_file}."'>";
    $table[$row{genes}][$col] .= join " ", @{$family{$family_name}->{members}};
    $table[$row{genes}][$col] .= "</a>";
	
    ### known patterns
    if ($known_sites_provided) {
      $table[$row{known}][$col] = "";
      my @fam_known_site = @{$known_site{$family_name}};
      my @fam_known_site_source = @{$known_site_source{$family_name}};
      for $c (0..$#fam_known_site) {
	#		$table[$row{known}][$col] .= ${known_site{$family_name}}[$c];
	$table[$row{known}][$col] .= $fam_known_site[$c];
	$table[$row{known}][$col] .= "<BR>(".$fam_known_site_source[$c].")" if ($fam_known_site_source[$c]);
	$table[$row{known}][$col] .= "<P>";
      }
    } 

    ################################################################
    #### Index results from oligo-analysis
    &IndexPatterns($family_name, 
		   $row{oligos}, 
		   $col, 
		   patterns=>$family{$family_name}->{oligo_file}, 
		   assembly=>$family{$family_name}->{oligo_assembly_file}, 
		   pssm=>$family{$family_name}->{oligo_pssm_file}, 
		   validation=>$family{$family_name}->{oligo_vs_known}, 
		   validation_table_relw=>$family{$family_name}->{oligo_vs_known_relw_table}, 
		   validation_table_weight=>$family{$family_name}->{oligo_vs_known_weight_table}, 
		   type=>"oligos", 
		  );

    ################################################################
    #### Index results from dyad-analysis
    &IndexPatterns($family_name, 
		   $row{dyads}, 
		   $col, 
		   patterns=>$family{$family_name}->{dyad_file}, 
		   assembly=>$family{$family_name}->{dyad_assembly_file}, 
		   pssm=>$family{$family_name}->{dyad_pssm_file}, 
		   validation=>$family{$family_name}->{dyad_vs_known}, 
		   validation_table_relw=>$family{$family_name}->{dyad_vs_known_relw_table}, 
		   validation_table_weight=>$family{$family_name}->{dyad_vs_known_weight_table}, 
		   type=>"dyads", 
		  );
	
    ################################################################
    #### Index results from oligo-analysis
    &IndexPatterns($family_name, 
		   $row{orm}, 
		   $col, 
		   patterns=>$family{$family_name}->{orm_file}, 
		   assembly=>$family{$family_name}->{orm_assembly_file}, 
		   pssm=>$family{$family_name}->{orm_pssm_file}, 
		   validation=>$family{$family_name}->{orm_vs_known}, 
		   validation_table_relw=>$family{$family_name}->{orm_vs_known_relw_table}, 
		   validation_table_weight=>$family{$family_name}->{orm_vs_known_weight_table}, 
		   type=>"orm", 
		  );

    ################################################################
    ### index results of manual pattern selection
    if ($task{report}) {
      &IndexPatterns($family_name, 
		     $row{selection}, 
		     $col, 
		     patterns=>$family{$family_name}->{oligo_selection},
		     type=>"manual"
		    );
    }


    ################################################################
    #### Index results of consensus
    &IndexConsensus($family_name, $row{consensus}, $col, matrix_file=>$family{$family_name}->{consensus_file});

    ################################################################
    #### Index results of gibbs
    &IndexGibbs($family_name, $row{gibbs}, $col, matrix_file=>$family{$family_name}->{gibbs_file});

    #### Index results of gibbs
    &IndexAlignACE($family_name, $row{AlignACE}, $col, matrix_file=>$family{$family_name}->{AlignACE_file});

    ################################################################
    #### Index results of meme
    &IndexMEME($family_name, $row{meme}, $col, matrix_file=>$family{$family_name}->{meme_file});

    ################################################################
    #### Index results of meme
    &IndexMotifSampler($family_name, $row{MotifSampler}, $col, matrix_file=>$family{$family_name}->{MotifSampler_file});
  }

  ###############################################################
  ## Print the header of the  synthetic table
  $syn = &OpenOutputFile($outfile{table});
  print $syn "<html>\n";
  print $syn "<title>",$table_suffix, "</title>","\n";
  print $syn "<body>\n";
  print $syn "<h1>".$table_suffix."</h1>\n";
   
  print $syn join( "\n",
		   "<pre>",
		   $verbose_message,
		   "</pre>"
		 ), "\n";
   
   
  print $syn "<table border=1>\n";

  ################################################################
  ## Add a link to the MDC report files
  if ($task{report}) {
    print $syn "<h4>Reports for the motif discovery competition</h4>";
    print $syn "<ul>";
    print $syn "<li><a href=../".$outfile{results}.">Results</a></li>";
    print $syn "<li><a href=../".$outfile{parameters}.">Parameters</a></li>";
    print $syn "</ul>";
  }


  ################################################################
  ## Sort families according to the selected criterion
  if ($sort_key eq "score") {
    #### sort families by score
    #### decreasing order
    @sorted_families = sort {$max_score{$b} <=> $max_score{$a}} @families; 

  } else {
    #### sort families by family name
    @sorted_families = sort @families;
  }


  ################################################################
  ## Transpose the result table
  if ($transpose) {
    foreach $r (0..$row_num) {
      print $syn "<tr valign=top>\n";
      foreach $f (@sorted_families) {
	my $c = $column{$f};
	print $syn "<td>", $table[$r][$c], "</td>\n";
      }
      print $syn "</tr>\n";
    }
  } else {
    #### print table header
    foreach $r (0..$row_num) {
      print $syn "<th>", $table[$r][0], "</th>\n";
    }
    #### print table content
    foreach $f (@sorted_families) {
      my $c = $column{$f};
      print $syn "<tr valign=top>\n";
      foreach $r (0..$row_num) {
	print $syn "<td>", $table[$r][$c], "</td>\n";
      }
      print $syn "</tr>\n";
    }
  }
   
  print $syn "</table>\n";
  print $syn "<hr>", &AlphaDate;
  print $syn "</body>\n";
  print $syn "</html>\n";
  close $syn;
  #    chdir "synthetic_tables";
  #    chdir "../";
}




################################################################
## Index the matrix from a consensus file
sub IndexConsensus {
   &IndexMatrix(@_, program=>"consensus");
}

################################################################
##  Read a matrix and generate a summary for the synthetic table
sub IndexMatrix {
   my ($family_name, $row, $col, %args) = @_;
   my $program = $args{program};

   my $base = "../";
   my $matrix_file = $args{matrix_file};
   my $program = $args{program};
#   my $family_dir = $args{dir}."/".$family_name."/";
   my $family_dir = $family_name."/";
   $family_dir =~ s|/+|/|g;
   my $matrix_dir = $family_dir.$program."_".$family_name."/";
   my $map_link = $base.$matrix_file;

   ## This piece of code has to be evaluated because it can raise an
   ## error, if the output file does not contain any matrix. This is
   ## the case for some output files of consensus, due to a bug.
   if (-e $matrix_file) {
#       &ConvertMatrix($matrix_file, $program);
       my @matrices = &ReadMatrices($family_name, $matrix_file, %args);
       $table[$row][$col] .= "<a href=".$base.$family_dir.">".$family_name."</a>\n";
       $table[$row][$col] .= "<a href=".$base.$matrix_file.">[".$program."]</a>\n";
       $table[$row][$col] .= "<a href=".$base.$matrix_file.".tab>[tab]</a>\n";
       $table[$row][$col] .= "<a href=".$base.$matrix_dir.">[dir]</a>\n";
#       $table[$row][$col] .= "<a href=".$base.$pattern_file.".".${IMG_FORMAT}.">[".${IMG_FORMAT}."]</a>\n";
#       if ($htmaps) {
#	   $table[$row][$col] .= "<a href=".$base.$pattern_file.".html>[html]</a>\n";
#       }
#       if ($matrix) {
#	   &RSAT::message::Debug("IndexMatrix", $matrix, 
#				 $matrix->get_attribute("id"),
#				 $matrix->get_attribute("input_file"),
#				) if ($main::verbose >= 10);
       $matrix_result = "";
       if (scalar(@matrices) > 0) {
	 my $m = 0;
	 foreach my $matrix (@matrices) {
	   $m++;
	   if ($m > $max_matrices) {
	     my $remaining = scalar(@matrices) - $m + 1;
	     $matrix_result .= ";\n; ... and ".$remaining." more matrices in the file.\n";
	     last;
	   }
	   &RSAT::message::Debug($family_name, "Indexing matrix", $m."/".scalar(@matrices),$program) 
	     if ($main::verbose >= 0);
#	   next;
#	   die "HELLO";
	   $matrix_result .= $matrix->toString(sep=>" ", col_width=>4, type=>"counts");
	   $matrix_result .= $matrix->toString(type=>"parameters");
	 }
	 $table[$row][$col] .= "<table cellpadding=3>\n";
	 $table[$row][$col] .= "<TR>\n";
	 $table[$row][$col] .= "<td colspan=2><pre>";
	 $table[$row][$col] .= $matrix_result;
	 $table[$row][$col] .= "</pre></td>\n";
	 $table[$row][$col] .= "</TR>\n";
	 $table[$row][$col] .= "</table>\n";
       } else {
	 $table[$row][$col] .= "<br><font color=red>No matrix could be found in the result file</font>\n";
       }
   } else {
       $table[$row][$col] =  "<a href=".$matrix_file."><font color=red>File not found</font></a><br>\n";
       &RSAT::message::Warning("File not found. Skipped.", $program, $matrix_file);
   }
}


################################################################
## Convert a PSSM to tab-delimited format

## Compute the options for converting a PSSM
sub ConvertMatrixCommand {
  my ($matrix_file, $program) = @_;

  ## Convert matrix in tab-delimited file
  my $command = "convert-matrix -v 1";
  $command .= " -from ".$program;
  $command .= " -to tab";
  $command .= " -return counts,parameters";
  $command .= " -i ".$matrix_file;
  my $sort_key = $pssm_sort_key{$program};
  my $sort_order = $pssm_sort_order{$program};
  if ($sort_key) {
    $command .= " -sort ".$sort_order." ".$sort_key;
  }
  $command .= " -o ".$matrix_file.".tab";
  return $command;
}

## Convert the PSSM
sub ConvertMatrix {
  my ($matrix_file, $program) = @_;
  my $command = &ConvertMatrixCommand($matrix_file, $program);
  &doit($command, $dry_run, $die_on_error, $verbose);
}

################################################################
##  Read a matrix from a matrix file and return a matrix object
##
## Matrix objects are used for displaying the top matrix in the
## synthetic table (-task synthesis), and for exporting matrices in
## tab-delimited files (-task sql).
##
sub ReadMatrices {
  my ($family_name, $matrix_file, %args) = @_;

  my $program = $args{program};
  &RSAT::message::TimeWarn("Indexing $program matrix for family", $family_name, $matrix_file, $row, $col) if ($verbose >= 2);

  ## If the matrix has already been loaded, return the indexed matrix
  if ($matrix_by_file{$matrix_file}) {
    return ($matrix_by_file{$matrix_file});
  } else {
    if (-e $matrix_file) {
      ## This piece of code has to be evaluated because it can raise
      ## an error, if the output file does not contain any
      ## matrix. This is the case for some output files of consensus,
      ## due to a bug. There are also gibbs file which contain empty
      ## matrices.
      #      eval {

      ################################################################
      ## Read matrices from the input file
      my @matrices = &RSAT::MatrixReader::readFromFile($matrix_file, $program);
      &RSAT::message::Info("Read",scalar(@matrices),"matrices from file",$matrix_file, $program) if ($main::verbose >= 0);
      foreach my $matrix (@matrices) {
	$matrix->force_attribute("family_id",$family_id);
	$matrix->force_attribute("family", $family_name);
	$matrix->force_attribute("format", $program);
	$matrix->set_attribute("input_file", $matrix_file);
	$matrix_by_file{$matrix_file} = $matrix;
	$matrix->calcConsensus();
	$matrix->calcInformation();
	#	  if ($@) {
	#	    &RSAT::message::Warning("Matrix file does no contain a valid matrix. Skipped.", $program, $matrix_file) if ($main::verbose >= 1);
	#	    &RSAT::message::Debug(join "\n", $@) if ($main::verbose >= 0);
	#	    return(undef);
	#	  } else {
	#	    return($matrix);
	#	  }
	#	}
	my $id = RSAT::matrix->auto_id($run_prefix."_mat");
	$matrix->force_attribute("id", $id);
	$matrix->set_attribute("analysis", $run_prefix);
      }

      ################################################################
      ## Sort matrices
      my $sort_key = $pssm_sort_key{$program};
      my $sort_order = $pssm_sort_order{$program};
      if ($sort_key) {
	@matrices = &RSAT::MatrixReader::SortMatrices($sort_key, $sort_order, @matrices);
      }

      ## Export matrices to an SQL databases
      my $first_matrix = $matrices[0];
      if ($first_matrix) {
	foreach my $attr (@matrix_scalar_out_fields) {
	  $first_matrix->_set_attribute_cardinality($attr, "SCALAR");
	}
      }
      foreach my $matrix (@matrices) {
	$matrix_factory->add_object($matrix);
      }

      ## Check that the result file contains at least one matrix
      if (scalar(@matrices) > 0) {
	return(@matrices);
      } else {
	&RSAT::message::Warning("Matrix file does no contain any valid matrix. Skipped.", $program, $matrix_file) if ($main::verbose >= 1);
	return()
      }

    } else {
      &RSAT::message::Warning("File not found. Skipped.", $program, $matrix_file) if ($main::verbose >= 1);
      return();
    }
  }
}

################################################################
## Index the matrix from a gibbs file
sub IndexGibbs {
   &IndexMatrix(@_, program=>"gibbs");
}

################################################################
## Index the matrix from a gibbs file
sub IndexAlignACE {
   &IndexMatrix(@_, program=>"AlignACE");
}

################################################################
## Index the matrix from a meme file
sub IndexMEME {
   &IndexMatrix(@_, program=>"meme");
}

################################################################
## Index the matrix from a MotifSampler file
sub IndexMotifSampler {
   &IndexMatrix(@_, program=>"MotifSampler");
}


################################################################
## Index the patterns discovered for the HTML synthetic table
sub IndexPatterns {
   my ($family_name, $row, $col, %args) = @_;


   undef @patterns;
   undef @sorted_patterns;
   undef %rc;
   undef %score;
   undef %type;

   my $base = "../";
   my $type = $args{type};
   my $assembly_file = $args{assembly};
   my $pssm_file = $args{pssm};
   my $pattern_file = $args{patterns};
   my $validation_file = $args{validation};
   my $validation_table_relw_file = $args{validation_table_relw};
   my $validation_table_weight_file = $args{validation_table_weight};
#   my $family_dir = $args{dir}."/".$family_name."/";
   my $family_dir = $family_name."/";
   $family_dir =~ s|/+|/|g;
   my $pattern_dir = $family_dir.$type."_".$family_name."/";
   my $map_link = $base.$pattern_file;

   &RSAT::message::Info(join("\t", "; Indexing patterns of type", $type, "for family", $family_name, $pattern_file)) if ($verbose >= 2);

   ## Read the patterns
   if (-e $assembly_file) {
       if (($type eq "dyads") ||
	   ($type eq "oligos") ||
	   ($type eq "orm"))
	   {
	   ## Parse an assembly file (only retain contigs and isolated)
	   ($error, @patterns) = &ReadAssemblyFile($family_name, $assembly_file, $type);
       } else {
	   ## Parse a pattern file (retain all patterns)
	   @patterns = &ReadPatterns($assembly_file);
       }
   } else {
	$table[$row][$col] = "<a href=".$assembly_file."><font color=red>File not found</font></a><br>\n";
	$pwd = `pwd`;
	&RSAT::message::Warning($pwd, "Family $family_name", "assembly file ", $pattern_file, " does not exist. Skipped.")
	  if ($main::verbose >= 1);
	return;
   }
   
   if ($error) {
	$table[$row][$col] = "<font color=red>$error</font>\n";
   } else {
	@sorted_patterns = sort { $score{$b} <=> $score{$a} } @patterns;
	$table[$row][$col] .= "<a href=".$base.$family_dir.">".$family_name."</a>\n";
	$table[$row][$col] .= "<a href=".$base.$pattern_dir.">[dir]</a>\n";
	$table[$row][$col] .= "<a href=".$base.$pattern_file.">[".$type."]</a>\n";
#	$table[$row][$col] .= "<a href=".$base.$pattern_file.">[patt]</a>\n";
	$table[$row][$col] .= "<a href=".$base.$assembly_file.">[asmb]</a>\n";
	$table[$row][$col] .= "<a href=".$base.$pattern_file.".".${IMG_FORMAT}.">[map]</a>\n";
	if ($htmaps) {
	    $table[$row][$col] .= "<a href=".$base.$pattern_file.".html>[html]</a>\n";
	}

	$table[$row][$col] .= "<a href=".$base.$pssm_file."_sig_matrices.txt>[sig matrix]</a>\n";
	$table[$row][$col] .= "<a href=".$base.$pssm_file."_count_matrices.txt>[count matrix]</a>\n";
	$table[$row][$col] .= "<a href=".$base.$pssm_file.".${IMG_FORMAT}>[scan map]</a>\n";

#	if ($task{validate}) {
	$table[$row][$col] .= "<a href=".$base.$validation_file.">[matches]</a>\n";
	$table[$row][$col] .= "<a href=".$base.$validation_table_weight_file.">[match_weight]</a>\n";
	$table[$row][$col] .= "<a href=".$base.$validation_table_relw_file.">[match_relw]</a>\n";
#	}

	$table[$row][$col] .= "<table>\n";
	$table[$row][$col] .="<tr><td align=right>max.score</td><td>".$max_score{$type}{$family_name}."</td></tr>\n";
	$table[$row][$col] .="</table>\n";
	$table[$row][$col] .= "<table>\n";
	$table[$row][$col] .= "<TR>\n";
	
	### print oligo sequence
	$table[$row][$col] .= "<TD>\n";
	for $p (@sorted_patterns) {
	    $table[$row][$col] .= "<B>" if ($p->get_attribute("score") >= 1);
	    my $sequence = $p->get_attribute("sequence"); 
	    $compressed = &compress_pattern($sequence, "n");
	    $compressed =~ s/N/n/g;
	    $table[$row][$col] .= $compressed;
	    $table[$row][$col] .= "</B>" if ($p->get_attribute("score") >= 1);
	    $table[$row][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row][$col] .= "</TD>\n";
	
	### print reverse complementary oligo
	if ($strands eq "-2str") {
	    $table[$row][$col] .= "<TD>\n";
	    for $p (@sorted_patterns) {
		$table[$row][$col] .= "<B>" if ($p->get_attribute("score") >= 1);
#		my $sequence =  $p->get_attribute("rc");
		my $rc =  &SmartRC($p->get_attribute("sequence"));
		$compressed = &compress_pattern($rc, "n");
		$compressed =~ s/N/n/g;
		$table[$row][$col] .= $compressed;
		$table[$row][$col] .= "</B>" if ($p->get_attribute("score") >= 1);
		$table[$row][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row][$col] .= "</TD>\n";
	}
	
	### print pattern scores
	$table[$row][$col] .= "<TD><a href=".$map_link.">\n";
	for $p (@sorted_patterns) {
	    $table[$row][$col] .= "<B>" if ($p->get_attribute("score") >= 1);
	    $table[$row][$col] .= $p->get_attribute("score");
	    $table[$row][$col] .= "</B>" if ($p->get_attribute("score") >= 1);
	    $table[$row][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row][$col] .= "</A></TD>\n";

	
	
	### print matching patterns
	if ($known_sites_provided) {
	    $table[$row][$col] .= "<TD>\n";
	    for $p (@sorted_patterns) {
		my @matches = ();
		foreach $site (@site_library) {
		    if (($p->contains($site, min_score=>$min_matching_score)) ||
			($site->contains($p->get_attribute("sequence"), min_score=>$min_matching_score))) {
			#my $match = $site->get_attribute("sequence");
			my $match = $site->get_id();
			push @matches, $match;
		    }
		}
		$table[$row][$col] .= join(";",@matches);
		$table[$row][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row][$col] .= "</TD>\n";
	}
	
	$table[$row][$col] .= "</TR>\n";
	$table[$row][$col] .= "</TABLE>\n";
   }
}

################################################################
#### Draw feature maps
sub DrawDyadFeatureMap {
   &RSAT::message::TimeWarn( "Drawing feature-map with results of dyad-analysis for family $family_name") if ($verbose >= 1);
   &RSAT::error::FatalError("Cannot read file $family{$family_name}->{seq_file}") unless (($batch) || ($dry_run) || (-r $family{$family_name}->{seq_file}));

   ## pattern matching
   $origin = "-0";
   my $command = "dna-pattern -pl $family{$family_name}->{dyad_file} -format $seq_format -i $family{$family_name}->{seq_file} -origin $origin -N 4 -return sites,limits ";
   $command .= "| features-from-dnapat -o $family{$family_name}->{dyad_ft_file} ";
   if ($batch) {
       push @main::batch_commands, $command;
   } else {
       my $error = &doit($command, $dry_run, 0, $verbose);
       if ($error) {
	   &RSAT::message::Warning("Feature map skipped because dna-pattern returned an error");
	   return;
       }
   }

   ## feature-map drawing
   $command = "feature-map -i $family{$family_name}->{dyad_ft_file} -o $family{$family_name}->{fmap_file} ";;
#   $command .= " -from $from" if (defined($from));
#   $command .= " -to $to " if (defined($to));
   $command .= "-legend ";
   $command .= "-scalebar -scalestep $scalestep ";
   $command .= "-scorethick ";
   $command .= "-mlen 520 ";
   $command .= "-title '${family_name}$dyad_suffix' ";
   if ($htmaps) {
	$command .= "-htmap >  $family{$family_name}->{htmap_file}";
   }

   ## Delete the feature file to save disk space (the feature space
   ## occupy half od the result directory)
   $command .= "; rm -f ".$family{$family_name}->{dyad_ft_file};

   #  $command .= " ;  xv -o $family{$family_name}->{fmap_file} &";
   if ($batch) {
       push @main::batch_commands, $command;
   } else {
       &doit($command, $dry_run, 0, $verbose);
   }
}


################################################################
#### check parameters
sub CheckParameters {
    
    ################################################################
    &RSAT::error::FatalError("You must specify the output directory (option -outdir)") unless $dir{output};

    #### accepted feature types
    unless (defined %accepted_feature_types) {
	## By default, accept all feature types
	$accepted_feature_types{cds} = 1;
    }
    $feature_types = join ",", keys (%accepted_feature_types);
    
    #### check selected tasks
    unless (defined(%task)) {
	&RSAT::error::FatalError("You should select at least one task.");
    }
    if ($task{all}) {
	foreach my $t (@supported_tasks) {
	    $task{$t} = 1;
	}
	unless ($draw_maps) {
	    $task{maps} = 0;
	    $task{oligo_maps} = 0;
	    $task{dyad_maps} = 0;
	    $task{orm_maps} = 0;
	}
    }
    if ($task{maps}) {
	$task{oligo_maps} = 1;
	$task{dyad_maps} = 1;
	$task{orm_maps} = 1;
    }

    ## Validation
    if (($task{validate_oligos}) ||
	($task{validate_dyads}) ||
	($task{validate_orm})) {
	$task{validate} = 1;
	&RSAT::error::FatalError("For the task 'validate', you must specify a list of known sites with the option -known")
	    unless ($known_site_file);
    }

    ## Db match
    if (($task{db_match_oligos}) ||
	($task{db_match_dyads})) {
	$task{db_match} = 1;
	&RSAT::error::FatalError("For the task 'db_match', you must specify a list of known sites with the option -db")
	    unless ($db_site_file);
    }
    ### family file ###
    unless (($family_file) || ($sequence_file_list)) {
	&RSAT::error::FatalError("Youmust specify either a family file or a sequence file list");
    }

    ### organism ###
    if ($organism_name)  {
	unless ($supported_organism{$organism_name}) {
	    &RSAT::error::FatalError ("organism $organism_name is not supported");
	}
    } elsif ($org_fam) {
    } else {
	&RSAT::error::FatalError ("You must specify an organism (option -org) or indicate the organism in the second column of the family file (-org_fam)."); 
    }
    
    ## Upstream region limits
    $from = $supported_organism{$organism_name}->{'up_from'}  unless defined($from);
    $to = $supported_organism{$organism_name}->{'up_to'}  unless defined($to);
    $seq_length = abs($to - $from) + 1;

    ## Dyad type
    $dyad_type = "any" unless ($dyad_type);

    ## Strands
    if (defined($force{strands})) {
	$strands = $force{strands}; ### force
    } else {
	$strands = "-2str";
    }

    ## Threshold on occurrence significance
    unless ((defined($lth{occ_sig})) || ($lth{occ_sig} eq $null)){
	$lth{occ_sig} = 0;
	&RSAT::message::Warning("Lower threshold on occ_sig automatically set to 0 for oligo-analysis and dyad-analysis.") 
	    if ($main::verbose >= 1);
    } 

}


################################################################
## Analyze all the families    
sub AnalyzeFamilies {
   my $fam_count=0;
   my $fam_nb = $#families+1;

   ### Calibrate oligonucleotides for each sequence length
   if (($task{calibrate}) || 
       ($task{calibN}) || 
	($sequence_file_list) ||
	($background eq "calib1") ||
	($background eq "calibN")
	) {
       my @calib_lengths = &CalcCalibrationLengths();
       &CalibrateOligos(@calib_lengths) if ($task{calibrate});
       &CalibrateOligosN() if ($task{calibN});
#    } else {
#	foreach $family_name (@families) {
#	    $family{$family_name}->{seq_length} = $seq_length*scalar(@{$family{$family_name}->{members}});
#	}
	$seq_length_calculated = 1;
   }

   ### Calculate background model for orm
   &ormbg() if ($task{ormbg});

   foreach $family_name (@families) {
#       @main::batch_commands = ();

	$fam_count++;
	my @members = @{$family{$family_name}->{members}};
	$gene_nb = scalar(@members);

#	&CheckSkip($fam_count,$family_name);
#	&CheckLast($fam_count);

	## Check minimum number of genes
	if ($gene_nb < $min_genes) {
	  &RSAT::message::Warning ("Skipping family", 
				   $fam_count, $family_name,
				   $gene_nb." genes",
				   "< min = ".$min_genes) if ($main::verbose >= 1);
	    next;
	}

       if ($org_fam) {
	   $organism_name = $family_name;
	   &RSAT::message::TimeWarn("Organism name", $organism_name);
       }

	&RSAT::message::TimeWarn("\n; Treating family ", $family_name," (".$fam_count."/".$fam_nb.")", 
				 $gene_nb." genes", $organism_name)
	    if ($verbose >=1);
	

	### retrieve upstream sequences of the family
	&UpstreamSequences() if ($task{upstream});

	### purge upstream sequences of the family
	&PurgeSequences() if ($task{purge});
	
	### oligo-analysis
	if ($task{oligos}) {
	    &OligoAnalysis();
	} elsif ($task{merge_oligos}) {
	    &MergeOligoLengths();
	}

	if ($task{oligo_maps}) {
	  ### feature-maps of oligonucleotide occurrences
	  &MatchPatterns($family{$family_name}->{oligo_file},
			   $family{$family_name}->{oligo_file},
			   " -N 4");
	    &DrawFeatureMap($family{$family_name}->{oligo_file});

	  ## scan sequences with the PSSM built from significant oligos
	  &ScanSequences($family{$family_name}->{oligo_pssm_file}."_count_matrices.txt","tab",
			 $family{$family_name}->{oligo_pssm_file}," -uth Pval 0.00025");
	  &DrawFeatureMap($family{$family_name}->{oligo_pssm_file});
	}

	### dyad analysis
	&DyadAnalysis() if ($task{dyads});

	### dyad feature-maps
	if ($task{dyad_maps}) {
	  &DrawDyadFeatureMap();
	  ## scan sequences with the PSSM built from significant dyads
	  &ScanSequences($family{$family_name}->{dyad_pssm_file}."_count_matrices.txt","tab",
			 $family{$family_name}->{dyad_pssm_file}," -uth Pval 0.00025");
	  &DrawFeatureMap($family{$family_name}->{dyad_pssm_file});
	}

	### Jerry Hertz' consensus
	if ($task{consensus}) {
	  &Consensus();
	}
	if ($task{consensus_maps}) {
	  &ScanSequences($family{$family_name}->{consensus_file}."_count_matrices.txt","consensus",
		       $family{$family_name}->{consensus_file}," -uth Pval 0.00025");
	  &DrawFeatureMap($family{$family_name}->{consensus_file});
	}

	### Andrew Neuwald's gibbs
	&Gibbs() if ($task{gibbs});
	if ($task{gibbs_maps}) {
	  &ScanSequences($family{$family_name}->{gibbs_file}."_count_matrices.txt","gibbs",
		       $family{$family_name}->{gibbs_file}," -uth Pval 0.00025");
	  &DrawFeatureMap($family{$family_name}->{gibbs_file});
	}

	### Roth's AlignACE
	&AlignACE() if ($task{AlignACE});
	if ($task{AlignACE_maps}) {
	  &ScanSequences($family{$family_name}->{AlignACE_file}."_count_matrices.txt","AlignACE",
		       $family{$family_name}->{AlignACE_file}," -uth Pval 0.00025");
	  &DrawFeatureMap($family{$family_name}->{AlignACE_file});
	}

	### Gert Thijs' MotifSampler
	&MotifSampler() if ($task{MotifSampler});

	### MEME
	&MEME() if ($task{meme});
	if ($task{meme_maps}) {
	  &ScanSequences($family{$family_name}->{meme_file}."_count_matrices.txt","meme",
		       $family{$family_name}->{meme_file}," -uth Pval 0.00025");
	  &DrawFeatureMap($family{$family_name}->{meme_file});
	}

	### orm
	&orm() if ($task{orm});

	### orm feature-maps
	if ($task{orm_maps}) {
	    &MatchPatterns($family{$family_name}->{orm_file},
			   $family{$family_name}->{orm_file},
			   " -N 4");
	    &DrawFeatureMap($family{$family_name}->{orm_file});
	}

#	### merge oligo-analysis and dyad-analysis results
#	&MergePatterns() if ($task{merge_patterns});

#	### Match all patterns together with a sliding window
#	&SlidingWindow() if ($task{slide});
		
	### delete upstream sequence file
       if ($task{clean}) {
	   warn ";\tCleaning files from the hard drive for family $family_name\n" if ($verbose >=1);
	   foreach my $file ($family{$family_name}->{seq_file},
			     $family{$family_name}->{seq_file_purged},
			     $family{$family_name}->{merged_ft_file},
			     $family{$family_name}->{orm_ft_file},
			     $family{$family_name}->{dyad_ft_file}
			    ) {
	       warn ";\t\t$file\n" if ($verbose >=1);
	       $command = "rm -f $file";
	       if ($main::batch) {
		   push @main::batch_commands, $command;
	       } else {
		   &doit($command, $dry_run, $die_on_error, $verbose);
	       }
	   }
	}
       

       ## Send the batch script to the queue
	if (($batch) && (scalar(@batch_commands) > 0)) {
	   my $batch_script = join ";", @main::batch_commands;
	   &doit($batch_script, $dry_run, $die_on_error, $verbose, $batch, $family_name);
	   @main::batch_commands = ();
       }
   }
}

################################################################
## Execute a command, with optional echo
#sub doit {
#    my ($command) = @_;
#    print "\n$command\n" if ($verbose >= 2);
#    system $command unless $dry_run;
#}

# ## Skip initial families if specified with -skip option
# sub CheckSkip {
#     my ($fam_count,$family_name) = @_;
#     if ($fam_count <= $skip) {
# 	warn join ("\t", "; Skipping family", 
# 		   $fam_count, $family_name,
# 		       $gene_nb." genes",
# 		   "\t(skip ".$skip. ")",
# 		   ), "\n" if ($main::verbose >= 1);
# 	next;
#     }
# }

# ## Stop after a few families
# sub CheckLast {
#     my ($fam_count) = @_;
#     if (($last >0) && ($fam_count > $last)) {
# 	&RSAT::message::Warning("Stopped after $last genes");
# 	last;
#     }
# }

########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
   $HELP_FAMILY_FILE = &help_message("class file");
   open HELP, "| more";
   print HELP <<End_of_help;
NAME
	multiple-family-analysis

       1999 by Jacques van Helden (jvanheld\@scmbb.ulb.ac.be)
	
USAGE
       multiple-family-analysis [-i inputfile] [-v]

DESCRIPTION
	Runs a combination of programs in order to discover significant
	patterns in the upstream regions of several gene families.

	This script is a way to auto;atize the systematic analysis of
	multiple clusters of co-regulated genes, such as those
	obtained with DNA chip experiments.

	The program reads the composition of several families in a
	single text file, then executes different program discovery
	programs, and generates a summary report.

	Results are subdifided in directories created on the fly, one
	directory per family plus one summary directory.
	
CATEGORY
	sequences
	pattern discovery

OPTIONS
	-h	(must be first argument) display full help message

	-help	(must be first argument) display options

	-v	verbose

	-i	family file (incompatible with -seq)

	-mask upper|lower
		Mask lower or uppercases, respecively, i.e. replace
		selected case by N characters.

	-seq	input sequences (incompatible with -i)
		This option allows to specify a file containing a list
		of sequence files. The first word of each line must
		specify the path of a sequence file. Each sequence
		file must be in fasta format.

	-skip # skip the first # data sets when performing the
		analyses (this si useful when the program has been
		interrupted after a considerable amount of work).

	-last # stop after the first # data sets when performing the
		analyses (this si useful to perform quick tests).

	-select	fam1[,fam2,fam3,...]
		Perform the analysis of selected families only.

	-maindir
		main directory (by default, the working directory is used)

	-outdir	output directory

	-mingenes #
		minimal number of genes per family. Families with less
		than this number are skiped.

   Sequence retrieval options
	-org	organism

	-org_fam
		When this option is used, the name of the family
		(second column of the family file) is used as
		organism. This allows to automatically perform a
		genome-per-genome analysis of the orthologs of a
		regulon from some model organism.

		Typically, the input for this option is obtained from
		the program get-orthologs: starting from a regulon
		from some model organism (e.g. Saccharomyces
		cerevisiae), one wants to discoer motifs in the
		corresponding orthologous genes in other species
		(e.g. each other species of Fungi).

		This option is incompatible with -org. 

	-taxon	taxon
		If this option is specified, sequences are retrieved
		for all the orthologs of the input genes in the
		selected taxon. This approach relies on the detection
		of phylogenetic footprints (conserved elements in
		non-coding sequences). If the taxon is chosen in an
		appropriate way, it increases the sensitivity of the
		analysis.

	-noorf	exclude upstream ORFs from upstream sequences

	-rm	use repeat masked version  of the genome

	-orfov  do not exclude upstream ORFs from upstream sequences

	-from	upstream region left limit

	-to	upstream region right limit

       -feattype
		feature type (e.g. CDS, mRNA)

   Sequence purging option

   	For pattern discovery, it is essential to purge sequences
   	i.e. to mask redundant fragments. Such redundant fragments can
   	come from genomic repeats (e.g. in duplicated genes in
   	telomeric regions), or from neighbour genes sharing the same
   	promoter, or , when working with multi-taxa sequences, the
   	fact that several promoters were retrieved from closely
   	related species (e.g. various strains of E.coli). These
   	repeats give a strong bia on the statistical estimation of
   	motif over-representation, and lead thus to a large number
   	of false positive motif.

	The approach followed here is to mask repeats (replace them
	with N characters) during the pattern discovery step, but use
	the unmasked sequences for pattern matching, in order to
	locate all the putative instances of the discovered motifs. 

	-purge	use purged sequences for pattern discovery
		(default)

	-nopurge	
		use non-purged sequences for pattern discovery

        -purge_ml #
		matching length above which repeats have to be masked   	

        -purge_mis #
		number of accetped mismatches to consider two sequence
		segments as repats to be masked.

   oligo-analysis and dyad-analysis options

	-1str   strand-sensitive analysis

	-2str   strand-insensitive analysis

	-htmaps	draw html maps (dynamic map with pointers to the features)
		These html files take space on the hard drive, so I
		suppressed them from the default output.

	-noov	prevent overlapping matches for self-overlapping patterms
		(default)

	-ovlp	allow overlapping matches for self-overlapping patterms

	-nomap	do not draw feature maps (for saving time and hard disk space)

	-bg	background frequency model
		This parameter indicates which background model has to
		be used for the estimation of expected pattern
		frequencies.
		Supported: $supported_background

	-calib_dir

		Directory containing the calibration files for the
		negative binomial. The calibration file name is then
		calculated automatically from the conditions (seq
		lengths, seq number, ...)

	-calibN_repet #
		Number of repetitions for the calibration. 

	-thosig #
		Threshold on occurrence significance.
		(obsolete: use -lth occ_sig instead)

	-lth param value
		Lower threshold on some parameter. All patterns with a
		parameter value smaller than the threshold are
		discarded.
		Supported parameters: $supported_thresholds
	      	Example: select patterns with a positive value for the
	      	occurrence significance.

			 -lth occ_sig 0

	-uth param value
		Upper threshold on some parameter. All patterns with a
		parameter value higher than the threshold are
		discarded.
		Supported parameters: $supported_thresholds
		Example: to select no more than 50 patterns
		        -uth rank 50

	-toppat # 
		(default $toppat)
		Maximal number of patterns to take into account for
		the assembly. This parameter is passed to the command
		pattern-assembly.

   oligo-analysis specific options
	-thmsf threshold on frequency of matching sequences (propotion
	        of sequences with at least one occurrence of the
	        pattern)

	-thmssig threshold on the significance of matching sequences
	        (sequences with at least one occurrence of the
	        pattern). 

	-maxol	maximum oligonucleotide length

	-minol	minimum oligonucleotide length

	-oligo_exp_freq
		name of a file containing the expected frequencies for
		oligo-analysis.

	-pseudo	pseudo-weight (see oligo-analysis manual)

	-markov #	
		calculate expected frequencies on the basis of a
		Markov chain model of order #

   dyad-analysis specific options
	-monad  monad length for dyad-analysis

	-minsp	maximum spacing for dyad-analysis

	-maxsp	maximum spacing for dyad-analysis

	-dyad_exp_freq
		name of a file containing the expected frequencies for
		dyad-analysis.

   ORM-specific options

	ORM is a pattern discovery program developed by Matthieu
	Defrance. This program is still in development and under
	evaluation. It should be installed in the contribution dir:
		    $RSAT/contrib/ORM/orm.py
		    $RSAT/contrib/ORM/ormbg.py

	ormbg.py allows to create a background model from a set of sequences.
	orm.py detects windows containing over-represented words, by
	comparison with the background model. Moree information can be found
	in the ORM documentation. 

	All options starting with ORM_ will be passed to the command orm.py.
	Alternative versions of orm.py and ormbg.py can be specified with
	environment variables ORM and ORMBG, respectively.

   Matrix-based pattern discovery options (consensus, gibbs, AlignACE, meme, MotifSampler)
       -width  matrix width (default $matrix_width)
       -sps	expected number of sites per sequence
		(default $expected_sites_per_gene)
       -nmotifs number of motifs to discover per sequence set (family)

   Gibbs sampler (Neuwald, 1995)
	-seed	 seed number for the random generator

   AlignACE (Roth, 1998)
	-seed	 seed number for the random generator

   MotifSampler (Thijs, 200X)
	-MS_b	backgound file
	-MS_p	prior probability of 1 motif copy (default $MS_p)
	-MS_M   Maximal number of motif instances per sequence. (default $MS_M; unset=0)
	-MS_n	number of different motifs to search for (default $MS_n).
	-MS_x	allowed overlap between different motifs. (default $MS_x)
	-MS_r	number of times the MotifSampler should be repeated (default = $MS_r).
	Note	-MS_w is replaced by -width

   MEME options (Bailey)
	Any option starting with -MEME_ will be passed to MEME. 
	In particular, the following options are passed by default. 
   	-MEME_minw	minimum motif width (default $MEME_minw)
   	-MEME_maxw	maximum motif widht (default $MEME_maxw)
	-MEME_bfile     name of background Markov model file

   Output options
	-transp	transpose synthetic result table (columns become rows)
	-sort sort_key
	        sort key for the synthetic table
		Supported: $supported_sort_keys

  Options for the automaticaly generated SQL scripts
	-schema database schema (default: $schema)
	-host	database host (default: $host)
	-user	database user (default: $user)
	-password	
		database password (default: $password)

   Other options
	-task selected_task
		Select the tasks to be performed.
		Supported tasks: $supported_tasks

		Can be used iteratively on the same command line to 
		select multiple tasks.  

		Example:
		    -task upstream -task oligos -task synthesis
		For a full analysis, simply type 
		    -task all
		
		See details below (TASK DESCRIPTION)

	-known	known_site_file
		A file containing a list of known sites/motifs for
		each of the gene families. These known sites are NOT
		used during the pattern discovery. They are simply
		displayed besides the discovered patterns, for the
		sake of comparison.
		
		Format: the known site file is a tab-delimited text
		files, with the collofing column content :
		       1) site/motif sequence
		       2) family
		       3) source (optional)
    		
		Example
		=======
		; sequence	family	source
		gGGAAAaTGAAACT	ISGF-3	TRANSFAC:R00001
		AGGAAATAGAAACT	ISGF-3	TRANSFAC:R00003
		ggagGGGCGGccct	Sp1	TRANSFAC:R14218
		...

    	-known_max_len #
		maximal length for using known sites. This allows to
		filter out some sites with large sequences annotated in
		TRANSFAC (default: $known_site_max_len)

        -db     database_file
                A file containing a list of known sites (from a database)

	-batch (advanced users)
		Send time-consuming jobs on a batch queue which will
		be executed on a PC cluster. This option only works on
		our lab cluster, but could be adapted for other
		configurations by adapting the method &doit() in the
		utilities ($RSAT/lib/RSA.lib).

	-nodie
		Continue the analysis even if errors are raised by
		sub-processes. By default, multiple-family-analysis
		stops if an error has occurred in one of the
		sub-programs. However, in some particular the user
		might want to ignore such errors. 

		In particular, this option is useful to circumvent a
		problem encountered with the gibbbs sampler under some
		operating systems (Linux but not Maax OSX): the gibbs
		program returns an error code to the system even when
		the pattern discovery was successful.

FILE FORMAT
   $HELP_FAMILY_FILE

QUICK START
   1) create a directory for the set of families

   2) witin this directory, create a text file contaning the
      description of family composition, as described above
   
   3) run the command. For example, with a bacterial genome :

      multiple-family-analysis -org organism -i family_file \
          -v -from -200 -to 49 -task all

   4) With a web browser (e.g. Netscape), open the folder
      'synthetic_tables'. There should be a HTML file with the name
      of your family ile as prefix, and the suffix indicating the
      other analysis parameters. Open this file and analyze the
      result.

TASK DESCRIPTION

   all		Perform all the tasks below.

   upstream	Retrieve upstream sequences for the families.
		(retrieve-seq)

   purge	Purge upstream sequences for the family.
		(purge-sequences)

   calibrate    
   		Perform a word-specific calibration of expected
		frequencies, by calculating oligonucleotide
		distributions in the whole genome set of upstream
		sequences of the same size. 

		Beware: this takes time, but, for higher organisms, it
		gives much less false positives than the standard
		background models.
  
   calibN
		Perform a family-specific calibration of expected
		oligonucleotide frequencies by calculating occurrences
		in N random selections of genes.

		Beware: this takes a lot of time, but it strongly
		reduces the rate of false positives for higher
		organisms. We did not yet measure the rate of true
		positives remaining after this calibration.

   oligos	Run oligo-analysis on each family.

   dyads	Run dyad-analysis on each family.

   maps	Draw feature maps with the results of oligo-analysi and
		dyad-analysis.
		(feature-map)

   merge	Merge the results of oligo-analysis and dyad-analysis.

   slide	Match discovered patterns with a sliding window.
		(dna-pattern)

   synthesis	Generate a HTML report in the directory sythetic_tables.

   sql		Export the discovered patterns in tab-delimited files, 
		and export SQL scripts for loading these tables in a
		relational database.  

   clean	Delete upstream sequences after processing, in order 
		to save disk space.  

   validate	Validate discovered patterns by comparing them to the list
   		of known sites. This requires to specify a collection
   		of know sites with the option -known.

   db_match     Compare discovered patterns to a list of known sites
                (for instance a whole database). This requires to specify
                the list of known sites with the option -db.

End_of_help
 close HELP;
 exit;
}

################################################################
#### Read arguments
sub ReadArguments {
  foreach my $a (0..$#ARGV) {
    ### verbose ###
    if ($ARGV[$a] eq "-v") {
      $verbose = $ARGV[$a+1];
      unless (&IsNatural($verbose)) {
	$verbose = 1;
      }

      #### dry run
    } elsif ($ARGV[$a] eq "-n") {
      $dry_run = 1;

      #### Sequence puring options
    } elsif ($ARGV[$a] eq "-nopurge") {
      $analyze_purged_sequences = 0;

    } elsif ($ARGV[$a] eq "-purge") {
      $analyze_purged_sequences = 1;

    } elsif ($ARGV[$a] eq "-purge_ml") {
      $purge_ml = 1;

    } elsif ($ARGV[$a] eq "-purge_mis") {
      $purge_mis = 1;

      ### detailed help
    } elsif ($ARGV[$a] eq "-h") {
      &PrintHelp();

      ### list of options
    } elsif ($ARGV[$a] eq "-help") {
      &PrintOptions();

      ### family file
    } elsif (($ARGV[$a] eq "-i") ||
	     ($ARGV[$a] eq "-fam") # for compatibility with previous versions
	    ) {
      $family_file = $ARGV[$a+1];

      ### skip some data sets
    } elsif ($ARGV[$a] eq "-skip") {
      &FatalError("The option -skip is incompatible with the option -select") if (scalar(@selected) > 0);
      $skip = $ARGV[$a+1];
      &RSAT::error::FatalError("Invalid number with option -skip\t$skip") unless &IsNatural($skip);

      ### stop after some data sets
    } elsif ($ARGV[$a] eq "-last") {
      &FatalError("The option -last is incompatible with the option -select") if (scalar(@selected) > 0);
      $last = $ARGV[$a+1];
      &RSAT::error::FatalError("Invalid number with option -last\t$last") unless &IsNatural($last);

      ### stop after some data sets
    } elsif ($ARGV[$a] eq "-select") {
      &FatalError("The option -delete is incompatible with the option -last") if ($last > 0);
      &FatalError("The option -delete is incompatible with the option -skip") if ($skip > 0);
      push (@selected, (split ",", $ARGV[$a+1]));

      ### sequence file list
    } elsif ($ARGV[$a] eq "-seq") {
      $sequence_file_list = $ARGV[$a+1];

      ## mask
    } elsif ($ARGV[$a] eq "-mask") {
      $mask = $ARGV[$a+1];
      &CheckMask($mask);	    

      ### main directory
    } elsif ($ARGV[$a] eq "-maindir") {
      $dir{main} = $ARGV[$a+1];

      ### output directory
    } elsif ($ARGV[$a] eq "-outdir") {
      $dir{output} = $ARGV[$a+1];

      ### min number of genes
    } elsif ($ARGV[$a] eq "-mingenes") {
      $min_genes = $ARGV[$a+1];

      ### max number of patterns to assemble
    } elsif ($ARGV[$a] eq "-toppat") {
      $toppat = $ARGV[$a+1];

      ### upstream sequence lmits
    } elsif (($ARGV[$a] eq "-from") &&
	     (&IsInteger($ARGV[$a+1]))) {
      $from = $ARGV[$a+1];
    } elsif (($ARGV[$a] eq "-to") &&
	     (&IsInteger($ARGV[$a+1]))) {
      $to = $ARGV[$a+1];

      ### strands 
    } elsif ($ARGV[$a] eq "-1str") {
      $force{strands} = "-1str";
    } elsif ($ARGV[$a] eq "-2str") {
      $force{strands} = "-2str";

      ### oligo-analysis parameters
    } elsif ($ARGV[$a] eq "-minol") {
      $min_oligo_len = $ARGV[$a+1];;
    } elsif ($ARGV[$a] eq "-maxol") {
      $max_oligo_len = $ARGV[$a+1];;

      ### dyad-analysis parameters
    } elsif ($ARGV[$a] eq "-monad") {
      $monad_length = $ARGV[$a+1];;
    } elsif ($ARGV[$a] eq "-minsp") {
      $min_sp = $ARGV[$a+1];;
    } elsif ($ARGV[$a] eq "-maxsp") {
      $max_sp = $ARGV[$a+1];;

      ### matrix-based pattern discovery
    } elsif ($ARGV[$a] eq "-width") {
      $matrix_width = $ARGV[$a+1];
    } elsif ($ARGV[$a] eq "-sps") {
      $expected_sites_per_gene = $ARGV[$a+1];
    } elsif ($ARGV[$a] eq "-nmotifs") {
      $nmotifs = $ARGV[$a+1];
      $MEME_options{nmotifs} = $nmotifs;
      $MS_n = $nmotifs;

      ### Gibbs sampler + AlignACE seed option
    } elsif ($ARGV[$a] eq "-seed") {
      $seed = $ARGV[$a+1];

      ### MotifSampler options
    } elsif ($ARGV[$a] =~ /-(MS_\S+)/) {
      $$1 =  $ARGV[$a+1];

      ### MEME options
    } elsif ($ARGV[$a] =~ /-MEME_(\S+)/) {
      my $option = $1;
      my $value =  $ARGV[$a+1];
      push @MEME_options, $option unless (defined($MEME_options{$option}));
      $MEME_options{$option} = $value;

      ### ORM options
    } elsif ($ARGV[$a] =~ /-(ORM_\S+)/) {
      $$1 =  $ARGV[$a+1];

      ### organism
    } elsif ($ARGV[$a] eq "-org") {
      $organism_name = $ARGV[$a+1];

      ### organisms are specified as family names
    } elsif ($ARGV[$a] eq "-org_fam") {
      $org_fam = 1;

      ### taxon
    } elsif ($ARGV[$a] eq "-taxon") {
      $taxon = $ARGV[$a+1];

      ### file with a collection of known motifs, for comparison between discovered and known motifs
    } elsif ($ARGV[$a] eq "-known") {
      $known_site_file = $ARGV[$a+1];
    } elsif ($ARGV[$a] eq "-known_max_len") {
      $known_site_max_len = $ARGV[$a+1];

      ### file with a collection of known motifs, for comparison between discovered and known motifs
    } elsif ($ARGV[$a] eq "-db") {
      $db_site_file = $ARGV[$a+1];

      ### file with a collection of known motifs, for comparison between discovered and known motifs
    } elsif ($ARGV[$a] eq "-dbname") {
      $db_site_name = $ARGV[$a+1];

      #### task selection
    } elsif ($ARGV[$a] eq "-task") {
      my @requested_tasks = split ",", $ARGV[$a+1];
      foreach my $task (@requested_tasks) {
	next unless $task;
	#	    $task = $ARGV[$a+1];
	if ($supported_task{$task}) {
	  $task{$task} = 1;
	} else {
	  &RSAT::error::FatalError("Unsupported task '$task'. \n\tSupported: $supported_tasks");
	}
      }

      #### transpose synthetic table
    } elsif ($ARGV[$a] =~ /^-transp/) {
      $transpose = 1;

      #### sort key
    } elsif ($ARGV[$a] =~ /^-sort/) {
      $sort_key = $ARGV[$a+1];
      unless ($supported_sort_key{$sort_key}) {
	&RSAT::error::FatalError("$sort_key is not supported as sort key");
      }

      #### clip upstream ORFs fom upstream regions
    } elsif ($ARGV[$a] =~ /^-noorf/) {
      $noorf = "-noorf";

      #### use repeat masked version of the genome
    } elsif ($ARGV[$a] eq "-rm") {
      $repeat_masked = 1;

      #### do not clip upstream ORFs fom upstream regions
    } elsif ($ARGV[$a] =~ /^-orfov/) {
      $noorf = "";

      #### Threshold on relative weight for compare-patterns
    } elsif ($ARGV[$a] eq '-rel_w') {
      $rel_w = $ARGV[$a+1];
      &FatalError("Relative weight should be a real value comprised between 0 and 1") unless ((&IsReal($rel_w)) && ($rel_w >= 0) && ($rel_w <= 1));

      ### Upper threshold
    } elsif ($ARGV[$a] eq "-lth") {
      my $thr_field = $ARGV[$a+1];
      my $thr_value =  $ARGV[$a+2];
      unless ($supported_threshold{$thr_field}) {
	&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
      }
      $lth{$thr_field} = $thr_value;
      #	    &RSAT::message::Debug("Lower threshold", $thr_field, $thr_value, $lth{$thr_field});

      ### Lower threshold
    } elsif ($ARGV[$a] eq "-uth") {
      my $thr_field = $ARGV[$a+1];
      my $thr_value =  $ARGV[$a+2];
      unless ($supported_threshold{$thr_field}) {
	&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
      }
      $uth{$thr_field} = $thr_value;

      #### threshold
    } elsif ($ARGV[$a] =~ /^-thosig/) {
      &Warning("Option -thosig is deprecated. Please use '-lth occ_sig' instead.");
      $force{th} = $ARGV[$a+1];

      #### threshold on mseq frequency
    } elsif ($ARGV[$a] =~ /^-thmsf/) {
      &Warning("Option -thmsf is deprecated. Please use '-lth ms_freq' instead.");
      $lth{ms_freq} = $ARGV[$a+1];

      #### threshold on mseq significance
    } elsif ($ARGV[$a] =~ /^-thmssig/) {
      &Warning("Option -thmssig is deprecated. Please use '-lth ms_sig' instead.");
      $lth{ms_sig} = $ARGV[$a+1];

      #### dyad type
    } elsif ($ARGV[$a] =~ /^-type/) {
      $force{type} = $ARGV[$a+1];

      #### feature types
    } elsif ($ARGV[$a] eq "-feattype") {
      my @types = split ",", $ARGV[$a+1];
      foreach my $type (@types) {
	if ($supported_feature_types{lc($type)}) {
	  $accepted_feature_types{lc($type)}++;
	} else {
	  &RSAT::error::FatalError("$type invalid feature type. Supported: $supported_feature_types");
	}
      }

      #### expected frequency file for dyad-analysis 
    } elsif ($ARGV[$a] =~ /^-dyad_exp_freq/) {
      $exp_freq_file{dyads} = $ARGV[$a+1];

      #### expected frequency file for oligo-analysis 
    } elsif ($ARGV[$a] =~ /^-oligo_exp_freq/) {
      $exp_freq_file{oligos} = $ARGV[$a+1];

      #### Calibration directory
    } elsif ($ARGV[$a] =~ /^-calib_dir/) {
      $dir{calib1} = $ARGV[$a+1];
      $dir{calibN} = $ARGV[$a+1];

      #### Number of repetitions for the calibration
    } elsif ($ARGV[$a] =~ /^-calibN_repet/) {
      $calibN_repet = $ARGV[$a+1];
      &FatalError("Invalid number of repetitions for the calibrations: should be at least 2, and a much larger value (e.g.100) is highly recommended.") 
	unless ((&IsNatural($calibN_repet)) && ($calibN_repet >= 2));

      #### background model for expected frequency. 
      #### Supported: "upstream", "upstream-noorf", "intergenic", "mncf", "upstream-rm", "upstream-noorf-rm"
    } elsif (($ARGV[$a] =~ /^-exp/) 
	     || ($ARGV[$a] =~ /^-bg/)) {
      $background = $ARGV[$a+1];
      $background =~ s/^ncf$/intergenic/;

      unless ($supported_background{$background}) {
	&RSAT::error::FatalError("$background\tInvalid value for background. Supported : $supported_background");
      }

      #### Markov chain estimation of expected oligo frequencies
    } elsif ($ARGV[$a] =~ /^-markov/) {
      $markov_order = $ARGV[$a+1];
      $markov=1;

      #### prevent self-overlap
    } elsif ($ARGV[$a] eq "-noov") {
      $noov = "-noov";

      #### allow self-overlap
    } elsif ($ARGV[$a] eq "-ovlp") {
      $noov = "-ovlp";

      #### prevent feature-map drawing
    } elsif ($ARGV[$a] eq "-nomap") {
      $draw_maps = 0;

      #### draw htmaps
    } elsif ($ARGV[$a] =~ /^-htmap/) {
      $draw_maps = 1;
      $htmaps = 1;

      #### pseudo-weight
    } elsif ($ARGV[$a] =~ /^-pseudo/) {
      $pseudo = $ARGV[$a+1];
      unless ((&IsReal($pseudo)) && ($pseudo > 0)) {
	&RSAT::error::FatalError("pseudo-weight must be a positive real number");
      }

      #### Options for the SQL scripts
    } elsif ($ARGV[$a] eq "-schema") {
      $schema = $ARGV[$a+1];
    } elsif ($ARGV[$a] eq "-host") {
      $host = $ARGV[$a+1];
    } elsif ($ARGV[$a] eq "-user") {
      $user = $ARGV[$a+1];
    } elsif ($ARGV[$a] eq "-password") {
      $password = $ARGV[$a+1];

    } elsif ($ARGV[$a] eq "-pc_cluster") {
      &RSAT::message::Warning("Option -pc_cluster is obsolete, use option -batch instead.");
      $batch = 1;

    } elsif ($ARGV[$a] eq "-batch") {
      $batch = 1;

    } elsif ($ARGV[$a] eq "-nodie") {
      $die_on_error = 0;

    }
  }
}



################################################################
# Verbosity
#
sub Verbose {
   my $verbose_message = "";
   $verbose_message .= "; multiple-family-analysis ";
   $verbose_message .= &PrintArguments()."\n";
   printf "; families     \t%d\n", $#families + 1;
   my $f = 0;
   foreach my $family_name (@families) {
     $f++;
     printf ";\tfamily\t%d\t%s\t%d elements\n", $f, $family_name, $family{$family_name}->get_size();
   }
   if ($family_file) {
	$verbose_message .= sprintf "; Family file\t%s\n", $family_file ;
	$verbose_message .= sprintf "; Upstream regions\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "Strands", $strands;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "From", $from;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "To", $to;
   } elsif ($sequence_file_list) {
	$verbose_message .= sprintf "; Sequence file list\t%s\n", $sequence_file_list;
   }
   $verbose_message .= sprintf "; %-13s\t%s\n", "Organism", $organism_name;

   if ($task{oligos}) {
	$verbose_message .= sprintf "; oligo-analysis\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "max oligo length", $max_oligo_len;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "min oligo length", $min_oligo_len;
   }
   
   if ($task{dyads}) {
	$verbose_message .= sprintf "; dyad-analysis\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "monad length", $monad_length;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "min spacing", $min_sp;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "max spacing", $max_sp;
	$verbose_message .= sprintf ";\t%-22s\t%s\n", "dyad type", $dyad_type;
	$verbose_message .= &PrintThresholdValues();
#	$verbose_message .= sprintf ";\t%-22s\t%g\n", "sig threshold", $lth{occ_sig};
   }

   if ($markov) {
	$verbose_message .= sprintf "; %-13s\t%s\n", "Markov chains, order", $markov_order;
   } elsif ($background) {
	$verbose_message .= sprintf "; %-13s\t%s\n", "background model", $background;
   }

   $verbose_message .= "; No overlap with upstream ORFs\n" if ($noorf);
   if ($noov eq "-noov") {
	$verbose_message .= "; Overlapping matches are discarded for self-overlapping patterns\n" ;
   } else {
	$verbose_message .= "; Overlapping matches are allowed for self-overlapping patterns\n" ;
   }
   warn $verbose_message;
   return($verbose_message);
}


################################################################
### initialize one directory for each family
sub MakeDirectories {
   foreach $family_name(@families) {
	$dir = "${family_name}/";
	unless (-d $dir) {
	    mkdir $dir, 0755 || &RSAT::error::FatalError("Cannot create directory", $dir);;
	}
	open FAM, ">$family{$family_name}->{family_file}" ||
	  &RSAT::error::FatalError("Cannot write family file", $family{$family_name}->{family_file});
	foreach $id ($family{$family_name}->get_members()) {
	  print FAM "$id\t$name{$id}\n";
	}
	close FAM;
   }
}


################################################################
### Generate tab files and SQL scripts for storing the results in a
### relational database
sub ExportSQL {
  &RSAT::message::TimeWarn ("Generating SQL") if ($verbose >= 1);

  &RSAT::message::debug($current_analysis, $current_analysis->get_attribute("id")) if ($main::verbose >= 10);

  ## Set the parameters for the analysis as a whole
  $current_analysis->set_attribute("date", $run_date);
  $current_analysis->set_attribute("family_file", $family_file);
  $current_analysis->set_attribute("organism", $organism_name);
  $current_analysis->set_attribute("background", $background);
  $current_analysis->set_attribute("up_from", $from);
  $current_analysis->set_attribute("up_to", $to);
  $current_analysis->set_attribute("orf_ovlp", $noorf);
  $current_analysis->set_attribute("pattern_ovlp", $noov);
  $current_analysis->set_attribute("strands", $strands);
  $current_analysis->set_attribute("thosig", $lth{occ_sig});
  $current_analysis->set_attribute("suffix", $table_suffix);

  my %export_columns = ();
  foreach my $family_name (@families) {

    #### general family attributes
    my $family_object = $family_factory->new_object(id=>$run_prefix."_".$family_name);
    local $family_id = $family_object->get_attribute("id");
    $current_analysis->push_attribute("families",$family_id);
    $family_object->set_attribute("analysis", $run_prefix);
    $family_object->set_attribute("name", $family_name);
    $family_object->set_attribute("size", scalar(@{$family{$family_name}->{members}}));
    $family_object->set_attribute("organism", $organism_name);
    &RSAT::message::Warning ("", "SQL export for family", $family_name, $organism_name) if ($main::verbose >= 2);

    #### family members
    my @members = @{$family{$family_name}->{members}};
    foreach my $m (@members) {
      $family_object->push_attribute("genes", $m);
    }

    #### discovered oligos
    my $oligo_file = $family{$family_name}->{oligo_file};
    if (-e $oligo_file) {
      my %export_columns = ();
      ($oligo_handle, $dir) = &OpenInputFile($oligo_file);
      while (<$oligo_handle>) {
	chomp;
	if (/^;/) {
	  if ((/;\s+(\d+)\t(\S+)/) && ($2 ne "id")) {
	    $export_columns{$2} = $1 - 1;
	  }
	  next;
	}
	next unless (/\S/);	## Skip empty lines
	next if (/^#/);		## Skip header line
	my @fields = split;
	my $sequence = uc($fields[0]);
	my $oligo_object = $pattern_factory->new_object();
	warn join ("\t", "; Created object", $sequence, $oligo_object), "\n" if ($main::verbose >= 3);
	foreach $k (sort keys %export_columns) {
	  &RSAT::message::Debug ( "specifying attribute", 
				  $k, 
				  $export_columns{$k},
				  $fields[$export_columns{$k}],
				) if ($main::verbose >= 5);
	  $oligo_object->set_attribute($k, $fields[$export_columns{$k}]);
	}
	&RSAT::message::Debug ("specifying sequence", $sequence) if ($main::verbose >= 5);
	$oligo_object->force_attribute("sequence", $sequence);
	$oligo_object->force_attribute("type", "oligo");
	$oligo_object->set_attribute("family_id", $family_id);
	$oligo_object->set_attribute("family", $family_name);
	if ($strands eq "-2str") {
	  $oligo_object->force_attribute("rev_compl", &ReverseComplement($oligo_object->get_attribute("sequence")));
	}
      }
      close $oligo_handle;
    } else {
      my $pwd = `pwd`;
      chomp $pwd;
      &RSAT::message::Warning(join ("\t", "SQL export", $family_name, $pwd, "oligo file does not exist",  $oligo_file , "SKIPPED"));
    }

    #### discovered dyads
    my $dyad_file = $family{$family_name}->{dyad_file};
    if (-e $dyad_file) {
      my %export_columns = ();
      open DYADS, $dyad_file;
      while (<DYADS>) {
	chomp;
	if (/^;/) {
	  ## Temporary patch for dyad obs_occ -> occ (to be compatile with oligo-analysis
	  s/obs_occ/occ/;

	  ## Output fields
	  if ((/;\s+(\d+)\t(\S+)/) && ($2 ne "id")) {
	    $export_columns{$2} = $1 - 1;
	  }
	  next;
	}
	next unless (/\S/);
	next if (/^#/);		## Skip header line
	my @fields = split;
	my $sequence = uc($fields[0]);
	$sequence =~ s/N/n/g;
	my $dyad_object = $pattern_factory->new_object();
	warn join ("\t", "; Created object", $sequence, $dyad_object), "\n" if ($main::verbose >= 3);
	foreach $k (sort keys %export_columns) {
	  &RSAT::message::Debug("specifying attribute", $k, $export_columns{$k},$fields[$export_columns{$k}])
	    if ($main::verbose >= 5);
	  $dyad_object->set_attribute($k, $fields[$export_columns{$k}]);
	}
	&RSAT::message::Debug ("specifying sequence", $sequence) if ($main::verbose >= 5);
	$dyad_object->force_attribute("sequence", $sequence);
	$dyad_object->force_attribute("type", "dyad");
	$dyad_object->set_attribute("family_id", $family_id);
	$dyad_object->set_attribute("family", $family_name);
	if ($strands eq "-2str") {
	  my $rc_sequence = uc( &ReverseComplement($dyad_object->get_attribute("sequence")));
	  $rc_sequence =~ s/N/n/g;
	  $dyad_object->force_attribute("rev_compl",$rc_sequence);
	}
      }
      close DYADS;
    } else {
      &RSAT::message::Warning(join ("\t", "SQL export", $family_name, $pwd, "dyad file does not exist",  $dyad_file , "SKIPPED"));
    }

    #### Matrices
    for my $program qw (consensus gibbs AlignACE meme MotifSampler) {
      my $matrix_file = $family{$family_name}->{$program."_file"};
      if (-e $matrix_file) {
	&ReadMatrices($family_name, $matrix_file, program=>$program);
      } else {
	&RSAT::message::Warning(join ("\t", "SQL export", $family_name, $pwd, "matrix file does not exist",  $matrix_file , "SKIPPED"));
      }
    }
  }

  ## Export directory
  $dir{sql} = "sql_export";
  chdir($dir{output}); &RSAT::util::CheckOutDir($dir{sql});

  ## Temporarily motify  output directory
  ## for table dumping
  $dir{output_bk} = $dir{output};
  $dir{output} = $dir{sql};
  my $pwd = `pwd`;
  chomp $pwd;
  &RSAT::message::Info ($pwd , $dir{output}, $dir{output_bk});
  #### export the result tables
  foreach my $factory ($analysis_factory, $family_factory, $pattern_factory, $matrix_factory) {
    $factory->dump_tables();
    $factory->generate_sql(schema=>$schema, 
			   host=>$host, 
			   password=>$password, 
			   user=>$user);
  }
  &ExportMakefile("analysis", "family", "pattern");
  $dir{output} = $dir{output_bk};
}

## ##############################################################
## If the input is a list of sequence files instead of a family file,
## index the input sequence files
sub ReadSequenceList {
   ($sequence_dir, $short_sequence_file_list) = &SplitFileName($sequence_file_list);

   ## Convert relative to absolute directory
   if (($dir{main}) && ($sequence_dir !~ /^\//)) {
	$sequence_dir = $dir{main}."/".$sequence_dir;
   }

   &RSAT::message::Info("Sequence dir", $sequence_dir) if ($verbose >= 1);
   &RSAT::message::Info("Reading sequence file list", $sequence_file_list) if ($verbose >= 1);
   my ($files) = &OpenInputFile($sequence_file_list);
   my $f = 0;
   while (<$files>) {
	next if (/^;/);
	next unless (/\S/);
	chomp;
	$f++;
	my @fields = split /\s+/;
	my $sequence_file = shift @fields; ## the first word of each row is a file
	my $short_file = &ShortFileName($sequence_file);
	my $family_name = $short_file;
	$family_name =~ s|\.${seq_ext}$||;
       my $comment = join "; ", @fields;
	
#	push @families, $family_name;
#	push @sequence_files, $sequence_file;

	#### create a new family if required
	unless ($family{$family_name}) {
	    $family{$family_name} = new RSAT::Family(name=>$family_name);
	}

       #### Sequence file
	if ($sequence_dir) {
	    $family{$family_name}->{seq_file} = $sequence_dir."/".$sequence_file;
	} else {
	    $family{$family_name}->{seq_file} = $sequence_file;
	}
	$family{$family_name}->{seq_file} =~ s|/+|/|g;
	$family{$family_name}->{seq_file_purged} = $family{$family_name}->{seq_file};
	$family{$family_name}->{seq_file_purged} =~ s/\.${seq_ext}$//;
	$family{$family_name}->{seq_file_purged} .= "_purged.".${seq_ext};

       #### Comment
       $family{$family_name}->{comment} = $comment;

	&RSAT::message::Info (join ("\t", "File $f", 
				    $family_name,
				    $family{$family_name}->{seq_file},
				    $family{$family_name}->{seq_file_purged},
#				    $sequence_file, 
#				    $short_file, 
#				    $family_name, 
				    $comment, 
#		   "\n", $family{$family_name}->{seq_file},
#		   "\n", $family{$family_name}->{seq_file_purged}
				   )) if ($verbose >= 3); 
	push @comments, $comment;
   }
   close $files;

   @families = sort keys %family;

   #### Family members are read from the sequence file (sequence IDs are used as member IDs)

   &RSAT::message::Info("Reading family members from input sequence files") if ($main::verbose >= 1);
   foreach my $family_name (@families) {
       my ($in, $input_dir) =  &OpenInputFile($family{$family_name}->{seq_file});
       my $seq_type = "dna";
       while ((($current_seq, $current_id, @comments) = &ReadNextSequence($in, $seq_format, $input_dir, $seq_type, $mask)) &&
	      (($current_seq) || ($current_id))) {
           $family{$family_name}->new_member($current_id);
           &RSAT::message::Info (join ("\t", 
				       "", "File", $family{$family_name}->{seq_file}, 
				       "Family", $family_name, 
				       "member", $current_id)) if ($main::verbose >= 3);
       }
       close $in;
       my $gene_nb = scalar(@{$family{$family_name}->{members}});
       &RSAT::message::Info (join ("\t", 
				   $family_name, 
				   $family{$family_name}->{seq_file}, 
				   $gene_nb." members")) if ($main::verbose >= 2);
			    }
}

################################################################
## Validate the pattern discovery results by comparing discovered patterns to
## known sites
sub Validate {
   &RSAT::message::Info( ";\n; Validating discovered patterns") if ($verbose >=1);
   if ($task{validate_oligos}) {
       $pattern_type = 'oligo';
       $pattern_suffix = $oligo_suffix;
   } elsif ($task{validate_dyads}) {
       $pattern_type = 'dyad';
       $pattern_suffix = $dyad_suffix;
   } elsif ($task{validate_orm}) {
       $pattern_type = 'orm';
       $pattern_suffix = $orm_suffix;
   }

   if ($noorf eq "-noorf") {
       $noorf_status = $noorf;
   } else {
       $noorf_status = "-orfov";
   }

   ## Validation per family file
   $outfile{validation_per_family} = join ("", "validation_per_family", $pattern_suffix,$from,$noorf_status,"_",$feature_types,".tab");
   $valid_fam_handle = &OpenOutputFile($outfile{validation_per_family});

   ## Validation per pattern file
   $outfile{validation_per_pattern} = join ("", "validation_per_pattern", $pattern_suffix,$from,$noorf_status,"_",$feature_types,".tab");
   $valid_patt_handle = &OpenOutputFile($outfile{validation_per_pattern});

   ## Print the column descriptions as comments
   ## Validation per family
   $valid_fam_keys{"Fam"} = "Family name"; 
   $valid_fam_keys{"Members"} = "Number of sequences";
   $valid_fam_keys{"Sites"} = "number of annotated sites";
   $valid_fam_keys{"sig_max"} = "Maximal significance";
   $valid_fam_keys{"sig_sum"} = "Sum of significances for the discovered patterns";
   $valid_fam_keys{"sig_m"} = "Mean of significance for the discovered patterns";
   $valid_fam_keys{"TPsites"} = "Know sites matched by at least one pattern";
   $valid_fam_keys{"nb_pat"} = "Number of discovered patterns";
   $valid_fam_keys{"TP_pat"} = "Number of discovered patterns matching at least one site";
   $valid_fam_keys{"PPV"} = "Positive predictive value: PVV=TP_pat/nb_pat"; 
   $valid_fam_keys{"Sn"} = "Sensitivity: Sn=TPsites/Sites";
   $valid_fam_keys{"Acc.a"} = "Arithmetic accuracy: Acc.a = (Sn + PPV)/2";
   $valid_fam_keys{"Acc.g"} = "Geometric accuracy: Acc.g = sqrt(Sn*PPV)";
   $valid_fam_keys{"Acc.h"} = "Harmonic accuracy: Acc.h = 2*(Sn*PPV)/(Sn+PPV)";
   print $valid_fam_handle "; Column contents\n";
   foreach my $fam_key (keys(%valid_fam_keys)) {
       print $valid_fam_handle ";\t", $fam_key, "\t", $valid_fam_keys{$fam_key}, "\n";
   }

   ## Print the column descriptions as comments
   ## Validation per pattern
   $valid_patt_keys{"Fam"} = "Family name"; 
   $valid_patt_keys{"Members"} = "Number of sequences";
   $valid_patt_keys{"Sites"} = "number of annotated sites";
   $valid_patt_keys{"Pattern"} = "Pattern sequence";
   $valid_patt_keys{"Sig"} = "Significance of discovered pattern";
   $valid_patt_keys{"TPsites"} = "Know sites matched by discovered pattern";
   $valid_patt_keys{"TP_pat"} = "Discovered pattern is matching at least one annotated site (0 = False, 1 = True)";
   $valid_patt_keys{"PPV"} = "Positive predictive value: PVV=TP_pat"; 
   $valid_patt_keys{"Sn"} = "Sensitivity: Sn=TPsites/Sites";
   $valid_patt_keys{"Acc.a"} = "Arithmetic accuracy: Acc.a = (Sn + PPV)/2";
   $valid_patt_keys{"Acc.g"} = "Geometric accuracy: Acc.g = sqrt(Sn*PPV)";
   $valid_patt_keys{"Acc.h"} = "Harmonic accuracy: Acc.h = 2*(Sn*PPV)/(Sn+PPV)";
   print $valid_patt_handle "; Column contents\n";
   foreach my $patt_key (keys(%valid_patt_keys)) {
       print $valid_patt_handle ";\t", $patt_key, "\t", $valid_patt_keys{$patt_key}, "\n";
   }
   
   ## Print header in validation files
   print $valid_fam_handle join("\t", 
			     "# Fam", 
			     "members",
			     "sites",
			     "sig_max",
			     "sig_sum",
			     "sig_m",
			     "TPsites",
			     "nb_pat",
			     "TP_pat",
			     "PPV", 
			     "Sn",
			     "Acc.a",
			     "Acc.g",
			     "Acc.h"), "\n";

   print $valid_patt_handle join("\t",
				 "# Fam",
				 "Members",
				 "Sites",
				 "Pattern",
				 "Sig",
				 "TPsites",
				 "TP_pat",
				 "PPV",
				 "Sn",
				 "Acc.a",
				 "Acc.g",
				 "Acc.h"), "\n";

   my $f = 0;
   foreach my $family_name (@families) {
       $f++;
       ## Create a separate file for compare-patterns with the current family
       my @sites = @{$known_site{$family_name}};
       my @sources = @{$known_site_source{$family_name}};

       &RSAT::message::Info("Validating family ".$f."/".scalar(@families), 
			    $family_name, 
			    "known sites", 
			    $family{$family_name}->{known_sites}, 
			    "Number of sites", 
			    scalar(@sites)) if ($main::verbose >= 1);
       
       $known_handle = &OpenOutputFile($family{$family_name}->{known_sites});
       foreach my $s (0..$#sites) {
	   my $source = $sources[$s];
	   unless ($source) {
	       $source = $family_name."known".$s;
	   }
	   print $known_handle join("\t", $sites[$s], $source), "\n";
       }
       close $known_handle;

       &ValidateOneResult($family_name, scalar(@sites));
   }
   close $valid_fam_handle;
   &RSAT::message::Info(join ("\t", "Validation per family done", $outfile{validation_per_family}));
   close $valid_patt_handle;
   &RSAT::message::Info(join ("\t", "Validation per pattern done", $outfile{validation_per_pattern}));
}

################################################################
## Compare one result file with annotated motifs
sub ValidateOneResult {
    my ($family_name, $number_sites) = @_;

    my $pattern_file = $family{$family_name}->{$pattern_type."_file"};

    ## Compare discovered patterns with known sites
    my $command = "compare-patterns";
    $command .= " -v 1";
    $command .= " ".$strands;
    $command .= " -file1 ".$family{$family_name}->{known_sites};
    $command .= " -file2 ".$pattern_file;
    $command .= " -slide";
    $command .= " -return match,weight,rel_w,id,strand,seq";
    $command .= " -lth rel_w ".$rel_w;
    $command .= " -o ".$family{$family_name}->{$pattern_type."_vs_known"};
    &doit($command, $dry_run, $die_on_error, $verbose);
    
    ## Compare discovered patterns with known sites (relw table output type)
    my $command = "compare-patterns";
    $command .= " -v 1";
    $command .= " ".$strands;
    $command .= " -file1 ".$family{$family_name}->{known_sites};
    $command .= " -file2 ".$pattern_file;
    $command .= " -slide";
    $command .= " -table rel_w";
    $command .= " -o ".$family{$family_name}->{$pattern_type."_vs_known_relw_table"};
    &doit($command, $dry_run, $die_on_error, $verbose);
    
    ## Compare discovered patterns with known sites (weight table output type)
    my $command = "compare-patterns";
    $command .= " -v 1";
    $command .= " ".$strands;
    $command .= " -file1 ".$family{$family_name}->{known_sites};
    $command .= " -file2 ".$pattern_file;
    $command .= " -slide";
    $command .= " -table weight";
    $command .= " -o ".$family{$family_name}->{$pattern_type."_vs_known_weight_table"};
    &doit($command, $dry_run, $die_on_error, $verbose);

    my $match_file = $family{$family_name}->{$pattern_type."_vs_known"};
    my ($pattern_handle) = &OpenInputFile($pattern_file);

    if ($pattern_type eq "oligo") {
	$score_col = 9;
    } elsif ($pattern_type eq "dyad") {
	$score_col = 8;
    } elsif ($pattern_type eq "orm") {
	$score_col = 9;
    } else {
	&FatalError ("Pattern type $pattern_type is not supported yet");
    }

    ## Statistics per pattern
    my $nb_patterns = 0;
    my $max_sig = 0;
    my $sum_sig = 0;

    while (<$pattern_handle>) {
        next if (/^;/); # Skip comment lines
        next unless (/\S/); # Skip empty lines
        chomp();
	$nb_patterns ++;
	    my @fields = split "\t", $_;
	    my $pattern = $fields[0];
	    my $score = $fields[$score_col -1];
	    if ($score > $max_sig) {
		$max_sig = $score;
	    }
	    $sum_sig = $sum_sig + $score;
	    if ($number_sites == 0) {
		$TPsites_patt = "NA";
		$TPpattern = "NA";
		$Sn_patt = "NA";
		$PPV_patt = "NA";
		$acc_a_patt = "NA";
		$acc_g_patt = "NA";
		$acc_h_patt = "NA";
	    } else {
		chomp($TPsites_patt = `more $match_file | grep '$pattern' | wc -l`);
		if ($TPsites_patt == 0) {
		    $TPpattern = 0;
		} elsif ($TPsites_patt >= 1) {
		    $TPpattern = 1;
		}
		$Sn_patt = $TPsites_patt/$number_sites;
		$Sn_patt = sprintf("%.4f", $Sn_patt);
		$PPV_patt = $TPpattern;
		$PPV_patt = sprintf("%.4f", $PPV_patt);
		$acc_a_patt = ($Sn_patt+$PPV_patt)/2;
		$acc_a_patt = sprintf("%.4f", $acc_a_patt);
		$acc_g_patt = sqrt($Sn_patt*$PPV_patt);
		$acc_g_patt = sprintf("%.4f", $acc_g_patt);
		if (($Sn_patt + $PPV_patt) == 0) {
		    $acc_h_patt = 0;
		} else {
		    $acc_h_patt = 2*($Sn_patt*$PPV_patt)/($Sn_patt+$PPV_patt);
		    $acc_h_patt = sprintf("%.4f", $acc_h_patt);
		}
	    }
	print $valid_patt_handle join("\t", $family_name, 
				      scalar(@{$family{$family_name}->{members}}),
				      $number_sites, 
				      $pattern,
				      $score,
				      $TPsites_patt, 
				      $TPpattern, 
				      $PPV_patt, 
				      $Sn_patt, 
				      $acc_a_patt, 
				      $acc_g_patt, 
				      $acc_h_patt), "\n";
    }

    ## Mean significance per family (only the patterns above the threshold of significance)
    if ($nb_patterns > 0) {
	$mean_sig = sprintf("%.3f",  $sum_sig / $nb_patterns);
    } else {
	$max_sig = "NA";
	$sum_sig = "NA";
	$mean_sig = "NA";
    }

    ## Count number of annotated sites matching at least one discovered pattern
    $TPsites = `more $match_file | grep -v ';' | grep -v '#' | cut -f 6 | sort -u | wc -l`;
    chomp($TPsites);

    ## Count number of discovered patterns matching at least one annotated site
    $TPpatterns = `more $match_file | grep -v ';' | grep -v '#' | cut -f 7 | sort -u | wc -l`;
    chomp($TPpatterns);

    ## Calculate sensitivity, positive predictive value and accuracy
    if ($number_sites == 0) {
	$TPsites = "NA";
	$TPpatterns = "NA";
	$Sn = "NA";
	$PPV = "NA";
	$acc_a = "NA";
	$acc_g = "NA";
	$acc_h = "NA";
    } else {
        $Sn = $TPsites/$number_sites;
        $Sn = sprintf("%.4f", $Sn);
	if ($nb_patterns == 0) {
	    $PPV = 0;
	    $acc_a = 0;
            $acc_g = 0;
            $acc_h = 0;
	} else {
	    $PPV = $TPpatterns/$nb_patterns;
	    $PPV = sprintf("%.4f", $PPV);
	    $acc_a = ($Sn+$PPV)/2;
	    $acc_a = sprintf("%.4f", $acc_a);
	    $acc_g = sqrt($Sn*$PPV);
	    $acc_g = sprintf("%.4f", $acc_g);
	    if ($Sn + $PPV == 0) {
		$acc_h = 0;
	    } else {
		$acc_h = 2*($Sn*$PPV)/($Sn+$PPV);
		$acc_h = sprintf("%.4f", $acc_h);
	    }
	}
    }

    ## Print results
    print $valid_fam_handle join("\t", $family_name, 
			     scalar(@{$family{$family_name}->{members}}),
			     $number_sites, 
			     $max_sig, 
			     $sum_sig, 
			     $mean_sig, 
			     $TPsites, 
			     $nb_patterns, 
			     $TPpatterns, 
			     $PPV, 
			     $Sn, 
			     $acc_a, 
			     $acc_g, 
			     $acc_h), "\n";

}

################################################################
## Database comparison
sub DatabaseMatch {
    &RSAT::message::Info( ";\n; Comparison of discovered patterns to database of known sites") if ($verbose >=1);
   if ($task{db_match_oligos}) {
       $pattern_type = 'oligo';
       $pattern_suffix = $oligo_suffix;
   } elsif ($task{db_match_dyads}) {
       $pattern_type = 'dyad';
       $pattern_suffix = $dyad_suffix;
   } elsif ($task{db_match_orm}) {
       $pattern_type = 'orm';
       $pattern_suffix = $orm_suffix;
   }

   if ($noorf eq "-noorf") {
       $noorf_status = $noorf;
   } else {
       $noorf_status = "-orfov";
   }

   ## Database comparison synthetic file
#   $outfile{db_match} = join ("", "database_match", $pattern_suffix,$from,$noorf_status,"_",$feature_types,".tab");
#   $db_match_handle = &OpenOutputFile($outfile{db_match});

   foreach my $family_name (@families) {
       $f++;
       &RSAT::message::Info("Matching patterns discovered for family ".$f."/".scalar(@families), 
			    $family_name) if ($main::verbose >= 1);
       
       my $pattern_file = $family{$family_name}->{$pattern_type."_file"};

       ## Compare discovered patterns with database sites
       my $command = "compare-patterns";
       $command .= " -v 1";
       $command .= " ".$strands;
       $command .= " -file1 ".$db_site_file;
       $command .= " -file2 ".$pattern_file;
       $command .= " -slide";
       $command .= " -return match,weight,rel_w,id,strand,seq";
       $command .= " -lth rel_w ".$rel_w;
       $command .= " -o ".$family{$family_name}->{$pattern_type."_vs_db"};
       &doit($command, $dry_run, $die_on_error, $verbose);
    
       ## Compare discovered patterns with database sites (relw table output type)
       my $command = "compare-patterns";
       $command .= " -v 1";
       $command .= " ".$strands;
       $command .= " -file1 ".$db_site_file;
       $command .= " -file2 ".$pattern_file;
       $command .= " -slide";
       $command .= " -table rel_w";
       $command .= " -o ".$family{$family_name}->{$pattern_type."_vs_db_relw_table"};
       &doit($command, $dry_run, $die_on_error, $verbose);
    
       ## Compare discovered patterns with database sites (weight table output type)
       my $command = "compare-patterns";
       $command .= " -v 1";
       $command .= " ".$strands;
       $command .= " -file1 ".$db_site_file;
       $command .= " -file2 ".$pattern_file;
       $command .= " -slide";
       $command .= " -table weight";
       $command .= " -o ".$family{$family_name}->{$pattern_type."_vs_db_weight_table"};
       &doit($command, $dry_run, $die_on_error, $verbose);

#       my $db_match_file = $family{$family_name}->{$pattern_type."_vs_db"};



       ## Print results in synthetic file
#       print $db_match_handle join("\t", $family_name, 
#				      scalar(@{$family{$family_name}->{members}}),
#				      $number_sites, 
#				      $pattern,
#				      $score,
#				      $site,
#				      $site_id), "\n";

   }
#   close $db_match_handle;
#   &RSAT::message::Info(join ("\t", "Database match done", $outfile{db_match}));
}

################################################################
## Distribution of significance
sub SigDistrib {
    &RSAT::message::Info( ";\n; Significance distribution of discovered patterns") if ($verbose >=1);
    if ($task{sig_distrib_oligos}) {
	$pattern_type = 'oligo';
	$pattern_suffix = $oligo_suffix;
    } elsif ($task{sig_distrib_dyads}) {
	$pattern_type = 'dyad';
	$pattern_suffix = $dyad_suffix;
    } elsif ($task{sig_distrib_orm}) {
	$pattern_type = 'orm';
	$pattern_suffix = $orm_suffix;
    }

    if ($noorf eq "-noorf") {
	$noorf_status = $noorf;
    } else {
	$noorf_status = "-orfov";
    }

   ## Significance distribution file
    $outfile{sig_distrib_file} = join ("", "sig_distrib", $pattern_suffix,$from,$noorf_status,"_",$feature_types);
    if ($min_genes > 1) {
	$outfile{sig_distrib_file} .= "_mingenes".$min_genes;
    }
    $sig_distrib_handle = &OpenOutputFile($outfile{sig_distrib_file}.".tab");

    ## Getting and printing patterns and their significance
    my %max_score = ();
    my %pps = ();
    my %fps = ();
    foreach my $family_name (@families) {
	my $pattern_file = $family{$family_name}->{$pattern_type."_file"};
	my ($pattern_handle) = &OpenInputFile($pattern_file);
	my $score_col;
	if ($pattern_type eq "oligo") {
	    $score_col = 9;
	} elsif ($pattern_type eq "dyad") {
	    $score_col = 8;
	} elsif ($pattern_type eq "orm") {
	    $score_col = 9;
	} else {
	    &FatalError ("Pattern type $pattern_type is not supported yet");
	}
	$max_score{$family_name} = "NA";
	while (<$pattern_handle>) {
	    next if (/^;/); # Skip comment lines
	    next unless (/\S/); # Skip empty lines
#	    print "HELLO\t", $_;
	    chomp();
	    my @fields = split "\t", $_;
	    my $pattern = $fields[0];
	    my $score = $fields[$score_col -1];
	    $pps{$score}++;
	    if (($max_score{$family_name} eq "NA") || ($score > $max_score{$family_name})) {
		$max_score{$family_name} = $score;
	    }
#	    print $sig_distrib_handle join ("\t", $family_name, $pattern, $score), "\n";
	}
	$fps{$max_score{$family_name}}++;
	close $pattern_handle;
    }

    ## Output columns 
    @sig_distrib_columns = qw(Sig pps pps_cum ppf_cum fps_cum ffs_cum E_ppf E_ffs);

    ## Print the column descriptions as comments
    $sig_distrib_keys{"Sig"} = "Significance of discovered patterns (s)";
    $sig_distrib_keys{"pps"} = "Patterns per score (number of patterns with score = s)";
    $sig_distrib_keys{"pps_cum"} = "Patterns per score (number of patterns with score >= s)";
#    $sig_distrib_keys{"ppf"} = "Patterns per family (number of patterns with exactly this score per family)";
    $sig_distrib_keys{"ppf_cum"} = "Patterns per family (number of patterns per family with score >= s)";
    $sig_distrib_keys{"fps_cum"} = "Number of families with score >= s";
    $sig_distrib_keys{"ffs_cum"} = "Fraction of families with score >= s";
    $sig_distrib_keys{"E_ppf"} = "Expected number of patterns per family with score >= s";
    $sig_distrib_keys{"E_ffs"} = "Expected fraction of families with score >= s";
    print $sig_distrib_handle "; Column contents\n";
    foreach my $k (0..$#sig_distrib_columns) {
	my $key = $sig_distrib_columns[$k];
	print $sig_distrib_handle join ("\t", ";", $k+1, $key,  $sig_distrib_keys{$key}), "\n";
    }

   ## Print header in validation file
   print $sig_distrib_handle "#", join("\t", @sig_distrib_columns), "\n";
    my @sorted_scores = sort {$b <=> $a} keys (%pps);
    my $pps_cum = 0;
    my $fps_cum = 0;
    my $nb_families = scalar(@families);

    ## Print statistics table
    foreach my $score (@sorted_scores) {
	$pps_cum += $pps{$score};
	$fps_cum += $fps{$score};
	my $E_ppf = 10**(-$score);
	my $E_ffs = 1- &poisson(0, $E_ppf);
	print $sig_distrib_handle join("\t",
				       $score,
				       $pps{$score}, 
				       $pps_cum,
				       sprintf("%.3f",$pps_cum/$nb_families),
				       $fps_cum,
				       sprintf("%.3f",$fps_cum/$nb_families), ## ffs
				       sprintf("%7.2g",$E_ppf),
				       sprintf("%7.2g",$E_ffs),
				       ), "\n";
    }
    
    close $sig_distrib_handle;
    &RSAT::message::Info(join ("\t", "Significance distribution done", $outfile{sig_distrib_file}.".tab"));

    foreach my $log ("", "-ylog") {
	if ($log) {
	    $log_option = $log." 10";
	}
	my $sig_distrib_graph = $outfile{sig_distrib_file}.$log;

	## Draw a graph with the number of patterns per family, as a function of the sig score
	my $command = "XYgraph ".$log_option;
	$command .= " -title1 '".$sig_distrib_graph."'";
	$command .= " -title2 $organism_name.' (".$nb_families." families; min ".$min_genes." genes)'";
	$command .= " -ymin 0 -ysize 400";
	$command .= " -xgstep1 1";
	$command .= " -i ".$outfile{sig_distrib_file}.".tab";
	$command .= " -o ".$sig_distrib_graph."_ppf.jpg";
	$command .= " -xcol 1 -ycol 4,7 -lines -header -legend -xsize 800 -xleg1 'score' -yleg1 'patterns per family'";
	&doit($command, $dry_run, $die_on_error, $verbose);
	&RSAT::message::Info(join ("\t", "Patterns per family curve", $sig_distrib_graph."_ppf.jpg"));
	
	## Draw a graph with the fraction of families per score, as a function of the sig score
	my $command = "XYgraph ".$log_option;
	$command .= " -title1 '".$sig_distrib_graph."'";
	$command .= " -title2 $organism_name.' (".$nb_families." families; min ".$min_genes." genes)'";
	$command .= " -i ".$outfile{sig_distrib_file}.".tab";
	$command .= " -o ".$sig_distrib_graph."_ffs.jpg";
	$command .= " -ymin 0 -ymax 1 -ygstep1 0.1 -ygstep2 0.02 -ysize 400";
	$command .= " -xgstep1 1";
	$command .= " -xcol 1 -ycol 6,8 -lines -header -legend -xsize 800 -xleg1 'score' -yleg1 'fraction of families per score'";
	&doit($command, $dry_run, $die_on_error, $verbose);
	&RSAT::message::Info(join ("\t", "Families per score curve", $sig_distrib_graph."_ffs.jpg"));
    }
}

################################################################
## INDEX one sequence length per family
sub CalcCalibrationLengths {
   my %calib_lengths = ();
   &RSAT::message::TimeWarn("Calculating sequence lengths") if ($verbose >=1);
   foreach my $family_name (@families) {
	$fam_count++;

#	&CheckSkip($fam_count,$family_name);
#	&CheckLast($fam_count);
	
	## Calculate sequence lengths
	&RSAT::message::Info( join("\t", "", "Calculating sequence lengths for family",
				   $fam_count."/".scalar(@families),
				   $family_name, 
				   $family{$family_name}->{seq_file},
				   $family{$family_name}->{seq_len_file})
			     ) if ($verbose >= 2);
	my $command = "sequence-lengths -i ".$family{$family_name}->{seq_file};
	$command .= " -o ".$family{$family_name}->{seq_len_file};
	&doit($command, $dry_run, $die_on_error, $verbose);
	
	## Index sequence lengths
	my ($in, $indir) = &OpenInputFile($family{$family_name}->{seq_len_file});
	while (<$in>) {
	    chomp;
	    @fields = split "\t";	    
	    my $current_len = $fields[1];
	    $family{$family_name}->{total_length} += $current_len;
	    ## check that all sequences of one family have the same length

	    if ((defined($family{$family_name}->{calib_length})) 
		&& ($task{calibrate})) {
		unless ($family{$family_name}->{calib_length} == $current_len) {
		    &RSAT::error::FatalError("Sequences of family $family_name have different lengths.\nThis is not compatible with the option calibrate");
		}
	    } else {
		if ($current_len > $family{$family_name}->{calib_length}) {
		    $family{$family_name}->{calib_length} = $current_len;
		}
	    }
	}
	close $in;
	$calib_lengths{$family{$family_name}->{calib_length}}++;
	&RSAT::message::TimeWarn("Calibration length for family ", $fam_count."/".scalar(@families), $family_name, 
				 $family{$family_name}->{total_length}) if ($main::verbose >= 1);
   }  
   my @calib_lengths = sort {$a <=> $b } keys %calib_lengths;
   &RSAT::message::Info("Calibration lengths", join( ";", @calib_lengths)) if ($main::verbose >= 1);
   return @calib_lengths;
}


## ##############################################################
## Calculate the prefix of the calibration file
sub CalibrationPrefix {
   my ($calib_length, $oligo_len, $N) = @_;

   my $calib_prefix = "";

   if ($N) {
	## set-based calibration (simulations)

	## Directories containing the calibration files
	unless ($dir{calibN}) {
#	    $dir{calibN} = $supported_organism{$organism_name}->{'data'}."/rand_gene_selections";
#	    ## Temporary
#	    $dir{calibN} = "~/motif_discovery_competition_2003/results/".$organism_name."/rand_gene_selections/";
	    ## Temporary
#	    $dir{calibN} = $dir{output}."/rand_gene_selections/";
	    $dir{calibN} = "calibrations";
	}

	## directory for the current calibration
#	$calib_prefix = $dir{calibN}."/";
	$calib_prefix = $dir{main}."/".$dir{calibN};
#	$calib_prefix .= $oligo_len."nt";
#	$calib_prefix .= $strands;
#	$calib_prefix .= $noov;
#	$calib_prefix .= "_N".$N;
#	$calib_prefix .= "_L".$calib_length;
#	$calib_prefix .= "_R".$calibN_repet;

	## file name
	$calib_prefix .= "/";
	$calib_prefix .= $organism_name."_";
	$calib_prefix .= $oligo_len."nt_";
	$calib_prefix .= $strands;
	$calib_prefix .= $noov;
	$calib_prefix .= "_n".$N;
	$calib_prefix .= "_l".$calib_length;
	$calib_prefix .= "_r".$calibN_repet;

   } else {
	## single-gene-based calibration (all upstream)
	$calib_prefix = $dir{calib1}."/";
	$calib_prefix .= $oligo_len."nt";
	$calib_prefix .= "_upstream_L".$calib_length;
	$calib_prefix .= "_".$organism_name;
	$calib_prefix .= $noov;
	$calib_prefix .= $strands;
   }

   return $calib_prefix;
}

################################################################
## Generate report fiels for the motif disovery competition 2004
sub MDCreport {
   chdir($dir{output}); &RSAT::util::CheckOutDir($dir{mdc_report});
   warn ";\n; Generating report\t", $outfile{results}, "\n" if ($verbose >=1);
   
   ################################################################
   ## Open a file for the report of results
   ($results) = &OpenOutputFile($outfile{results});
#      print $results join ("\n", 
#  			 ">name of contact",
#  			 "Jacques van Helden",
#  			 ">email",
#  			 "jvanheld\@scmbb.ulb.ac.be",
#  			 ">program name",
#  			 "multiple-family-analyis"), "\n";
   close $results;
   
   ################################################################
   ## Open a file for the report of parameters
   ($parameters) = &OpenOutputFile($outfile{parameters});
#      print $parameters join ("\n", 
#  			    ">name of contact",
#  			    "Jacques van Helden",
#  			    ">email",
#  			    "jvanheld\@scmbb.ulb.ac.be",
#  			    ">program name",
#  			    "multiple-family-analyis"), "\n";

   ################################################################
   ## Generate the report for each family
   my $command = "";
   foreach $family_name (@families) {
	$fam_count++;
#	if ($fam_count <= $skip) {
#	    warn "; Skipping family\t$fam_count\t$family_name\n" if ($main::verbose >= 1);
#	    next;
#	}

	my $selection_file = $family{$family_name}->{oligo_selection};
	unless (-e $selection_file) {
#	    $selection_file = $family{$family_name}->{oligo_file};
#	    &RSAT::message::Warning("No manual selection: using default file $selection_file") if ($main::verbose >= 0);
	    &RSAT::message::Warning("No manual selection: file does not exist $selection_file") if ($main::verbose >= 0);
	    next;
	}
	&RSAT::message::Info("Pattern file for the report",  $selection_file) if ($main::verbose >= 1);

	my $selection_ft_prefix =  $family{$family_name}->{oligo_selection};
	my $feature_file = $selection_ft_prefix.".ft";
 	my $matching_options = " -N 0"; ## Make sure flanking sequences are not considered
	$matching_options .= " -merge"; ## merge overlapping matches

#  	## Threshold for reporting a match
#  	my $threshold = 0;

#  	### Sliding window options
#  	if ($sliding_window_size >= 1) {
#  	    my @patterns = &ReadPatterns(pattern_file=>$selection_file);
#  	    my @scores = ();
#  	    foreach my $pattern (@patterns) {
#  		push @scores, $pattern->get_attribute("score");
#  	    }
#  	    if (scalar(@patterns) >= 1) {
#  		$threshold = &max(@scores) + 0.01;
#  	    } elsif (scalar(@patterns) == 1) {
#  		$threshold = &max(@scores);
#  	    }
#  	    $matching_options .= " -window ".$sliding_window_size;
#  	}
#  	$matching_options .= " -th ".$threshold;



	################################################################
	## initialize postprocessing and parameter description
	my $postprocessing_text = ">postprocessing\n";
	my $parameters_text = ">parameters\n";
	my $multi_params = join " ", @ARGV;
	$multi_params =~ s/\ -/\n-/g;
	$parameters_text .= $multi_params."\n";

	### Read the pattern file in order to select
	### manually-specified parameters threshold
	($in) = &OpenInputFile($selection_file);
	my $parameters_started = 0;
	my $postprocessing_started = 0;
	while ($line = <$in>) {
	    if ($line =~ />parameters/) {
		$parameters_started = 1;
		next;
	    }
	    next unless ($parameters_started);
	    if ($line =~ />postprocessing/) {
		$postprocessing_started = 1;
		next;
	    }
	    next unless ($parameters_started);
	    $line =~ s/^;\s*//;
	    if ($postprocessing_started) {
		$postprocessing_text .= $line;
	    } elsif ($parameters_started) {
		$parameters_text .= $line;
		$matching_options .= " ".$line;
		warn "manually specified parameter $line\n" if ($main::verbose >= 3);
	    }
	}
	close($in);
	$matching_options =~ s/\n/ /g;
	$matching_options =~ s/\r/ /g;

	warn "Family $family_name\tParameters\t", $parameters_text, "\n" if ($main::verbose >= 2);
	warn "Family $family_name\tPostprocessing\t", $postprocessing_text, "\n" if ($main::verbose >= 2);
	warn "Matching options\t", $matching_options, "\n" if ($main::verbose >= 2);

	## Make sure there is a carriage return after postprocessing and parameters
	chomp($parameter_text);
	$parameter_text .= "\n";
	chomp($postprocessing_text);
	$postprocessing_text .= "\n";

	## Write parameters and postprocessing
	print $parameters ">data set\n";
	print $parameters $family_name, "\n";
	print $parameters $parameters_text;
	print $parameters $postprocessing_text;
	
	## Draw the feature map of the selected oligos
	&MatchPatterns($selection_file, $selection_ft_prefix,  $matching_options);
	&DrawFeatureMap($selection_ft_prefix, $selection_ft_prefix, " -minfthick 5");

	## Convert the features in MDC format
	warn ";\tReporting\t",$feature_file, "\n" if ($verbose >=2);
	$command = "MDCreport-from-dnapat -d ".$family_name;
	$command .= " -i ".$feature_file;
	$command .= ">> ".$outfile{results} if ($outfile{results});
	&doit($command, $dry_run, $die_on_error, $verbose);
   }    

   close $parameters;

   warn ";\n; Generated report\t", $outfile{results}, "\n" if ($verbose >=1);
}


## ##############################################################
## Extract contigs and isolated patterns from an assembly file for the
## synthetic table
sub ReadAssemblyFile {
  my ($family_name, $assembly_file, $pattern_type) = @_;
  my ($pattern_handle, $input_dir) = &OpenInputFile($assembly_file);
  my @assembled_patterns = ();
  my $error = "";
  my %score = ();

  while (<$pattern_handle>) {
    chomp;
    if (/Too many patterns to assemble/i) {
      $error = $_;
      while (<$pattern_handle>) {
	$error .= "\n", $_;
      } 
      return($error);
    }
    next if (/^;/);
    next if (/^\#/);
    next unless (/\S/);

    if ((/contig/) || (/consensus/) || (/isol/)) {
      @fields = split "\t";
      my $pattern_seq = &RSAT::util::trim(shift (@fields));
      $pattern_seq =~ s/^\.+//g;
      $pattern_seq =~ s/\.+$//g;
      $pattern = new RSAT::pattern();
      $pattern->set_attribute("sequence", $pattern_seq);
      push @assembled_patterns, $pattern;
      if ($strands eq "-2str") {
	my $rc = &RSAT::util::trim(shift @fields);
	$pattern->set_attribute("rc", $rc);
      }
      $score{$pattern} = shift @fields;
      $pattern->set_attribute("score", $score{$pattern});

      my $type = shift @fields;
      $pattern->force_attribute("type", $type);
      $max_score{$family_name} = &max($max_score{$family_name}, $score{$pattern});
      $max_score{$pattern_type}{$family_name} = &max($max_score{$pattern_type}{$family_name}, $score{$pattern});
      warn "Pattern\t", $_, "\n", join("\t", $family_name, 
				       $pattern->get_attribute('sequence'),
				       $pattern->get_attribute('rc'),
				       $pattern->get_attribute('score'),
				       $pattern->get_attribute('type'),
				       $score{$pattern},
				       $max_score{$family_name},
				      ), "\n" if ($main::verbose >= 10);
    }
  }
  close $pattern_handle;
  return ($error, @assembled_patterns);
}



################################################################
## Calibrate oligonucleotide occurrences (mean and variance) for each
## sequence length
sub CalibrateOligos {
   my @calib_lengths = @_;
   warn ";\n; Calibrating oligonucleotide occurrences\n" if ($verbose >=1);

   ### Analyse upstream occurrence distributions for each sequence length
   chdir($dir{output}); &RSAT::util::CheckOutDir($dir{calib1});
   &RSAT::message::TimeWarn ("Calculating oligonucleotide distributions in all upstream sequences") 
     if ($verbose >= 1);
   foreach my $calib_length (sort {$a <=> $b} @calib_lengths) {

	## retrieve all upstream sequence if required
	my $allup_file = $dir{calib1}."/tmp_all_up_".$calib_length.".fasta";
	if (-e $allup_file) {
	    &RSAT::message::Info("All upstream sequence file already exists. Skipping retrieval", $allup_file) if ($main::verbose >= 1);
	} else {
	    $command = "retrieve-seq -imp_pos -org $organism_name -all -from -$calib_length -to -1 -o $allup_file";
	    &RSAT::message::TimeWarn("Retrieving all upstream sequences", $allup_file) if ($main::verbose >= 1);
### This should not be done in batch, since the calibrate-oligo commands will be distributed over the nodes of the cluster
#	    if ($batch) {
#		push @main::batch_commands, $command;
#	    } else {
		&doit($command, $dry_run, $die_on_error, $verbose);
#	    }
	}

	## Calibrate oligonucleotides
	for my $oligo_len ($min_oligo_len..$max_oligo_len) {

	    ## Names of the calibration files
	    my $calib_prefix = &CalibrationPrefix($calib_length, $oligo_len);
	    my $distrib_file = $calib_prefix."_distrib.tab";
	    my $fitting_file = $calib_prefix."_negbin.tab";

	    ## Skip the calibration if the file already exists
	    if ((-e $fitting_file.".gz") && !($force_calib)) {
		warn "Calibration file already exists. Skipping calibration.\t${fitting_file}.gz\n";
		next;
	    } else {
		warn "Calculating oligo calibration\t${fitting_file}.gz\n";
	    }

	    ## Calculate occurrence distributions
	    $command = "oligo-analysis -v 3 -l $oligo_len $noov $strands  -i $allup_file -return occ -distrib -o $distrib_file";
	    &RSAT::message::TimeWarn( "Analysing ",$oligo_len."nt distributions",$distrib_file) if ($main::verbose >= 1);
	    if ($batch) {
		push @main::batch_commands, $command;
	    } else {
		&doit($command, $dry_run, 0, $verbose);
	    }

	    ## Calculate stats and fit negbin on the distributions
	    $command = "fit-distribution -v 1 -i $distrib_file -distrib negbin -o $fitting_file";
	    if ($batch) {
		push @main::batch_commands, $command;
	    } else {
		&doit($command, $dry_run, $die_on_error, $verbose);
	    }

	    ## Compress distrib and fitting file
	    $command = "gzip -f $distrib_file $fitting_file";
	    if ($batch) {
		push @main::batch_commands, $command;
	    } else {
  	        &doit($command, $dry_run, $die_on_error, $verbose);
           }
	}

	## Delete the file with all upstream sequences
	$command = "rm -f $allup_file";
	&RSAT::message::Info ("Cleaning all upstream sequences", $allup_file) if ($main::verbose >= 1);
	if ($batch) {
	    push @main::batch_commands, $command;
	} else {
	    &doit($command, $dry_run, 0, $verbose);
	}

	## Send the batch script to the queue
	if ($batch) {
	    my $batch_script = join "\n\n", @main::batch_commands;
	    &doit($batch_script, $dry_run, $die_on_error, $verbose, $batch);
	    @main::batch_commands = ();
	}
   }

}



################################################################
## Calibrate oligo frequencies by selecting R random sets of N genes,
## counting the occurrences of each word in each set, and estimating
## the average and standard deviation of the occurrence number.
#sub CalibrateOligosN {
sub CalibrateOligosN {
  &RSAT::message::Info("Calibrating oligo occurrences with random gene selections") if ($main::verbose >= 1);

  chdir($dir{main}); ## Calibration directory is specified relative to the main directory
  &RSAT::message::Info("Chdir to main directory\t".$dir{main});
  for my $oligo_len ($min_oligo_len..$max_oligo_len) {
    foreach my $family_name (@families) {
      my $gene_nb = scalar(@{$family{$family_name}->{members}});
      my $seq_len = $family{$family_name}->{calib_length};
	    
      if ($calib_done{$gene_nb}{$seq_len} > 0) {
	&RSAT::message::Info($family_name, "Already done a calibration of oligo occurrences with ",$gene_nb, 
			     "random gene selections","upstream length", $seq_len);
      } else {
		
	&RSAT::message::Info($family_name, "Calibrating oligo occurrences with ",$gene_nb, 
			     "random gene selections","upstream length", $seq_len)
	  if ($main::verbose >= 1);
	my $command = "calibrate-oligos -v 1";
	$command  .= " -r ".$calibN_repet." -sn ".$gene_nb." -ol ".$oligo_len." -sl ".$seq_len;
	my $calibN_task = "all,clean_oligos";
	$command .= " -task ".$calibN_task;
	#		$command .= "-start ${START}";
	#		$command .= "${END}";
	$command .= " ".$strands;
	$command .= " ".$noov;
	$command .= " -outdir ".$dir{calibN};
	$command .= " -org ".$organism_name;
	$calib_done{$gene_nb}{$seq_len}++;
	&doit($command, $dry_run, $die_on_error, $verbose, $batch, "multi_calibN");
      }
    }
  }
  chdir($dir{output});
}


################################################################
#### display short help message
sub PrintOptions {
 open HELP, "| more";
 print HELP <<End_short_help;
multiple-family-analysis options
--------------------------------
## General options
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-v		verbose
-i		family file (incompatible with -seq)
-mask upper|lower	mask upper- or lowercases, respectively
-seq		sequence file (incompatible with -i)
-maindir	main directory (by default, the working directory is used
-outdir		output directory
-skip #		skip the # first data sets
-last #		stop after the # first data sets
-select		fam1[,fam2,fam3,...]. Perform the analysis of selected families only.
-task		selected task (supported: $supported_tasks)
-htmaps		draw html maps (dynamic map with pointers to the features)
-n      	dry run: print commands without executing them
-batch	send time-consuming jobs to a batch queue for a PC cluster
-nodie	        continue the analysis even if errors are raised by sub-processes

## Sequence options
-org		organism
-org_fam	each family corresponds to one organism
-taxon		taxon (collect upstream sequences of orthologous genes)
-purge		use purged sequences for pattern discovery (default)
-nopurge	use non-purged sequences for pattern discovery
-purge_ml	min matching length for purge-sequence
-purge_mis	max number of mismatches for purge-sequence
-mingenes	minimal number of genes per family
-from		upstream region left limit
-to		upstream region right limit
-noorf		exclude upstream ORFs from upstream sequences
-rm		use repeat masked version of the genome
-orfov		do not exclude upstream ORFs from upstream sequences
-feattype	feature type for sequence retrieval (e.g. CDS, mRNA)

## Parameters for oligo-analysis and dyad-analysis
-1str   	strand-sensitive analysis
-2str   	strand-insensitive analysis
-noov		prevent overlapping matches for self-overlapping patterms
-ovlp		allow overlapping matches for self-overlapping patterms
-pseudo		pseudo-weight (see oligo-analysis manual)
-nomap		do not draw feature maps (for saving time and hard disk space)
-lth param \#	lower threshold on parameter. Supported: $supported_thresholds
-uth param \#	upwer threshold on parameter. Supported: $supported_thresholds
-thosig		threshold on occurrence significance (obsolete)
-toppat # 	Maximal number of patterns to assemble (default $toppat).
		
## oligo-analysis specific parameters
-maxol		maximum oligonucleotide length
-minol		minimum oligonucleotide length
-exp		expected frequency file (obsolete)
-oligo_exp_freq	expected frequencies for oligo-analysis
-bg		background frequency model
-calib_dir	calibration directory
-calibN_repet #	Number of repetitions for the calibration. 
-markov #	exp. freq. calcualted with Markov chain model of order #
-thmsf		threshold on frequency of matching sequences (obsolete)
-thmssig	threshold on the significance of matching sequences (obsolete)

## dyad-analysis specific parameters
-monad		monad length for dyad-analysis
-minsp		maximum spacing for dyad-analysis
-maxsp		maximum spacing for dyad-analysis
-transp		transpose synthetic result table (columns become rows)
-sort		sort key (supported: $supported_sort_keys)
-dyad_exp_freq	expected frequencies for dyad-analysis

## General options for matrix-based pattern discovery
-width		matrix width (default $matrix_width)
-sps		expected number of sites per sequence (default $expected_sites_per_gene)
-nmotifs	number of motifs to discover per sequence set (family)

## Gibbs sampler (Neuwald, 1995)
-seed		seed number for the random generator

## AlignACE (Roth, 1998)
-seed		seed number for the random generator

## MotifSampler (Thijs, 2000)
-MS_b		backgound file
-MS_p		prior probability of 1 motif copy (default $MS_p)
-MS_M   	Maximal number of motif instances per sequence. (default $MS_M; unset=0)
-MS_n		number of different motifs to search for (default $MS_n).
-MS_x		allowed overlap between different motifs. (default $MS_x)
-MS_r		number of times the MotifSampler should be repeated (default = $MS_r).

## MEME options (Bailey)
-MEME_minw	minimum motif width (default $MEME_minw)
-MEME_maxw	maximum motif width (default $MEME_maxw)
-MEME_bfile     name of background Markov model file

## Validation
-known		file containing a list of known sites/motifs
-known_max_len 	maximal length for using known sites (default: $known_site_max_len)

## Database comparison
-db             file containing a list of known sites (from a database)

## Database
-schema		database schema (default: $schema)
-host		database host (default: $host)
-user		database user (default: $user)
-password	database password (default: $password)

End_short_help

 close HELP;
 exit;
}
