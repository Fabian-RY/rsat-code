#!/usr/bin/perl
############################################################
#
# $Id: dna-pattern,v 1.21 2002/06/06 10:16:47 jvanheld Exp $
#
# Time-stamp: <2002-06-06 12:16:36 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.classes";

# for more info type:
#            dna-pattern -help
#
# help content at the end of this file

$start_date = &AlphaDate;

#### init variables ####
$threshold = 1.0e-12; #### this is a tricky way to circumvent a Perl floating-point imprecision 
$pattern_score = 1;
$noid = 0;
$strands_to_search = "DR";
$in_format = "fasta";
#$search_method = "IUPAC";
$search_method = "regexp";

if ($HelpRequested) {
    &Help;
    exit;
}


&ReadArguments;

################################################################
#
# check parameter values 
#

#### return values
unless (defined(%return)) {
    $return{match_positions} = 1;
}

#### top scores only valid with sliding window
if (($return{top} ) && !($search_method eq "sliding window")) {
    &FatalError("The option -top is only vlid with the option -window\n");
}
if (($sort ) && !($return{top})) {
    &FatalError("The option -sort is only vlid with the option -top\n");
}

#### check allowed substitutions ####
unless (($allowed_subst eq "") || (&IsNatural($allowed_subst))) {
    &FatalError("Invalid number of allowed substitutions.\n");
}

### check input format 
&CheckInputSeqFormat($in_format);



@patterns = &ReadPatterns(pattern_file=>$pattern_file, 
			  score_column=>$score_column, 
			  noid=>$noid,
			  pattern_score=>$pattern_score,
			  pattern_id=>$pattern_id,
			  pattern_seq=>$pattern_seq);

#### check patterns

### no pattern specified
if ($#patterns < 0) {
    &Warning("There is not a single pattern.") ;
}

#### prepare pattern hash for sliding window 
%pattern_scores = ();
if ($search_method eq "sliding window") {
    #### calculate pattern length
    my $first_pattern_seq =  $patterns[0]->get_attribute("sequence");
    $pattern_length = length($first_pattern_seq);

    foreach my $pattern (@patterns) {
	my $pattern_seq = lc($pattern->get_attribute("sequence"));
	#### check pattern length
	if (length($pattern_seq) != $pattern_length) {
	    &FatalError("With the sliding window option, all patterns must have the same length");
	}
	#### check non-degeneracy
	if ($pattern_seq =~ /[^acgt]/i) { &FatalError("With the sliding window option, only non-degenerate DNA alphabet is supported [ACGT]\n") };
	#### index pattern score
	my $pattern_score = $pattern->get_attribute("score");
	$pattern_scores{$pattern_seq} = $pattern_score;
    }

    #### two strand search
    if ($strands_to_search eq "DR") {
	foreach my $pattern_seq (keys %pattern_scores) {
	    $pattern_scores{lc(&ReverseComplement($pattern_seq))} = $pattern_scores{$pattern_seq};
	}
	$strand = "DR";
    } else {
	$strand = "D";
    }

    #### crate an object for the composite pattern
    $pattern = new RSA::pattern(id => "composite",
				sequence => "*composite*",
				score => $pattern_score);

}

### open output file ###
$out = &OpenOutputFile($outputfile);

&Verbose if ($verbose >=1);

#### search ###
### open sequence file ###
($in, $input_dir) = &OpenInputFile($inputfile);

### read input sequences
while ((($current_seq, $sequence_id, @comments) = &ReadNextSequence($in, $in_format, $input_dir)) &&
       (($current_seq) || ($sequence_id))) {
    
    push @sequence_ids, $sequence_id;

    #### remove tabs and blank spaces ####    
    $current_seq = &FoldSequence($current_seq, 0);
    
    $sequence_length = length($current_seq);

    if (($origin <  0) || ($origin eq "-0")) {
	$orig_pos = $sequence_length + $origin + 1; 
    } else {
	$orig_pos = $origin;
    }
    
    if ($search_method eq "sliding window") {
	&SlidingWindowSearch();
	
    } else {
	foreach $pattern (@patterns) {
	    $expression = $pattern->get_attribute("sequence");
	    $expression =~ tr/a-z/A-Z/;
	    $pattern_length = length($expression);
	    $D_regular_expression = &IUPAC_to_regular($expression);
	    $R_regular_expression = &ReverseComplement($D_regular_expression);
	    $RC_pattern = &ReverseComplement($expression);
	    
	    $match_count = 0;
	    #### palindromic patterns are searched only  on one strand 
	    if (($expression eq &ReverseComplement($expression)) && 
		($strands_to_search eq "DR")) {
		$regular_expression = $D_regular_expression;
		$strand = "DR";
		if ($search_method eq "regexp") {
		    &RegExpSearch($current_seq, $regular_expression);
		} else {
		    &IUPACsearch();
		}
	    } else { 
		#### search on direct strand
		if ($strands_to_search =~ /D/) {
		    $regular_expression = $D_regular_expression;
		    $strand = "D";
		    if ($search_method eq "regexp") {
			&RegExpSearch($current_seq, $regular_expression);
		    } else {
			&IUPACsearch();
		    }
		}
		#### search on reverse complement strand
		if ($strands_to_search =~ /R/) {
		    $regular_expression = $R_regular_expression;
		    $strand = "R";
		    if ($search_method eq "regexp") {
			&RegExpSearch($current_seq, $regular_expression);
		    } else {
			&IUPACsearch();
		    }
		}
	    }
	    
	    #### increment the total counter for the pattern
	    $sum_per_pattern{$pattern} += $match_count;
	    $sum_per_sequence{$sequence_id} += $match_count;
	    $total_sum += $match_count;
	    
	    #### store match count if requested
	    if ($calc{match_counts}) {
		$match_count{$sequence_id}{$pattern} = $match_count;
	    }
	}
    }
}



&MatchCounts if ($return{match_counts});

&TopScores if ($return{top});

&CountTable if ($return{table});

&MatchingStatistics() if ($return{stats});

#### elapsed time
if ($verbose) {
    $done_date = &AlphaDate;
    print $out "; Job started\t$start_date\n";
    print $out "; Job done   \t$done_date\n";
}

if ($outputfile) {
    close ($out);
}


################################################################
#################### subroutine definition #####################
################################################################


################################################################
# search with a regular expression
#
sub RegExpSearch {
    my %pat_hash = &Substitute($regular_expression, $allowed_subst, 0);
    my @keys = sort {
	($pat_hash{$a} > $pat_hash{$b}) ||
	    (($pat_hash{$a} == $pat_hash{$b}) and
	     (lc($a) cmp lc($b)))
	    } keys %pat_hash;
    foreach my $reg_pat (@keys) {
	my $seq_to_crop = $current_seq;
	while ($seq_to_crop =~ /($reg_pat)(.*)/i) {
	    $match_count++;
	    if ($strand eq "DR") {
		$match_count++;
	    }
	    $matching_word = $1;
	    $matching_word_length = length($matching_word);
	    $remaining_seq = $2;
	    $offset = $matching_word_length + length($remaining_seq)-1;
	    if ($return{match_positions}) {
		if ($strand eq "R") {
		    $matching_word = &ReverseComplement($matching_word);
		    $up_neighborhood = $right_neighborhood;
		    $down_neighborhood = $left_neighborhood;
		} else {
		    $up_neighborhood = $left_neighborhood;
		    $down_neighborhood = $right_neighborhood;
		}
		if (($left_neighborhood) || ($right_neighborhood)){
		    $up_neighb = substr($current_seq,-$offset-$up_neighborhood-1,$up_neighborhood);
		    $down_neighb = substr($current_seq,-$offset+$matching_word_length-1,$down_neighborhood);
		    if ($strand eq "R") {
			$up_neighb = &ReverseComplement($up_neighb);
			$down_neighb = &ReverseComplement($down_neighb);
			$matching_word = lc($down_neighb).uc($matching_word).lc($up_neighb);
		    } else {
			$matching_word = lc($up_neighb).uc($matching_word).lc($down_neighb);
		    }
		}
		$start_pos = $sequence_length - $offset - $orig_pos;
		$end_pos = $start_pos + $matching_word_length - 1;
		$mismatches = $pat_hash{$reg_pat};
		&PrintMatchLocation();
	    }
	    if ($no_overlap) {
		$seq_to_crop = $remaining_seq;
	    } else {
		$seq_to_crop = substr($seq_to_crop,-$offset);
	    }
	}
    }
} # RegExpSearch

################################################################
# search a IUPAC pattern
#
sub IUPACsearch {
    $offset = 0;
    $match_pos = 0;
    
    if ($strand eq "R") {
	$IUPAC_pattern = &ExpandSeq($RC_pattern);
    } else {
	$IUPAC_pattern = &ExpandSeq($pattern->get_attribute("sequence"));
    }
    $pattern_len = length($IUPAC_pattern);
    
    do {
	($match_pos,$matching_word,$mismatches) = &NextMatch($current_seq, $IUPAC_pattern, $allowed_subst, $offset);
	unless ($match_pos == -1) {
	    $match_count++;
	    if ($strand eq "DR") {
		$match_count++;
	    }
	    
	    unless ($return{match_counts}) {
		if ($strand eq "R") {
		    $matching_word = &ReverseComplement($matching_word);
		} 
		$start_pos = $match_pos -$orig_pos;
		$end_pos = $start_pos + $pattern_len -1;
		&PrintMatchLocation();
	    }
	    if ($no_overlap) {
		$offset = $match_pos + $pattern_len;
	    } else {
		$offset = $match_pos;
	    }
	} ###unless
    } until ($match_pos == -1);
} # IUPACsearch


################################################################
# Print a single match location
sub PrintMatchLocation {
    if ($score_column > 0) {
	$score = $pattern->get_attribute("score");
    } else {
	$match_length = length($matching_word);
	$score = ($match_length - $mismatches)/$match_length;
    }
    print $out $pattern->get_attribute("id");
    print $out "\t$strand";
    print $out "\t", $pattern->get_attribute("sequence");
    print $out "\t$sequence_id";
    print $out "\t$start_pos";
    print $out "\t$end_pos";
    print $out "\t$matching_word";
    printf $out "\t%.2f", $score;
    print $out "\n";
}

############ HELP message ####################
sub Help	{
    open HELP, "|more";
    print HELP <<EndOfHelp;
NAME
	dna-pattern
	perl script v1.1 by Jacques van Helden, 30 July 1997.

DESCRIPTION
	Searches all occurrences of a pattern within DNA sequences.
        The pattern can be entered as a simple nucleotide sequence, 
        but can also include degenerate nucleotide codes, or regular 
        expressions. 

CATEGORY
	sequences

USAGE
	(get help)
	dna-pattern -h

	(directly enter the sequence to search)
	dna-pattern  -i sequencefile -format seq_format -p pattern [-id identifier] 
			[-D|-R|-DR] [-c|-ct] [-noov]
			[-N neighborhood] [-v]

	(read a list of patterns from a file)
	dna-pattern -i sequencefile -format seq_format -pl pattern_file 
   			[-D|-R|-DR] [-c|-ct]  [-noov] 
   			[-N neighborhood] [-v]

ARGUMENTS
	-h	help (displays the current message)
	-help	short help message
	-i	input sequence file. This file contains the sequences where the pattern(s)
		will be searched for. 
		Various format are accepted
		If omitted, standard input (eg keyboard) will be used. 
		This allows to use the program within a pipe.
	-format	input sequence format. The accepted formats are
		fasta	       FastA format
		IG	       IntelliGenetics format
		raw	       a single sequence in a file
		multi	       each new line is a new sequence
		filelist       a list of files containing each 
			       a single raw sequence
	-o	output file.
		If omitted, standard output (eg screen) will be used. 
		This allows to use the program within a pipe.
	-p	pattern entered directly after -p. 
		Alternatively use -pl.
	-pl	name of the file containing the patterns to search .
		each line of this file should contain an identifier and the 
		corresponding pattern, separated by a single tab.
		Alternatively use -p.
	-subst #
        allow # substitutions. 
	-sc #	
		score column
		the #th column of the pattern file contains a number indicating 
		the score for a match of this pattern. This option allows to 
		weight the matches according to a user-defined scheme.
	-noid	
		do not search pattern identifier in the second column of 
		pattern file. instead the id takes the same content as the
		pattern sequence.
	-noov	
		prevents detection of overlapping pattern
	-DR	search matches on both strands (direct and reverse complement)
	-D	search matches only on the direct strand.
	-R 	search matches only on the reverse complement strand.
	-id	pattern identifier (one word). 
		Use this option combined with -p.
	-pos	return match positions (default)
	-c	return the count of matches rather than the list of
		positions and matching words. 
		If a list of sequence files is given (-sl), the count of 
                matches within each file is returned, as well as the 
                cumulative count.
	-table	return the count of pattern matches per sequence
		in the form of a table.
		(one line per sequence, one column per pattern)
	-colsum	(together with -table)
		prints an extra column with the total occurrences per sequence
	-rowsum	(together with -table)
		prints an extra row with total occurrences per pattern
	-total	(together with -table)
		prints an extra column with the total occurrences per sequence
		and an extra row with total occurrences per pattern.
		(amounts to combine -colsum and -rowsum)
	-stats	return matching statistics
        -th #   Threshold. 
                Return match count only for sequences with >= # matches.
                Only valid in combination with -c.
	-ct	same as c, except that it returns the sum of matches in all 
		the files of the sequence file list, instead of the count 
		within each separate file. 
	-N #	return matching sequences with # flanking nucleotides
	-NL #	return matching sequences with # left flanking nucleotides
	-NR #	return matching sequences with # right flanking nucleotides
	-v	verbose.
        -origin #
                define # as the origin for the calculation of positions.
                -origin -0 defines the end of each sequence as the 
                origin. The matching positions are then negative values, 
                providing the distance between the match and the end of the 
                sequence.
	-window #	
		Sliding window size. The score at each position is
		calculated by summing the scores of all patterns
		encountered within a sliding window of size #. This
		option automatically returns matching positions. 
		A threshold can be specified to specify the minimal
		matching score to be returned.
	-top	(with sliding window only)
		only return the top score obtained with the sliding
		window for each sequence.
	-sort	(with -top only)
		sort sequences according to their top score
PATTERN FORMATS
	PATTERN SEQUENCE FORMAT
	The standard degenerate nucleotide code of the IUPAC-IUB commission 
	is supported (see http://www.chem.qmw.ac.uk/iupac/misc/naseq.html for 
	complete information).
	The pattern sequence should thus only contain the following characters:
		A			(Adenine)
		C			(Cytosine)
		G			(Guanine)
		T			(Thymine)
		R	= A or G        (puRines)
		Y	= C or T        (pYrimidines)
		W	= A or T        (Weak hydrogen bonding)
		S	= G or C        (Strong hydrogen bonding)
		M	= A or C        (aMino group at common position)
		K	= G or T        (Keto group at common position)
		H	= A, C or T     (not G)
		B	= G, C or T     (not A)
		V	= G, A, C       (not T)
		D	= G, A or T     (not C)
		N	= G, A, C or T  (aNy)
	Upper and lower case are considered equivalent.
	
	Patterns can be either entered directly by the user, or listed in a 
	file.

        The pattern can also contain regular expression elements:
        - GAT\[TA\]AG means \"GATAAG or GATTAG\" (equivalent to GATWAG).
        - CGGN{11}CCG means CGG followed by 10 N followed by CCG.
        - GATAAGN{0,30}GATAAG means two GATAAG spaced by 0 to 30 
          nucleotides.

	DIRECT PATTERN INPUT
	Type the -p option directly followed by a pattern sequence. 
	An optional identifier can be further entered after the -id option.

	PATTERN FILE 
	Each line contains a single pattern, for which two informations can 
	be provided: 
	- the pattern sequence (mandatory)
	- a pattern identifier (optional)
	Identifier and sequence must be separated by a single tab 
	character (\\t). 

SEQUENCE FILE FORMAT
        3 formats are supported:
        - raw
        - filelist
        - IG (intelligenetics)

	raw	The input file must contain raw sequences without any 
                comment or other text. Tabs (\\t), blank spaces and newline 
                characters (\\n) are accepted (they will be automatically 
                removed before analysis). The sequence must be terminated by 
                a newline character.
	
	filelist	
		file list. Each line of the input file contains the 
		name of a file containing a single sequence in raw format.

	IG	IntelliGenetics format. 	
 		The first non-comment line must be the sequence identifier 
		(a single word without spaces). 
		The sequence follows the identifier line identifier. It can 
                include spaces, tabs or newlines, that will be removed for 
                sequence analysis.
                The end of one sequence is indicated by termination character:
		1 for linear, 2 for circular sequences. 
		A single file may contain several sequences. 

		EXAMPLE of IG suite:

		; sequence of the region upstream from NIL1
	        ; Locus GAT1
 	        ; ORF YFL021W  coord:   6 95964 97496
 	        ; upstream region size: 100
 	        ; upstream region coord:        6 95864 95963
 	        GAT1
 	        ACAGAGCAACAATAATAACAGCACTATGAGTCGCACACTT
  	        GCGGTGCCCGGCCCAGCCACATATATATAGGTGTGTGCCA
  	        CTCCCGGCCCCGGTATTAGC
  	        1
 	        ; sequence of the region upstream from PUT4
                ; Locus PUT4
                ; ORF YOR348C  coord:   15 988773 986890
                ; upstream region size: 100
                ; upstream region coord:        15 988873 988774
                PUT4
                GGGTTTGTGTTCCTCTTCCTTTCCTTTTTTTTTCTCTCTT
                CCCTTCCAGTTTCTTTTATTCTTTGCTGTTTCGAAGAATC
                ACACCATCAATGAATAAATC
                1	

OUTPUT
	The output file contains columns separated by tabs (\\t), 
	providing respectively:
	- query pattern identifier word
	- match found on direct (D) or reverse complement (R) strand
	- pattern sequence
	- sequence file name
	- start position of the match
	- end position of the match
	- matching sequence
	- the matching score

	If the -c option is entered, output file provides :
	- query pattern identifier word
	- query pattern sequence
	- sequence file name
	- number of matches for the current pattern in the current file

EXAMPLES
	dna-pattern -i GATA -p GATWA -s $RSAGENOME/chr1.raw -c
	
	will count all occurences of the strings 'GATAA' and 'GATTA' present 
	in the file $RSAGENOME/chr1.raw.
WEB VERSION
	http://www.ucmb.ulb.ac.be/bioinformatics/rsa-tools/
";
EndOfHelp
    close HELP;
    exit(0);
}


sub ShortHelp	{
    open HELP, "|more";
    print HELP <<EndShortHelp;
dna-pattern options
-------------------
-h	complete help message
-help   short help message
-p	pattern
-pl	pattern list file
-s	sequence file. 
-subst  allowed substitutions
-sc	score column
-o	output file.
-format	input format (raw, filelist or IG)
-id	pattern identifier (one word). 
-noid	use pattern sequence as id
-noov	prevent detection of overlapping pattern
-DR	search matches on both strands (default)
-D	search matches on the Direct strand only
-R 	search matches on the Reverse complementary strand only
-pos	return match positions (default)
-c	return the count of matches for each pattern in each sequence
-table	return a table with the count of pattern matches per sequence
-colsum	return total occ per sequence in the count table
-rowsum	return total occ per pattern in the count table
-total	return total occ per sequence and per pattern in the count table
-stats	return matching statistics
-window	sliding window size
-top	only return the top score
-sort	sort sequences according to their top score
-th     threshold
-ct	return total count in all sequences
-N #	return matching sequences with # flanking nucleotides
-NL #	return matching sequences with # left flanking nucleotides
-NR #	return matching sequences with # right flanking nucleotides
-v	verbose
-origin origin (position 0)
EndShortHelp
    close HELP;
    exit(0);
}


################################################################
#
# Read command line arguments
#
sub ReadArguments {
    foreach $a (0..$#ARGV) {
	if ($ARGV[$a] eq "-h") {
	    &Help;
	} elsif  ($ARGV[$a] eq "-help") {
	    &ShortHelp;
	    
	} elsif ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }

	} elsif ($ARGV[$a] =~ /^-ori/) {
	    $origin = $ARGV[$a+1];
	    
	} elsif (($ARGV[$a] eq "-subst") && (&IsNatural($ARGV[$a+1]))){
	    $allowed_subst = $ARGV[$a+1];
	    if ($allowed_subst > 0) {
		$search_method = "IUPAC";
		warn "; Seach method: IUPAC\n" if ($verbose >=1);
	    }
	    
	} elsif ($ARGV[$a] eq "-IUPAC") {
	    $search_method = "IUPAC";
	    warn "; Seach method: IUPAC\n" if ($verbose >=1);
	    
	    ################################################################
	    #### pattern specification
	} elsif ($ARGV[$a] eq "-id") {
	    # directly read pattern identifier from the command line
	    if ($ARGV[$a+1] =~ /(\S+)/) {
		$pattern_id = $1;
	    }
	    
	} elsif ($ARGV[$a] eq "-p") {
	    # directly read pattern sequence from the command line
	    $pattern_seq = $ARGV[$a+1];
	    warn ("; Pattern sequence\t", $pattern_seq, "\n") if ($verbose >=4);
	    
	} elsif ($ARGV[$a] eq "-pl") {
	    # read name of file containing the list of patterns and open it
	    if ($ARGV[$a+1] =~ /(\S+)/) {
		$pattern_file = $1;
		&FatalError("Cannot read pattern file '$pattern_file'.") 
		    unless (-r $pattern_file);
	    } 

	    #### score column in the pattern file
	} elsif (($ARGV[$a] eq "-sc") && (&IsNatural($ARGV[$a+1])) && ($ARGV[$a+1] > 1)) {
	    $score_column = $ARGV[$a+1];
	    
	    #### the pattern file contains no identifier
	} elsif ($ARGV[$a] eq "-noid") {
	    $noid = 1;
	    
	    ################################################################
	    #### sequence file
	} elsif ($ARGV[$a] eq "-i") {
	    # read input file name (sequence file)
	    $inputfile = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-format") {
	    # read input format (sequence format)
	    $in_format = lc($ARGV[$a+1]);
	    
	    
	    ################################################################
	    #### output file
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];

	    ################################################################
            #### matching options

	    #### strands
	} elsif (($ARGV[$a] eq "-D") ||($ARGV[$a] eq "-W") || ($ARGV[$a] eq "-1str")) {
	    $strands_to_search = "D";
	} elsif (($ARGV[$a] eq "-R") ||($ARGV[$a] eq "-C")) {
	    $strands_to_search = "R";
	} elsif (($ARGV[$a] eq "-DR") || 
		 ($ARGV[$a] eq "-RD") ||
		 ($ARGV[$a] eq "-CW") ||
		 ($ARGV[$a] eq "-CW") ||
		 ($ARGV[$a] eq "2str")
		 ) {
	    $strands_to_search = "DR";
	    
	    #### threshold
	} elsif ($ARGV[$a] eq "-th") {
	    $threshold = $ARGV[$a+1];
	    unless (&IsReal($threshold)) {
		&FatalError("Threshold must have a real value");
	    }

	    #### no overlap
	} elsif ($ARGV[$a] eq "-noov") {
	    $no_overlap = 1;
	    
	    ################################################################
            #### output 
	    
	    #### count matches
	} elsif ($ARGV[$a] eq "-pos") {
	    $return{match_positions} = 1;
	    
	    #### count matches
	} elsif ($ARGV[$a] eq "-c") {
	    $calc{match_counts} = 1;
	    $return{match_counts} = 1;
	    
	    #### sum matches over all sequences
	} elsif ($ARGV[$a] eq "-ct") {
	    $return{match_counts} = 1;
	    $return{sum_only} = 1;
	    
	    #### return results in a sequence x pattern_count table
	} elsif ($ARGV[$a] eq "-table") {
	    $calc{match_counts} = 1;
#	    $return{sum_only} = 0;
	    $return{table} = 1;

	    #### add a column containing the sum of colums to the table output
	} elsif ($ARGV[$a] eq "-colsum") {
	    $return{col_sum} = 1;
	    #### add a row containing the sum of rows to the table output
	} elsif ($ARGV[$a] eq "-rowsum") {
	    $return{row_sum} = 1;
	    #### add a column and a row for totals to the table output
	} elsif ($ARGV[$a] eq "-total") {
	    $return{col_sum} = 1;
	    $return{row_sum} = 1;

	    #### return a summary of matching statistics 
	} elsif ($ARGV[$a] eq "-stats") {
	    $calc{match_counts} = 1;
	    $calc{col_sum} = 1;
	    $calc{row_sum} = 1;
	    $return{stats} = 1;

	    #### sliding window
	} elsif ($ARGV[$a] =~ /-win/) {
	    $search_method = "sliding window";
	    $sliding_window_size = $ARGV[$a+1];
	    unless (&IsNatural($sliding_window_size)) {
		&FatalError( "Sliding window size must be a natural number");
	    }
	    unless ($sliding_window_size > 0) {
		&FatalError( "Sliding window size must be > 0");
	    }

	    #### top score
	} elsif ($ARGV[$a] eq "-top") {
	    $return{top} = 1;
	    #### sort
	} elsif ($ARGV[$a] eq "-sort") {
	    $sort = 1;

	    #### neighborhood (return flanking residues)
	} elsif (($ARGV[$a] eq "-N") && (&IsNatural($ARGV[$a+1]))) {
	    $left_neighborhood = $ARGV[$a+1];
	    $right_neighborhood = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-NL") && (&IsNatural($ARGV[$a+1]))) {
	    $left_neighborhood = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-NR") && (&IsNatural($ARGV[$a+1]))) {
	    $right_neighborhood = $ARGV[$a+1];
	    
	}
    }
}



################################################################
# scan the sequence with a sliding window
sub SlidingWindowSearch {
    $last_pos = $sequence_length - $pattern_length;

    return if ($last_pos < $sliding_window_size);

    $current_seq = lc($current_seq);
    my @scores = ();
    my $current_score = 0;
    my $previous_score = 0;
    my $score_sum = 0;
    my $top_score;

    #### initialize score vector
    for my $pos (0..($sliding_window_size-2)) {
	my $subseq = substr($current_seq, $pos, $pattern_length);
	my $current_score = $pattern_scores{$subseq};
	push @scores, $current_score;
	$score_sum += $current_score;
    }
    $top_score = $score_sum;

    #### scan the sequence with the sliding window
    for my $pos (($sliding_window_size-1)..$last_pos) {
	my $subseq = substr($current_seq, $pos, $pattern_length);
	my $current_score = $pattern_scores{$subseq};

	push @scores, $current_score;
	$score_sum += $current_score;

	if ($score_sum >= $threshold) {
	    $pattern->set_attribute("score", $score_sum);
	    $end_pos = $pos - $orig_pos + $pattern_length ;
	    $start_pos = $pos - $orig_pos - $sliding_window_size +2;
	    $matching_word = substr($current_seq, $start_pos, $sliding_window_size + $pattern_length - 1);
	    &PrintMatchLocation() if ($return{match_positions});
	}

	$previous_score = shift @scores;
	$score_sum -= $previous_score;
	$top_score = &max($top_score, $score_sum);
    }
    if ($top_score >= $threshold) {
	$top_score{$sequence_id} = $top_score;
    }
}



################################################################
# Verbosity: report parameters
# 
sub Verbose {
    print $out "; dna-pattern ";
    &PrintArguments($out);
    print $out "; Citation: van Helden et al. (2000). Yeast 16(2), 177-187.\n";
    printf $out "; %-21s\t%s\n", "Input file", $inputfile if ($inputfile);
    printf $out "; %-21s\t%s\n", "Input format", $in_format; 
    printf $out "; %-21s\t%s\n", "Output file", $outputfile if ($outputfile);
    printf $out "; %-21s\t%s\n", "Pattern file", $pattern_file if ($pattern_file);
    printf $out "; %-21s\t%s\n", "Search method", $search_method;
    if ($search_method eq "sliding window") {
	printf $out "; %-21s\t%s\n", "Sliding window", $sliding_window_size;
	printf $out "; %-21s\t%s\n", "Pattern length", $pattern_length;
    }
    
    printf $out "; %-21s\t%g\n", "Threshold", $threshold;
    printf $out "; %-21s\t%d\n", "Allowed substitutions", $allowed_subst;
    if (defined(%return)) {
	foreach $key (keys %return) {
	    printf $out "; %-21s\t%s\n", "return", $key 
		if ($return{$key});
	}
    }
    print $out "; Patterns\n";
    print $out "; \tseq\tid\tscore\n";
    foreach my $pattern (@patterns) {
	print $out ("; ", 
		    "\t", $pattern->get_attribute("sequence"),
		    "\t", $pattern->get_attribute("id"),
		    "\t", $pattern->get_attribute("score"),
		    "\n");
    }
    print $out "; \n";

    if ($return{match_positions}) {
	print $out "; Matching positions\n";
	print $out "; PatID";
	print $out "\tStrand";
	print $out "\tPattern";
	print $out "\tSeqID";
	print $out "\tStart";
	print $out "\tEnd";
	print $out "\tMatching_word";
	print $out "\tScore";
	print $out "\n";
    }
}



################################################################
# Matching statistics
#
sub MatchingStatistics {
    my $nb_sequences = $#sequence_ids + 1;
    my $nb_patterns = $#patterns + 1;
    my $matching_patterns = 0;
    my $matching_patterns_pct = 0;
    my $max_matching_score_pct = 0;
    my $max_matching_score;
    my $max_score;
    foreach my $pattern (@patterns) {
	$max_score = &max($max_score, $pattern->get_attribute("score"));
	if ($sum_per_pattern{$pattern} > 0) {
	    $matching_patterns++ ;
	    $max_matching_score = &max($max_matching_score, $pattern->get_attribute("score"));
	}
    }
    if ($nb_patterns > 0) {
	$matching_patterns_pct =  100*$matching_patterns/$nb_patterns;
    }

    if ($max_score > 0) {
	$max_matching_score_pct =  100*$max_matching_score/$max_score;
    }

    my $matched_sequences = 0;
    my $matched_sequences_pct = 0;
    foreach my $sequence_id (@sequence_ids) {
	$matched_sequences++ if ($sum_per_sequence{$sequence_id} > 0);
    }
    if ($nb_sequences > 0) {
	$matched_sequences_pct = 100*$matched_sequences/$nb_sequences;
    }

    print $out "; Matching statistics\n";

    printf $out ( "%-21s\t%s\t%s\t%s\n", 
		  "; statistics",
		  "max",
		  "matched",
		  "percent"
		  ), "\n";
    printf $out ( "%-21s\t%d\t%d\t%.1f\n", 
		  "matching patterns",
		  $nb_patterns,
		  $matching_patterns,
		  $matching_patterns_pct
		  );
    printf $out ( "%-21s\t%.2f\t%.2f\t%.1f\n", 
		  "matching scores",
		  $max_score,
		  $max_matching_score,
		  $max_matching_score_pct
		  );
    printf $out ( "%-21s\t%d\t%d\t%.1f\n", 
		  "matching sequence",
		  $nb_sequences,
		  $matched_sequences,
		  $matched_sequences_pct
		  );
}

################################################################
# print the matching table (patterns/sequences)
sub CountTable {
#    print $out "; Match count table\n";
    print $out ";seq";
    foreach my $pattern (@patterns) {
	print $out "\t", $pattern->get_attribute("id");
    }
    print $out "\ttotal" if ($return{col_sum}); #### print total of occurrences per sequence
    print $out "\n";
    foreach $sequence_id (@sequence_ids) {
	print $out $sequence_id;
	foreach my $pattern (@patterns) {
	    print $out "\t", $match_count{$sequence_id}{$pattern};
	}
	print $out "\t", $sum_per_sequence{$sequence_id} if ($return{col_sum});
	print $out "\n";
    }
    #### print total of occurrences per pattern
    if ($return{row_sum}) {
	print $out "total";
	foreach my $pattern (@patterns) {
	    print $out "\t", $sum_per_pattern{$pattern};
	}
	print $out "\t", $total_sum;
	print $out "\n";
    }
}

################################################################
# match counts
sub MatchCounts {
    if ($return{sum_only}) {
	print $out "; Counts per pattern\n";
	print $out "; PatID\tPattern\tMatches\n";
	foreach my $pattern (@patterns) {
	    print $out $pattern->get_attribute("id");
	    print $out "\t", $pattern->get_attribute("sequence");
	    print $out "\t", $sum_per_pattern{$pattern};
	    print $out "\ttotal";
	    print $out "\n";
	}

    } else {
	print $out "; Counts per sequence and per pattern\n";
	print $out "; SeqID\tPatID\tPattern\tMatches\n";
	foreach $sequence_id (@sequence_ids) {
	    foreach $pattern (@patterns) {
		if ($match_count{$sequence_id}{$pattern} >= $threshold) {
		    print $out join ("\t", "$sequence_id",
				     $pattern->get_attribute("id"),
				     $pattern->get_attribute("sequence"),
				     $match_count{$sequence_id}{$pattern}
				     ), "\n";
		}
	    }
	}
    }
}

################################################################
# top scores
sub TopScores {
    print $out "; Top score per sequence (sliding window)\n";
    print $out "; SeqID\ttop\n";
    if ($sort) {
	@sequence_ids = sort {$top_score{$b} <=> $top_score{$a}} @sequence_ids;
    }
    foreach $sequence_id (@sequence_ids) {
	printf $out  "$sequence_id\t%f\n", $top_score{$sequence_id};
    }
}
