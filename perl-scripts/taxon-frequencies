#!/usr/bin/perl -w
############################################################
#
# $Id: taxon-frequencies,v 1.2 2007/08/06 22:52:14 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

taxon-frequencies

=head1 DESCRIPTION

Calculate taxon-wide oligo and dyad frequencies.

=head1 AUTHORS

jvanheld@scmbb.ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE

taxon-frequencies -taxon my_taxon [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

Oligo and dyad frequency files are loaded from $RSAT genome
directories.

=head1 OUTPUT FORMAT

The output format is a tab-delimited file with one row per pattern
(oligo or dyad).

By default, the output file contains 4 columns:

=over

=item pattern sequence

=item pattern ID

For single-strand frequencies, the ID is simply the pattern
sequence. For two-strand frequencies, the pattern ID includes the
direct sequence + its reverse complement, separated by a pipe
character.

=item frequency

Taxon-wide frequency of the pattern.

=item occurrences

Taxon-wide occurrences of the pattern in the considered sequence type
(upstream, upstream-noorf, intergenic).

=item organism-specific occurrences

When the option -occ_per_org is active, the program exports one
additional column per organism, indicating the organism-specific
number of occurrences of each pattern.

=item organism-specific frequencies

When the option -freq_per_org is active, the program exports one
additional column per organism, indicating the organism-specific
frequency of each pattern.

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";



################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();

    local $taxon = "";
    local %outfile = ();
    local %infile = ();

    local $verbose = 0;
    local $out = STDOUT;

    local $pattern_type = "oligo";
    local $oligo_length = 0;
    local $monad_length = 3;
    local $dyad_spacing = "0-20";
    local $background_model = "upstream-noorf";
    local $str = "-1str";
    local $sum_rc = 0;
    local $noov="-noov"; ## Supported= -noov, -ovlp
    local $occ_col = 4; ## Column containing pattern occurrences in the frequency files

    local %sum_per_pattern = ();
    local %occ_sum_per_organism = ();
    local %freq_sum_per_organism = ();
    local %pattern_freq;
    local $pattern_freq_sum = 0;
    local $total_occ = 0;

    local $occ_per_org = 0;
    local $freq_per_org = 0;
    local @organisms = ();

    local $decimals = 13; ## Decimals for printing frequencies

    #### background models
    %supported_bg = ('upstream'=>1,
		     'upstream-noorf'=>1,
		     'intergenic'=>1,
		     'upstream-rm'=>1,
		     'upstream-noorf-rm'=>1
		    );

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values

    ## Check taxon and collect organisms
    @organisms = &CheckTaxon($taxon);

    ## Strands
    if ($str eq "-1str") {
      $sum_rc = 0;
    } elsif ($str eq "-2str") {
      $sum_rc = 1;
    } else {
      &RSAT::error::FatalError($str, "Invalid value for the strands. Supported= -1str, -2str.");
    }

    ################################################################
    ## Open output stream
    $out = &OpenOutputFile($outfile{output});

    ################################################################
    ## Read background pattern frequencies
    foreach my $org (@organisms) {
      if ($pattern_type eq "oligo") {
	$infile{$org} = &ExpectedFreqFile($org, $oligo_length, $background_model,
						    noov=>$noov, str=>$str);
      } elsif  ($pattern_type eq "dyad") {
      } else {
	&RSAT::error::FatalError($pattern_type, "is not a valid pattern type. Supported: oligo,dyad");
      }

      ## Count occurrences for each frequency file
      &RSAT::message::TimeWarn("Loading pattern occurrences for organism", $org, $infile{$org}) if ($main::verbose >= 2);
      my ($in) = &OpenInputFile($infile{$org});
      my $l = 0;
      while (<$in>) {
	$l++;
	next if (/^--/); ## Skip comment lines
	next if (/^;/); ## Skip comment lines
	next if (/^#/); ## Skip header line
	next unless (/\S/); ## Skip empty lines
	my @fields = split /\s+/;
	my $pattern_seq = $fields[0];
	my $pattern_id = $fields[1];
	my $occ = $fields[$occ_col -1];
	&RSAT::error::FatalError($occ, "Invalid value for occurrences. Should be a Natural number", $infile{$org}, "line", $l) unless (&IsNatural($occ));

	$pattern_occ{$pattern_seq}{$org} = $occ;
	$sum_per_pattern{$pattern_seq} += $occ;
	$occ_sum_per_organism{$org} += $occ;
	if (defined($pattern_id{$pattern_seq})) {
	  if ($pattern_id{$pattern_seq} ne $pattern_id) {
	    &RSAT::error::FatalError("Inconsistency betwen pattern identifiers", $infile{$org}, $pattern_id, $pattern_id{$pattern_seq});
	  }
	} else {
	  $pattern_id{$pattern_seq} = $pattern_id;
	}
      }
      close $in if ($infile{input});
    }

    ################################################################
    ## Compute total pattern occurrences
    foreach my $pattern_seq (keys %sum_per_pattern) {
      $total_occ += $sum_per_pattern{$pattern_seq};
    }
    foreach my $pattern_seq (sort keys %pattern_id) {
      $pattern_freq{$pattern_seq} = $sum_per_pattern{$pattern_seq}/$total_occ;
      $pattern_freq_sum += $pattern_freq{$pattern_seq};
    }
    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);


    ################################################################
    ## Print output


    ## Define output fields
    my @out_fields =  ("seq", "pattern_id", "frequency", "occ");
    $field_descr{seq} = "pattern sequence";
    $field_descr{pattern_id} = "pattern identifier";
    $field_descr{frequency} = "taxon-wide patter, frequency";
    $field_descr{occ} = "taxon-wide occurrences";

    if ($main::occ_per_org) {
      foreach my $org (@organisms) {
	my $field = "N.".$org;
	push @out_fields, $field;
	$field_descr{$field} = "occurrences\t".$org;
      }
    }
    if ($main::freq_per_org) {
      foreach my $org (@organisms) {
	my $field = "F.".$org;
	push @out_fields, $field;
	$field_descr{$field} = "frequencies\t".$org;
      }
    }

    ## Print column content
    if ($main::verbose >= 1) {
      print $out "; Column content\n";
      my $c = 0;
      foreach my $field (@out_fields) {
	$c++;
	print $out join ("\t", ";", $c, $field, $field_descr{$field}), "\n";
      }
    }

    ## Print header
    print $out "#", join( "\t", @out_fields), "\n";

    ## Print pattern occurrences
    foreach my $pattern_seq (sort keys %pattern_id) {
      print $out join( "\t", 
		       $pattern_seq,
		       $pattern_id{$pattern_seq},
		       sprintf("%.${decimals}f", $pattern_freq{$pattern_seq}),
		       $sum_per_pattern{$pattern_seq},
		     );

      ## Print organism-specific occurrences
      if ($occ_per_org) {
	foreach my $org (@organisms) {
	  print $out "\t", $pattern_occ{$pattern_seq}{$org} || 0;
	}
      }

      ## Print organism-specific frequencies
      if ($freq_per_org) {
	foreach my $org (@organisms) {
	  my $freq = 0;
	  if ((defined($pattern_occ{$pattern_seq}{$org})) 
	      && (defined($occ_sum_per_organism{$org}))
	      && ($occ_sum_per_organism{$org} > 0)
	     ) {
	    $freq = $pattern_occ{$pattern_seq}{$org}/$occ_sum_per_organism{$org}
	  } else {
	    $freq = 0;
	  }
	  $freq_sum_per_organism{$org} += $freq;
	  printf $out "\t%.${decimals}f", $freq;
	}
      }
      print $out "\n";
    }

    ################################################################
    ## print totals per column
    if ($main::verbose >= 1) {
      my @totals = ("total","total",sprintf("%.${decimals}f", $pattern_freq_sum),$total_occ);
      if ($occ_per_org) {
	foreach my $org (@organisms) {
	  push @totals, $occ_sum_per_organism{$org} || 0;
	}
      }
      if ($freq_per_org) {
	foreach my $org (@organisms) {
	  push @totals, sprintf("%.${decimals}f", $freq_sum_per_organism{$org});
	}
      }
      print $out ";", join( "\t", @totals), "\n";
    }

    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $out "; Job started $start_time\n";
	print $out "; Job done    $done_time\n";
    }

    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});

    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Taxon
=pod

=item B<-taxon taxon>

Specify the taxon for which frequencies have to be computed.

=cut
	} elsif ($arg eq "-taxon") {
	    $main::taxon = shift(@arguments);

	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);

	    ### Background model
=pod

=item B<-bg background_model>

Specify a background model for expected frequencies.

  Supported: upstream-noord, upstream, intergenic
  Default: upstream-noorf

=cut
	} elsif ($arg eq "-bg") {
	    $background_model = shift (@arguments);
	    $background_model =~ s/ncf/intergenic/;
	    $background_model =~ s/input/bernoulli/;
	    unless ($supported_bg{$background_model}) {
		&RSAT::error::FatalError("Invalid background model\t$background_model\tsupported: $supported_bg");
	    }

	    #### strands
=pod

=item B<-2str>

Collect frequenies computed on both strands.

=item B<-1str>

Collect frequenies computed on a single strand.

=cut
	} elsif ($arg eq "-1str") {
	  $str = "-1str";
	} elsif ($arg eq "-2str") {
	  $str = "-2str";

	  ## Overlap
=pod

=item B<-ovlp>

Do not allow mutual overlap between successive occurrences of
self-overlaping patterns (e.g. TATATA).

=item B<-ovlp>

Allow mutual overlap between successive occurrences of self-overlaping
patterns (e.g. TATATA).

=cut
	} elsif ($arg eq "-ovlp") {
	  $noov = "-ovlp";
	} elsif ($arg eq "-noov") {
	  $noov = "-noov";


	  ## Oligonucleotide length
=pod

=item B<-ol #>

Oligonucleotide length.

This option is only valid when pattern type is set to 'oligo'.

=cut

	  ## Monad length
=pod

=item B<-ml #>

Monad length for the dyads.

This option is only valid when pattern type is set to 'dyad'.

=cut

	  ### oligo-analysis parameters
	} elsif ($arg eq "-ol") {
	  $oligo_length = shift @arguments;

	  ## Return occurrences per organism
=pod

=item B<-occ_per_org>

Return additional columns with the organism-specific pattern
occurrences (one column per organism).

=cut
        } elsif ($arg eq "-occ_per_org") {
	  $main::occ_per_org = 1;

	  ## Return frequencies per organism
=pod

=item B<-freq_per_org>

Retun additional columns with the organism-specific pattern
frequencies (one column per organism).

=cut
        } elsif ($arg eq "-freq_per_org") {
	  $main::freq_per_org = 1;

	  ## Decimals for printing frequencies
=pod

=item B<-decimals #>

Number of decimal for printing frequencies (default 13)

=cut
        } elsif ($arg eq "-decimals") {
	  $main::decimals = shift(@arguments);
	  &RSAT::error::FatalError($main::decimals, "Invalid value for decimals. Must be a Natural number") 
	    unless (&IsNatural($main::decimals));

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; taxon-frequencies ";
    &PrintArguments($main::out);

    ## Compute the length of the largest organism name
    my $org_len = 20; ## Length of the string or printing organism names
    foreach my $org (@organisms) {
      if (length($org) > $org_len) {
	$org_len = length($org);
      }
    }

    ## Print the list of input files
    print $out "; Input files\n";
    my $i = 0;
    foreach my $org (@organisms) {
      $i++;
      print $out join ("\t", ";",
		       sprintf("%-${org_len}s", $org),
		       $infile{$org},
		      ), "\n";
    }

    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=cut
