#!/usr/bin/perl -w
############################################################
#
# $Id: retrieve-snp-seq,v 1.10 2013/03/26 11:07:18 jeremy Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

retrieve-snp-seq

=head1 VERSION

$program_version

=head1 DESCRIPTION

Retrieve snp and haplotype sequences for a set of coordinates
specified in a bed-formatted file.

=head1 AUTHORS

jeremy.delerce@univ-amu.fr

=head1 CATEGORY

=over

=item util

=back

=head1 USAGE

retrieve-snp-seq -i bedfile -len # [-species #] [-population #] [-o outputfile] [-v#] [...]

=head2 Example

 retrieve-snp-seq -v 1 \
   -i $RSAT/public_html/demo_files/sample_regions_for_variations_hg19.bed \
   -species human \
   -population 1000GENOMES:phase_1_ALL \
   -len 30 \
   -o variations.tab

=head1 INPUT FORMAT

=head2 Example of bed file:


=head2 Format specification

The definition of the BED format is provided on the UCSC Genome
Browser web site (http://genome.ucsc.edu/FAQ/FAQformat#format1).

The first three required fields are:

=over

=item 1. chrom

The name of the chromosome (e.g. chr3, chrY, chr2_random).

=item 2. chromStart

The starting position of the feature in the chromosome or
scaffold. The first base in a chromosome is numbered 0.

B<Note> from Jacques van Helden: the UCSC genome browser adopts a
somewhat inconsistent convention for start and end coordinates: the
start position is zero-based (first nucleotide of a
chromosome/scaffold has coordinate 0), but the end position is
considered not included in the selection. This is equivalent to have a
zero-based coordinate for the start, and a 1-base coordinate for the
end.

=item 3. chromEnd

The ending position of the feature in the chromosome or scaffold. The
chromEnd base is not included in the display of the feature. For
example, the first 100 bases of a chromosome are defined as
chromStart=0, chromEnd=100, and span the bases numbered 0-99.

=back

=head1 OUTPUT FORMAT

A tab delimited file with the following column content.

=over

=item 1. chrom

The name of the chromosome (e.g. 1, X, 8...)

=item 2. chromStart

The starting position of the feature in the chromosome

=item 3. chromEnd

The ending position of the feature in the chromosome

=item 4. chromStrand

The strand of the feature in the chromosome

=item 5. snp

rsID, variant and position on which the sequence is center. All information
are separate by a '-'.

=item 6. NeighboorsSnp

rsID, variant and position of all snp present in the sequence except the
center snp. All neighboors snp are separate by a "/".

=item 7. sequence

=item 8. number

The numer of time that this sequence is observed in the population

=back

=head1 SEE ALSO

=head1 WISH LIST

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
    push (@INC, "/jolidisk/software/rsa-tools/perl-scripts/lib");
}

require "RSA.lib";
use Bio::EnsEMBL::Registry; ##require to connect to Ensembl API

################################################################
## Main package
package	main;
{

    ###############################################################
    ## Initialise parameters
    our $start_time = &RSAT::util::StartScript();
    our $program_version = do { my @r = (q$Revision: 1.10 $ =~ /\d+/g); sprintf"%d."."%02d" x $#r, @r };

    our %infile	= ();
    our %outfile = ();

    our $verbose = 0;
    our $in = STDIN;
    our $out = STDOUT;

    our $species = 'Homo_sapiens';
    our $population = '1000GENOMES:phase_1_ALL';
    our $want_pop = 0;
    our $want_pop_1k =0;
    our $want_pop_hap =0;
    our $len ='';

    our $marge = 50; #in case of indel on extremity of slice
    our @output_lines = ();

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values

    my @species_l = qx($ENV{'RSAT'}/perl-scripts/supported-organisms-ensembl);
    unless ( grep($_ eq $species."\n", @species_l ) ) {
	&RSAT::error::FatalError("$species not avalaible on ensembl\n\tUse : supported-organisms-ensembl to get all avalaible species");
    }

    if ( ($want_pop_1k || $want_pop_hap) && $species ne "Homo_sapiens") {
        &RSAT::error::FatalError("-pop1k and -popHap only avalaible for Homo_sapiens");
    }

    unless ($want_pop || $want_pop_1k || $want_pop_hap) { 
	if ($species ne 'Homo_sapiens' && $population eq '1000GENOMES:phase_1_ALL') {
	    &RSAT::error::FatalError("Population is mandatory if species different of Homo_sapiens");
	}
	
	unless ($len) {
	    &RSAT::error::FatalError("Length of flank of the sequence must be specified with option -length");
	}

	unless (&IsNatural($len)) {
	    &RSAT::error::FatalError("Length must be a int");
	}
    }

    ################################################################
    ## Open a connection to Ensembl
    &RSAT::message::TimeWarn("Connection to Ensembl") if ($main::verbose >= 2);

    my $registry = 'Bio::EnsEMBL::Registry';
    $registry->load_registry_from_db(
        -host => 'ensembldb.ensembl.org',
        -user => 'anonymous'
        );

    ##Get adaptor
    my $slice_adaptor = $registry->get_adaptor($species, 'core', 'slice');
    my $vf_adaptor = $registry->get_adaptor($species, 'variation','variationfeature');
    my $population_adaptor = $registry->get_adaptor($species, 'variation', 'population');
    my $individual_adaptor = $registry->get_adaptor($species,'variation','individual');

    ##Print all population
    if ($want_pop) {
        foreach my $population (@{$population_adaptor->fetch_all()}) {
	    print $population->name(),"\n";
	}
	exit(1);
    }

    if ($want_pop_1k) {
        foreach my $population (@{$population_adaptor->fetch_all_1KG_Populations()}) {
            print $population->name(),"\n";
        }
        exit(1);
    }

    if ($want_pop_hap) {
        foreach my $population (@{$population_adaptor->fetch_all_HapMap_Populations()}) {
            print $population->name(),"\n";
        }
        exit(1);
    }


    ##Check argument BIS
    unless ( scalar(@{$population_adaptor->fetch_all_by_name_search($population)}) == 1) {
	&RSAT::error::FatalError("$population don't exist in $species");
    }

    ################################################################
    ## Open output stream
    $out = &OpenOutputFile($outfile{output});

    ################################################################
    ## Download input from remote URL
    if ($main::infile{input_url}) {
	&RSAT::message::TimeWarn("Transferring input file from URL", $main::infile{input_url}) if ($main::verbose >= 2);
	use LWP::Simple;

	if (defined($outfile{output})) {
	    $main::outfile{input} = $main::outfile{output};
	    $main::outfile{input} =~ s/\.fasta$//;
	    $main::outfile{input} =~ s/\.fa$//;

	    ## Add extension to the input file, in order to recognize compressed files
	    if ($main::infile{input_url} =~ /\.(\w+)$/) {
		my $extension = $1;
		$main::outfile{input} .= ".".$extension;
	    } else {
		$main::outfile{input} .= ".bed";
	    }

	} else {
	    $main::outfile{input} = &RSAT::util::make_temp_file("", "test");
	    &RSAT::message::Info("Storing downloaded input file as", $main::outfile{input}) if ($main::verbose >= 3);
	}

	getstore($main::infile{input_url}, $main::outfile{input});
	&RSAT::message::TimeWarn("Genomic coordinates transferred to local file", $main::outfile{input}) if ($main::verbose >= 2);
	($main::in) = &OpenInputFile($main::outfile{input});

    } else {
	($main::in) = &OpenInputFile($main::infile{input});
    }

    ################################################################
    ## Read input
    &RSAT::message::TimeWarn("Reading genomic coordinates") if ($main::verbose >= 2);
    
    my @slices = ();
    my %chr_length = ();
    
    ($main::in) = &OpenInputFile($main::infile{input});
    while (<$main::in>) {
	next if (/^#/); ## Skip comment lines
	next if (/^;/); ## Skip RSAT-like comment lines
	next unless (/\S/); ## Skip empty lines
	next unless (/\t/); ## Skip lines containing no tab (likely to be starting comment lines)
	chomp();

	################################################################
	## BEWARE: in bed format the left limit is zero-based. However the
	## DAS server expects 1-based coordinates. We convert here the
	## zero-based into 1-based coordinate.
	my ($chrom, $zero_left, $right) = split(/\t/);
	$left = $zero_left + 1;

	&RSAT::message::Debug($chrom, $left, $right) if ($main::verbose >= 5);

	##Removing "chr" in front of chr name
	if ( $chrom =~ /chr/) {
	    $chrom = substr($chrom,3);
	}

	##Get length of chrom and chr name
	unless ($chr_length{$chrom}) {
	    my @slices = @{ $slice_adaptor->fetch_all('chromosome') };

	    foreach my $slice (@slices) {
		my $chr = $slice->seq_region_name();
		$chr_length{$chr}{'start'} = $slice->start();
		$chr_length{$chr}{'end'} = $slice->end();
	    }
	}

	## Check that the left is smaller than the right
	if ($left > $right) {
	    my $tmp = $left;
	    $left = $right;
	    $right = $tmp;
	}

        ##Remove wrong line
        unless ( $chr_length{$chrom} && $chr_length{$chrom}{'start'} <= $left && $chr_length{$chrom}{'end'} >= $right) {
            &RSAT::message::Warning( "Wrong coordinate : $_") if ($main::verbose >= 1);
	    next;
	}

	##Slice is bigger than the region of interest to getting neighboors variation
	push(@slices, $slice_adaptor->fetch_by_region('chromosome',$chrom,$left-($len+$marge),$right+($len+$marge) ) );

    }
    close $main::in if ($main::infile{input});

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose >= 1);

    ################################################################
    ## Execute the command
    my $i = 0;
    my $nb_slice = scalar(@slices);

    foreach my $slice (@slices)  {
	$i++;

	##Search all variation in $slice
	my @vfs = @{ $vf_adaptor->fetch_all_by_Slice($slice) };

	##Search all individu name in $population
	my $pop = $population_adaptor->fetch_by_name($population);
	my $individuals = $individual_adaptor->fetch_all_by_Population($pop);

	my %population_individual = ();
	foreach my $individual (@{$individuals}) {
	    $population_individual{$individual->name()} = ();
	}

	##Search haplotype and get info on variation of interst
	my @vfs_good = ();
	my %variation_info = ();
	my $pos_diff = 0;

	foreach my $vf ( @vfs ) {

	    ##Remove non-analizable Variation feature
            ## !!!!!!!! $vf-get_all_validation_states class at Risk and remove all indel but remove problem of 2 variations with same coordinate
            if ( $vf->variation()->is_failed()
                     || $vf->allele_string() =~ /[^ACTG\-\/]/
                     || ($vf->start() > $vf->end() && $vf->ref_allele_string() ne "-")
#                     || scalar(@{$vf->get_all_validation_states()}) == 0 ) {
		){
                next;
            }

	    my $igs = $vf->variation()->get_all_IndividualGenotypes();
	    my $variation_name = $vf->variation_name();
	    my @list_variants = ();

	    foreach my $individual_genotype (@{$igs}) {

		my $individual_name = $individual_genotype->individual()->name();

                if ( grep($_ eq $individual_name, keys(%population_individual) ) ) {

		    $variant1 = $individual_genotype->allele(1);
		    $population_individual{$individual_name}{$variation_name}{'allele1'} = $variant1;

		    unless ( grep($_ eq $variant1 , @list_variants ) ) {
			push (@list_variants,$variant1 );
		    }

		    next if (  ( $slice->seq_region_name() eq "X" && $individual_genotype->individual()->gender() eq "Male") || $slice->seq_region_name() eq "Y");

		    $variant2 = $individual_genotype->allele(2);
		    $population_individual{$individual_name}{$variation_name}{'allele2'} = $variant2;

		    unless ( grep($_ eq $variant2 , @list_variants ) ) {
			push (@list_variants,$variant2 );
		    }
		}
	    }

	    ##Only keep variations with more than 1 variant in $population
	    next unless ( scalar (@list_variants) > 1);
	    
	    push (@vfs_good,$vf);
	    $variation_name = $vf->variation_name();

	    ## Get max length of variant
	    $variation_info{$variation_name}{'len_max_var'} = 0;
	    foreach my $variant (@list_variants ) {
		if ($variation_info{$variation_name}{'len_max_var'} < length($variant)) {
		    $variation_info{$variation_name}{'len_max_var'} = length($variant);
		}
	    }

	    ##Get length of ref variant
	    $variation_info{$variation_name}{'len_ref_var'} = length($vf->ref_allele_string());

	    ##Get change in position foreach $vf
	    $variation_info{$variation_name}{'diff_pos'} = $pos_diff;
	    
	    if ( $variation_info{$variation_name}{'len_max_var'} != length($vf->ref_allele_string()) ) {
		$pos_diff += $variation_info{$variation_name}{'len_max_var'}-length($vf->ref_allele_string());
	    }

	    if ( $vf->ref_allele_string() eq "-" ) {
		$variation_info{$variation_name}{'len_ref_var'} = 0;
		$pos_diff++;
	    }
	}

	if ( scalar(@vfs_good) == 0) {
	    &RSAT::message::TimeWarn("Slice $i/".$nb_slice."\t".$slice->seq_region_name().":".$slice->start()."-".$slice->end()."\tNo variation found") if ($main::verbose >= 2);
	    next;
	} else {
	    &RSAT::message::TimeWarn("Slice $i/".$nb_slice."\t".$slice->seq_region_name().":".$slice->start()."-".$slice->end()."\t".scalar(@vfs_good)." variation(s) found") if ($main::verbose >= 2);
	}


	##"Create" haplotype sequence
	my %pop_alleles = ();
	my $ref_allele = $slice->seq();

	foreach my $individual ( keys(%population_individual)) {
	    my $allele1=$ref_allele;
	    my $allele2=$ref_allele;
	    my $two_alleles = 0;

	    foreach my $vf ( @vfs_good ) {
		my $variation_name = $vf->variation_name();
		my %vf_inf = %{$variation_info{$variation_name}};
		my %genotype = %{$population_individual{$individual}{$variation_name}};

		$allele1 = substr($allele1,0,$vf->start()-1+$vf_inf{'diff_pos'}).$genotype{'allele1'}."-"x($vf_inf{'len_max_var'}-length($genotype{'allele1'})).substr( $allele1,$vf->end()+$vf_inf{'diff_pos'} );

		if ($genotype{'allele2'}) {
		    $two_alleles = 1;
		    $allele2 = substr($allele2,0,$vf->start()-1+$vf_inf{'diff_pos'}).$genotype{'allele2'}."-"x($vf_inf{'len_max_var'}-length($genotype{'allele2'})).substr( $allele2,$vf->end()+$vf_inf{'diff_pos'} );
		}

	    }

	    unless ( $pop_alleles{$allele1} ) {
		$pop_alleles{$allele1} = 0;
	    }
	    $pop_alleles{$allele1} ++;

	    if ($two_alleles) {
		unless ($pop_alleles{$allele2}) {
		    $pop_alleles{$allele2} = 0;
		}
		$pop_alleles{$allele2} ++;
	    }

	}

	##Selected region of interest on each haplotype sequence
	foreach my $vf (@vfs_good)  {

	    next unless ( $vf->start() > $len+$marge && $vf->end() < $slice->length()-$len-$marge );

	    ##Get all alleles center on $vf
	    my %var_alleles =();
	    my %vf_inf = %{$variation_info{$vf->variation_name()}};
	    

	    foreach my $allele (keys(%pop_alleles) ) {
		my @indel = ();

		##Get $len-1+nb_indel nucleotide in the 5' sequence
		my $five_prime_nb_indel = 0;
		
		while (1) {
		    $five_prime_seq = substr($allele, $vf->start()-$len+$vf_inf{'diff_pos'}-$five_prime_nb_indel, $len-1+$five_prime_nb_indel );
		    @indel = $five_prime_seq =~/\-/g;
		    $five_prime_nb_indel = scalar(@indel);

		    last if ( length($five_prime_seq) - $five_prime_nb_indel == $len-1 );
		}

		##Get $len-1+$len_max_var+$nb_indel in variant and 3' sequence
		@indel = ();
		
		while (1) {
		    $variant_three_prime_seq = substr($allele, $vf->start()-1+$vf_inf{'diff_pos'}, $len-1+$vf_inf{'len_max_var'}+scalar(@indel) );
		    @indel = $variant_three_prime_seq =~/\-/g;
		    
		    last if ( length($variant_three_prime_seq)- ( $vf_inf{'len_max_var'}+scalar(@indel)) == $len-1 );
		}

		my $centred_allele = $five_prime_seq.$variant_three_prime_seq;

		if ( $var_alleles{$centred_allele} ) {
		    $var_alleles{$centred_allele}{'count'} += $pop_alleles{$allele};
		} else {
		    $var_alleles{$centred_allele}{'count'} = $pop_alleles{$allele};
		    $var_alleles{$centred_allele}{'five_prime_nb_indel'} = $five_prime_nb_indel;
		    $var_alleles{$centred_allele}{'five_prime_seq_len'} = length($five_prime_seq);
		    $var_alleles{$centred_allele}{'three_prime_seq_len'} = length($variant_three_prime_seq)-$vf_inf{'len_max_var'};
		}
	    }
	    
	    ##Make output line
	    my $variation_chr = $vf->seq_region_name();
	    
	    my $variation_strand = "+";
	    unless ($vf->seq_region_strand()) {
		$variation_strand = "-";
	    }
	    
	    foreach my $centred_allele ( keys(%var_alleles) ) {
		
		my $line = "$variation_chr\t".($vf->seq_region_start()-$var_alleles{$centred_allele}{'five_prime_seq_len'})."\t";
		$line .= ($vf->seq_region_end()+$var_alleles{$centred_allele}{'three_prime_seq_len'})."\t$variation_strand\t"; #chromo start end strand
		$line .= $vf->variation_name()."/".substr($centred_allele , $len-1+$var_alleles{$centred_allele}{'five_prime_nb_indel'}, $vf_inf{'len_max_var'} )."/".$len."\t"; #rsID/variant/pos
		
		my $co_var_str = ",";
		foreach my $co_vf (@vfs_good) {
		    
		    next unless ( $co_vf->end() >= $vf->start()-$var_alleles{$centred_allele}{'five_prime_seq_len'} && $co_vf->start() <= $vf->end()+$var_alleles{$centred_allele}{'three_prime_seq_len'} && $co_vf->variation_name() ne $vf->variation_name());
		    my %co_vf_inf = %{$variation_info{$co_vf->variation_name()}};
		    $co_var_str .= $co_vf->variation_name."/";

		    ##get nb_nucleotide between $co_vf and $vf
		    my $pos = 0;
		    my $co_variant_pos = 0;
			
		    if ($co_vf->start() > $vf->start()) {
			$pos = $co_vf->start()-$vf->end();

			##If co_var and var are insertion
			if ($vf->ref_allele_string() eq "-" && $co_vf->ref_allele_string() eq "-") {
			    $co_variant_pos =-1;
			}

		    } else {
			$pos = $co_vf->end()-$vf->start();

			##If co_var and var are insertion
			if ($vf->ref_allele_string() eq "-" && $co_vf->ref_allele_string() eq "-") {
			    $co_variant_pos =+1;
			}
		    }

		    ##get position of the co_vatiarion in the centred allele
		    $co_variant_pos += $len-1; ##length of five prime seq
		    $co_variant_pos += $pos; ##distance between variations
		    $co_variant_pos += $co_vf_inf{'diff_pos'}-$vf_inf{'diff_pos'}; ##change in position du to insertion
		    $co_variant_pos += $vf_inf{'len_ref_var'}-$co_vf_inf{'len_ref_var'}; ##change in position du to deletion
		    $co_variant_pos += $var_alleles{$centred_allele}{'five_prime_nb_indel'};

		    my $co_var_len = $co_vf_inf{'len_max_var'};

		    ##Change position et length of co_var if only a part of a co-variation is present
		    if ( $co_variant_pos < 0) {
			$co_var_len += $co_variant_pos;
			$co_variant_pos = 0;
		    } elsif ( $co_variant_pos+$co_var_len > length($centred_allele)) {
			$co_var_len -= $co_variant_pos+$co_var_len-length($centred_allele);
		    }

		    $co_var_str .= substr($centred_allele , $co_variant_pos,$co_var_len)."/";
		    $co_var_str .= $pos.",";
		}

		$line .= substr($co_var_str,1,length($co_var_str)-2)."\t";

		my $count = $var_alleles{$centred_allele}{'count'};
		$centred_allele =~ tr/\-//d;
		$line .= "$centred_allele\t$count\n"; ##allele count
		push (@output_lines,$line);
	    }
	}

    }

    ################################################################
    ## Insert here output printing
    print $out "#chr\tstart\tend\tstrand\tvar\tco-var\tseq\tcount\n";
    foreach my $output_line (@output_lines) {
	print $out $output_line;
    }

    ################################################################
    ## Report execution time and close output stream
    my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
    print $out $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified
    close $out if ($outfile{output});

    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################

################################################################
## Display full help message
sub PrintHelp {
    system "pod2text -c $0";
exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
	$arg = shift (@arguments);
## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
if ($arg eq "-v") {
    if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
    } else {
	$main::verbose = 1;
    }

=pod

=item B<-h>

Display full help message

=cut
} elsif ($arg eq "-h") {
    &PrintHelp();

=pod

=item B<-help>

Same as -h

=cut
} elsif ($arg eq "-help") {
    &PrintOptions();

=pod

=item B<-i inputfile>

The input file should be in bed format (see section INPUT FORMATS
above).

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

This option is mutually exclusive with option I<-u>.

=cut
} elsif ($arg eq "-i") {
    &RSAT::error::FatalError("Options -i and -u are mutually exclusive") if ($main::infile{input_url});
    $main::infile{input} = shift(@arguments);

=pod

=item B<-u input_file_URL>

Use as input a file available on a remote Web server (e.g. a bed file
on your Galaxy account).

This option is mutually exclusive with option I<-i>.

=cut
} elsif ($arg eq "-u") {
    &RSAT::error::FatalError("Options -i and -u are mutually exclusive") if ($main::infile{input});
    $main::infile{input_url} = shift(@arguments);

=pod

=item B<-species species_name>

Species (e.g. "Homo_sapiens","mus_musculus").

Default: "Homo_sapiens".

Help : Use supported-organisms-ensembl to get all avalaible species

=cut
} elsif ($arg eq "-species") {
    $main::species = ucfirst(shift(@arguments));

=pod

=item B<-population population_name>

Population name on ensembl data base (e.g. '1000GENOMES:phase_1_YRI').

Default : 1000GENOMES:phase_1_ALL

Help : Use retrieve-snp-seq -species # -pop to get all avalaible population for this species.

=cut
} elsif ($arg eq "-population") {
    $main::population = shift(@arguments);

=pod

=item B<-pop | -pop1k | -popHap>

Get all population avalaible for a species.

Get all 1000 populations.

Get all HapMap populations.

=cut
} elsif ($arg eq "-pop") {
    $main::want_pop = 1;
} elsif ($arg eq "-pop1k") {
    $main::want_pop_1k = 1;
} elsif ($arg eq "-popHap") {
    $main::want_pop_hap = 1;
=pod

=item B<-len int>

Length of flank of the sequence.

The total length of the sequence return is equal to 
(flank length-1)*2 + snp length

This option is mandatory.

=cut
} elsif ($arg eq "-len") {
    $main::len = shift(@arguments);

=pod

=item B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
} elsif ($arg eq "-o") {
    $outfile{output} = shift(@arguments);

} else {
    &FatalError(join("\t", "Invalid option", $arg));

}
    }

=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
    print $out "; retrieve-snp-seq ";
    &PrintArguments($out);
    printf $out "; %-22s\t%s\n", "Program version", $program_version;
    if (%main::infile) {
	print $out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    printf $out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    if (%main::outfile) {
	print $out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    printf $out ";\t%-13s\t%s\n", $key, $value;
	}
    }

    print $out ";  column headers\n";
    print $out ";  \t1\tchr\tChromosome id (ex 1, X, 12)\n";
    print $out ";  \t2\tstart\tStarting position of the sequence\n";
    print $out ";  \t3\tend\tEnding position of the sequence\n";
    print $out ";  \t4\tstrand\tStrand of the sequence\n";
    print $out ";  \t5\tvar\trsID, variant, position on the center of sequence. Information are separate by / \n";
    print $out ";  \t6\tco-var\trsID, variant, position of all variations present in sequence. Information are separate by '/', Co-variation are separate by ',' \n";
    print $out ";  \t7\tseq\tsequence\n";
    print $out ";  \t8\tcount\tNumber of time that this sequence is observed\n";
}

__END__
