#!/usr/bin/perl
############################################################
#
# $Id: multiple-family-analysis,v 1.22 2002/09/14 15:45:39 jvanheld Exp $
#
# Time-stamp: <2002-09-14 10:45:29 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
  push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.cgi.lib";
require "RSA.classes";

###read parameters
if ($#ARGV < 0) {
  die ("Usage : multiple-family-analysis -org organism -fam family_file \n", 
       "\t[-noup] [-nocalc] [-nosynt] [-v]\n");
}


#### initialisations	    
@supported_tasks = qw (upstream oligos dyads synthesis clean all);
foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
}
$supported_tasks = join ",", @supported_tasks;
$noorf = 0;
$default{from} = -800;
$default{to} = 0;
$known_site_file = "known-consensus";
$known_sites_provided = 0;
$background = "upstream-noorf";
$seq_format = "fasta";
$min_oligo_length = 6;
$max_oligo_length = 6;
$min_matching_score = 4;
$monad_length = 3;
$noov = 1;
$min_sp = 0;
$max_sp = 20;
$start_date = `date`;
$maps=1;

&ReadArguments();

&CheckParameters;

### read gene name and identifiers
warn "; Reading ORF information ...\n" 
    if ($verbose);
&ReadOrfPositions($organism_name);
&ReadSynonyms($organism_name);


################################################################
#
# read data
&ReadKnownSites();
&ReadSiteLibrary();
&ReadFamilies();

#### verbose
if ($verbose >= 1) {
    print "; multiple-family-analysis ";
    &PrintArguments($out);
    printf "; families     \t%d\n", $#families + 1;
    foreach $family (@families) {
	printf ";\t%s\n", $family;
    }
    printf "; family file\t%s\n", $family_file;
    printf "; upstream region\n";
    printf ";\t%-22s\t%d\n", "strands", $strands;
    printf ";\t%-22s\t%d\n", "from", $from;
    printf ";\t%-22s\t%d\n", "to", $to;
    printf ";\t%-22s\t%d\n", "size", $size;
    printf "; oligo-analysis\n";
    printf ";\t%-22s\t%d\n", "max oligo length", $max_oligo_length;
    printf ";\t%-22s\t%d\n", "min oligo length", $min_oligo_length;
    printf "; dyad-analysis\n";
    printf ";\t%-22s\t%d\n", "monad length", $monad_length;
    printf ";\t%-22s\t%d\n", "min spacing", $min_sp;
    printf ";\t%-22s\t%d\n", "max spacing", $max_sp;
    printf ";\t%-22s\t%s\n", "dyad type", $dyad_type;
    printf ";\t%-22s\t%g\n", "sig threshold", $th;
    printf ";%-13s\t%s\n", "background model", $background;
    printf ";%-13s\t%s\n", "organism", $organism_name;
    print "; no overlap with upstream ORFs" if ($noorf);
}


### write composition of the families in the separated directories
&SetFileNames();

### initialize one directory for each family
foreach $family_name(@families) {
  $dir = "${family_name}/";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }
  open FAM, ">$family{$family_name}->{family_file}" ||
      die "Error: cannot write family file $family{$family_name}->{family_file}\n";
  foreach $id (@{$family{$family_name}->{members}}) {
    print FAM "$id\t$name{$id}\n";
    
  }
  close FAM;
}

### perform analysis
&AnalyzeFamilies();
&SyntheticTable if ($task{synthesis});

#### report execution time 
if ($verbose) {
  $done_date = `date`;
  print ";Job started\t$start_date";
  print ";Job done\t", `date`;
}
exit(0);


################################################################
#
#                 SUBROUTINE DEFINITION
#
################################################################

#### set the file names as a function of parameters
sub SetFileNames {
  $sp = "$min_sp-$max_sp";
  $dyad_options = "-v ";
  $dyad_options .= " -sort ";
  $dyad_options .= " -${strands} ";
  $dyad_options .= " -type $dyad_type ";
  $dyad_options .= " -noov " if ($noov);
  $dyad_options .= " -l $monad_length ";
  $dyad_options .= " -thosig $th ";
  $dyad_options .= " -sp $sp ";
  
  $dyad_suffix = "_dyads";
  $dyad_suffix .= "_l${monad_length}";
  $dyad_suffix .= "_sp${sp}";
  $dyad_suffix .= "_${strands}";
  $dyad_suffix .= "_${type}";
  $dyad_suffix .= "_sig${th}";
  if ($noov) {
    $dyad_suffix .= "_noov";
  } else {
    $dyad_suffix .= "_ov";
  }

  #### expected frequency model
  if ($exp_freq_file{dyads}) {
    $dyad_options .= " -expfreq $exp_freq_file{dyads}";
  } elsif ($background eq "intergenic") {
    $dyad_options .= " -ncf ";
    $dyad_options .= " -org $organism_name ";
    $dyad_suffix .= "_ncf";
  } elsif ($background eq "mncf") {
    $dyad_options .= " -mncf ";
    $dyad_options .= " -org $organism_name ";
    $dyad_suffix .= "_mncf";
  }

  $noorf_string = "_noorf" if ($noorf);
  $noov_string = "_noov" if ($noov);
  foreach my $family_name (@families) {
      $family{$family_name}->{family_file} = "$family_name/${family_name}.fam";
      $family{$family_name}->{known_site_file} = "$family_name/${family_name}_known_sites";
      $family{$family_name}->{file_prefix} = "${family_name}_up${seq_length}${noorf_string}"; 
      $family{$family_name}->{seq_file} = $family_name."/".$family{$family_name}->{file_prefix}.".${seq_format}";
      $family{$family_name}->{seq_file_purged} = $family_name."/".$family{$family_name}->{file_prefix}."_purged.${seq_format}";
      
      $family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}."_oligos_${min_oligo_length}-${max_oligo_length}nt_${strands}_sig${th}${noov_string}";
      $family{$family_name}->{oligo_assembly_file} = $family{$family_name}->{oligo_file}."_contigs";
      $family{$family_name}->{oligo_ft_file} = $family{$family_name}->{oligo_file}.".ft";
      
      $family{$family_name}->{dyad_file} = "$family_name/dyads_${family_name}/".$family{$family_name}->{file_prefix}.$dyad_suffix;
      $family{$family_name}->{dyad_assembly_file} = $family{$family_name}->{dyad_file}."_contigs";
      $family{$family_name}->{dyad_ft_file} = $family{$family_name}->{dyad_file}.".ft";
      $family{$family_name}->{fmap_file} = $family{$family_name}->{dyad_file}.".gif";
      $family{$family_name}->{htmap_file} = $family{$family_name}->{dyad_file}.".html";
  }  

  $table_suffix = $family_file."_up_".$from."_".$to.$noorf_string.$noov_string;
  $table_suffix = `basename $table_suffix`;
  chomp $table_suffix;
}

################### SUBROUTINE DEFINITION ###################"



#### retrieve upstream sequences
sub UpstreamSequences {
  warn ";\tGenerating upstream sequences for family $family_name\n" if ($verbose >= 1);
  $command = "retrieve-seq -type upstream -org $organism_name";
  $command .= " -noorf " if ($noorf);
  $command .= " -i $family{$family_name}->{family_file}";
  $command .= " -o $family{$family_name}->{seq_file}";
  $command .= " -from $from -to $to ";
  $command .= " -label orf_gene ";
  $command .= " -format $seq_format";
  &doit($command);

  $command = "purge-sequence -ml 40 -mis 3";
  $command .= " -i $family{$family_name}->{seq_file}";
  $command .= " > $family{$family_name}->{seq_file_purged}";
  &doit($command);
}



### oligo-analysis
sub OligoAnalysis {
    warn join ("\t", 
	       ";\tAnalyzing oligonucleotides for family $family_name",
	       "min len: $min_oligo_length",
	       "max len: $max_oligo_length"), "\n" if ($verbose >= 1);
    $dir = "${family_name}/oligos_${family_name}";
    unless (-d $dir) {
	mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
    }
    die "Error : cannot read file $family{$family_name}->{seq_file_purged}\n" unless (-r $family{$family_name}->{seq_file_purged});
    
    
    system "echo '' > $family{$family_name}->{oligo_file}" if ($verbose >=1);
    
    for $oligo_length ($min_oligo_length..$max_oligo_length) {
	$oligo_options = "-v ";
	$oligo_options .= "-pseudo $pseudo " if ($pseudo);
	$oligo_options .= "-sort ";
	$oligo_options .= "-${strands} ";
	$oligo_options .= "-l $oligo_length ";
	$oligo_options .= "-thosig $th ";
	if ($exp_freq_file{oligos}) {
	    $oligo_options .= "-expfreq $exp_freq_file{oligos} ";
	} else {
	    $oligo_options .= "-org $organism_name ";
	    $oligo_options .= "-bg $background ";
	}
	$oligo_options .= "-return occ,proba,mseq,rank ";
	$oligo_options .= "-noov " if ($noov);
	
	$oligo_suffix = "_oligos";
	$oligo_suffix .= "_${oligo_length}nt";
	$oligo_suffix .= "_${strands}";
	$oligo_suffix .= "_sig${th}";
	$oligo_suffix .= "_noov" if ($noov);
	
	$oligo_file = "$family_name/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix;    
	$command = "oligo-analysis -i $family{$family_name}->{seq_file_purged} -format $seq_format -o $oligo_file $oligo_options";
	
	&doit($command);
	system "cat $oligo_file | grep -v ';' >> $family{$family_name}->{oligo_file}";
    }
    
    ### fragment assembly
    $fmap_file = $family{$family_name}->{oligo_file}.".gif";
    $htmap_file = $family{$family_name}->{oligo_file}.".html";
    
    $command = "pattern-assembly -i $family{$family_name}->{oligo_file} -sc 8 -${strands} -v -o $family{$family_name}->{oligo_assembly_file} -maxfl 1 -maxpat 200 ";
    
    &doit($command);
    

    if ($maps) {
	### feature-map for oligo-analysis
	die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
#    $origin = -$from + 1;
	$origin = "-0";
	$command = "dna-pattern -i $family{$family_name}->{seq_file} -format $seq_format -pl $family{$family_name}->{oligo_file} -origin $origin -sc 8 -N 4 ";
	$command .= " | features-from-dnapat -o $family{$family_name}->{oligo_ft_file} ";
	$command .= " ; feature-map -i $family{$family_name}->{oligo_ft_file} -scalebar -scalestep 50 -legend -from $from -to $to -o $fmap_file -scorethick -htmap > $htmap_file ";
	
	&doit($command);
    }
}

### dyad analysis
sub DyadAnalysis {
    warn join( "\t", 
	       ";\tAnalyzing dyads for family $family_name",
	       "monad length: $monad_length",
	       "min_sp: $min_sp",
	       "max_sp: $max_sp",
	       ), "\n" if ($verbose >= 1);
    $dir = "${family_name}/dyads_${family_name}";
    unless (-d $dir) {
	mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
    }
    die "Error : cannot read file $family{$family_name}->{seq_file_purged}\n" unless (-r $family{$family_name}->{seq_file_purged});
    $command = "dyad-analysis -return occ,proba,rank -i $family{$family_name}->{seq_file_purged} -format $seq_format -o $family{$family_name}->{dyad_file} $dyad_options";
    
    &doit($command);
    
    ### fragment assembly
    $command = "pattern-assembly -v -i $family{$family_name}->{dyad_file} -o $family{$family_name}->{dyad_assembly_file} -$strands -maxfl 2 -sc 8 -maxpat 200 ";
    
    &doit($command);
    
    ### feature-maps
    die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
    &DrawFeatureMaps if ($maps);
}

### read known known_site for each family
sub ReadKnownSites {
    %known_site = ();
    %known_site_source = ();
    if (-e $known_site_file) {
	$known_sites_provided = 1;
	open KNOWN_SITE, $known_site_file;
	while (<KNOWN_SITE>) {
	    next if (/^;/);
	    next if (/^\#/);
	    next unless (/\S/);
	    chomp;
	    @fields = split "\t";
	    $family_name = $fields[0];
	    $source = $fields[2];
	    $known_site = uc($fields[1]);
	    #$known_site = uc(&compress_pattern($known_site,"n"));
	    $known_site =~ s/N/n/g;
	    push @{$known_site{$family_name}}, $known_site;
	    push @{$known_site_source{$family_name}}, $source;
	}
	close KNOWN_SITE;
    }
}

sub ReadSiteLibrary {
  @site_library = ();
  $library_file = "known_sites.tab";
  if (-e $library_file) {
    open LIBRARY, $library_file;
    while (<LIBRARY>) {
	next if (/^;/);
	next if (/^\#/);
	next unless (/\S/);
	chomp;
	my @fields = split "\t";
	my $source = $fields[2] || $library_file;
	my $id = uc($fields[1]);
	my $sequence = uc($fields[0]);
	$sequence =~ s/N/n/g;
	
	$pattern = RSA::pattern->new(id=>$id,
				     sequence=>$sequence,
				     source=>source);
	push @site_library, $pattern;
    }
    close LIBRARY;
  }
}


################################################################
### build a synthetic table ###
sub SyntheticTable {
    warn "; Generating synthetic table $table_file\n" if ($verbose);
    $dir = "synthetic_tables";
    
    $table_file = $dir."/".$table_suffix;
    $table_file .= "_tr" if ($transpose);
    
    unless (-d $dir) {
	mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
    }
    
    ### synthesize the results of all families into a single file
    
    ### headers
    $row = 0;
    $row{f} = $row++;
    $row{family} = $row++;
    $row{size} = $row++;
    $row{genes} = $row++;
    $row{known} = $row++ if ($known_sites_provided);
    $row{oligo} = $row++;
    $row{dyad} = $row++;
    $row_num = $row-1;
    while (($header,$row) = each %row) {
	$table[$row][0] = "<B>$header</B>";
    }
    my $col = 0;
    foreach $family_name (@families) {
	$col++;
	
	### check directory
	$dir = "${family_name}/dyads_${family_name}";
	unless (-d $dir) {
	    &Warning ("Cannot find directory $dir\n");
	}
	
	### family number
	$table[$row{f}][$col] = "<B>$col</B>";
	
	### family name
	$table[$row{family}][$col] = "<B><a href='../$family_name'>$family_name</a></B>";
	
	#### number of genes
	$table[$row{size}][$col] = scalar(@{$family{$family_name}->{members}});

	### list of genes
	$table[$row{genes}][$col] = "<a href='../".$family{$family_name}->{family_file}."'>";
	$table[$row{genes}][$col] .= join " ", @{$family{$family_name}->{members}};
	$table[$row{genes}][$col] .= "</a>";
	
	### known patterns
	if ($known_sites_provided) {
	    $table[$row{known}][$col] = "";
	    for $c (0..$#{$known_site{$family_name}}) {
		$table[$row{known}][$col] .= ${known_site{$family_name}}[$c];
		$table[$row{known}][$col] .= "<BR>(".${known_site_source{$family_name}}[$c].")" if (${known_site_source{$family_name}}[$c]);
		$table[$row{known}][$col] .= "<P>";
	    }
	} 
	
	#### oligo-analysis
	open OLIGOS, "$family{$family_name}->{oligo_assembly_file}";
	$map_link = "<A HREF=../$family{$family_name}->{oligo_file}.html>\n";
	warn ";\tExtracting info from\t$family{$family_name}->{oligo_assembly_file}\n" if ($verbose >= 2);
	undef @patterns;
	undef @sorted_patterns;
	undef %rc;
	undef %score;
	undef %type;
	while (<OLIGOS>) {
	    chomp;
	    next if (/^;/);
	    next if (/^\#/);
	    next unless (/\S/);
	    if ((/contig/) || (/consensus/) || (/isol/)) {
		@fields = split "\t";
		my $sequence = uc($fields[0]);
		$pattern = new RSA::pattern(sequence=>$sequence);
		push @patterns, $pattern;
		$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
		$score{$pattern} = $fields[2];
		$type{$pattern} = $fields[3];
		$max_score{$family} = &max($max_score{$family}, $score{$pattern});
	    }
	}
	@sorted_patterns = sort { $score{$b} <=> $score{$a} } @patterns;
	$table[$row{oligo}][$col] = "<TABLE>\n";
	$table[$row{oligo}][$col] .= "<TR>\n";
	
	### print oligo sequence
	$table[$row{oligo}][$col] .= "<TD>\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= uc($sorted_patterns[$p]->get_attribute("sequence")); 
	    $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{oligo}][$col] .= "</TD>\n";
	
	### print reverse complementary oligo
	$table[$row{oligo}][$col] .= "<TD>\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= uc($rc{$sorted_patterns[$p]});
	    $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{oligo}][$col] .= "</TD>\n";
	
	### print oligo score
	$table[$row{oligo}][$col] .= "<TD>$map_link\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "$score{$sorted_patterns[$p]}";
	    $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{oligo}][$col] .= "</A></TD>\n";
	
	### print matching patterns
	if ($known_sites_provided) {
	    $table[$row{oligo}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		my @matches = ();
		foreach $site (@site_library) {
		    if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
			($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
			#my $match = $site->get_attribute("sequence");
			my $match = $site->get_id();
			push @matches, $match;
		    }
		}
		$table[$row{oligo}][$col] .= join(";",@matches);
		$table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{oligo}][$col] .= "</TD>\n";
	}
	
	$table[$row{oligo}][$col] .= "</TR>\n";
	$table[$row{oligo}][$col] .= "</TABLE>\n";
	close OLIGOS;
	
	### dyad analysis
	open DYADS, "$family{$family_name}->{dyad_assembly_file}";
	$map_link = "<A HREF=../$family{$family_name}->{dyad_file}.html>\n";
	warn ";\tExtracting info from\t$family{$family_name}->{dyad_assembly_file}\n" if ($verbose >= 2);
	undef @patterns;
	undef @sorted_patterns;
	undef %rc;
	undef %score;
	undef %type;
	while (<DYADS>) {
	    chomp;
	    next if (/^;/);
	    next if (/^\#/);
	    next unless (/\S/);
	    if ((/contig/) || (/consensus/) || (/isol/)) {
		@fields = split "\t";
		my $sequence = $fields[0];
		$pattern = new RSA::pattern(sequence=>$sequence);
		push @patterns, $pattern;
		$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
		$score{$pattern} = $fields[2];
		$type{$pattern} = $fields[3];
	    }
	}
	@sorted_patterns = sort {$score{$b} <=> $score{$a}} @patterns;
	$table[$row{dyad}][$col] = "<TABLE>\n";
	$table[$row{dyad}][$col] .= "<TR>\n";
	
	### print dyad sequence
	$table[$row{dyad}][$col] .= "<TD>\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $sequence = $sorted_patterns[$p]->get_attribute("sequence");
	    $compressed = uc(&compress_pattern($sequence, "n"));
	    $compressed =~ s/N/n/g;
	    $table[$row{dyad}][$col] .= $compressed;
	    $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{dyad}][$col] .= "</TD>\n";
	
	### reverse complementary dyad
	$table[$row{dyad}][$col] .= "<TD>\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $compressed = uc(&compress_pattern($rc{$sorted_patterns[$p]},"n"));
	    $compressed =~ s/N/n/g;
	    $table[$row{dyad}][$col] .= $compressed;
	    $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{dyad}][$col] .= "</TD>\n";
	
	### dyad scores
	$table[$row{dyad}][$col] .= "<TD>$map_link\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "$score{$sorted_patterns[$p]}";
	    $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{dyad}][$col] .= "</A></TD>\n";
	
	### print matching patterns
	if ($known_sites_providde) {
	    $table[$row{dyad}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		my @matches = ();
		foreach $site (@site_library) {
		    if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
			($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
			#my $match = $site->get_attribute("sequence");
			my $match = $site->get_id();
			push @matches, $match;
		    }
		} 
		$table[$row{dyad}][$col] .= join(";",@matches);
		$table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{dyad}][$col] .= "</TD>\n";
	}
	
	$table[$row{dyad}][$col] .= "</TR>\n";
	$table[$row{dyad}][$col] .= "</TABLE>\n";
	close DYADS;
    }
    
    open TABLE, "> ${table_file}.html" 
	|| die "Error: cannot write file $table_file\n";
    print TABLE "<HTML><BODY>\n";
    print TABLE "<H1>$table_file</H1>\n";
    
    print TABLE "<TABLE BORDER=1>\n";

    @sorted_families = sort {$max_score{$a} <=> $max_score{$b}} @families;
    
    if ($transpose) {
	foreach $r (0..$row_num) {
	    print TABLE "<TR>\n";
	    foreach $c (0..$col) {
		print TABLE "<TD>", $table[$r][$c], "</TD>\n";
	    }
	    print TABLE "</TR>\n";
	}
    } else {
	foreach $c (0..$col) {
	    print TABLE "<TR>\n";
	    foreach $r (0..$row_num) {
		print TABLE "<TD>", $table[$r][$c], "</TD>\n";
	    }
	    print TABLE "</TR>\n";
	}
    }
    
    print TABLE "</TABLE>\n";
    print TABLE "<HR>", &AlphaDate;
    print TABLE "</BODY>\n";
    print TABLE "</HTML>\n";
    close TABLE;
    chdir "synthetic_tables";
#  system "html_dir.csh > index.html";
    chdir "../";
}


################################################################
#### draw feature maps
sub DrawFeatureMaps {
##  $origin = -$from + 1;
    $origin = "-0";
    $command = "dna-pattern -pl $family{$family_name}->{dyad_file} -format $seq_format -i $family{$family_name}->{seq_file}  -sc 8 -origin $origin -N 4 ";
    $command .= "| features-from-dnapat -o $family{$family_name}->{dyad_ft_file} ";
    $command .= "; feature-map -i $family{$family_name}->{dyad_ft_file} -o $family{$family_name}->{fmap_file} ";;
    $command .= "-from $from -to $to ";
    $command .= "-legend ";
    $command .= "-scalebar -scalestep 50 ";
    $command .= "-scorethick ";
    $command .= "-mlen 520 ";
    $command .= "-title '${family_name}$dyad_suffix' ";
    $command .= "-htmap >  $family{$family_name}->{htmap_file}";
    #  $command .= " ;  xv -o $family{$family_name}->{fmap_file} &";

    &doit($command);
}


############################### check parameters ###############################
sub CheckParameters {
    #### check selected tasks
    unless (defined(%task)) {
	&FatalError("You should select at least one task.");
    }
    if ($task{all}) {
	foreach my $t (@supported_tasks) {
	    $task{$t} = 1;
	}
    }
    
    ### family file ###
    if ($family_file eq "") {
	die "Error: you should specify a family file\n";  
    } 
    
    ### organism ###
    if ($organism_name eq "") {
	die "Error: you should specify an organism\n$supported_organisms\n";  
    } 
    unless ($supported_organism{$organism_name}) {
	die ("Error: organism $organism_name is not supported\n",
	     "Supported organisms:\n$supported_organisms\n");
    }
    $from = $default{from} unless defined($from);
    $to = $default{to} unless defined($to);
    $seq_length = abs($to - $from) + 1;
    $dyad_type = "any" unless ($dyad_type);

    if (defined($force{strands})) {
	$strands = $force{strands}; ### force
    } else {
	$strands = "2str";
    }
    if (defined($force{exp})) {
	$exp = $force{exp}; ### force
    }
    if (&IsReal($force{th})) {
	$th = $force{th}; ### force
    } elsif ($#families > 0) {
	$th = &round(10*abs(log($#families + 1)/log(10)))/10;
    } else {
	$th = 0;
    } 
}

    
sub AnalyzeFamilies {
    my $fam_count=0;
    my $fam_nb = $#families+1;
    foreach $family_name (@families) {
	$fam_count++;
	warn ";\n; Treating family $family_name ($fam_count of $fam_nb)\t", `date` if ($verbose >=1);
	
	### retrieve upstream sequences
	&UpstreamSequences if ($task{upstream});
	
	### oligo-analysis
	&OligoAnalysis if ($task{oligos});
	
	### dyad analysis
	&DyadAnalysis if ($task{dyads});
	
	### delete upstream sequence file
	if ($task{clean}) {
	    warn ";\tCleaning files from the hard drive for family $family_name\n" if ($verbose >=1);
	    foreach my $file ($family{$family_name}->{seq_file},
			      $family{$family_name}->{seq_file_purged},
			      $family{$family_name}->{oligo_ft_file},
			      $family{$family_name}->{dyad_ft_file}
			      ) {
		warn ";\t\t$file\n" if ($verbose >=1);
		system "rm -f $file" ;
	    }
	}
	
    }
}

sub doit {
    my ($command) = @_;
    print "\n$command\n" if ($verbose >=2);
    system $command unless $dry_run;
}


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	multiple-family-analysis

        1999 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        multiple-family-analysis [-i inputfile] [-o outputfile] [-v]

DESCRIPTION
	Runs a combination of programs in order to discover significant
	patterns in the upstream regions of several gene families.

	This script is a way to auto;atize the systematic analysis of
	multiple clusters of co-regulated genes, such as those
	obtained with DNA chip experiments.

	The program reads the composition of several families in a
	single text file, then executes different program discovery
	programs, and generates a summary report.

	Results are subdifided in directories created on the fly, one
	directory per family plus one summary directory.
	
CATEGORY
	sequences
	pattern discovery

OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-i	family file
	-org	organism
	-from	upstream region left limit
	-to	upstream region right limit
	-1str   strand-sensitive analysis
	-2str   strand-insensitive analysis
	-maxol	maximum oligonucleotide length
	-minol	minimum oligonucleotide length
	-monad  monad length for dyad-analysis
	-minsp	maximum spacing for dyad-analysis
	-maxsp	maximum spacing for dyad-analysis
	-task selected_task
		Select the tasks to be performed.
		Supported tasks: $supported_tasks

		Can be used iteratively on the same command line to 
		select multiple tasks.  

		Example:
		    -task upstream -task oligos -task synthesis
		For a full analysis, simply type 
		    -task all
	-dyad_exp_freq
		name of a file containing the expected frequencies for
		dyad-analysis.
	-oligo_exp_freq
		name of a file containing the expected frequencies for
		oligo-analysis.
	-noorf	exclude upstream ORFs from upstream sequences
	-noov	prevent overlapping matches for self-overlapping patterms
		(default)
	-ovlp	allow overlapping matches for self-overlapping patterms
	-pseudo	pseudo-weight (see oligo-analysis manual)
	-nomap	do not draw feature maps (for saving time and hard disk space)

FILE FORMAT
    FAMILY FILE
	The family file specifies the co;position of several gene families.
	It is a text file containing 2 tab-separated columns.
	col 1:	gene name (or ID)
	col 2: family name
	
	Lines starting with a semicolumn (;) are ignored, allowing to
	document the family files with comments..
	
	Example
		; genes responding to Phosphate stress
		pho5	PHO
		pho8	PHO
		; genes responding to nitrogen starvation
		DAL5    NIT
		GAP1    NIT
		...
HOW TO PROCEED
    1) create a directory for the set of families

    2) witin this directory, create a text file contaning the
       description of family composition, as described above
    
    3) run the command

       multiple-family-analysis -org organism -i family_file \
           -v -from -200 -to 49 -task all

    4) With a web browser (e.g. Netscape), open the folder
       'synthetic_tables'. There should be a HTML file with the name
       of your family ile as prefix, and the suffix indicating the
       other analysis parameters. Open this file and analyze the
       result.

End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
multiple-family-analysis options
--------------------------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-v		verbose
-vv 		hyperverbose
-i		family file
-org		organism
-from		upstream region left limit
-to		upstream region right limit
-1str   	strand-sensitive analysis
-2str   	strand-insensitive analysis
-maxol		maximum oligonucleotide length
-minol		minimum oligonucleotide length
-monad		monad length for dyad-analysis
-minsp		maximum spacing for dyad-analysis
-maxsp		maximum spacing for dyad-analysis
-n      	dry run: print commands without executing them
-exp		expected frequency file
-transp		transpose synthetic result table (columns become rows)
-task		selected task (supported: $supported_tasks)
-dyad_exp_freq	expected frequencies for dyad-analysis
-oligo_exp_freq	expected frequencies for oligo-analysis
-noorf		exclude upstream ORFs from upstream sequences
-noov		prevent overlapping matches for self-overlapping patterms
-ovlp		allow overlapping matches for self-overlapping patterms
-pseudo		pseudo-weight (see oligo-analysis manual)
-nomap		do not draw feature maps (for saving time and hard disk space)
End_short_help
  close HELP;
  exit;
}


sub ReadArguments {
#### read arguments ####
    foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    $verbose = 1;
	} elsif ($ARGV[$a] eq "-vv") {
	    $verbose = 2;
	    
	    #### dry run
	} elsif ($ARGV[$a] eq "-n") {
	    $dry_run = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions;
	    
	    ### family file
	} elsif (($ARGV[$a] eq "-i") ||
		 ($ARGV[$a] eq "-fam") # for compatibility with previous versions
		 ) {
	    $family_file = $ARGV[$a+1];

	    ### upstream sequence lmits
	} elsif (($ARGV[$a] eq "-from") &&
		 (&IsInteger($ARGV[$a+1]))) {
	    $from = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-to") &&
		 (&IsInteger($ARGV[$a+1]))){
	    $to = $ARGV[$a+1];

	    ### strands 
	} elsif ($ARGV[$a] eq "-1str") {
	    $force{strands} = "1str";
	} elsif ($ARGV[$a] eq "-2str") {
	    $force{strands} = "2str";

	    ### oligo-analysis parameters
	} elsif ($ARGV[$a] eq "-minol") {
	    $min_oligo_length = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-maxol") {
	    $max_oligo_length = $ARGV[$a+1];;
	    
	    ### dyad-analysis parameters
	} elsif ($ARGV[$a] eq "-monad") {
	    $monad_length = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-minsp") {
	    $min_sp = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-maxsp") {
	    $max_sp = $ARGV[$a+1];;

	    ### organism
	} elsif ($ARGV[$a] eq "-org") {
	    $organism_name = $ARGV[$a+1];


	    #### task selection
	} elsif ($ARGV[$a] eq "-task") {
	    my @requested_tasks = split ",", $ARGV[$a+1];
	    foreach my $task (@requested_tasks) {
		next unless $task;
#	    $task = $ARGV[$a+1];
		if ($supported_task{$task}) {
		    $task{$task} = 1;
		} else {
		    &FatalError("Unsupported task '$task'. \n\tSupported: $supported_tasks");
		}
	    }

	    #### transpose synthetic table
	} elsif ($ARGV[$a] =~ /^-transp/) {
	    $transpose = 1;

	    #### clip upstream ORFs fom upstream regions
	} elsif ($ARGV[$a] =~ /^-noorf/) {
	    $noorf = 1;

	    #### threshold
	} elsif ($ARGV[$a] =~ /^-th/) {
	    $force{th} = $ARGV[$a+1];

	    #### dyad type
	} elsif ($ARGV[$a] =~ /^-type/) {
	    $force{type} = $ARGV[$a+1];

	    #### expected frequency file for dyad-analysis 
	} elsif ($ARGV[$a] =~ /^-dyad_exp_freq/) {
	    $exp_freq_file{dyads} = $ARGV[$a+1];

	    #### expected frequency file for oligo-analysis 
	} elsif ($ARGV[$a] =~ /^-oligo_exp_freq/) {
	    $exp_freq_file{oligos} = $ARGV[$a+1];


	    #### background model for expected frequency. 
	    #### Supported: "upstream", "upstam-noorf", "intergenic", "mncf"
	} elsif (($ARGV[$a] =~ /^-exp/) 
		 || ($ARGV[$a] =~ /^-bg/)) {
	    $background = $ARGV[$a+1];
	    $background =~ s/^ncf$/intergenic/;
	    
	    #### prevent self-overlap
	} elsif ($ARGV[$a] eq "-noov") {
	    $noov = 1;

	    #### allow self-overlap
	} elsif ($ARGV[$a] eq "-ovlp") {
	    $noov = 0;

	    #### prevent feature-map drawing
	} elsif ($ARGV[$a] eq "-nomap") {
	    $maps = 0;

	    #### pseudo-weight
	} elsif ($ARGV[$a] =~ /^-pseudo/) {
	    $pseudo = $ARGV[$a+1];
	    unless ((&IsReal($pseudo)) && ($pseudo > 0)) {
		&FatalError("pseudo-weight must be a positive real number");
	    }
	}
    }
}



################################################################
#### read gene families
sub ReadFamilies {
    warn "\n; Reading family file\t$family_file\n" 
	if ($verbose >=1);
    unless (-r $family_file) {
	die "Error : cannot read family file $family_file\n";
    }
    
    open FAM, $family_file || 
	die "Error : cannot read file $family{$family_name}->{family_file}\n" ;
    $line = 0;
    while (<FAM>) {
	$line++;
	next if (/^;/);
	next if (/^\#/);
	next unless (/\S/);
	chomp;
	@fields = split /\s+/;
	
	### family name
#    $family_name = uc($fields[1]);
	$family_name = $fields[1];
	unless ($family_name =~ /\S/) {
	    warn ("Error family file $family_file line $line\t",
	    "family not specified\n");
	    next;
	}
	
	### gene name or ID
	$query = uc($fields[0]);
	unless ($query =~ /\S/) {
	    warn ("Error family file $family_file line $line\t",
		  "gene not specified\n");
	    next;
	}
	
	### identify the gene
	$id = $orf_id{$query};
	if ($id eq "") {
	    &Warning (";\tWARNING ! $query unknown gene name \n");
	} else {
	    push @{$family{$family_name}->{members}}, $id;
	    warn "\t$family_name\t$query\t$id\t$name{$id}\n" 
		if ($verbose >= 2);
	}
	
    }
    close FAM;
    
    @families = sort keys %family;
}

