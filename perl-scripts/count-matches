#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";

## CVS
## - Added proba as return field
## - improved Countmatches (matches between 2 ambiguous codes are supported)
## - improved the output 
## - implemented &BestMatch(), which slides seq2 along seq1 and returns the match with the highest weight
## - added the options -lth and -uth

################################################################
#### initialise parameters
my $start_time = &AlphaDate();

local %infile = ();
local %outfile = ();

local $verbose = 0;
local $in = STDIN;
local $out = STDOUT;
$slide = 0;

## lower and upper thresholds
%lth = ();
%uth = ();
@supported_threshold_fields = qw(
			      match
			      proba
			      weight
			      len1
			      len2
			      mlen
			      tlen
			      offset
			      );
foreach my $field (@supported_threshold_fields) {
    $supported_threshold_field{$field} = 1;
}
$supported_threshold_fields = join (",", @supported_threshold_fields);


#### initialise parameters ####
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;
@supported_return_fields = qw(
			      match
			      proba
			      weight
			      seq
			      length
			      offset
			      );
foreach my $field (@supported_return_fields) {
    $supported_return_field{$field} = 1;
}
$supported_return_fields = join (",", @supported_return_fields);

my %field_format = (match=>"%d",
		    weight=>"%.2f",
		    proba=>"%.2g",
		    seq1=>"%s",
		    seq2=>"%s",		
		    len1=>"%d",
		    len2=>"%d",
		    mlen=>"%d",
		    tlen=>"%d",
		    offset=>"%g",
   );

&ReadArguments();

################################################################
## Check arguments

## return fields
if (scalar(@return_fields) < 1) {
    @return_fields = ("match");
}

my @temp_return_fields = @return_fields;
@return_fields = (); ## Ordered list of fields to return. 
%return_field = ();  ## Index for the fields to return.
foreach my $field (@temp_return_fields) {
    &FatalError("$field\tInvalid return field. Supported: $supported_return_fields\n") unless $supported_return_field{$field};

    $return_field{$field}++;

#    warn "; Adding field\t", $field, "\n" if ($verbose >= 5);
    if ($field eq "seq") {
	push @return_fields, "seq1", "seq2";
    } elsif ($field eq "length") {
	push @return_fields, "len1", "len2", "mlen", "tlen";
    } else {
	push @return_fields, $field;
    }
}

## Check input sequences
&FatalError("You must specify at least one first sequence") unless (scalar(@seq1) > 0);
&FatalError("You must specify at least one second sequence") unless (scalar(@seq2) > 0);


################################################################
### open output stream
$out = &OpenOutputFile($outfile{output});

################################################################
#### print verbose
&Verbose() if ($verbose >= 1);

## Print header
if ($verbose >= 1) {
    print $out ";", join ("\t", @return_fields), "\n";
}

## Count matches for each pair of input sequences	
foreach $seq1 (@seq1) {
    foreach $seq2 (@seq2) {
	local @result = ();
	local $match;
	local $weight;
	local $proba;
	local $offset;
	local $len1;
	local $len2;
	local $mlen;
	local $tlen;

	## Check input sequences
	&FatalError("You must specify a first sequence") unless ($seq1);
	&FatalError("You must specify a second sequence") unless ($seq2);
	
	################################################################
	## Count the matches
	if ($slide) {
	    ($match, $weight, $proba, $mlen, $offset) = &BestMatch($seq1,$seq2);
	} else {
	    ($match, $weight, $proba, $mlen) = &CountMatches($seq1,$seq2);
	}
	if ($return_field{length}) {
	    $len1 = length($seq1);
	    $len2 = length($seq2);
	    $tlen = $len1 + $len2 - $mlen; ## total length of the alignment
	}
 	
	################################################################
	## Print the result for this comparison
	my $to_print = 1;
	foreach my $field (@return_fields) {
	    my $result = $$field;

	    ## Check thresholds on this field
	    if ((defined($lth{$field})) && ($result < $lth{$field})) {
		$to_print = 0;
		last
	    }
	    if ((defined($uth{$field})) && ($result > $uth{$field})) {
		$to_print = 0;
		last
	    }

	    ## Format the field
	    push @result, sprintf $field_format{$field}, $result;
	    warn join "\t", ";", $field, $result, "\n" if ($verbose >= 3);
	}
	if ($to_print) {
	    print $out join ("\t", @result), "\n";
	}
    }
}

exit(0);

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
	count-matches

AUTHOR
	Jacques van Helden (jacques\@scmbb.ulb.ac.be)

USAGE
	count-matches seq1 seq2

DESCRIPTION
	Count matching positions between two sequences provided as
	command line arguments.

CATEGORY
	util
	sequences

OPTIONS
	-h	display full help message
	-help   (must be first argument) display options
	-v	verbose
	-seq1	first sequence for the comparison

	-seq2	second sequence for the comparison
		-seq1 and -seq2 can be used iteratively to specify
		multiple patterns. Each sequence of group 1 is then
		compared t each sequence of group 2.

	-return	return fields
		Each selected field is returned in a separate column.
		Supported: $supported_return_fields

        -uth field #
                upper threshold value for a given field
                Supported_fields: $supported_thresold_fields

        -lth field #
                lower threshold value for a given field
                (same fields as -uth)

	-slide	find best match by sliding seq2 along seq1
		When this option is used, the best offset is also
		returned. The offset is the number of positions to
		shift seq1 in order to obtain the best scoring
		alignment. Negative values represent a shit of seq2 to
		the left side, positive values ot the right side.

INPUT FORMAT
      seq1 and seq2 must be DNA sequences (not peptidic). 
      IUPAC degenerate code is accepted in seq1 as well as seq2.

OUTPUT FORMAT
       The output consists in a tab-separated text table, with one row
       per pair of sequences, and one column per return field.

RETURN FIELDS
       match	number of matching positions

       proba 	probability to observe a random match. The probability of
                an alignment is the product of probabilities of
                matching pairs of residues.

		If one assumes equiprobable nucleotides, the
		probability of random match is estimated as follows
		for non-ambiguous and ambiguous nucleotides.

	code	nucleotides	proba	mnemonics
	---------------------------------------------------------------
	A			1/4	(Adenine)
	C			1/4	(Cytosine)
	G			1/4	(Guanine)
	T			1/4	(Thymine)
	R	= A or G	1/2	(puRines)
	Y	= C or T	1/2	(pYrimidines)
	W	= A or T	1/2	(Weak hydrogen bonding)
	S	= G or C	1/2	(Strong hydrogen bonding)
	M	= A or C	1/2	(aMino group at common position)
	K	= G or T	1/2	(Keto group at common position)
	H	= A, C or T	3/4	(not G)
	B	= G, C or T	3/4	(not A)
	V	= G, A, C	3/4	(not T)
	D	= G, A or T	3/4	(not C)
	N	= G, A, C or T	1	(aNy)

	weight 	the weight reflects the number of matching positions,
                with a lower weight for matches between partially
                specified nucleotides (IUPAC codes).

		The weight is calculated as
		    -log4(proba)

		For an alignment between non-ambigous nucleotides, the
		weight is maximal, and its value is the number of
		matching residues.

	length	lengths 
		This option returns 4 length values
		     len1   length of sequence 1
		     len2   length of sequence 2
		     mlen   length of the match
		     tlen   total length of the alignment
		     	    tlen = len1 + len2 - mlen

	seq	sequences to be compared

EXAMPLES

	Single pair of sequences
	------------------------
	count-matches -seq1 GATAAT -seq2 GATWAG -return match,weight

	should return the value 5 matches (the degenerate code W
        stands for "T or A") and a weight of 4.5

	Multiple pairs of sequences
	---------------------------

	count-matches -seq1 GATAAG -seq2 GATWAG -seq2 GATAAG \
	    -seq2 GATAAT -seq2 gatha -seq2 gatnns -seq2 NNNNNN \
	    -v 1 -return match,weight,proba,length,seq

        Compares the firsts sequence with each sequence of group 2.
        Notice the difference between the columns match and weight.

	Sliding sequences
	-----------------
	count-matches -v 1 -seq1 gatasg -seq2 twagtt -slide \
	    -return match,weight,proba,seq,length

        Thresholds
	----------
	count-matches -v 1 -seq1 gatasg -seq2 twagtt -seq2 ccccga \
	    -slide -return match,weight,proba,seq,length -lth mlen 3

	This options sets a lower threshold of 3 on matching length.

End_of_help
  close HELP;
  exit;
}

################################################################
#### display short help message
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
count-matches options
----------------
-h		display full help message
-help   	display options
-seq1		first sequence for the comparison
-seq2		second sequence for the comparison
-return		return fields. Supported: $supported_return_fields
-lth            lower threshold on a given field
-uth            upper threshold on a given field
-slide	      	find best match by sliding seq2 along seq1
End_short_help
  close HELP;
  exit;
}


################################################################
#### read arguments 
sub ReadArguments {
    foreach my $a (0..$#ARGV) {
	### verbose  
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp();
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions();
	    
	    ### input file  
	} elsif ($ARGV[$a] eq "-i") {
	    $infile{input} = $ARGV[$a+1];
	    
	    ### output file  
	} elsif ($ARGV[$a] eq "-o") {
	    $outfile{output} = $ARGV[$a+1];
	    
	    ### first sequence  
	} elsif ($ARGV[$a] eq "-seq1") {
	    push @seq1, $ARGV[$a+1];
	    
	    ### second sequence  
	} elsif ($ARGV[$a] eq "-seq2") {
	    push @seq2, $ARGV[$a+1];

	    ### return fields
	} elsif ($ARGV[$a] eq "-return") {
	    push @return_fields, split ",", $ARGV[$a+1];
	    
            #### threshold values
        } elsif ($ARGV[$a] eq "-lth") {
            my $field = $ARGV[$a+1];
            my $value = $ARGV[$a+2];
	    &FatalError("Invalid threshold crierion\t".$field)
		unless ($supported_threshold_field{$field});
            $lth{$field} = $value;
        } elsif ($ARGV[$a] eq "-uth") {
            my $field = $ARGV[$a+1];
            my $value = $ARGV[$a+2];
	    &FatalError("Invalid threshold crierion\t".$field)
		unless ($supported_threshold_field{$field});
            $uth{$field} = $value;

	    ### slide sequences 
	} elsif ($ARGV[$a] eq "-slide") {
	    $slide = 1;
	    
	}
    }
}

################################################################
#### verbose message
sub Verbose {
    print $out "; count-matches ";
    &PrintArguments($out);
    if (defined(%infile)) {
	print $out "; Input files\n";
	while (($key,$value) = each %infile) {
	    print $out ";\t$key\t$value\n";
	}
    }
    if (defined(%outfile)) {
	print $out "; Output files\n";
	while (($key,$value) = each %outfile) {
	    print $out ";\t$key\t$value\n";
	}
    }
}
