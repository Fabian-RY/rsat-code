#!/usr/bin/perl
############################################################
#
# $Id: purge-sequence,v 1.5 2001/09/21 04:32:12 jvanheld Exp $
#
# Time-stamp: <2001-09-21 06:31:16 jvanheld>
#
############################################################
#use strict;;
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";


my $skdir = "$RSA/bin";
#my $skdir = "~jvanheld/applications/stefan_kurtz/virtual.distrib";
#if ($config_site eq "rubens") {
#    $skdir = "/rubens/dsk2/jvanheld/applications/stefan_kurtz/virtual.distrib";
#}

#### initialise parameters ####
my $start_time = &AlphaDate();

local $inputfile = "";
local $outputfile = "";
local $verbose = 0;
local $match_len = 100;
local $mismatches = 3;
local $in_format = "fasta";

&ReadArguments;


#### check argument values ####
### check input format 
&CheckInputSeqFormat($in_format);

if ($inputfile) {
    $basename = `basename ${inputfile}`;
    chomp $basename;
    $dirname = `dirname ${inputfile}`;
    chomp $dirname;
} else {
    $dirname = ".";
    $basename = $start_time;
}

#chdir $dirname;

#unless ($outputfile) {
#    $outputfile = "$dirname/$basemane"."_purged_l${match_len}_m${mismatches}.fasta";
#    $outputfile =~ s/\s//g;
#}


#### verbose ####
#&Verbose if ($verbose);


#### create a temp file to filter out non-conform lines 
#### (comment lines starting with ";")
$tmp_file = "tmp_".$basename;
#&doit("grep -v '^;' $basename > $tmp_file");
#&doit("grep -v '^;' $inputfile > $tmp_file");

$command = "convert-seq -from $in_format -to fasta -dna -o $tmp_file";
$command .= " -i $inputfile" if ($inputfile);
&doit($command);


###### execute the command #########
@extensions = qw(al1 ssp bck bwt des lcp llv prj suf tis sds);
&doit("$skdir/mkvtree -bck -dna -tis -bwt -suf -lcp -pl 8 -db $tmp_file");
my $command = "$skdir/vmatch -s -dbnomatch 1 -l $match_len ";
$command .= " -e $mismatches" if ($mismatches > 0);
$command .= " $tmp_file ";
$command .= " | grep -v '# args=' ";
$command .= "> $outputfile" if ($outputfile);
&doit($command);
foreach $ext  (@extensions) {
    &doit("rm -f ${tmp_file}.${ext}");
}

#### remove the temp file
&doit("rm -f $tmp_file");


###### verbose ######
if ($verbose) {
  my $done_time = &AlphaDate;
  warn "; Job started $start_time\n";
  warn "; Job done    $done_time\n";
}


exit(0);


########################## subroutine definition ############################

sub doit {
    my ($command) = @_;
    warn "\n$command\n" if ($verbose);
    system $command unless $dry_run;
}

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	purge-sequence

        1999 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        purge-sequence [-i inputfile] [-o outputfile] [-v]

DESCRIPTION
	
OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-i inputfile
	        The file containing the sequence to purge.
		If inputfile is not specified, the standard input is
		used.  This allows to place the command within a pipe.
	-format sequence format
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-n	dry run
		print commands without executing them
	-ml #	match length
	-mis #	mismatches
End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
purge-sequence options
----------------
-h	(must be first argument) display full help message
-help	(must be first argument) display options
-i	input file
-o	output file
-v	verbose
-n	dry run
-format sequence format
-ml #	match length
-mis #	mismatches
End_short_help
  close HELP;
  exit;
}


sub ReadArguments {
#### read arguments ####
    foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### dry run
	} elsif ($ARGV[$a] eq "-n") {
	    $dry_run  = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions;
	    
	    ### input file ###
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    
	    ### sequence format
	} elsif ($ARGV[$a] eq "-format") {
	    $in_format = lc($ARGV[$a+1]);
	    
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    
	    ### output file ###
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    
	    ### matching length
	} elsif (($ARGV[$a] eq "-ml") && (&IsInteger($ARGV[$a+1]))) {
	    $match_len = $ARGV[$a+1];
	    
	    ### mismatches
	} elsif (($ARGV[$a] eq "-mis") && (&IsInteger($ARGV[$a+1]))) {
	    $mismatches = $ARGV[$a+1];
	    
	}
    }
}

