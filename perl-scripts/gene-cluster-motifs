#!/usr/bin/perl
############################################################
#
# $Id: gene-cluster-motifs,v 1.33 2003/06/15 22:36:37 jvanheld Exp $
#
# Time-stamp: <2003-06-16 00:31:11 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
  push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.help.pl";
require "RSA.cgi.lib";
require "RSA.classes";



#### initialisations	    
@supported_tasks = qw (upstream oligos maps dyads synthesis sql clean all);
foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
}
$supported_tasks = join ",", @supported_tasks;


%supported_sort_key = (
			"score"=>1,
			"name"=>1
			);
$supported_sort_keys  = join ",", sort keys %supported_sort_key;

%supported_background = (
			"intergenic"=>1,
			"upstream"=>1,
			"upstream-noorf"=>1
			);
$supported_background  = join ",", sort keys %supported_background;

$scalestep = 100;
$noorf = 1;
#$default{from} = -800;
#$default{to} = 0;
$known_site_file = "known-consensus";
$known_sites_provided = 0;
$background = "upstream-noorf";
$seq_format = "fasta";
$min_oligo_length = 6;
$max_oligo_length = 6;
$min_matching_score = 4;
$monad_length = 3;
$noov = 1;
$min_sp = 0;
$max_sp = 20;
$start_date = `date`;
$no_map=0;
$sort_key = "score";
$verbose = 0;

#### data export options
%supported_dbms = (mysql=>1,
		   oracle=>1,
		   postgresql=>1);
$supported_dbms = join ",", @supported_dbms;
$dbms = "mysql";
$schema = "multifam";


&ReadArguments();

&CheckParameters();

### read gene name and identifiers
warn "; Reading ORF information ...\n" 
    if ($verbose >= 1);
&ReadOrfPositions($organism_name);
&ReadSynonyms($organism_name);


################################################################
#
# read data
&ReadKnownSites($known_site_file);
&ReadSiteLibrary();
%family = &ReadFamilies($family_file, 1);
@families = sort keys %family;

### write composition of the families in the separated directories
&SetFileNames();

&CheckOutputDirectory();

&MakeDirectories();

#### verbose
$verbose_message = &Verbose() if ($verbose >= 1);

### perform analysis
&AnalyzeFamilies();
&SyntheticTable() if ($task{synthesis});
&ExportSQL() if ($task{sql});

#### report execution time 
if ($verbose >= 1) {
  $done_date = `date`;
  print ";Job started\t$start_date";
  print ";Job done\t", `date`;
}
exit(0);


################################################################
#
#                 SUBROUTINE DEFINITION
#
################################################################

#### set the file names as a function of parameters
sub SetFileNames {
    $sp = "$min_sp-$max_sp";
    $dyad_options = "-v ";
    $dyad_options .= " -sort ";
    $dyad_options .= " -${strands} ";
    $dyad_options .= " -type $dyad_type ";
    $dyad_options .= " -noov " if ($noov);
    $dyad_options .= " -l $monad_length ";
    $dyad_options .= " -thosig $th ";
    $dyad_options .= " -sp $sp ";
    
    $dyad_suffix = "_dyads";
    if ($markov) {
	$dyad_suffix .= "_monad"; ### TEMP
    } elsif ($background) {
	$dyad_suffix .= "_bg_${background}"; ### TEMP
    }
    $dyad_suffix .= "_l${monad_length}";
    $dyad_suffix .= "_sp${sp}";
    $dyad_suffix .= "_${strands}";
    $dyad_suffix .= "_${dyad_type}";
    $dyad_suffix .= "_sig${th}";
    if ($noov) {
	$dyad_suffix .= "_noov";
    } else {
	$dyad_suffix .= "_ov";
    }

    #### expected frequency model
    if ($markov) {
	## do nothing. Expected dyad frequencies will be calculated on the basis of monad frequencies
    } elsif ($exp_freq_file{dyads}) {
	$dyad_options .= " -expfreq $exp_freq_file{dyads}";
    } elsif ($background) {
	$dyad_options .= " -bg $background ";
	$dyad_options .= " -org $organism_name ";
#      $dyad_suffix .= "_ncf";
    } elsif ($background eq "mncf") {
	$dyad_options .= " -mncf ";
	$dyad_options .= " -org $organism_name ";
	$dyad_suffix .= "_mncf";
    }
#  $dyad_suffix .= "_ncf" if ($background); ### TEMP

    #### suffix for the oligo-analysis file
    $noorf_string = "_noorf" if ($noorf);
    $noov_string = "_noov" if ($noov);
    $oligo_suffix = "_oligos";
    if ($markov) {
	$oligo_suffix .= "_mkv${markov_order}";
    } elsif ($background) {
	$oligo_suffix .= "_bg_${background}";
    }
    $oligo_suffix .= "_${min_oligo_length}-${max_oligo_length}nt";
    $oligo_suffix .= "_${strands}";
    $oligo_suffix .= "_sig${th}${noov_string}";

    foreach my $family_name (@families) {
	$family{$family_name}->{family_file} = "$family_name/${family_name}.fam";
	$family{$family_name}->{known_site_file} = "$family_name/${family_name}_known_sites";
	$family{$family_name}->{file_prefix} = "${family_name}_up${seq_length}${noorf_string}"; 
	$family{$family_name}->{seq_file} = $family_name."/".$family{$family_name}->{file_prefix}.".${seq_format}";
	$family{$family_name}->{seq_file_purged} = $family_name."/".$family{$family_name}->{file_prefix}."_purged.${seq_format}";
#      $family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}."_oligos_${min_oligo_length}-${max_oligo_length}nt_${strands}_sig${th}${noov_string}";
	$family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix; ## TEMP
	$family{$family_name}->{oligo_assembly_file} = $family{$family_name}->{oligo_file}."_contigs";
	$family{$family_name}->{oligo_ft_file} = $family{$family_name}->{oligo_file}.".ft";
	
	$family{$family_name}->{dyad_file} = "$family_name/dyads_${family_name}/".$family{$family_name}->{file_prefix}.$dyad_suffix;
	$family{$family_name}->{dyad_assembly_file} = $family{$family_name}->{dyad_file}."_contigs";
	$family{$family_name}->{dyad_ft_file} = $family{$family_name}->{dyad_file}.".ft";
	$family{$family_name}->{fmap_file} = $family{$family_name}->{dyad_file}.".${IMG_FORMAT}";
	$family{$family_name}->{htmap_file} = $family{$family_name}->{dyad_file}.".html";
    }  

    $table_suffix = $family_file;
    if ($markov) {
	$table_suffix .= "_mkv${markov_order}";
    } elsif ($background) {
	$table_suffix .= "_bg_${background}";
    }

    $table_suffix .= "_up".$from     if (defined($from));
    $table_suffix .= "_".$to     if (defined($to));
    $table_suffix .= $noorf_string;
    $table_suffix .= $noov_string;
    $table_suffix .= "_".$strands;
    $table_suffix = `basename $table_suffix`;
    chomp $table_suffix;
}

################### SUBROUTINE DEFINITION ###################"



#### retrieve upstream sequences
sub UpstreamSequences {
    warn ";\tRetrieving upstream sequences for family $family_name\n" if ($verbose >= 1);
    $command = "retrieve-seq -type upstream -org $organism_name";
    $command .= " -noorf " if ($noorf);
    $command .= " -i $family{$family_name}->{family_file}";
    $command .= " -o $family{$family_name}->{seq_file}";
    $command .= " -from $from" if (defined($from));
    $command .= " -to $to " if (defined($to));
    $command .= " -label orf_gene ";
    $command .= " -feattype $feature_types " if ($feature_types);
    $command .= " -format $seq_format";
    &doit($command);

    $command = "purge-sequence -ml 40 -mis 3";
    $command .= " -i $family{$family_name}->{seq_file}";
    $command .= " > $family{$family_name}->{seq_file_purged}";
    &doit($command);
}



### oligo-analysis
sub OligoAnalysis {
    warn join ("\t", 
	       ";\tAnalyzing oligonucleotides for family $family_name",
	       "min len: $min_oligo_length",
	       "max len: $max_oligo_length"), "\n" if ($verbose >= 1);
    $dir = "${family_name}/oligos_${family_name}";
    unless (-d $dir) {
	mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
    }
    die "Error : cannot read file $family{$family_name}->{seq_file_purged}\n" unless (-r $family{$family_name}->{seq_file_purged});
    
    
    system "echo '' > $family{$family_name}->{oligo_file}" if ($verbose >=1);
    
    for $oligo_length ($min_oligo_length..$max_oligo_length) {
	$oligo_options = "-v ";
	$oligo_options .= "-pseudo $pseudo " if ($pseudo);
	$oligo_options .= "-sort ";
	$oligo_options .= "-${strands} ";
	$oligo_options .= "-l $oligo_length ";
	$oligo_options .= "-thosig $th ";
	if ($markov) {
	    $oligo_options .= "-markov $markov_order ";
	} elsif ($exp_freq_file{oligos}) {
	    $oligo_options .= "-expfreq $exp_freq_file{oligos} ";
	} else {
	    $oligo_options .= "-org $organism_name ";
	    $oligo_options .= "-bg $background ";
	}
	$oligo_options .= "-return occ,proba,mseq,rank ";
	$oligo_options .= "-noov " if ($noov);
	
	$oligo_suffix = "_oligos";
	$oligo_suffix .= "_${oligo_length}nt";
	$oligo_suffix .= "_${strands}";
	$oligo_suffix .= "_sig${th}";
	$oligo_suffix .= "_noov" if ($noov);
	
	$oligo_file = "$family_name/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix;    
	$command = "oligo-analysis -i $family{$family_name}->{seq_file_purged} -format $seq_format -o $oligo_file $oligo_options";
	
	&doit($command);
	system "cat $oligo_file >> $family{$family_name}->{oligo_file}";
    }
    
    ### fragment assembly
    $command = "pattern-assembly -i $family{$family_name}->{oligo_file} -${strands} -v -o $family{$family_name}->{oligo_assembly_file} -maxfl 1 -maxpat 200 -subst 1";
    
    &doit($command);
    

}

################################################################
#### draw feature-map for the result of oligo-analysis
sub DrawOligoFeatureMap {
    warn ";\tDrawing feature-map with results of oligo-analysis for family $family_name\n" if ($verbose >= 1);
    ### feature-map for oligo-analysis
    die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
    $fmap_file = $family{$family_name}->{oligo_file}.".${IMG_FORMAT}";
    $htmap_file = $family{$family_name}->{oligo_file}.".html";
    $origin = "-0";
    $command = "dna-pattern -i $family{$family_name}->{seq_file} -format $seq_format -pl $family{$family_name}->{oligo_file} -origin $origin -N 4 ";
    $command .= " | features-from-dnapat -o $family{$family_name}->{oligo_ft_file} ";
    $command .= " ; feature-map -i $family{$family_name}->{oligo_ft_file} -scalebar -scalestep $scalestep -legend ";
    $command .= " -from $from" if (defined($from));
    $command .= " -to $to" if (defined($to));
    $command .= " -o $fmap_file -scorethick ";
    if ($htmaps) {
	$command .= " -htmap > $htmap_file ";
    };
    
    &doit($command);
}

################################################################
### dyad analysis
sub DyadAnalysis {
    warn join( "\t", 
	       ";\tAnalyzing dyads for family $family_name",
	       "monad length: $monad_length",
	       "min_sp: $min_sp",
	       "max_sp: $max_sp",
	       ), "\n" if ($verbose >= 1);
    $dir = "${family_name}/dyads_${family_name}";
    unless (-d $dir) {
	mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
    }
    die "Error : cannot read file $family{$family_name}->{seq_file_purged}\n" unless (-r $family{$family_name}->{seq_file_purged});
    $command = "dyad-analysis -return occ,proba,rank -i $family{$family_name}->{seq_file_purged} -format $seq_format -o $family{$family_name}->{dyad_file} $dyad_options";
    
    &doit($command);
    
    ### fragment assembly
    $command = "pattern-assembly -v -i $family{$family_name}->{dyad_file} -o $family{$family_name}->{dyad_assembly_file} -$strands -maxfl 2 -maxpat 200 ";
    
    &doit($command);
    
}

### read known known_site for each family
sub ReadKnownSites {
    my ($known_site_file) = @_;
    %known_site = ();
    %known_site_source = ();
    if (-e $known_site_file) {
	$known_sites_provided = 1;
	open KNOWN_SITE, $known_site_file;
	while (<KNOWN_SITE>) {
	    next if (/^;/);
	    next if (/^\#/);
	    next unless (/\S/);
	    chomp;
	    @fields = split "\t";
	    $family_name = $fields[0];
	    $known_site = uc($fields[1]);
	    $source = $fields[2];
	    #$known_site = uc(&compress_pattern($known_site,"n"));
	    $known_site =~ s/N/n/g;
	    push @{$known_site{$family_name}}, $known_site;
	    push @{$known_site_source{$family_name}}, $source;
	}
	close KNOWN_SITE;
    }
}

sub ReadSiteLibrary {
    @site_library = ();
    $library_file = "known_sites.tab";
    if (-e $library_file) {
	open LIBRARY, $library_file;
	while (<LIBRARY>) {
	    next if (/^;/);
	    next if (/^\#/);
	    next unless (/\S/);
	    chomp;
	    my @fields = split "\t";
	    my $source = $fields[2] || $library_file;
	    my $id = uc($fields[1]);
	    my $sequence = uc($fields[0]);
	    $sequence =~ s/N/n/g;
	    
	    $pattern = RSA::pattern->new(id=>$id,
					 sequence=>$sequence,
					 source=>source);
	    push @site_library, $pattern;
	}
	close LIBRARY;
    }
}


################################################################
### build a synthetic table ###
sub SyntheticTable {
    my $dir = "synthetic_tables";
    
    my $table_file = $dir."/".$table_suffix;
    $table_file .= "_tr" if ($transpose);

    warn "; Generating synthetic table $table_file\n" if ($verbose >= 1);
    
    unless (-d $dir) {
	mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
    }
    
    ### synthesize the results of all families into a single file
    
    ### headers
    $row = 0;
    $row{f} = $row++;
    $row{family} = $row++;
    $row{size} = $row++;
    $row{genes} = $row++;
    $row{known} = $row++ if ($known_sites_provided);
    $row{oligo} = $row++;
    $row{dyad} = $row++;
    $row_num = $row-1;
    while (($header,$row) = each %row) {
	$table[$row][0] = "<B>$header</B>";
    }
    my $col = 0;

    foreach $family_name (@families) {
	$col++;
	
	#### remember which column is associated to each family
	$column{$family_name} = $col;

	### check directory
	$dir = "${family_name}/dyads_${family_name}";
	unless (-d $dir) {
	    &Warning ("Cannot find directory $dir\n");
	}
	
	### family number
	$table[$row{f}][$col] = "<B>$col</B>";
	
	### family name
	$table[$row{family}][$col] = "<B><a href='../$family_name'>$family_name</a></B>";
	
	#### number of genes
	$table[$row{size}][$col] = scalar(@{$family{$family_name}->{members}});

	### list of genes
	$table[$row{genes}][$col] = "<a href='../".$family{$family_name}->{family_file}."'>";
	$table[$row{genes}][$col] .= join " ", @{$family{$family_name}->{members}};
	$table[$row{genes}][$col] .= "</a>";
	
	### known patterns
	if ($known_sites_provided) {
	    $table[$row{known}][$col] = "";
	    for $c (0..$#{$known_site{$family_name}}) {
		$table[$row{known}][$col] .= ${known_site{$family_name}}[$c];
		$table[$row{known}][$col] .= "<BR>(".${known_site_source{$family_name}}[$c].")" if (${known_site_source{$family_name}}[$c]);
		$table[$row{known}][$col] .= "<P>";
	    }
	} 
	
	#### oligo-analysis
#	open OLIGOS, "$family{$family_name}->{oligo_assembly_file}";
        if ($htmaps) {
          $map_link = "<A HREF=../$family{$family_name}->{oligo_file}.html>\n";
        } else {
	  $map_link = "<A HREF=../$family{$family_name}->{oligo_file}.${IMG_FORMAT}>\n";
        }
 	warn ";\tExtracting info from\t$family{$family_name}->{oligo_assembly_file}\n" if ($verbose >= 2);
	undef @patterns;
	undef @sorted_patterns;
	undef %rc;
	undef %score;
	undef %type;

	if (-e $family{$family_name}->{oligo_assembly_file}) {
	    my ($olig, $input_dir) = &OpenInputFile($family{$family_name}->{oligo_assembly_file});
	    while (<$olig>) {
		chomp;
		next if (/^;/);
		next if (/^\#/);
		next unless (/\S/);
		if ((/contig/) || (/consensus/) || (/isol/)) {
		    @fields = split "\t";
		    my $sequence = shift (@fields);
		    $pattern = new RSA::pattern(sequence=>$sequence);
		    push @patterns, $pattern;
		    if ($strands eq "2str") {
			$rc{$pattern} = shift @fields;
#			$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
		    }
		    $score{$pattern} = shift @fields;
		    $type{$pattern} = shift @fields;
		    $max_score{$family_name} = &max($max_score{$family_name}, $score{$pattern});
		}
	    }
	} else {
	    &Warning(join ( "\t", 
			    "Family $family_name\t",  
			    "oligo-analysis file ", $family{$family_name}->{oligo_assembly_file}, 
			    " does not exist. Skipped."));

	}
	@sorted_patterns = sort { $score{$b} <=> $score{$a} } @patterns;
	$table[$row{oligo}][$col] = "<TABLE>\n";
	$table[$row{oligo}][$col] .= "<TR>\n";
	
	### print oligo sequence
	$table[$row{oligo}][$col] .= "<TD>\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= $sorted_patterns[$p]->get_attribute("sequence"); 
	    $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{oligo}][$col] .= "</TD>\n";
	
	### print reverse complementary oligo
	if ($strands eq "2str") {
	    $table[$row{oligo}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		$table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
		$table[$row{oligo}][$col] .= $rc{$sorted_patterns[$p]};
		$table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
		$table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{oligo}][$col] .= "</TD>\n";
	}

	### print oligo score
	$table[$row{oligo}][$col] .= "<TD>$map_link\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "$score{$sorted_patterns[$p]}";
	    $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{oligo}][$col] .= "</A></TD>\n";
	
	### print matching patterns
	if ($known_sites_provided) {
	    $table[$row{oligo}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		my @matches = ();
		foreach $site (@site_library) {
		    if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
			($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
			#my $match = $site->get_attribute("sequence");
			my $match = $site->get_id();
			push @matches, $match;
		    }
		}
		$table[$row{oligo}][$col] .= join(";",@matches);
		$table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{oligo}][$col] .= "</TD>\n";
	}
	
	$table[$row{oligo}][$col] .= "</TR>\n";
	$table[$row{oligo}][$col] .= "</TABLE>\n";
	close $olig;
	
	### dyad analysis
        if ($htmaps) {
	  $map_link = "<A HREF=../$family{$family_name}->{dyad_file}.html>\n";
        } else {
	  $map_link = "<A HREF=../$family{$family_name}->{dyad_file}.${IMG_FORMAT}>\n";
        }
	warn ";\tExtracting info from\t$family{$family_name}->{dyad_assembly_file}\n" if ($verbose >= 2);
	undef @patterns;
	undef @sorted_patterns;
	undef %rc;
	undef %score;
	undef %type;

	if (-e $family{$family_name}->{dyad_assembly_file}) {
	    my ($dyadhandle) = &OpenInputFile($family{$family_name}->{dyad_assembly_file});
#	open DYADS, "$family{$family_name}->{dyad_assembly_file}";
	    while (<$dyadhandle>) {
		chomp;
		next if (/^;/);
		next if (/^\#/);
		next unless (/\S/);
		if ((/contig/) || (/consensus/) || (/isol/)) {
		    @fields = split "\t";
		    my $sequence = shift @fields;
		    $pattern = new RSA::pattern(sequence=>$sequence);
		    push @patterns, $pattern;
		    if ($strands eq "2str") {
			$rc{$pattern} = shift @fields;
#			$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
		    }
		    $score{$pattern} = shift @fields;
		    $type{$pattern} = shift @fields;
		}
	    }
	} else {
	    &Warning(join( "\t", 
			   "Family $family_name", 
			   "dyad-analysis file ", $family{$family_name}->{dyad_assembly_file}, 
			   " does not exist. Skipped."));
	}
	@sorted_patterns = sort {$score{$b} <=> $score{$a}} @patterns;
	$table[$row{dyad}][$col] = "<TABLE>\n";
	$table[$row{dyad}][$col] .= "<TR>\n";
	
	### print dyad sequence
	$table[$row{dyad}][$col] .= "<TD>\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $sequence = $sorted_patterns[$p]->get_attribute("sequence");
	    $compressed = &compress_pattern($sequence, "n");
	    $compressed =~ s/N/n/g;
	    $table[$row{dyad}][$col] .= $compressed;
	    $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{dyad}][$col] .= "</TD>\n";
	
	### reverse complementary dyad
	if ($strands eq "2str") {
	    $table[$row{dyad}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		$table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
		$compressed = &compress_pattern($rc{$sorted_patterns[$p]},"n");
		$compressed =~ s/N/n/g;
		$table[$row{dyad}][$col] .= $compressed;
		$table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
		$table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{dyad}][$col] .= "</TD>\n";
	}

	### dyad scores
	$table[$row{dyad}][$col] .= "<TD>$map_link\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "$score{$sorted_patterns[$p]}";
	    $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{dyad}][$col] .= "</A></TD>\n";
	
	### print matching patterns
	if ($known_sites_providde) {
	    $table[$row{dyad}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		my @matches = ();
		foreach $site (@site_library) {
		    if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
			($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
			#my $match = $site->get_attribute("sequence");
			my $match = $site->get_id();
			push @matches, $match;
		    }
		} 
		$table[$row{dyad}][$col] .= join(";",@matches);
		$table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{dyad}][$col] .= "</TD>\n";
	}
	
	$table[$row{dyad}][$col] .= "</TR>\n";
	$table[$row{dyad}][$col] .= "</TABLE>\n";
	close $dyadhandle;
    }
    
    open TABLE, "> ${table_file}.html" 
	|| die "Error: cannot write file $table_file\n";
    print TABLE "<HTML>\n";
    print TABLE "<TITLE>",${table_file}, "</TITLE>","\n";
    print TABLE "<BODY>\n";
    print TABLE "<H1>$table_file</H1>\n";
    
    print TABLE join( "\n",
		      "<PRE>",
		      $verbose_message,
		      "</PRE>"
		      ), "\n";


    print TABLE "<TABLE BORDER=1>\n";
    

    if ($sort_key eq "score") {
	#### sort families by score
	#### decreasing order
	@sorted_families = sort {$max_score{$b} <=> $max_score{$a}} @families; 
# 	foreach my $f (@sorted_families) {
# 	    warn join "\t", $f, $max_score{$f}, "\n";
# 	}

    } else {
	#### sort families by family name
	@sorted_families = sort @families;
    }
    
    if ($transpose) {
	foreach $r (0..$row_num) {
	    print TABLE "<TR>\n";
#		foreach $c (0..$col) {
	    foreach $f (@sorted_families) {
		my $c = $column{$f};
		print TABLE "<TD>", $table[$r][$c], "</TD>\n";
	    }
	    print TABLE "</TR>\n";
	}
    } else {
	
	
	#### print table header
	foreach $r (0..$row_num) {
	    print TABLE "<TH>", $table[$r][0], "</TH>\n";
	}
	#### print table content
#	foreach $c (0..$col) {
	foreach $f (@sorted_families) {
	    my $c = $column{$f};
	    print TABLE "<TR>\n";
	    foreach $r (0..$row_num) {
		print TABLE "<TD>", $table[$r][$c], "</TD>\n";
	    }
	    print TABLE "</TR>\n";
	}
    }
    
    print TABLE "</TABLE>\n";
    print TABLE "<HR>", &AlphaDate;
    print TABLE "</BODY>\n";
    print TABLE "</HTML>\n";
    close TABLE;
    chdir "synthetic_tables";
#  system "html_dir.csh > index.html";
    chdir "../";
}


################################################################
#### draw feature maps
sub DrawDyadFeatureMap {
    warn ";\tDrawing feature-map with results of dyad-analysis for family $family_name\n" if ($verbose >= 1);
    die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
    $origin = "-0";
    $command = "dna-pattern -pl $family{$family_name}->{dyad_file} -format $seq_format -i $family{$family_name}->{seq_file} -origin $origin -N 4 ";
    $command .= "| features-from-dnapat -o $family{$family_name}->{dyad_ft_file} ";
    $command .= "; feature-map -i $family{$family_name}->{dyad_ft_file} -o $family{$family_name}->{fmap_file} ";;
    $command .= " -from $from" if (defined($from));
    $command .= " -to $to " if (defined($to));
    $command .= "-legend ";
    $command .= "-scalebar -scalestep $scalestep ";
    $command .= "-scorethick ";
    $command .= "-mlen 520 ";
    $command .= "-title '${family_name}$dyad_suffix' ";
    if ($htmaps) {
	$command .= "-htmap >  $family{$family_name}->{htmap_file}";
    }
    #  $command .= " ;  xv -o $family{$family_name}->{fmap_file} &";

    &doit($command);
}


############################### check parameters ###############################
sub CheckParameters {

    #### accepted feature types
    unless (defined %accepted_feature_types) {
	$accepted_feature_types{cds} = 1;
    }
    $feature_types = join ",", keys (%accepted_feature_types);


    #### check selected tasks
    unless (defined(%task)) {
	&FatalError("You should select at least one task.");
    }
    if ($task{all}) {
	foreach my $t (@supported_tasks) {
	    $task{$t} = 1;
	}
	if ($no_map) {
	    $task{maps} = 0;
	}
    }
    
    ### family file ###
    if ($family_file eq "") {
	die "Error: you should specify a family file\n";  
    } 
    
    ### organism ###
    if ($organism_name eq "") {
	die "Error: you should specify an organism\n$supported_organisms\n";  
    } 
    unless ($supported_organism{$organism_name}) {
	die ("Error: organism $organism_name is not supported\n",
	     "Supported organisms:\n$supported_organisms\n");
    }

    
#    $from = $default{from} unless defined($from);
#    $to = $default{to} unless defined($to);

    $from = $supported_organism{$organism_name}->{'up_from'}  unless defined($from);
    $to = $supported_organism{$organism_name}->{'up_to'}  unless defined($to);

    $seq_length = abs($to - $from) + 1;
    $dyad_type = "any" unless ($dyad_type);

    if (defined($force{strands})) {
	$strands = $force{strands}; ### force
    } else {
	$strands = "2str";
    }
    if (defined($force{exp})) {
	$exp = $force{exp}; ### force
    }
    if (&IsReal($force{th})) {
	$th = $force{th}; ### force
    } elsif ($#families > 0) {
	$th = &round(10*abs(log($#families + 1)/log(10)))/10;
    } else {
	$th = 0;
    } 
}

    
sub AnalyzeFamilies {
    my $fam_count=0;
    my $fam_nb = $#families+1;
    foreach $family_name (@families) {
	$fam_count++;
	warn ";\n; Treating family $family_name ($fam_count of $fam_nb)\t", `date` if ($verbose >=1);
	
	### retrieve upstream sequences
	&UpstreamSequences if ($task{upstream});
	
	### oligo-analysis
	&OligoAnalysis if ($task{oligos});
	
	### dyad feature-maps
	&DrawOligoFeatureMap if ($task{maps});

	### dyad analysis
	&DyadAnalysis if ($task{dyads});

	### dyad feature-maps
	&DrawDyadFeatureMap if ($task{maps});
	
	### delete upstream sequence file
	if ($task{clean}) {
	    warn ";\tCleaning files from the hard drive for family $family_name\n" if ($verbose >=1);
	    foreach my $file ($family{$family_name}->{seq_file},
			      $family{$family_name}->{seq_file_purged},
			      $family{$family_name}->{oligo_ft_file},
			      $family{$family_name}->{dyad_ft_file}
			      ) {
		warn ";\t\t$file\n" if ($verbose >=1);
		system "rm -f $file" ;
	    }
	}
	
    }
}

sub doit {
    my ($command) = @_;
    print "\n$command\n" if ($verbose >= 2);
    system $command unless $dry_run;
}


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
    $HELP_FAMILY_FILE = &help_message("family file");
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
	multiple-family-analysis

        1999 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        multiple-family-analysis [-i inputfile] [-v]

DESCRIPTION
	Runs a combination of programs in order to discover significant
	patterns in the upstream regions of several gene families.

	This script is a way to auto;atize the systematic analysis of
	multiple clusters of co-regulated genes, such as those
	obtained with DNA chip experiments.

	The program reads the composition of several families in a
	single text file, then executes different program discovery
	programs, and generates a summary report.

	Results are subdifided in directories created on the fly, one
	directory per family plus one summary directory.
	
CATEGORY
	sequences
	pattern discovery

OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-i	family file
	-outdir	output directory

    Sequence retrieval options
	-org	organism
	-noorf	exclude upstream ORFs from upstream sequences
	-from	upstream region left limit
	-to	upstream region right limit
        -feattype
		feature type (e.g. CDS, mRNA)

    oligo-analysis and dyad-analysis options
	-1str   strand-sensitive analysis
	-2str   strand-insensitive analysis
	-htmaps	draw html maps (dynamic map with pointers to the features)
		These html files take space on the hard drive, so I
		suppressed them from the default output.
	-noov	prevent overlapping matches for self-overlapping patterms
		(default)
	-ovlp	allow overlapping matches for self-overlapping patterms
	-nomap	do not draw feature maps (for saving time and hard disk space)
	-bg	background frequency model
		This parameter indicates which background model has to
		be used for the estimation of expected pattern
		frequencies.
		Supported: $supported_background

    oligo-analysis options
	-maxol	maximum oligonucleotide length
	-minol	minimum oligonucleotide length
	-oligo_exp_freq
		name of a file containing the expected frequencies for
		oligo-analysis.
	-pseudo	pseudo-weight (see oligo-analysis manual)
	-markov #	
		calculate expected frequencies on the basis of a
		Markov chain model of order #

    dyad-analysis options
	-monad  monad length for dyad-analysis
	-minsp	maximum spacing for dyad-analysis
	-maxsp	maximum spacing for dyad-analysis
	-dyad_exp_freq
		name of a file containing the expected frequencies for
		dyad-analysis.

    Output options
	-transp	transpose synthetic result table (columns become rows)
	-sort sort_key
	        sort key for the synthetic table
		Supported: $supported_sort_keys

    Other options
	-task selected_task
		Select the tasks to be performed.
		Supported tasks: $supported_tasks

		Can be used iteratively on the same command line to 
		select multiple tasks.  

		Example:
		    -task upstream -task oligos -task synthesis
		For a full analysis, simply type 
		    -task all
	-known	known_site_file
		A file containing a list of known sites/motifs for
		each of the gene families. These known sites are NOT
		used during the pattern discovery. They are simply
		displayed besides the discovered patterns, for the
		sake of comparison.
		
		Format: the known site file is a tab-delimited text
		files, with the collofing column content :
		       1) family
		       2) site/motif
		       3) source (optional)

FILE FORMAT
    $HELP_FAMILY_FILE
HOW TO PROCEED
    1) create a directory for the set of families

    2) witin this directory, create a text file contaning the
       description of family composition, as described above
    
    3) run the command

       multiple-family-analysis -org organism -i family_file \
           -v -from -200 -to 49 -task all

    4) With a web browser (e.g. Netscape), open the folder
       'synthetic_tables'. There should be a HTML file with the name
       of your family ile as prefix, and the suffix indicating the
       other analysis parameters. Open this file and analyze the
       result.

End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
multiple-family-analysis options
--------------------------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-v		verbose
-i		family file
-outdir		output directory
-org		organism
-from		upstream region left limit
-to		upstream region right limit
-noorf		exclude upstream ORFs from upstream sequences
-feattype	feature type for sequence retrieval (e.g. CDS, mRNA)
-1str   	strand-sensitive analysis
-2str   	strand-insensitive analysis
-maxol		maximum oligonucleotide length
-minol		minimum oligonucleotide length
-monad		monad length for dyad-analysis
-minsp		maximum spacing for dyad-analysis
-maxsp		maximum spacing for dyad-analysis
-n      	dry run: print commands without executing them
-exp		expected frequency file
-transp		transpose synthetic result table (columns become rows)
-sort		sort key (supported: $supported_sort_keys)
-task		selected task (supported: $supported_tasks)
-htmaps		draw html maps (dynamic map with pointers to the features)
-dyad_exp_freq	expected frequencies for dyad-analysis
-oligo_exp_freq	expected frequencies for oligo-analysis
-noov		prevent overlapping matches for self-overlapping patterms
-ovlp		allow overlapping matches for self-overlapping patterms
-pseudo		pseudo-weight (see oligo-analysis manual)
-nomap		do not draw feature maps (for saving time and hard disk space)
-bg		background frequency modelEnd_short_help
-markov #	exp. freq. calcualted with Markov chain model of order #
-known		file containing a list of known sites/motifs
End_short_help
  close HELP;
  exit;
}


sub ReadArguments {
#### read arguments ####
    foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    $verbose = $ARGV[$a+1];
	    unless (&IsNatural($verbose)) {
		$verbose = 1;
	    }
	    
	    #### dry run
	} elsif ($ARGV[$a] eq "-n") {
	    $dry_run = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions;
	    
	    ### family file
	} elsif (($ARGV[$a] eq "-i") ||
		 ($ARGV[$a] eq "-fam") # for compatibility with previous versions
		 ) {
	    $family_file = $ARGV[$a+1];

	    ### output directory
	} elsif ($ARGV[$a] eq "-outdir") {
	    $dir{output} = $ARGV[$a+1];

	    ### upstream sequence lmits
	} elsif (($ARGV[$a] eq "-from") &&
		 (&IsInteger($ARGV[$a+1]))) {
	    $from = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-to") &&
		 (&IsInteger($ARGV[$a+1]))){
	    $to = $ARGV[$a+1];

	    ### strands 
	} elsif ($ARGV[$a] eq "-1str") {
	    $force{strands} = "1str";
	} elsif ($ARGV[$a] eq "-2str") {
	    $force{strands} = "2str";

	    ### oligo-analysis parameters
	} elsif ($ARGV[$a] eq "-minol") {
	    $min_oligo_length = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-maxol") {
	    $max_oligo_length = $ARGV[$a+1];;
	    
	    ### dyad-analysis parameters
	} elsif ($ARGV[$a] eq "-monad") {
	    $monad_length = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-minsp") {
	    $min_sp = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-maxsp") {
	    $max_sp = $ARGV[$a+1];;

	    ### organism
	} elsif ($ARGV[$a] eq "-org") {
	    $organism_name = $ARGV[$a+1];

	    ### file with a collection of known motifs, for comparison between discovered and known motifs
	} elsif ($ARGV[$a] eq "-known") {
	    $known_site_file = $ARGV[$a+1];

	    #### task selection
	} elsif ($ARGV[$a] eq "-task") {
	    my @requested_tasks = split ",", $ARGV[$a+1];
	    foreach my $task (@requested_tasks) {
		next unless $task;
#	    $task = $ARGV[$a+1];
		if ($supported_task{$task}) {
		    $task{$task} = 1;
		} else {
		    &FatalError("Unsupported task '$task'. \n\tSupported: $supported_tasks");
		}
	    }

	    #### transpose synthetic table
	} elsif ($ARGV[$a] =~ /^-transp/) {
	    $transpose = 1;

	    #### sort key
	} elsif ($ARGV[$a] =~ /^-sort/) {
	    $sort_key = $ARGV[$a+1];
	    unless ($supported_sort_key{$sort_key}) {
		&FatalError("$sort_key is not supported as sort key");
	    }

	    #### clip upstream ORFs fom upstream regions
	} elsif ($ARGV[$a] =~ /^-noorf/) {
	    $noorf = 1;

	    #### threshold
	} elsif ($ARGV[$a] =~ /^-th/) {
	    $force{th} = $ARGV[$a+1];

	    #### dyad type
	} elsif ($ARGV[$a] =~ /^-type/) {
	    $force{type} = $ARGV[$a+1];

	    #### feature types
	} elsif ($ARGV[$a] eq "-feattype") {
	    my @types = split ",", $ARGV[$a+1];
	    foreach my $type (@types) {
		if ($supported_feature_types{lc($type)}) {
		    $accepted_feature_types{lc($type)}++;
		} else {
		    &FatalError("$type invalid feature type. Supported: $supported_feature_types");
		}
	    }

	    #### expected frequency file for dyad-analysis 
	} elsif ($ARGV[$a] =~ /^-dyad_exp_freq/) {
	    $exp_freq_file{dyads} = $ARGV[$a+1];

	    #### expected frequency file for oligo-analysis 
	} elsif ($ARGV[$a] =~ /^-oligo_exp_freq/) {
	    $exp_freq_file{oligos} = $ARGV[$a+1];


	    #### background model for expected frequency. 
	    #### Supported: "upstream", "upstam-noorf", "intergenic", "mncf"
	} elsif (($ARGV[$a] =~ /^-exp/) 
		 || ($ARGV[$a] =~ /^-bg/)) {
	    $background = $ARGV[$a+1];
	    $background =~ s/^ncf$/intergenic/;

	    unless ($supported_background{$background}) {
		&FatalError("$background\tInvalid value for background. Supported : $supported_background");
	    }

	    #### Markov chain estimation of expected oligo frequencies
	} elsif ($ARGV[$a] =~ /^-markov/) {
	    $markov_order = $ARGV[$a+1];
	    $markov=1;
	    
	    #### prevent self-overlap
	} elsif ($ARGV[$a] eq "-noov") {
	    $noov = 1;

	    #### allow self-overlap
	} elsif ($ARGV[$a] eq "-ovlp") {
	    $noov = 0;

	    #### prevent feature-map drawing
	} elsif ($ARGV[$a] eq "-nomap") {
	    $no_map = 1;

	    #### draw htmaps
	} elsif ($ARGV[$a] eq "-htmaps") {
	    $htmaps = 0;

	    #### pseudo-weight
	} elsif ($ARGV[$a] =~ /^-pseudo/) {
	    $pseudo = $ARGV[$a+1];
	    unless ((&IsReal($pseudo)) && ($pseudo > 0)) {
		&FatalError("pseudo-weight must be a positive real number");
	    }


	    
	    ################################################################
	    #### options for the data export
	} elsif ($ARGV[$a] eq "-dbms") {
	    $dbms = $ARGV[$a+1];
	    unless ($supported_dbms{$dbms}) {
		&FatalError("$dbms\tInvalid DBMS\tsupported: $supported_dbms");
	    }

	} elsif ($ARGV[$a] eq "-schema") {
	    $schema = $ARGV[$a+1];

	}
    }
}



################################################################
# Verbosity
#
sub Verbose {
    my $verbose_message = "";
    $verbose_message .= "; multiple-family-analysis ";
    $verbose_message .= &PrintArguments();
    printf "; families     \t%d\n", $#families + 1;
    foreach my $family_name (@families) {
	printf ";\t%s\t%d elements\n", $family_name, $family{$family_name}->get_size();
    }
    $verbose_message .= sprintf "; family file\t%s\n", $family_file;
    $verbose_message .= sprintf "; upstream region\n";
    $verbose_message .= sprintf ";\t%-22s\t%d\n", "strands", $strands;
    $verbose_message .= sprintf ";\t%-22s\t%d\n", "from", $from;
    $verbose_message .= sprintf ";\t%-22s\t%d\n", "to", $to;

    $verbose_message .= sprintf "; %-13s\t%s\n", "organism", $organism_name;

    if ($task{oligos}) {
	$verbose_message .= sprintf "; oligo-analysis\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "max oligo length", $max_oligo_length;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "min oligo length", $min_oligo_length;
    }
    
    if ($task{dyads}) {
	$verbose_message .= sprintf "; dyad-analysis\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "monad length", $monad_length;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "min spacing", $min_sp;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "max spacing", $max_sp;
	$verbose_message .= sprintf ";\t%-22s\t%s\n", "dyad type", $dyad_type;
	$verbose_message .= sprintf ";\t%-22s\t%g\n", "sig threshold", $th;
    }

    if ($markov) {
	$verbose_message .= sprintf "; %-13s\t%s\n", "Markov chains, order", $markov_order;
    } elsif ($background) {
	$verbose_message .= sprintf "; %-13s\t%s\n", "background model", $background;
    }

    $verbose_message .= "; No overlap with upstream ORFs\n" if ($noorf);
    $verbose_message .= "; Overlapping matches are discarded for self-overlapping patterns\n" if ($noov);
    warn $verbose_message;
    return($verbose_message);
}


################################################################
### initialize one directory for each family
sub MakeDirectories {
    foreach $family_name(@families) {
	$dir = "${family_name}/";
	unless (-d $dir) {
	    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
	}
	open FAM, ">$family{$family_name}->{family_file}" ||
	    die "Error: cannot write family file $family{$family_name}->{family_file}\n";
	foreach $id ($family{$family_name}->get_members()) {
	    print FAM "$id\t$name{$id}\n";
    
	}
	close FAM;
    }
}




################################################################
#### check output directory
#### output directory
sub CheckOutputDirectory {
    if ($dir{output}) {
	unless (-d $dir{output}) {
	    `mkdir -p $dir{output}`;
	    unless (-d $dir{output}) {
		&FatalError("Cannot create output directory $dir{output}");
	    }
	}
	chdir ($dir{output});
    }
}



################################################################
### Generate tab files and SQL scripts for storing the results in a
### relational database
sub ExportSQL {
#    push @INC, $ENV{PARSER};
    require "PFBP_classes.pl";
    require "PFBP_parsing_util.pl";
    
    warn "; Generating SQL $table_file\n" if ($verbose >= 1);

    my $family_factory = PFBP::ClassFactory->new_class(object_type=>"RSAT::Family",
						       prefix=>"fam_");



    my $pattern_factory = PFBP::ClassFactory->new_class(object_type=>"RSAT::Pattern",
						       prefix=>"pat_");


    #### output directory
    $dir{output} = "sql_export";
    &CheckOutputDir();

    my $table_file = $dir."/".$table_suffix;

    my %export_columns = ();
    
    foreach my $family_name (@families) {
	
	#### general family attributes
	my $family_object = $family_factory->new_object(id=>$family_name);
	my $family_id = $family_object->get_attribute("id");
	$family_object->set_attribute("name", $family_name);
	$family_object->set_attribute("size", scalar(@{$family{$family_name}->{members}}));
	$family_object->set_attribute("organism", $organism_name);
	$family_object->set_attribute("suffix", $table_suffix);

	#### family members
	my @members = @{$family{$family_name}->{members}};
	foreach my $m (@members) {
	    $family_object->push_attribute("genes", $m);
	}

	#### discovered oligos
	
	my $oligo_file = $family{$family_name}->{oligo_file};
	if (-e $oligo_file) {
	    open OLIGOS, $oligo_file;
	    while (<OLIGOS>) {
		chomp;
		if (/^;/) {
		    if ((/;\s+(\d+)\t(\S+)/) && ($2 ne "id")){
			$export_columns{$2} = $1 - 1;
		    }
		    next;
		}
		next unless (/\S/);
		my @fields = split;
#		my %export_columns = ();
		my $oligo_object = $pattern_factory->new_object();
#		warn join ("\t", "HELLO", $oligo_object, $score_column, $fields[0], $fields[$score_column]), "\n";
		my $sequence = uc($fields[0]);
		$oligo_object->set_attribute("sequence", $sequence);
		foreach $k (sort keys %export_columns) {
		    $oligo_object->set_attribute($k, $fields[$export_columns{$k}]);
		}
#		$oligo_object->set_attribute("occ_sig", $fields[$export_columns{occ_sig}]);
#		$oligo_object->set_attribute("occ", $fields[$export_columns{occ}]);
		$oligo_object->set_attribute("type", "oligo");
		$oligo_object->set_attribute("family_id", $family_id);
		$oligo_object->set_attribute("family", $family_name);
		if ($strands eq "2str") {
		    $oligo_object->set_attribute("rev_compl", &ReverseComplement($oligo_object->get_attribute("sequence")));
		}
	    }
	    close OLIGOS;
	} else {
	    &Warning("$family_name\toligo file $oligo_file does not exist\tSKIPPED\n");
	}

	#### discovered dyads
	my $dyad_file = $family{$family_name}->{dyad_file};
	if (-e $dyad_file) {
	    open DYADS, $dyad_file;
	    while (<DYADS>) {
		chomp;
		if (/^;/) {
		    if ((/;\s+(\d+)\t(\S+)/) && ($2 ne "id")){
			$export_columns{$2} = $1 - 1;
		    }
#		    if (/;\s+(\d+)\tocc_sig/) {
#			$export_columns{occ_sig} = $1 - 1;
#		    } elsif (/;\s+(\d+)\tocc\s/) {
#			$export_columns{occ} = $1 - 1;
#		    }
		    next;
		}
		next unless (/\S/);
		my @fields = split;
#		my %export_columns = ();
		my $dyad_object = $pattern_factory->new_object();
#		warn join ("\t", "HELLO", $dyad_object, $score_column, $fields[0], $fields[$score_column]), "\n";
		my $sequence = uc($fields[0]);
		$sequence =~ s/N/n/g;
		$dyad_object->set_attribute("sequence", $sequence);
		foreach $k (sort keys %export_columns) {
		    $dyad_object->set_attribute($k, $fields[$export_columns{$k}]);
		}
#		$dyad_object->set_attribute("occ_sig", $fields[$export_columns{occ_sig}]);
#		$dyad_object->set_attribute("occ", $fields[$export_columns{occ}]);
		$dyad_object->set_attribute("type", "dyad");
		$dyad_object->set_attribute("family_id", $family_id);
		$dyad_object->set_attribute("family", $family_name);
		if ($strands eq "2str") {
		    my $rc_sequence = uc( &ReverseComplement($dyad_object->get_attribute("sequence")));
		    $rc_sequence =~ s/N/n/g;
		    $dyad_object->set_attribute("rev_compl",$rc_sequence);
		}
	    }
	    close DYADS;
	} else {
	    &Warning("$family_name\tdyad file $dyad_file does not exist\tSKIPPED\n");
	}
	
	
    }

    #### export the result tables
    @pattern_out_fields = qw(id
			     family_id
			     family 
			     type 
			     sequence 
			     rev_compl
			     occ 
			     exp_occ
			     occ_P
			     occ_E
			     occ_sig
			     rank
			     );
#    push @pattern_out_fields, sort keys %export_columns;
    $family_factory->set_out_fields(qw(id organism size name suffix genes));
    $pattern_factory->set_out_fields(@pattern_out_fields);
    foreach my $factory ($family_factory, $pattern_factory) {
	$factory->dump_tables();
	$factory->generate_sql(dbms=>$dbms, schema=>$schema);
    }
}
