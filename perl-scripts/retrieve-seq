#!/usr/bin/perl
############################################################
#
# $Id: retrieve-seq,v 1.2 2000/03/26 22:06:15 jvanheld Exp $
#
# Time-stamp: <2000-03-26 23:28:59 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib.pl";
require "RSA.classes.pl";
require "RSA.seq.lib.pl";

############# help ###########
if ($ARGV[0] eq "-h") {
  &PrintHelp;
}

if ($ARGV[0] eq "-help") {
  &PrintShortHelp;
}

#### initialize parameters
my $start_time = &AlphaDate;

my %col = ();
$col{'id'} = 0;
$col{'kind'} = 1;
$col{'name'} = 2;
$col{'chrom'} = 3;
$col{'left'} = 4;
$col{'right'} = 5;
$col{'strand'} = 6;
$col{'descr'} = 8;

my %chomosome = ();
my $chrom = "";

  
$upstream_reg_from = -200;
$upstream_reg_to = -1;
@queries = ();
$out_format = "fasta";
$linewidth = 60;


&ReadArguments;


################################################################################
############################### check parameters ###############################
################################################################################


### organism ###
if ($organism eq "") {
  die "Error: you should specify an organism\n$supported_organisms\n";  
} elsif ($organism eq "yeast") {
  $args = join " ", @ARGV;
  system "upstream-region-yeast $args";
  exit(0);
} elsif ($supported_organism{$organism}) {
  $feature_table_file = $supported_organism{$organism}->{'features'};
  $genome_file = $supported_organism{$organism}->{'genome'};
  $genome_seq_format = $supported_organism{$organism}->{'seq_format'};
  
  ### open a direct read access to the genome file
  $chrom = "genome";
  $genome_file =~ s/\.fna$/\.raw/;
  $chromosome{$chrom} = new RSA::SequenceOnDisk (filename=>  $genome_file,
						 id=>        $chrom,
						 circular=>  1, ### for bacterial genomes
						 organism=>  $organism);

} else {
  die "Error: unsupported organism $organism\n";
}

#### check output format ####
&CheckOutputSeqFormat($out_format);

#### check limits ####
if ($upstream_reg_to < $upstream_reg_from) {
  $tmp = $upstream_reg_to;
  $upstream_reg_to = $upstream_reg_from;
  $upstream_reg_from = $tmp;
}

#### queries ####
if ($return_all) {
  $query_file = $feature_table_file;
}
if (@queries == ()) {
  ### open query file ###
  if ($query_file ne "") {
    open(QUERIES, $query_file) || 
	die "\tcannot open query file $query_file\n";
    $in = QUERIES;
  } else {
    $in = STDIN;
  }
  while (<$in>) {
    next if (/^;/);
    if ((/(\S+)/) && !(/^;/)) {
      push @queries, $1;
    }
  }
  close $in;
}
if ($#queries <0) {
  print "Error: you should enter at least one valid query\n";
  print "type upstream-region -help for info\n";
  exit;
}

#### output file ####
$out = &OpenOutputFile($outputfile);

#### verbose ####
if ($warn_level) {
  print $out ";upstream-region\n";
  print $out ";Queries:\n";
  foreach $q (@queries) {
    print $out ";	$q\n";
  }
  
  if ($no_CDS) {
    print $out ";maximal upstream region sizes\n";
    foreach $key (keys %up_dist) {
      print $out ";\t$key\t$up_dist{$key}\n";
    }
  }
  
  print $out ";relative coordinates\n";
  print $out ";        from    $upstream_reg_from\n";
  print $out ";        to      $upstream_reg_to\n";
  print $out ";        size    $upstream_reg_size\n";
  print $out ";Output Format		$out_format\n";
  if ($linewidth > 0) {
    print $out ";line width		$linewidth\n";
  }
  print $out ";\n";
}

#### read data
&ReadCDSPositions;
&ReadSynonyms($organism);
#&ReadGenomeSequence;

#### get the upstream regions ####
QUERYLOOP: foreach $query (@queries) {
  unless (defined($CDS_id{uc($query)})) {
    print $out ";WARNING\tinvalid query $query\n";
    next;
  }
  
  $CDS_id = $CDS_id{uc($query)};
  $name = $name{$CDS_id}; 
  $CDS_left = $left{$CDS_id};
  $CDS_right = $right{$CDS_id};
  $CDS_strand = $strand{$CDS_id};
  
  if ($no_CDS) {
    $current_from = &max(-$up_dist{$CDS_id} + 1, $upstream_reg_from);
  } else {
    $current_from = $upstream_reg_from;
  }
  $current_to = $upstream_reg_to;
  
  
  if ($CDS_strand eq ">") {
    $upstream_reg_left = $CDS_left + $current_from;
    $upstream_reg_right = $CDS_left + $current_to;
  } else {
    $upstream_reg_right = $CDS_right - $current_from;
    $upstream_reg_left = $CDS_right - $current_to;
  }
  
  $upstream_reg_size =  $upstream_reg_right - $upstream_reg_left + 1;
  if ($upstream_reg_size <= 0) {
    $upstream_reg_size = 0;
  }
  
  
  
  ### upstream region ID and comments ####
  if (($CDS_as_id) || ($name eq "")) {
    $current_id = $CDS_id;
  } else {
    $current_id = "$name";
  }
  
  unless ($no_comments) {
    @comments = ("$query upstream sequence, from $current_from to $current_to, size $upstream_reg_size");
    @comments = (@comments, "upstream region size: $upstream_reg_size; upstream region location: $upstream_reg_left $upstream_reg_right $CDS_strand");
    @comments = (@comments, "Gene: $name; ID: $CDS_id; gene location: $CDS_left $CDS_right $CDS_strand");
  }
  
  ### substring retrieval
  ### beware! DNA is circular
  $current_seq = $chromosome{$chrom}->get_sequence($upstream_reg_left,$upstream_reg_right,$CDS_strand);
#    if (($upstream_reg_left <= 0) && ($upstream_reg_right > 0)) { 
#      $current_seq = substr($genome_seq, $genome_length + $upstream_reg_left - 1, -$upstream_reg_left + 1);
#      $current_seq .= substr($genome_seq,0,$upstream_reg_right);
#    } elsif (($upstream_reg_left <= 0) && ($upstream_reg_right <= 0)) { 
#      $current_seq = substr($genome_seq, $genome_length + $upstream_reg_left - 1, $upstream_reg_size);
#    } elsif (($upstream_reg_right > $genome_length) && ($upstream_reg_left <= $genome_length)) {
#      $current_seq = substr($genome_seq, $upstream_reg_left - 1, $genome_length - $upstream_reg_left + 1);
#      $current_seq .=  substr($genome_seq, 0, $upstream_reg_right - $genome_length);
#    } elsif (($upstream_reg_right > $genome_length) && ($upstream_reg_left > $genome_length)) {
#      $current_seq = substr($genome_seq, $upstream_reg_left - $genome_length + 1, $upstream_reg_size);
#    } else {
#      $current_seq = substr($genome_seq, $upstream_reg_left - 1, $upstream_reg_size);
#    }
  
#    ### reverse complement
#    if ($CDS_strand eq "<") {
#      $current_seq = &ReverseComplement($current_seq);
#    } else {
#      $current_seq = uc($current_seq);
#    }
  
    ### print result sequence
  &PrintNextSequence($out,$out_format,$linewidth,$current_seq,$current_id, @comments);
}

close $out;

###### verbose ######
if ($warn_level) {
  my $done_time = &AlphaDate;
  print $out "; Job started $start_time\n";
  print $out "; Job done    $done_time\n";
}



exit(0);



sub ReadCDSPositions {
  
  open CDS, "$feature_table_file" ||
    die "Cannot open CDS location file $feature_table_file\n";
  
  
  ### read CDS positions
  while (<CDS>) {
    next unless (/\S/);
    next if (/^;/);
    chomp;
    @fields = split "\t";
    foreach $f (keys %col) {
      ${$f} = $fields[$col{$f}];
    }
    
    next unless (($kind eq "CDS") || ($kind =~ /^gene$/i));
    
    next unless ($left < $right);
    ### we adopt Madison notation: orientation is ">" or "<" 
    ### Heli's notation: F (forward) or R (reverse)
    $strand =~ s/F/>/;
    $strand =~ s/R/</;
    
    ### D for Direct
    $strand =~ s/D/>/;
    
    ### Yeast notation: W (Watson) or C (Crick)
    $strand =~ s/W/>/;
    $strand =~ s/C/</;
  
    
    $left{$id} = $left;
    $right{$id} = $right;
    $strand{$id} = $strand;
    $name{$id} = $name;
    $CDS_id{uc($id)} = $id;
    $CDS_id{uc($name)} = $id;
  }
}


#  sub ReadGenomeSequence {
#      unless (open GENOME, "$genome_file") {
#  	die "Cannot open sequence file $genome_file\n";
#      }
#      ($genome_seq, $seq_id, @seq_comments) = &ReadNextSequence(GENOME, $genome_seq_format);
#      $genome_seq =~ s/\///g;    #### end of the Madison file
#      $genome_seq = &FoldSequence($genome_seq,0);
#      $genome_length = length($genome_seq);
#      $seq_id = "coli";
#      close GENOME;
#  #    print "$genome_file\n$seq_id\t$genome_length\n";
#  }


sub PrintHelp {
    open(HELP, "| more");
    print HELP<<End_help;
USAGE
	upstream-region -org organism	
			[-from] [-to] [-format seqformat] [-lw linewidth] 
			[-o outpufile] -q query_CDS | -i query file | -all
	
	returns the DNA sequence of a region located upstream from a query CDS.
	
OPTIONS
	-org organism
	     supported organisms : 
$supported_organisms
	-q query
		The query should be an CDS identifier (eg 'metR').
		The query is case-insensitive.
		Multiple queries can be entered by reiteratively using the -q 
		option.
        -i     query file. The first word of each line is taken as a query.
                This option is incompatible with -q.
	-all	return all genomic upstream regions
	-o	followed by the name of the outputfile. 
        -from #1 -to #2 
                where #1 and #2 are numbers. #2 should be higher than #1.
                limits of the region to extract, relative to CDS start 
                (=position 0). Use negative values for upstream sequence.
                        example: -from -800 -to -1 
                        will extract the 800 bp upstream the CDS start.
			 (this is the default)
	-format	allows to select different output formats, with the following 
		options:
		IG	IntelliGenetics (default format)
		WC	wconsensus format
		raw	only the sequence is returned, without spaces, newlines
			nor comments.
                FastA
	-lw ##	Line width. A newline character will be inserted in the 
		sequence every ## bases. Default is 60. 
		-lw 0 will prevent newline insertion.
        -id CDS Use CDS identifier instead of gene name in the output file
	-nocds	the upstream sequence can only contain non-coding sequence.
		i.e. the -from values is modified if a predicted CDS
		is encountered within its range. 
		The weaknesses of using this option are that
		- all predicted CDS do not correspond to real CDS,
		- there is no a priori reason to exclude a regulatory site
		  which would overlap the upstream coding sequence.
	-nocom	no comments. Only the identifier and the sequence are
		returned. By default, the comment indicates the CDS and
		upstream sequence coordinates.

INPUT FORMAT
	Sequence file
		Sequence file can adopt any format supported by RSA 
		(currently : fasta, IG, raw, multi, filelist)

	Feature file
		The feature file contains one line per feature, with
		tab-delimited columns providing the following information:
		column	field
		1	id	feature identifier
		2	kind	CDS for coding sequence
		3	name	feature name
		4	chrom	chomosome. 
				For bacteria, use the organism abbrev
		5	left	left end position
		6	right	right end position
		7	strand	D (direct) or R (reverse)
		8	descr	short description (optional)

EXAMPLES
	upstream-region -org coli -q metJ -from +59 -to -200
	
	will return the sequence of 260 nucleotides, 200of which 
	extracted upstream the start codon, and the 60 following being 
	the beginning of the coding sequence.

WEB VERSION
	http://www.ucmb.ulb.ac.be/bioinformatics/rsa-tools

End_help
    close HELP;
    exit;
}

sub PrintShortHelp {
  open(HELP, "| more");
  print HELP<<End_short_help;
upstream-region options
-----------------------
-org		organism
$supported_organisms
-i		query file. This option is incompatible with -q.
-q		query
-all		returns all genomic upstream regions
-o		followed by the name of the outputfile. 
-from #1 -to #2	limits of the region to extract, relative to CDS start 
-format		output sequence format. accepted: IG, raw, WC
-lw ##		Line width. -lw 0 will prevent newline insertion.
-id CDS		Use CDS identifier rather than gene name
-nocds		the upstream sequence can only contain non-coding sequence.
-nocom		do not print related information (start, end position, ...)
End_short_help
  close HELP;
  exit;
}


#### read arguments
sub ReadArguments {
  foreach $a (0..$#ARGV) {
    ### output file name
    if ($ARGV[$a] eq "-o") {
      $outputfile = $ARGV[$a+1];
      
      ### help request
    } elsif ($ARGV[$a] eq "-h") {
      &PrintHelp;
    } elsif ($ARGV[$a] eq "-help") {
      &PrintShortHelp;
      
      ### output sequence format
    } elsif ($ARGV[$a] eq "-format") {
      $out_format = lc($ARGV[$a+1]);
      
      ### limits of the region to retrieve
    } elsif (($ARGV[$a] eq "-from") && ($ARGV[$a+1] =~ /^[+-]{0,1}(\d+)$/)) {
      $upstream_reg_from = $ARGV[$a+1];
    } elsif (($ARGV[$a] eq "-to") && ($ARGV[$a+1] =~ /^[+-]{0,1}(\d+)$/)) {
      $upstream_reg_to = $ARGV[$a+1];
      
      ### verbose
    } elsif ($ARGV[$a] eq "-v") {
      $warn_level = 1;
      
      ### warn_level
    } elsif (($ARGV[$a] eq "-w") &&
	     (&IsNatural($ARGV[$a+1]))){
      $warn_level = $ARGV[$a+1];
      
      #### new query
    } elsif ($ARGV[$a] eq "-q") {
      @queries = (@queries, $ARGV[$a+1]);
      
      #### input file (one query per line)
    } elsif ($ARGV[$a] eq "-i") {
      $query_file =$ARGV[$a+1];
      
      ### return all genomic  upstream regions	
    } elsif ($ARGV[$a] eq "-all") {
      $return_all = 1;;
      
      #### organism
    } elsif ($ARGV[$a] eq "-org") {
      $organism =$ARGV[$a+1];
      
      
      #### line width
    } elsif (($ARGV[$a] eq "-lw") && ($ARGV[$a+1] >= 0)) {
      $linewidth = $ARGV[$a+1];
      
      #### use identifiers rather than gene names
    } elsif (($ARGV[$a] eq "-id") && (lc($ARGV[$a+1]) eq "cds")) {
      $CDS_as_id = 1;
      
      #### do not allow overlapping coding sequences
    } elsif (($ARGV[$a] =~ /^-nocds/i) || 
	     ($ARGV[$a] =~ /^-noorf/i)) {
      $no_CDS = 1;
      
      #### do not print the comments field
    } elsif ($ARGV[$a] =~ /^-nocom/i) {
      $no_comments = 1;
      
    }
  }
}
