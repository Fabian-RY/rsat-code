#!/usr/bin/perl -w
############################################################
#
# $Id: parse-go,v 1.1 2006/10/19 16:04:37 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

#use strict;


=pod

=head1 NAME

parse-go

=head1 DESCRIPTION

Parse Gene Ontology (GO) files, in order to convert them into
tab-delimited files.

The Gene Ontology defines a controlled vocabulary to describe
biological processes, molecular functions and cellular locations, as
well as a hierarchical classification between these terms (in the form
of a directed acyclici graph).

Gene Ontology annotations can be obtained from the GO web site
(http://www.geneontology.org/GO.downloads.shtml), and are included in
the genome annotations distributed by the NCBI
(ftp.ncbi.nih.gov/genomes).

=head1 AUTHORS

jvanheld@scmbb.ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE
    
parse-go [-i inputfile] [-o outputdir] [-v]

=head1 INPUT FORMAT

The "obo" format available on the the GO web site. 

=head1 OUTPUT FORMAT

A series of tab-delimited files. 

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
	push (@INC, "$`parsers/");
    }
}
require "RSA.lib";
use RSAT::util;
push @INC, "$RSA/perl-scripts/parsers/";
require "lib/load_classes.pl";
require "lib/util.pl";
require "lib/parsing_util.pl";




################################################################
#### GO term
package GO::Term;
{
  @ISA = qw ( classes::DatabaseObject );
  ### class attributes
  $_count = 0;
  $_prefix = "go:";
  @_objects = ();
  %_name_index = ();
  %_id_index = ();
  %_attribute_count = ();
  %_attribute_cardinality = (id=>"SCALAR",
			     name=>"ARRAY",
			     namespace=>"SCALAR",
			     subsetdef=>"ARRAY",
			     "remark"=>"ARRAY",
			     );
}

################################################################
## Main package
package main;
{

    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();


    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::in = STDIN;
    $main::out = STDOUT;

    &ReadArguments();

    ################################################################
    #### check argument values

    ################################################################
    ### Output directory
    unless (defined($dir{output})) {
      $dir{output} = 'parsed_go';
    }
    &RSAT::util::CheckOutDir($dir{output});

    ### open error report file
    $out_file{error} = "$dir{output}/go_parsing_errors.txt";    
    open ERR, ">$out_file{error}" 
	|| die "Error: cannot write error file $out_file{error}\n";

    ### open log file
    $out_file{log} = "$dir{output}/go_parsing_log.txt";    
    open LOG, ">$out_file{log}" 
	|| die "Error: cannot write log file $out_file{log}\n";

    $go_terms = classes::ClassFactory->new_class(object_type=>"GO::Term", prefix=>"ft_");

    ################################################################
    ##### read input
    ($main::in) = &OpenInputFile($main::infile{input});
    my $current_term;
    my $l=0;
    while (<$main::in>) {
      $l++;
      next unless (/\S/);
      if (/^\[Term\]/) {
	$current_term = $go_terms->new_object();
      } elsif (/^\[/) {
	$current_term = "";
      } elsif (!($current_term)) {
	print LOG $_;
	&RSAT::message::Warning(join("\t", "Skipping header line", $l, $_)) if ($main::verbose >= 3);
	next;
      } elsif (/^id:\s+(\S+)/) {
	$current_term->force_attribute("id", $1);
      } elsif (/^(\S+):\s+(\S.*)$/) {
	my $key = $1;
	my $value = $2;
	$current_term->new_attribute_value($key, $value);
	if (($key='relationship') && ($value = /part_of (\S+)/)) {
	  $current_term->push_attribute("part_of", $1);
	}
      } else {
	&RSAT::message::Warning(join("\t", "Skipping line", $l, $_)) if ($main::verbose >= 0);
      }
    }
    close $main::in if ($main::infile{input});
    
    ################################################################
    #### print verbose
    &Verbose() if ($main::verbose);
    
    ################################################################
    ###### execute the command
    
    ################################################################
    ###### print output
    $go_terms->dump_tables();
    
    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    

     
    ################################################################
    ###### close output stream
    close LOG;
    close ERR;
    &RSAT::message::Info("Output directory", $dir{output});
    &RSAT::message::Info("Log file", $out_file{log});
    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
#    foreach my $a (0..$#ARGV) {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();
	    

	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

The input file should be a .obo file, as those available on the GO web
site.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);
	    
	    ## Output file
=pod

=item	B<-o output directory>

This directory will contain the parsed files.

If no output directory is specified, the results are stored in a
directory named "parsed_go".

=cut
	} elsif ($arg eq "-o") {
	    $main::dir{output} = shift(@arguments);
	    
	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; parse-go ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    print $main::out "; Output dir\t",$dir{output},"\n";
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=cut
