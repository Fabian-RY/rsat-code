#!/usr/bin/perl -w
############################################################
#
# $Id: colsplit,v 1.3 2002/03/21 09:12:54 jvanheld Exp $
#
# Time-stamp: <2002-03-21 10:11:00 jvanheld>
#
############################################################
#use strict;;
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";


#### initialise parameters ####
my $start_time = &AlphaDate;

local $output_dir = ".";
local $column = 1;
local $prefix = "";
local $suffix = "";
local $full_line = 1;
local @output_fields = ();

local %infile = ();
local %outfile = ();
local %counts = ();


local $verbose = 0;
local $in = STDIN;
local $out = STDOUT;
local $separator = "\t";

&ReadArguments;


#### check argument 

#### check existence of output dir
unless (-d $output_dir) {
    `mkdir -p $output_dir`;
    unless (-d $output_dir) {
	&FatalError("Cannot create output directory $output_dir");
    }
}

##### read input #####
$in = &OpenInputFile($infile{input});
while (my $line = <$in>) {
    chomp $line;
    next if ($line =~ /^;/); #### ignore comment lines
    next if ($line =~ /^\#/); #### ignore comment lines
    next if ($line =~ /^\-\-/); #### ignore comment lines
    next unless ($line =~ /\S/); #### ignore empty lines
    my @fields = split $separator, $line;
    my $pattern = $fields[$column-1];
#    unless (defined($$pattern)) {
    my $filename = $output_dir."/".$prefix.$pattern.$suffix;
    if ($counts{$pattern}) {
	open OUT, ">>$filename";
    } else {
	open OUT, ">$filename";
    }
    $counts{$pattern}++;
    if ($full_line) {
	print OUT $line, "\n";
    } else {
	print OUT join $separator, @fields[@output_fields];
	print OUT "\n";
    }
    close OUT;
#	warn "opening $filename\n" if ($verbose >=1);
#	open ${$pattern}, ">$filename"
#	    || &FatalError ("Cannot write file $filename");
#	push @patterns, $pattern;
#    }
#    print ${$pattern} $line;
}

close $in if ($infile{input});

#### verbose ####
&Verbose if ($verbose);

###### execute the command #########


###### print output ######


###### verbose ######
if ($verbose) {
    my $done_time = &AlphaDate;
    print $out "; Job started $start_time\n";
    print $out "; Job done    $done_time\n";
}


###### close output file ######
close $out if ($outfile{output});


exit(0);


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	colsplit

        2001 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        colsplit [-i inputfile] [-o outputfile] [-v]

DESCRIPTION

	Splits a file accoding to the content of a specified column
	(the pattern column).

	A separate output file will be gnerated for each distinct
	value of the specified column of the input file.

OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.
	-prefix prefix for output file names
	-suffix suffix for output file names
		Each output file name starts with the prefix, followed
		by the value of the pattern column, followed by the 
		suffix. 
	-c pattern column (default $column)
	-sep field separator
	        (default \\t)
	-outdir	output directory
	-fields	output fields
		output fields are olumn numbers, separated by commas.
		Example:
			-fields 1,3,2
End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
colsplit options
----------------
-h	(must be first argument) display full help message
-help	(must be first argument) display options
-v	verbose
-i	input file
-prefix	prefix for output file names
-suffix	suffix for output file names
-c	pattern column (default $column)
-sep	field separator (default \\t)
-outdir	output directory
-fields	output fields
End_short_help
  close HELP;
  exit;
}


sub ReadArguments {
#### read arguments ####
    foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions;
	    
	    ### input file ###
	} elsif ($ARGV[$a] eq "-i") {
	    $infile{input} = $ARGV[$a+1];
	    
	    ### output file prefix
	} elsif ($ARGV[$a] eq "-prefix") {
	    $prefix = $ARGV[$a+1];
	    
	    ### output file suffix
	} elsif ($ARGV[$a] eq "-suffix") {
	    $suffix = $ARGV[$a+1];
	    
	    ### output directory
	} elsif ($ARGV[$a] eq "-outdir") {
	    $output_dir = $ARGV[$a+1];
	    
	    ### field separator
	} elsif ($ARGV[$a] eq "-sep") {
	    $separator = $ARGV[$a+1];
	    
	    ### outpput fields
	} elsif ($ARGV[$a] eq "-fields") {
	    $full_line = 0;
	    @output_fields = split ",", $ARGV[$a+1];
	    foreach $field (@output_fields) {
		unless (&IsNatural($field)) {
		    &FatalError("Field columns must be natural numbers");
		}
		unless ($field >=1)  {
		    &FatalError("Field columns must be strictly positive");
		}
	    }
	    for $f (0..$#output_fields) {
		$output_fields[$f] -= 1;
	    }
	    
	    ### pattern column
	} elsif ($ARGV[$a] eq "-c") {
	    $column = $ARGV[$a+1];
	    unless (&IsNatural($column)) {
		&FatalError("Pattern column must be a natural number");
	    }
	    unless ($column >=1)  {
		&FatalError("Pattern column must be strictly positive");
	    }

	}
    }
}

sub Verbose {
    print $out "; colsplit ";
    &PrintArguments($out);
    if (defined(%infile)) {
	print $out "; Input files\n";
	while (($key,$value) = each %infile) {
	    print $out ";\t$key\t$value\n";
	}
    }
    if (defined(%outfile)) {
	print $out "; Output files\n";
	while (($key,$value) = each %outfile) {
	    print $out ";\t$key\t$value\n";
	}
    }
    if ($full_line) {
	print $out "; Full line output\n";
    } else {
	print $out "; Output fields\t",join (",", @output_fields),"\n";	
    }
    print $out "; Pattern counts\n";
    foreach my $pattern (keys %counts) {
	print $out ";\t$pattern\t$counts{$pattern}\n";
    }
}
