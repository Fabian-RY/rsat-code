#!/usr/bin/perl -w
############################################################
#
# $Id: convert-graph,v 1.14 2007/05/23 09:59:49 rsat Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

## use strict;

=pod

=head1 NAME

convert-graph

=head1 DESCRIPTION

Convert graphs between diffferent formats. 

In the current state, the only supported input format are 
tab-delimited file and gml file. Various output format are already supported (dot,
gml, tab).

In the future, there should be as many input as output formats (the
program should perform interconversions between any supported format).

The programs also allows to return a randomized graph with the same number of edges, and 
each node keeping the same number of neighbours.

=head1 AUTHORS

jvanheld@scmbb.ulb.ac.be
sylvain@scmbb.ulb.ac.be

=head1 CATEGORY

util



=head1 USAGE
    
convert-graph [-i inputfile] [-o outputfile] [-from tab|gml] [-to format tab|dot|gml] [-random #] [-arc_id] [-v #]

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph2;


################################################################
## Main package
package main;
{

    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();

    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
#    $main::in = STDIN;
    $main::out  = STDOUT;
    
    ## arc_id_option
    $arc_id_option = 0;

    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	tab=>1,
	gml=>1
    );
    $supported_input_formats = join (",", keys %supported_input_format);
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;
    local $color_col = 0;

    ## Output formats
    local $output_format = "dot";
    %supported_output_format =(
			       dot=>1,
			       gml=>1,
			       tab=>1
			       
    );
    $supported_output_formats = join (",", keys %supported_output_format);

    # return a randomized graph
    $random = 0;
    
    &ReadArguments();

    ################################################################
    #### check argument values
    if ($random > 1 && !defined($main::outfile{output})) {
       &RSAT::error::FatalError("You must specify an output file prefix when more than one random graph is required");
    }

    ################################################################
    ## Initialize the graph
    my $graph = new RSAT::Graph2();
    $graph->set_attribute("label", "graph");
    
    ################################################################
    ##### read input
    $graph->graph_from_text($input_format, $main::infile{input}, $source_col, $target_col, $weight_col, 0, 0,$color_col);
    
    ################################################################
    ###### print output
    if ($random) {
      if ($random == 1) {
        &RSAT::message::Info("Randomizing graph") if ($main::verbose >= 2);
        $graph = $graph->randomize();
        $main::out = &OpenOutputFile($main::outfile{output});
        if ($output_format eq "tab") {
	  $main::verbose_out = $main::out;
        } else {
	  $main::verbose_out = STDOUT;
        }
        print $out $graph->to_text($output_format, $arc_id_option);        
      } else {
        for (my $i = 1; $i <= $random; $i++) {
          &RSAT::message::Info("\t", "Randomizing graph",$i) if ($main::verbose >= 2);;
          $graph = $graph->randomize();
          my $outputfile = $main::outfile{output}."_".$i.".".$output_format;
          $main::out = &OpenOutputFile($outputfile);
          if ($output_format eq "tab") {
	    $main::verbose_out = $main::out;
          } else {
	    $main::verbose_out = STDOUT;
          }
          print $out $graph->to_text($output_format, $arc_id_option);
        }
      }
    } else {
      ### open output streams
      $main::out = &OpenOutputFile($main::outfile{output});
      if ($output_format eq "tab") {
	$main::verbose_out = $main::out;
      } else {
	$main::verbose_out = STDOUT;
      }
      #### print verbose
      &Verbose() if ($main::verbose);
      print $out $graph->to_text($output_format, $arc_id_option);
    }
    
    
    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::verbose_out "; Job started $start_time\n";
	print $main::verbose_out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ###### close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
#    foreach my $a (0..$#ARGV) {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    
=pod

=item B<-random [#]>

The program will return a randomized graph, shuffling the edges but keeping the node degree.
If more than one random graph is required, you may specify a number following this option. In that case, you must use the -o option (without any extension).

=cut
	} elsif ($arg eq "-random") {
	  $random=1;
	  if (defined($arguments[0]) && $arguments[0] !~ /^-/) {
	    $random = shift(@arguments);
	  } 

		    	    
	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ### Input format  
=pod

=item B<-from input_format>

Input format. Supported: tab, gml

=cut
	} elsif ($arg eq "-from") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});


	    ### Output format  
=cut

=item B<-to output_format>

Output format. Supported: tab, dot, gml

=cut 
	} elsif ($arg eq "-to") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});


	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes. 

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes. 

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight nodes. 

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }
=pod

=item B<-ccol>

Edge color column. Column containing the color of the edges(RGB). 

=cut
	} elsif ($arg eq "-ccol") {
	    $color_col = shift (@arguments);
	    unless (&IsNatural($color_col) && ($color_col > 0)) {
		&RSAT::error::FatalError(join("\t", $color_col, "Invalid value for the color column. Must be a strictly positive natural number"));
	    }
=pod


=item B<-arc_id>

Adds a unique id for each arc when using the tab-delimited output. 

=cut
	    	    
	} elsif ($arg eq "-arc_id") {
	    $arc_id_option = 1;

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::verbose_out "; convert-graph ";
    &PrintArguments($main::verbose_out);
    if (defined(%main::infile)) {
	print $main::verbose_out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::verbose_out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=item I<compare-graphs>

=item I<compare-graph-clusters>

=item I<convert-graph>

=item I<graph-get-clusters>

=item I<graph-neighbours>

=item I<graph-node-degree>

=item I<graph-set-attributes>

=cut
