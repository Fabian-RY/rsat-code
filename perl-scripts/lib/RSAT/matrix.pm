###############################################################
#
# Manipulation of Position-Specific Scoring Matrices (PSSM)
#
package RSAT::matrix;

require "RSA.seq.lib";

use RSAT::GenericObject;
@ISA = qw( RSAT::GenericObject );

=pod

=head1 NAME

    RSAT::matrix

=head1 DESCRIPTION

Main class for manipuating profile matrices (also called PSSM,
Position-Specific Scoring Matrices, alignment matrices,
position-weight matrices).

PSSM can be used to represent the binding specificity of a transcription
factor or the conserved residues of a protein domain.

Each row of the matrix corresponds to one residue (nucleotide or
amino-acid depending on the sequence type).  Each column corresponds
to one position in the alignment.  The value within each cell
represents the frequency of each residue at each position.

This converter takes as input PSSM generated by different pattern
discovery programs (consensus, gibbs, MEME, MotifSampler), and exports
them in different formats.

=head1 OUTPUT FORMATS

=over

=item alignment

Each cell of the matrix indicates the number of occurrences of the
residue at a given position of the alignment.

=item crude frequencies

Relative frequencies are calculated as the counts of residues divided
by the total count of the column.

S<Fij=Cij/SUMi(Cij)>

where 

=over

=item Cij 

is the absolute frequency (counts) of residue i at position j of the alignment

=item Fij

is the relative frequency of residue i at position j of the alignment

=back


=item frequencies corrected with pseudo-weights

Relative frequencies can be corrected by a pseudo-weight (b) to reduce
the bias due to the small number of observations.

S<F''ij=Cij+b*Pi/[SUMi(Cij)+b]>

where 

=over

=item Pi 

is the prior frequency for residue i

=item b

is the pseudo-weight, which is "shared" between residues according to
their prior frequencies.

=back



=item weights

Weights are calculated according to the formula from Hertz (1999), as
the natural logarithm of the ratio between the relative frequency
(corrected for pseudo-weights) and the prior residue probability.

S<Wij=ln(F''ij/Pi)>

=item information

The crude information content is calculated according to the formula
from Hertz (1999).

S<Iij = Fij*ln(Fij/Pi)>

In addition, we calculate a "corrected" information content which
takes pseudo-weights into account.

S<I''ij = F''ij*ln(F''ij/Pi)>


=item parameters

Returns a series of parameters associated to the matrix. The list of
parameters to be exported depends on the input formats (each pattern
discovery program returns specific parameters, which are more or less
related to each others but not identical).

Some additional parameters are optionally calculated

=over

=item consensus

The degenerate consensus is calculated by collecting, at each
position, the list of residues with a positive weight. Contrarily to
most applications, this consensus is thus weighted by prior residue
frequencies: a residue with a high frequency might not be represented
in the consensus if this frequency does not significantly exceed the
expected frequency.

=item information

The total information is calculated by summing the information content
of all the cells of the matrix. This parameters is already returned by
the program consensus (Hertz), but not by other programs.

=back

=back

=head1 METHODS

=over

=cut


################################################################
=pod

=item new()

Create an empty matrix.

=cut
sub new {
    my ($class, %args) = @_;
    my $matrix = bless {
	nrow=>0,
	ncol=>0
	}, $class;
    return $matrix;
}

################################################################
=pod

=item setAlphabet(@alphabet)

Specify the alphabet (i.e. the list of valid letters) for the matrix.

=cut
sub setAlphabet {
    my ($self, @new_alphabet) = @_;
    @{$self->{alphabet}} = @new_alphabet;	

#    warn join("\t", "; Alphabet", $self->getAlphabet()), "\n" if ($main::verbose >= 10);
    
    ## update the number of columns
    $self->force_attribute("nrow", scalar(@alphabet));
} 


################################################################
=pod

=item reset()

Empty the matrix

=cut
sub reset {
    my ($self) = @_;
    warn "Resetting the matrix to empty\n" if ($main::verbose >= 5);
    undef(@{$self->{alphabet}});
    undef(@{$self->{matrix}});
    $self->force_attribute("nrow", 0);
    $self->force_attribute("ncol", 0);
}


################################################################
=pod

=item getPrior()

Return prior frequencies. If these were not defined previously,
estimate them on the basis of equiprrobable residues. 

=cut
sub getPrior() {
    my ($self) = @_;
    my %prior = ();
    if ($self->get_attribute("prior_specified")) {
	%prior = $self->get_attribute("prior");
    } else {
	if (scalar(keys %prior) <= 0) {
	    &main::Warning( "No prior defined: using equiprobable residues");
	    my @alphabet = $self->getAlphabet();
	    my $alphabet_size = scalar(@alphabet);
	    foreach my $letter (@alphabet) {
		$prior{$letter} = 1/$alphabet_size;
		warn join "\t", ";", $letter, $prior{$letter}, "\n" if ($main::verbose >= 10);
	    }
	    $self->setPrior(%prior);
	}
    }
    if ($main::verbose >= 10) {
	foreach my $letter (sort keys %prior) {
	    warn join("\t", "; prior", $letter, $prior{$letter}), "\n";
	}
    }
    return %prior;
}

################################################################
=pod 

=item setPrior(%prior)

Specify prior frequencies. The priors are provided as a hash table,
where keys are residues and values prior probabilities.

=cut
sub setPrior {
    my ($self, %prior) = @_;
    $self->set_hash_attribute("prior", %prior);
    $self->force_attribute("prior_specified", 1);
}

################################################################
=pod

=item getAlphabet()

Return the list of valid letters for the matrix

=cut
sub getAlphabet {
    my ($self) = @_;
    return @{$self->{alphabet}};
}

################################################################
=pod

=item addColumn()

Add a new column to the matrix

=cut
sub addColumn {
    my ($self,@new_col) = @_;
#	push @{$self->{matrix}}, [@new_col];
    
    
    warn ("Matrix: adding column\t", join (" ", @new_col), "\n") if ($main::verbose >= 5);
    
    ## Update number of columns
    my $ncol = $self->ncol()+1;
    $self->force_attribute("ncol", $ncol);
    warn ("Matrix: updating number of columns\t", $self->ncol(), "\n") if ($main::verbose >= 5);
    
    ## update number of rows
    my $column_size = scalar(@new_col);
    if ($column_size >= $self->nrow()) {
	warn ("Matrix: updating number of rows\t", $column_size, "\n") if ($main::verbose >= 5);
	$self->force_attribute("nrow", scalar(@new_col));
    }
    
    ## update matrix content
    for my $r (0..$#new_col) {
	${$self->{matrix}}[$ncol-1][$r] = $new_col[$r];
    }
}

################################################################
=pod

=item addRow(@new_row)

Add a new row to the matrix

=cut
sub addRow {
    my ($self,@new_row) = @_;
    
    ## Update number of rows
    my $nrow = $self->nrow()+1;
	$self->force_attribute("nrow", $nrow);
    warn ("Matrix: updating number of rows\t", $self->nrow(), "\n") if ($main::verbose >= 5);
    
    ## update number of colmuns
    my $row_size = scalar(@new_row);
    if ($row_size >= $self->ncol()) {
	warn ("Matrix: updating number of columns\t", $row_size, "\n") if ($main::verbose >= 5);
	$self->force_attribute("ncol", scalar(@new_row));
    }
    
    ## update matrix content
    for my $c (0..$#new_row) {
	${$self->{matrix}}[$c][$nrow-1] = $new_row[$c];
    }
}

################################################################
=pod

=item addIndexedRow($index, @new_row)

Add a new row and append its symbol to the alphabet

=cut
sub addIndexedRow {
    my ($self, $index, @new_row) = @_;
    $self->addRow(@new_row);
    push @{$self->{alphabet}}, $index;
}

################################################################
=pod

=item ncol()

Return number of columns

=cut
sub ncol {
    my ($self) = @_;
    return $self->get_attribute("ncol");
}

################################################################
=pod

=item nrow()

Return number of rows

=cut
sub nrow {
    my ($self) = @_;
    return $self->get_attribute("nrow");
}

################################################################
=pod

=item getParameters()

Return the list of parameters associated to the matrix

=cut
sub getParameters {
    my ($self) = @_;
    return @{$self->{parameters}};
}

################################################################
=pod

=item size()

Return matrix size

=cut
sub size {
    my ($self) = @_;
    return ($self->nrow(), $self->ncol());
}


################################################################
=pod

=item getMatrix()

Return the whole matrix as a vector

=cut
sub getMatrix {
    my ($self) = @_;
    return @{$self->{matrix}};
}

################################################################
=pod

=item setMatrix($nrow, $ncol, @matrix)

Specify the whole matrix

=cut
sub setMatrix {
    my ($self,$nrow, $ncol, @matrix) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{matrix}} = @matrix;
}


################################################################
=pod

=item setCell($row, $col, $value)

Specify the content of a single cell. 

=cut
sub setCell {
    my ($self,$row, $col, $value) = @_;
#    warn join("\t", "Setting cell", 
#	      "row", $row, 
#	      "column", $col, 
#	      "value", $value), "\n" 
#		  if (main::verbose >= 10); 
    ${$self->{matrix}}[$col-1][$row-1] = $value;
}


################################################################
=pod

=item getCell($row, $col)

Return the content of a single cell. 

=cut
sub getCell {
    my ($self,$row, $col) = @_;
    return ${$self->{matrix}}[$col-1][$row-1];
}



################################################################
=pod

=item readFromFile($file, $format)

Read a matrix from a file

=cut
sub readFromFile {
    my ($self, $file, $format) = @_;
    if (($format =~ /consensus/i) || ($format =~ /^wc/i)) {
	$self->_readFromConsensusFile($file);
    } elsif ($format =~ /gibbs/i) {
	$self->_readFromGibbsFile($file);
    } elsif ($format =~ /MotifSampler/i) {
	$self->_readFromMotifSamplerFile($file);
    } elsif ($format =~ /meme/i) {
	$self->_readFromMEMEFile($file);
    } else {
	&main::FatalError("Invalid format for reading matrix\t$format");
    }

    ## Check that the matrix contains at least one row and one col
    if (($self->nrow() > 0) && ($self->ncol() > 0)) {
	warn join("\t", "; Matrix read", 
		  "nrow = ".$self->nrow(),
		  "ncol = ".$self->ncol(),
		  ), "\n" if ($main::verbose >= 2);
    } else {
#	&main::Warning("The file $file does not seem to contain a matrix in format $format. Please check the file format and contents.");
	&main::FatalError("The file $file does not seem to contain a matrix in format $format. Please check the file format and contents.");
    }
}


################################################################
=pod

=item _readFromGibbsFile($file)

Read a matrix from a gibbs file. This method is called by the method 
C<readFromFile($file, "gibbs")>.

=cut
sub _readFromGibbsFile {
    my ($self, $file) = @_;
    
    ## open input stream
    my $in = STDIN;
    if ($file) {
	open INPUT, $file;
	$in = INPUT;
    }
    $in_matrix = 0;
    my @matrix = ();
    my @alphabet = ();
    my $ncol = 0;
    my $nrow = 0;
    my $last_ncol = 0;
    my $last_nrow = 0;
    while (<$in>) {
	next unless (/\S/);
	chomp();
	if (/Information \(relative entropy\) contribution in tenth bits\:/) {
	    $in_matrix = 1;
	    $self->setAlphabet("A","C","G","T");   # default nucletodide alphabet
	    next;
	} elsif (/site/) {
	    ### Empty the previous matrix because it was not the definitive result
	    $in_matrix = 0;
	    @last_matrix = @matrix;
	    $last_nrow = $nrow;
	    $last_ncol = $ncol;
	    @matrix = ();
	    $nrow = 0;
	    $ncol = 0;
#		$self->reset();
	    next;
	} elsif ((/^\s*POS/) && ($in_matrix)) {
	    chomp;
	    @header = split " +";
	    @alphabet = @header[1..$#header-1];
#		$self->setAlphabet(@alphabet);
	} elsif (/model map = (\S+); betaprior map = (\S+)/) {
	    $self->set_attribute("model.map", $1);
	    $self->push_attribute("parameters", "model.map");
	    $self->set_attribute("betaprior.map", $2);
	    $self->push_attribute("parameters", "betaprior.map");
	} elsif (/MAP = (\S+)/) {
	    $self->force_attribute("MAP", $1);
	    $self->push_attribute("parameters", "MAP");
	} elsif (/seed: (\S+)/) {
	    $self->force_attribute("seed", $1);
	    $self->push_attribute("parameters", "seed");
	} elsif (/^gibbs /) {
	    $self->set_attribute("command", $_);
	    $self->push_attribute("parameters", "command", "STRING");
	} elsif ($in_matrix) {
	    ## Add a column to the matrix (gibbs rows correspond to our columns)
	    chomp;
	    s/^\s+//;
	    @fields = split " +";
	    @values = @fields[1..$#header-1];
	    $nrow = scalar(@values);
	    foreach my $v (0..$#values) {
		$values[$v] =~ s/^\.$/0/;
		$matrix[$ncol][$v] = $values[$v];
	    }
	    $ncol++;
	}
    }
    close $in if ($file);

    $self->setAlphabet (@alphabet);
    $self->force_attribute("nrow", $last_nrow);
    $self->force_attribute("ncol", $last_ncol);
    $self->setMatrix ($last_nrow, $last_ncol, @last_matrix);
}


################################################################
=pod

=item _readFromConsensusFile($file)

Read a matrix from a consensus file. This method is called by the
method C<readFromFile($file, "consensus")>.

=cut
sub _readFromConsensusFile {
    my ($self, $file) = @_;
    warn ("; Reading matrix from consensus file\t",$file, "\n") if ($main::verbose >= 2);
    
#	($in, $dir) = &main::OpenInputFile($file);
#
#	die "HELLO\t", $in, "\t", $dir;
    
    ## open input stream
    my $in = STDIN;
    if ($file) {
	open INPUT, $file;
	$in = INPUT;
    }
    my $current_matrix_nb = 0;
    while (<$in>) {
	next unless (/\S/);
	chomp();
	if (/COMMAND LINE: /) {
	    $command = $';
	    $self->set_attribute("command", $command);
	    $self->push_attribute("parameters", "command", "STRING");
	} elsif (/MATRIX\s(\d+)/) {
	    $current_matrix_nb = $1;
	    next;
	} elsif (/letter\s+\d:\s+(\S).+prior frequency =\s+(\S+)/) {
	    my $letter = $1;
	    my $prior = $2;
#		die join "\t", "HELLO", $letter, $prior, "\n";
	    $self->add_hash_attribute("prior",$letter, $prior);
	    $self->force_attribute("prior_specified", 1);
	} elsif  ($current_matrix_nb == 1) {
	    if (/^\s*(\S)\s+\|/) {
		my @fields = split / +/, $_;
		## residue associated to the row
		my $residue = shift @fields;
		
		## skip the | between residue and numbers
		shift @fields unless &main::IsReal($fields[0]);	
		
		$self->addIndexedRow($residue, @fields);
		
	    } elsif (/number of sequences = (\d+)/) {
		$self->set_attribute("nb.sequences", $1); 
		$self->push_attribute("parameters", "nb.sequences");
	    } elsif (/unadjusted information = (\S+)/) {
		$self->set_attribute("unadjusted.information", $1); 
		$self->push_attribute("parameters", "unadjusted.information");
	    } elsif (/sample size adjusted information = (\S+)/) {
		$self->set_attribute("adjusted.information", $1); 
		$self->push_attribute("parameters", "adjusted.information");
	    } elsif (/ln\(p\-value\) = (\S+)   p\-value = (\S+)/) {
		$self->set_attribute("ln.Pval", $1); 
		$self->push_attribute("parameters", "ln.Pval");
		$self->set_attribute("Pval", $2); 
		$self->push_attribute("parameters", "Pval");
	    } elsif (/ln\(expected frequency\) = (\S+)   expected frequency = (\S+)/) {
		$self->set_attribute("ln.exp", $1); 
		$self->push_attribute("parameters", "ln.exp");
		$self->set_attribute("exp", $2); 
		$self->push_attribute("parameters", "exp");
	    }
	}
    }
    close $in if ($file);
}


################################################################
=pod

=item init

Initialize the matrix.

=cut

sub init {
    my ($self) = @_;

    ## initialize the matrix
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    warn "Initializing the matrix $nrow rows, $ncol columns\n" if ($main::verbose >= 5);
    foreach my $r (1..$nrow) {
	foreach my $c (1..$ncol) {
	    $self->setCell($r,$c,0);
	}
    }
#    warn $self->toString() if ($verbose >= 10);

}

################################################################
=pod

=item _readFromMEMEFile($file)

Read a matrix from a MEME file. This method is called by the
method C<readFromFile($file, "MEME")>.

=cut

sub _readFromMEMEFile {
    my ($self, $file) = @_;
    warn ("; Reading matrix from consensus file\t",$file, "\n") if ($main::verbose >= 2);
    
    ## open input stream
#    ($in, $dir) = &main::OpenInputFile($file);
    my $in = STDIN;
    if ($file) {
	open INPUT, $file;
	$in = INPUT;
    }

    my $current_matrix_nb = 0;
    my $current_col = 0;
    my $in_proba_matrix = 0;
    my $in_blocks = 0;
    my $width_to_parse = 0;
    my %alphabet = ();
    my @frequencies = ();
#    my @matrix = ();
    my $parsed_width = 0;
    while (<$in>) {
	next unless (/\S/);
	chomp();
	$_ = &main::trim($_);
	if (/MOTIF\s+(\d+)\s+width =\s+(\d+)\s+sites =\s+(\d+)\s+llr =\s+(\d+)\s+E-value =\s+(\S+)/) {
	    warn "Parsing matrix parameters\n" if ($main::verbose >= 5);

	    $current_matrix_number = $1;
	    $width_to_parse = $2;
	    $self->set_attribute("ncol", $2);
	    $self->set_attribute("sites", $3);
	    $self->push_attribute("parameters", "sites");
	    $self->set_attribute("llr", $4);
	    $self->push_attribute("parameters", "llr");
	    $self->set_attribute("E-value", $5);
	    $self->push_attribute("parameters", "E-value");
	    
	    $self->init();
#	    @matrix = $self->getMatrix();

#	    warn $self->toString() if ($main::verbose >= 0);

	    ## Parse alphabet
	} elsif (/Letter frequencies in dataset/) {
	    warn "Reading letter frequencies\n" if ($main::verbose >= 5);
	    my $alphabet = <$in>;
	    $alphabet = &main::trim($alphabet);
	    %residue_frequencies = split /\s+/, $alphabet;

	    $self->setPrior(%residue_frequencies);

	    my @alphabet = sort (keys %residue_frequencies);
	    $self->setAlphabet(@alphabet);
	    
	    ## Index the alphabet
	    foreach my $l (0..$#alphabet) {
		$alphabet{$alphabet[$l]} = $l;
	    }

	    ## Specify the number of rows of the matrix
	    $self->force_attribute("nrow", scalar(@alphabet));

	    ## Parse BLOCKS format
	} elsif (/Motif (\d+) in BLOCKS format/) {
	    $current_matrix_number = $1;
	    $in_blocks = 1;
	    warn "; Starting to parse BLOCKS format\n" if ($main::verbose >= 5);
	} elsif ($in_blocks) {
	    if (/(\S+)\s+\(\s*\d+\)\s+(\S+)/) {
		my $seq_id = $1;
		my $seq = $2;
		my @letters = split "|", $seq;
		$parsed_width = &main::max($parsed_width, scalar(@letters));
		warn join ("\t", ";\tAdding site", $seq_id, $seq, scalar(@letters)), "\n" 
		    if ($main::verbose >= 5);
		foreach my $c (0..$#letters) {
		    my $row = $alphabet{$letters[$c]};
#		    warn join ("\t","Incrementing column", $c, "row", $row, "letter", $letters[$c]), "\n" if ($main::verbose >= 10);
		    ${$self->{matrix}}[$c][$row]++;
#		    $matrix[$c][$row]++;
		}
#		warn $self->toString() if ($main::verbose >= 10);
		
	    } elsif (/\/\//) {
		warn "; BLOCKS format parsed\n" if ($main::verbose >= 5);
#		$self->setMatrix(@matrix);
#		$self->force_attribute("ncol", $parsed_width);
#		print join( ":", $self->toString()), "\n" if ($main::verbose >= 10);
		$in_blocks = 0;
	    }
	    
#	} elsif (/Motif (\d+) position-specific probability matrix/) {
#	    $current_matrix_number = $1;
#	    $in_proba_matrix = 1;
#	    warn ("; Parsing motif $current_matrix_number\n") if ($main::verbose >= 0);
#	    next;
#	}
#	if (/letter-probability matrix: alength= (\d+) w= (\d+) n= (\d+) E= (\S+)/) {
#	    warn join ("\t", 
#		       $1." rows",
#		       $2." columns",
#		       "n=".$3,
#		       "E=".$4,
#		       ), "\n" if ($main::verbose >= 1);
#	    $self->force_attribute("nrow", $1);
#	    $width_to_parse = $2;
#	    $self->set_attribute("n", $3);
#	    $self->push_attribute("parameters", "n");
#	    $self->set_attribute("E", $4);
#	    $self->push_attribute("parameters", "E");
#	} elsif ($in_proba_matrix) {
#	    $current_col++;
#	    my @fields = split /\s+/;
#	    warn (join "\t", @fields, "\n") if ($main::verbose >= 0);
#	    
#	    foreach my $r (0..$#fields) {
#		$frequencies[$current_col-1][$r] = $fields[$r];
#	    }
#	    
#	    ## Terminate the reading of this matrix
#	    if ($current_col == $width_to_parse) {
#		warn "; Read ".$current_col." columns\n" if ($main::verbose >= 0);
#		$in_proba_matrix = 0;
#		$self->setFrequencies(@frequencies);
#	    }
	}
    }
    close $in if ($file);
}

################################################################
=pod

=item _readFromMotifSamplerFile($file)

Read a matrix from a MotifSampler file. This method is called by the
method C<readFromFile($file, "MotifSampler")>.

TO BE IMPLEMENTED

=cut

sub _readFromMotifSamplerFile {
    &FatalError("The MotifSampler format is not yet supported in this version of the program.");
}

################################################################
=pod

=item _addSeparator($sep, $col_width, $type, $ncol, $to_print)

Print a separator between header/footer and matrix

=cut

sub _addSeparator {
    my ($self, $sep, $col_width, $type, $ncol, $to_print) = @_;
    if (($col_width) && ($col_width < 6)){
	$to_print .= ";-";
    } else {
	$to_print .= "; -----";
    }
    $to_print .= $sep."|-";
    for $c (0..($ncol-1)) {
	if ($col_width) {
	    $to_print .= "-"x($col_width-1);
	} else {
	    $to_print .= "-"x7;
	}
	$to_print .= "|";
    }
    $to_print .= "\n";
    return $to_print;
}

################################################################
=pod

=item toString(sep=>$sep, col_width=>$col_width, type=>$type)

Return a string description of the matrix in the same format as Jerry
Hertz programs. Additional parameters are also exported as comments,
when the verbosity is > 0.

=cut
sub toString {
    my ($self, %args) = @_;
    my $to_print = "";

    ## Matrix type
    $type = $args{type} || "alignment";

    %supported_types = (alignment=>1,
			frequencies=>1,
			weights=>1,
			information=>1,
			parameters=>1
			);
    &main::FatalError("Invalid matrix type $type") unless $supported_types{$type};

    ## Format for the matrix entries
    my $sep = $args{sep} || "\t";
    my $col_width = $args{col_width};
    my $number_width = 0;
    if ($col_width) {
	$number_width = $col_width - 1;
    }
    my $decimals = $args{decimals};
    unless ($decimals) {
	if ($type eq "alignment") {
	    $decimals = 0;
	} else {
	    $decimals = $number_width - 2;
	}
    }

    
    ################################################################
    ## Print parameters
    if ($type eq "parameters") {
	$to_print .= ";\n";
	$to_print .= "; Matrix parameters\n";
	
	## Matrix size
	$to_print .= ";\t".$self->ncol()."\tcolumns\n";
	$to_print .= ";\t".$self->nrow()."\trows\n";
	
	## Alphabet
	$to_print .= "; Alphabet\t";
	$to_print .= join(" ", $self->getAlphabet());
	$to_print .= "\n";
	
	## Prior probabilities
	my %prior = $self->getPrior();
	foreach my $letter (sort keys %prior) {
	    $to_print .= join ("\t", ";", $letter, $prior{$letter})."\n";
	}
	
	## Matrix attributes
	my @params = $self->get_attribute("parameters");
	my %printed = ();
	for my $param (@params) {
	    ## Print only once if the param was entered several times
	    next if $printed{$param};
	    $printed{$param}++;
	    
	    if ($self->get_attribute($param)) {
		if (&main::IsReal($self->get_attribute($param))) {
		    $to_print .= sprintf "; %-29s\t%g\n", $param, $self->get_attribute($param);
		} else {
		    $to_print .= sprintf "; %-29s\t%s\n", $param, $self->get_attribute($param);
		}
	    }
	}
	
    } else {
	my @matrix = ();
	if ($type eq "alignment") {
	    @matrix = @{$self->{matrix}};
	} else {
	    @matrix = @{$self->{$type}};
	}
	my @alphabet = $self->getAlphabet();
	my $ncol = $self->ncol();
	my $nrow = $self->nrow();
	
	## Header for the matrix
	if ($main::verbose >= 1) {
	    $to_print .= ";\n";
	    $to_print .= "; Matrix type: $type\n";
	    if (($col_width) && ($col_width < 6)) {
		$to_print .= ";P";
	    } else {
		$to_print .= "; Pos";
	    }
	    $to_print .= $sep."|";
	    for my $c (0..($ncol-1)) {
		my $pos = $c+1;
		if ($col_width) {
		    $to_print .= sprintf "%${col_width}s", $pos;
		} else {
		    $to_print .= $sep;
		    $to_print .= $pos;
		}
	    }
	    $to_print .= "\n";

	    $to_print = $self->_addSeparator($sep, $col_width, $type, $ncol, $to_print);
	}

	## Print the matrix
	for $a (0..$#alphabet) {
	    $to_print .= $alphabet[$a];
	    $to_print .= $sep."|";
	    for $c (0..($ncol-1)) {
		my $value = $matrix[$c][$a];
		if ($col_width) {
		    my $value_format = "%${number_width}s";
		    if (&main::IsReal($value)){
			if ($type eq "alignment") {
			    $value_format = "%${number_width}d";
			} else {
			    $value_format= "%${number_width}.${decimals}f";
			}
		    }
		    $to_print .= sprintf " ${value_format}", $value;
		} else {
		    $to_print .= $sep.$value;
		}
	    }
	    $to_print .= "\n";
	}

	## Print information per column
	if (($type eq "information") && ($main::verbose >= 1)){
	    $to_print = $self->_addSeparator($sep, $col_width, $type, $ncol, $to_print);
	    my @column_information = $self->get_attribute("column.information");
	    $to_print .= ";I";
	    $to_print .= $sep."|";
	    for my $c (0..($ncol-1)) {
		my $value = $column_information[$c];
		if ($col_width) {
		    my $value_format = "%${number_width}s";
		    if (&main::IsReal($value)){
			if ($type eq "alignment") {
			    $value_format = "%${number_width}d";
			} else {
			    $value_format= "%${number_width}.${decimals}f";
			}
		    }
		    $to_print .= sprintf " ${value_format}", $value;
		} else {
		    $to_print .= $sep.$value;
		}
	    }
	    $to_print .= "\n";
	}
    }
    return $to_print;
}

################################################################
=pod

=item getWeights()

Return the weight matrix

=cut
sub getWeights {
    my ($self) = @_;
    return @{$self->{weights}};
}

################################################################
=pod

=item setWeights($nrow, $ncol, @weights)

Specify the weight matrix

=cut
sub setWeights {
    my ($self,$nrow, $ncol, @weights) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{weights}} = @weights;
    $self->force_attribute("weight_specified", 1);
}

################################################################
=pod 

=item calcWeights()

Calculate weights from the frequency matrix.

=cut
sub calcWeights {
    my ($self) = @_;

    ## Calculate frequencies if required
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }
    my @frequencies = $self->getFrequencies();    
    
    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }
    
    ## Get or calculate prior residue probabilities
    my %prior = $self->getPrior();
    
    ## get matrix size
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    
    ## Calculate the weights
    my @weights = ();
    for my $c (0..($ncol-1)) {
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
#	    my $prior = 0.25;
	    my $freq = $frequencies[$c][$r];
	    if ($freq == 0) {
		$weights[$c][$r] = "-Inf";
	    } elsif ($prior <= 0) {
		$weights[$c][$r] = "NA";
	    } else {
		$weights[$c][$r] = log($freq/$prior);
	    }
	    warn join "\t", "weight", "r:".$r, "c:".$c, "l:".$letter, "f:".$freq, "pr:".$prior, $weights[$c][$r], "\n" 
		if ($main::verbose >= 10);
	}
    }
    $self->setWeights($nrow,$ncol,@weights);
}

################################################################
=pod

=item getInformation()

Return the information content matrix. 

=cut
sub getInformation {
    my ($self) = @_;
    return @{$self->{information}};
}

################################################################
=pod

=item setInformation($nrow, $ncol, @information)

Specify the information content matrix.

=cut
sub setInformation {
    my ($self,$nrow, $ncol, @information) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{information}} = @information;
    $self->force_attribute("information_specified", 1);
}

################################################################
=pod 

=item calcInformation()

Calculate information content from the weight matrix.

=cut
sub calcInformation {
    my ($self) = @_;

    ## Calculate frequencies if required
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }
#    my @frequencies = $self->getFrequencies();    
    my @frequencies = $self->getCrudeFrequencies();    

    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }

    ## Get or calculate prior residue probabilities
    my %prior = $self->getPrior();

    ## Matrix size
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();

    ## Calculate information contents
    my @information = (); ## Informatiion matrix 
    my @column_information = (); ## Information per column
    my $total_information = 0; ## Total information for the matrix
    for my $c (0..($ncol-1)) {
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $freq = $frequencies[$c][$r];
	    if ($freq == 0) {
		$information[$c][$r] = 0;
	    } else {
		$information[$c][$r] = $freq * log($freq/$prior);
	    }
	    $column_information[$c] += $information[$c][$r];
	    $total_information += $information[$c][$r];
	    warn join "\t", "information", $r, $c, $information[$c][$r], $total_information, "\n" if ($main::verbose >= 10);
	}
    }
    $self->setInformation($nrow,$ncol,@information);


    ## Information per column
    $self->push_attribute("column.information", @column_information);

    ## Total information for the matrix
    $self->force_attribute("total.information", $total_information);
    $self->push_attribute("parameters", "total.information");

}


################################################################
=pod

=item getFrequencies()

Return the matrix of frequencies. Beware: these frequencies are taking
pseudp-weights into account.

=cut
sub getFrequencies {
    my ($self) = @_;
    return @{$self->{frequencies}};
}

################################################################
=pod

=item setFrequencies($nrow, $ncol, @frequencies)

Specify the matrix of frequencies. Beware: these frequencies are
taking pseudp-weights into account.

=cut
sub setFrequencies {
    my ($self,$nrow, $ncol, @frequencies) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{frequencies}} = @frequencies;
    $self->force_attribute("frequencies_specified", 1);
}

################################################################
=pod

=item getCrudeFrequencies()

Return the matrix of crude frequencies, i.e. NOT corrected by
pseudo-weights.

=cut
sub getCrudeFrequencies {
    my ($self) = @_;
    return @{$self->{crudeFrequencies}};
}

################################################################
=pod

=item setCrudeFrequencies($nrow, $ncol, @crudeFrequencies)

Specify the matrix of crude frequencies, i.e; NOT corrected by
pseudo-weights.

=cut
sub setCrudeFrequencies {
    my ($self,$nrow, $ncol, @crudeFrequencies) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{crudeFrequencies}} = @crudeFrequencies;
    $self->force_attribute("crudeFrequencies_specified", 1);
}

################################################################
=pod 

=item calcFrequencies()

Calculate frequencies from the alignment matrix (corrected with pseudo-weights).

=cut
sub calcFrequencies {
    my ($self) = @_;
    
    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }

    ## Matrix size
    my ($nrow, $ncol) = $self->size();
    if (($nrow <= 0) ||
	($ncol <= 0)) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }

    
    ## Get or calculate prior residue probabilities
    my %prior = $self->get_attribute("prior");
    if (scalar(keys %prior) <= 0) {
	&main::Warning( "No prior defined: using equiprobable residues");
	my $alphabet_size = scalar(@alphabet);
	foreach my $letter (@alphabet) {
	    $prior{$letter} = 1/$alphabet_size;
	    warn join "\t", ";", $letter, $prior{$letter}, "\n" if ($main::verbose >= 10);
	}
    }

    ## pseudo-weight
    my $pseudo = $self->get_attribute("pseudo");
    
    ## Alignment matrix
    my @matrix = $self->getMatrix();
    
    ## Calculate the frequencies
    my @frequencies = ();
    my @crude_frequencies = ();
    for my $c (0..($ncol-1)) {
	my $col_sum = 0;
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $occ = $matrix[$c][$r];
	    $col_sum += $occ;
	    $frequencies[$c][$r] = $occ + $pseudo*$prior{$letter};
	    warn join "\t", "freq", $r, $c, $letter, $prior, $pseudo, $occ, $col_sum, "\n" if ($main::verbose >= 10);
	}
	for my $r (0..($nrow-1)) {
	    $crude_frequencies[$c][$r] = $matrix[$c][$r]/$col_sum;
	    $frequencies[$c][$r] /= ($col_sum + $pseudo);
	    warn join( "\t", "freq", $r, $c, $pseudo, 
		       $col_sum, 
		       "a:".$matrix[$c][$r], 
		       "f:".$crude_frequencies[$c][$r], 
		       "f':".$frequencies[$c][$r]), "\n" 
			   if ($main::verbose >= 10);
	}
    }

    $self->setFrequencies($nrow,$ncol,@frequencies);
    $self->setCrudeFrequencies($nrow,$ncol,@crude_frequencies);
}

################################################################
## Calculate the consensus
sub calcConsensus {
    my ($self) = @_;
#    my $consensus_type = $args{type} || "degenerate";

    ## Calculate weight only if required
    unless ($self->get_attribute("weight_specified")) {
	$self->calcWeights();
    }
    my @weights = $self->getWeights();

    my @alphabet = $self->getAlphabet();
    
    ## Calculate consensus
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    my $consensus = "";
    my $consensus_strict = "";
    for my $c (0..($ncol-1)) {
	my $col_max = 0;
	my $col_consensus = "-";
	my %positive_score = ();
	for my $r (0..($nrow - 1)) {
	    my $weight = $weights[$c][$r];
	    if ((&main::IsReal($weight)) && ($weight >= 0)) {
		my $letter = $alphabet[$r];
		$positive_score{$letter} = $weight;
		if ($weight >= $col_max) {
		    $col_max = $weight;
#		die join "\t", $c, $r, $col_max, $alphabet[$r], $col_consensus;
		    $col_consensus = $letter;
		}
	    }
	}
	
	## Calculate degenerate code
	my  $regular = $col_consensus;
	if (scalar(keys %positive_score) >= 2) {
	    $regular = "[";
	    $regular .= join "", sort keys %positive_score;
	    $regular .= "]";
	}
	
	## Use uppercase for scores >= 1
	if ($col_max >= 1) {
	    $consensus_strict .= uc($col_consensus);
	    $consensus .= uc($regular);
	} else {
	    $consensus_strict .= lc($col_consensus);
	    $consensus .= lc($regular);
	}
    }

    

    ## Strict consensus 
    $self->force_attribute("consensus.strict", $consensus_strict);
    $self->push_attribute("parameters","consensus.strict");

    ## Degenerate consensus in regexp format
    $self->force_attribute("consensus.regexp", $consensus);
    $self->push_attribute("parameters","consensus.regexp");

    ## Degenerate consensus in IUPAC format
    my $consensus_IUPAC = &main::regular_to_IUPAC($consensus);
    $self->force_attribute("consensus.IUPAC", $consensus_IUPAC);
    $self->push_attribute("parameters","consensus.IUPAC");

}



return 1;


__END__

=pod

=back
