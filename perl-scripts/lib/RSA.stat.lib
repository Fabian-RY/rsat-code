#!/usr/bin/perl

sub max {
#### returns the maximum of a list of numeric values
#### usage:
#### $max_value = &max(@value_list);
  my @sorted_values = sort {$a <=> $b} @_;
  return $sorted_values[$#sorted_values];
}


sub min {
  #### returns the minimum of a list of numeric values
  #### usage:
  #### $min_value = &min(@value_list);
  my @sorted_values = sort {
    $a <=> $b
  } @_;
  return $sorted_values[0];
}

sub checked_min {
    #### returns the minimum of a list of numeric values
    #### usage:
    #### $min_value = &min(@value_list);
    my @sorted_values = sort {
	$a <=> $b
	} @_;
    my $c;
    $c = -1;
    do {
	$c++;
    } until (($c > $#sorted_values) || (&IsReal($sorted_values[$c])));
    return $sorted_values[$c];
}

sub checked_max {
    #### returns the minimum of a list of numeric values
    #### usage:
    #### $min_value = &min(@value_list);
    my @sorted_values = sort {
	$b <=> $a
	} @_;
    my $c;
    $c = -1;
    do {
	$c++;
    } until (($c > $#sorted_values) || (&IsReal($sorted_values[$c])));
    return $sorted_values[$c];
}

sub checked_sum {
    #### returns the sum of a list of numbers
    #### ignore non-numeric values
    my @values = @_;
    my $sum = 0;
    foreach $value (@values) {
	$sum += $value if (&IsReal($value));
    } 
    return $sum;
}

sub checked_avg {
    #### returns the sum of a list of numbers
    #### ignore non-numeric values
    my @values = @_;
    my $sum = 0;
    my $valid_values = 0;
    foreach $value (@values) {
	if (&IsReal($value)) {
	    $valid_values++;
	    $sum += $value;
	}
    } 
    if ($valid_values > 0) {
	return ($sum/$valid_values);
    } else {
	&FatalError( "Error: cannot calculate average of an empty list\n");
    }
}


### usage:
###     &binomial($proba,$trials,$successes)
### this routine uses the recursive formula for the calculation of binomial:
### We calculate everything in logarithms, and make a custom exp conversion
### to overcome the limitation of the Perl exp(x) function
###
###           P(x) * p(r-x)
###  P(x+1) = -------------
###              q(x+1)
###
sub binomial {
    my($proba) = $_[0];
    my($trials) = $_[1];
    my($succ) = $_[2];
    my($q) = 1 - $proba;

    if ($proba <=0) {
	&FatalError( "Error : invalid probability value $proba\n");
    }

    my($logproba) = log($proba);
    my($logq) = log($q);

    my($x) = 0;
    my($logbin) = log($q)*($trials-$x);

    for $x (0..$succ-1) {
        $logbin += $logproba + log($trials - $x) - $logq - log($x+1);
    }

#     $logbin /= log(10);
#     $bin = 10**(1+$logbin - int($logbin));
#     $bin .= "e";
#     if (int($logbin)-1 > 0) {
#         $bin .= "+";
#     }
#     $bin .= int($logbin)-1;
#     return($bin);


    my $bin = &LogToEng($logbin);
    return ($bin);
}


################################################################
#### converts a natural logarithm (x) into e^x.
#### This is performed by generating the output string, in order to
#### cirumvent a problem with very low values (<< e-70).
sub LogToEng {
    my ($log) = @_;
    my $base = 10;
    my $log_base = log($base);

    $log /= log(10);
    $eng = 10**(1+$log - int($log));
    $eng .= "e";
    if (int($log)-1 > 0) {
        $eng .= "+";
    }
    $eng .= int($log)-1;
    return($eng);

}

### usage:
###     &sum_of_binomials($proba,$trials,$from,$to)
### Calculates the sum of binomial probabilities between two values.
###
### This routine uses the recursive formula for the calculation of
### binomial:
###           P(x) * p(r-x)
###  P(x+1) = -------------
###              q(x+1)
###
sub sum_of_binomials {
    my ($proba, $trials, $from, $to) = @_;

    if ($verbose >= 5) {
	print join ("\t", "sum_of_binomials", "p=$proba", "t=$trials", "from=$from", "to=$to"), "\n";
    }

#    my $precision_limit = 1.0e-06;
    my $expected = $trials*$proba;

    if ($proba <=0) {
	 &FatalError("Error: invalid probability $proba (must be a positive value)\n");
    }
    ($from,$to) = sort {$a <=> $b} ($from, $to);
    if ($to > $trials) {
	&FatalError( "Error: successes ($to) cannot be higher than trials ($trials)\n");
    }
    my $q = 1 - $proba;
    my $logproba = log($proba);
    my $logq = log($q);

    my $sum_of_bin = 0;
    my $x = 0;
    my $logbin;
    my $prev_value = -1;

    #### initialize
    $x = 0;
    $logbin = $trials * log($q);
    if ($from == 0) {
	$sum_of_bin = exp($logbin);
	$loop_start = 1;
    } else {
	$loop_start = $from;
	for $x (1..$from-1) {
	    $logbin += log($trials - $x + 1) - log($x) + $logproba - $logq;
	}
    }

    for $x ($loop_start..$to) {
	$logbin += log($trials - $x + 1) - log($x) + $logproba - $logq;
	$sum_of_bin += exp($logbin);
	last if (($x > $expected) && ($sum_of_bin <= $prev_value)); ### limit of precision
	$prev_value = $sum_of_bin;
    }

    $sum_of_bin = 1 if ($sum_of_bin > 1);
    $sum_of_bin = "ND0" if ($sum_of_bin < 0);
    return($sum_of_bin);
}



### usage:
###     &binomial_boe($proba,$trials,$successes)
### Calculates the probability of observing >=s successes with a
### probability $p and $r repeats, with the sum of binomials for j
### varying from s to r.
sub binomial_boe {
    my ($proba, $trials, $succ) = @_;
    
    if ($verbose >=5) {
	print join ("\t", "binomial_boe", "p=$proba", "t=$trials", "s=$succ"), "\n";
    }
    
    return (sum_of_binomials($proba,$trials,$succ,$trials));
}



### usage: &binomial_approx($proba,$trials,$successes)
### this is the entropy approximation for the sum of binomials
### note that the approximation is only valid for s/r > p 
sub binomial_approx {
    my ($proba, $trials, $successes) = @_;
    my $beta = $successes/$trials;
    my $alpha = $proba;

    if (($beta >= $alpha) && 
	($beta <1) && 
	($beta > 0)) {
	$b_approx = exp(-$trials*($beta*log(abs($beta/$alpha)) + (1-$beta)*log(abs((1-$beta)/(1-$alpha)))));
    } else {
	$b_approx = "ND";
    }
    $b_approx;
}


### usage poisson($successes,$expected)
### note: on our sun station, this algorithm works only for m < 746
### direct calculation would be                  
###    p(x) = lambda^x exp(-lambda)/x!
### We use a recursive formula 
###    p(x) = p(x-1) * lambda / x
sub poisson {

    my ($x,$lambda) = @_;
    my $poi;
    my $log_lambda = log($lambda);

    my $log_poi;

    if ($x ==0) {
	$log_poi = -$lambda;
    } else {
	$log_poi = -$lambda + $log_lambda;
    }
    
    for my $i (2..$x) {
	$log_poi += $log_lambda - log($i);
    }
    return exp($log_poi);
}

### usage poisson($successes,$expected)
### note: on our sun station, this algorithm works only for m < 746
### direct calculation would be                  
###    p(x) = lambda^x exp(-lambda)/x!
### We use a recursive formula 
###    p(x) = p(x-1) * lambda / x
sub sum_of_poisson {

    my ($lambda,$from,$to) = @_;
    my $poi;
    my $log_lambda = log($lambda);

    my $log_poi;
    my $sum_of_poi;
    my $start;

    $sum_of_poi = exp(-$lambda) if ($from ==0);

    if ($to ==0) {
	$log_poi = -$lambda;
    } else {
	$log_poi = -$lambda + $log_lambda;
	$sum_of_poi += exp($log_poi) if ($from <= 1);
    }


    if ($from <= 1) {
	$start = 2;
    } else {
	$start = $from;
	for my $i (2..$start-1) {
	    $log_poi += $log_lambda - log($i);
	}
    }

    for my $i ($start..$to) {
	$log_poi += $log_lambda - log($i);
	$sum_of_poi += exp($log_poi);
	last if (($i > $lambda) && ($sum_of_poi <= $prev_value));
	$prev_value = $sum_of_poi;
    }
    return $sum_of_poi;
}


################################################################
### Hypergeometric formula. 
###
### Usage:
###     $p = &hypergeometric($m, $n, $k, $x)
### where
###   $m = number of black balls in the urn
###   $n = total number of balls in the urn
###   $k = number of balls in the sample
###   $x = number of black balls in the sample
###
### The hypergeometric is calculated with the recursive formula. 
###
###                       (m - x + 1) (k - x + 1)
###  P(X = x) = P(X=x-1) ------------------------
###                         x ( n - m - k + x)
###
###
### Instead of a product, calculations are performmed with sums of
### logarithms. Then, we make a custom exp conversion to overcome the
### limitation of the Perl exp(x) function.
###
### This gives a precision of the order of e-300.
###
### This routine also calculates the sum of hypergeometrics, when an
### argument 'to' is added.
###   $p = &hypergeometric($m, $n, $k, $from, to=>$to);
###
sub hypergeometric {
    my($m, $n, $k, $x, %args) = @_;
    
#     warn join ( "\t", 
# 		"Hypergeometric", 
# 		"m=$m",
# 		"n=$n",
# 		"k=$k",
# 		"x=$x"
# 		), "\n";

    my $to;
    my $proba = 0;

    #### sum of hypergeometrics
    if (defined($args{to})) {
	$to = $args{to};
    } else {
	$to = $x;
    }

    #### check parameter values
    unless ($args{nocheck}) {
	if ($x < 0) {
	    &FatalError( "Number of black balls in the sample ($x) must be strictly positive\n");
	}
	if ($k > $n) {
	    &FatalError("Sample ($k) cannot be larged than number of balls in the urn ($n)");	
	}
	if ($m > $n) {
	    &FatalError("Number of black balls in the urn ($m) cannot be larged than number of balls in the urn ($n)");	
	}
	if ($x > $m) {
	    &FatalError("Number of black balls in the sample ($x) cannot be larged than number of black balls in the urn ($m)");	
	}
	if ($x > $k) {
	    &FatalError("Number of black balls in the sample ($x) cannot be larged than sample size ($k)");	
	}
    }
# 	$Id: RSA.stat.lib,v 1.7 2002/09/27 05:43:06 jvanheld Exp $	

    #### initialization
    if (defined($args{previous_value})) {
	#### a single recursion is sufficient
#	die;
	$log_proba = log($args{previous_value});
	warn "Previous value\t", $log_proba, "\n";
	$start = $x;
    } else {
	#### calculate value for 0 successes
	$log_proba = 0;
	for my $i (($n-$m-$k+1)..($n-$m)) {
	    $log_proba += log($i);
	}
	for my $i (($n-$k+1)..$n) {
	    $log_proba -= log($i);
	}
	$start = 1;
    }

    #### recursive calculation
    for my $i ($start..$x) {
	$log_proba += log($m - $i + 1);
	$log_proba -= log($i);
	$log_proba += log($k - $i + 1);
	$log_proba -= log($n - $m - $k + $i);
    }

    $proba = &LogToEng($log_proba);

    #### recursive calculation
    for my $i ($x + 1..$to) {
	$log_proba += log($m - $i + 1);
	$log_proba -= log($i);
	$log_proba += log($k - $i + 1);
	$log_proba -= log($n - $m - $k + $i);
	$proba += &LogToEng($log_proba);
    }

#    my $proba = exp($log_proba);
    return($proba);
}


################################################################
#### sum_of_hypergeometric($m, $n, $k, $from, $to)
####
sub sum_of_hypergeometrics {
    my ($m, $n, $k, $from, $to) = @_;

    return (&hypergeometric($m,$n,$k,$from,to=>$to));
}


################################################################
### usage: &factorial($n)
sub factorial {
    my $n = $_[0];
    my $fact_n = 1;

    if ($n < 0) {
	print "	Error: invalid entry for factorial calculation\n";
	exit;
    }
    for my $j (1..$n) {
	$fact_n *= $j;
    }
    return $fact_n;
}

sub FisherExactTest {
#### calculates the probability according to Fisher's exact test
#### Usage
#### =====
#### $proba = &FisherExactTest($row_nb, $col_nb, @values);
####
#### where
####	$row_nb is the number of rows
####	$col_nb is th number of columns
####	@values is the list of values
#### all values must be natural numbers (0,1,2, ...)
#### the number of values must equal the product of col_nb by row_nb
####
#### the first step is to calculate the marginal sums:
#### ni+ = sum of all values from the ith row
#### n+j = sum of all values from the jth column
#### N = sum of all values from the table
####
#### The probability is then calculated by:
####
####         PROD(ni+!)PROD(n+j!)
#### proba = --------------------
####          N!PROD(PROD(nij!))
####
#### the input data are reported together with all marginal sums
#### by setting a global variable called $report_data to 1 

    my($N);
    my($row); 
    my($col);
    my(@col_sum);
    my(@row_sum);
    my($offset);
    my($i);
    my($proba);
    my($log_proba);
    my($log10_proba);
    my($row_nb) = shift;
    my($col_nb) = shift;
    my(@values) = @_;
    my($val_nb) = $#values + 1;

    if (($row_nb < 2) || ($col_nb < 2)) {
	return ";Error: at least 2 rows and 2 columns are required"; # too few rows or columns
    }
    unless ($val_nb == $row_nb * $col_nb) {
	return ";Error: invalid number of numeric values"; # inappropriate number of values provided
    }
    foreach $v (@values) {
	return ";Error: $v is not a natural number" unless &IsNatural($v); # invalid values
    }


    #### calculate marginal sums ni+, n+j, and N ###
    $N = 0;
    for $row (1..$row_nb) {
	$col_sum[$row] = 0;
	for $col (1..$col_nb) {
	    $offset = ($row-1) * $col_nb + $col -1;
	    $col_sum[$row] += $values[$offset];
	}
	$N += $col_sum[$row];
    }
    for $col (1..$col_nb) {
	$row_sum[$col] = 0;
	for $row (1..$row_nb) {
	    $offset = ($row-1) * $col_nb + $col -1;
	    $row_sum[$col] += $values[$offset];
	}
    }

    #### calculate the probability ####
    $log_proba = 0;
    for $row (1..$row_nb) {

	for $i (2..$col_sum[$row]) {
	    $log_proba += log($i);
	}
    }
    for $col (1..$col_nb) {
	for $i (2..$row_sum[$col]) {
	    $log_proba += log($i);
	}
    }
    for $i (2..$N) {
	$log_proba -= log($i);
    }
    for $row (1..$row_nb) {
	for $col (1..$col_nb) {
	    $offset = ($row-1) * $col_nb + $col -1;
	    for $i (2..$values[$offset]) {
		$log_proba -= log($i);
	    }
	}
    }
    $proba = exp($log_proba);
    $log10_proba = $log_proba / log(10);

    ### data report ###
    if ($report_data) {
	print $out ";Fisher's exact test with $row_nb rows and $col_nb col ($val_nb values)\n";
	print $out ";DATA REPORT\n";
	print $out ";";
	for $col (1..$col_nb) {
	    print $out "\tA$col";
	}
	print $out "\tni+\n";
	for $row (1..$row_nb) {
	    print $out ";B$row";
	    for $col (1..$col_nb) {
		$offset = ($row-1) * $col_nb + $col -1;
		print $out "\t$values[$offset]";
	    }
	    print $out "\t$col_sum[$row]\n";
	}
	print $out ";n+j";
	for $col (1..$col_nb) {
	    print $out "\t$row_sum[$col]";
	}
	print $out "\t$N\n";
    }
    return $proba;
} ### end FisherExactTest


sub ChiSquare {
#### calculates Pearson chi-square statistics for a table of numbers
#### Usage
#### =====
#### $chi_square = &ChiSquare($test,$row_nb, $col_nb, @values);
####
#### where
####	$test	indicates the kind of hypothesis to test:
####		- independence
####		- homogeneity
####		- good fit
####	$row_nb is the number of rows
####	$col_nb is th number of columns
####	@values is the list of values
#### all values must be real numbers
#### the number of values must equal the product of col_nb by row_nb
####
#### Good fit test
#### =============
#### In this case, there must be exactly two rows:
#### - the first row contains the observed frequencies.
#### - the second row contains the expected frequencies.
####
#### The chi-square value is calculated by:
####
####              (obs_j -exp_j)^2
#### ChiSq = SUM  ----------------
####          j      (exp_j)
####
#### where j is the index for columns.
####
#### Independence or homogeneity test:
#### =================================
#### the first step is to calculate the marginal sums:
#### ni. = sum of all values from the ith row
#### n.j = sum of all values from the jth column
#### N = sum of all values from the table
#### 
#### The chi-square value is then calculated by:
####
####                   (nij - n.j*ni./N)^2
#### ChiSq = SUM (SUM -----------------)
####          j    i     (n.j*ni./N)
####
####
#### the input data are reported together with all marginal sums
#### by setting a global variable called $report_data to 1 
####
#### Applicability
#### =============
#### One condition of applicability for the chi-square test is that each 
#### class should contain a "sufficient" number of expected observations. 
#### One commonly takes 5 as the minimal number of expected observations per class.
#### When the condition of acceptability is not met, our ChiSquare function
#### returns the calculated value surrounded by parenthesis, in order to 
#### warn the user that the chi2 value is not valid.

    my($N);
    my($row); 
    my($col);
    my(@col_sum);
    my(@row_sum);
    my($offset);
    my($i);
    my($chi_square);
    my($test) = shift;
    my($row_nb) = shift;
    my($col_nb) = shift;
    my(@values) = @_;
    my($val_nb) = $#values + 1;
    my($obs);
    my($exp);
    my($deg_freedom) = ($row_nb - 1)*($col_nb - 1);
    my($not_valid) = 0;

    ### check parameter values ###
    unless (($test =~ /^indep/i) || ($test =~ /^good/i) || ($test =~ /^homog/i)) {
	return ";Error: unknown test (supported: 'goodness of fit', 'homogeneity' and 'independence')"; # 
    }
    if (($row_nb < 2) || ($col_nb < 2)) {
	return ";Error: at least 2 rows and 2 columns are required"; # too few rows or columns
    }
    unless ($val_nb == $row_nb * $col_nb) {
	return ";Error: invalid number of numeric values"; # inappropriate number of values provided
    }
    ### all values must be real numbers
    foreach $val (@values) {
	return ";Error: $val is not a real number" unless &IsReal($val); # invalid values
    }

    if (($test =~ /^indep/i) || ($test =~ /^homog/i)) {
	#### calculate marginal sums ni+, n+j, and N ###
	$N = 0;
	for $row (1..$row_nb) {
	    $col_sum[$row] = 0;
	    for $col (1..$col_nb) {
		$offset = ($row-1) * $col_nb + $col -1;
		$col_sum[$row] += $values[$offset];
	    }
	    $N += $col_sum[$row];
	}
	for $col (1..$col_nb) {
	    $row_sum[$col] = 0;
	    for $row (1..$row_nb) {
		$offset = ($row-1) * $col_nb + $col -1;
		$row_sum[$col] += $values[$offset];
	    }
	}

	#### calculate the chi square value ####
	$chi_square = 0;
	for $row (1..$row_nb) {
	    for $col (1..$col_nb) {
		$exp = $row_sum[$col] * $col_sum[$row] / $N;
		$not_valid = 1 if ($exp < 5);   
		$offset = ($row-1) * $col_nb + $col -1;
		$obs = $values[$offset];
		$chi_square += (($obs - $exp)**2)/$exp unless ($exp == 0);
	    }
	}
    } elsif ($test =~ /^good/i) {
	unless ($row_nb == 2) {
	    return ";Error: test of goodness of fit requires esactly two lines";
	}
	$chi_square = 0;
	for $col (1..$col_nb) {
	    $obs = $values[$col-1];
	    $exp = $values[$col_nb + $col-1];
	    $not_valid = 1 if ($exp < 5);
	    $chi_square +=   (($obs - $exp)**2)/$exp unless ($exp == 0);
	}
    }


    ### data report ###
    if ($report_data) {
	print $out ";Pearson chi-square statistics with $row_nb rows and $col_nb col ($val_nb values)\n";
	print $out ";Test of $test\n";
	print $out ";$deg_freedom degrees of freedom\n";
	print $out ";DATA REPORT\n";
	if ($not_valid) {
	    print $out "; WARNING: data do not conform to the applicability conditions\n";
	    print $out "; WARNING: (each class must have at least 5 expected observations).\n";
	}
	print $out ";";
	for $col (1..$col_nb) {
	    print $out "\tA$col";
	}
	if (($test =~ /^indep/i) || ($test =~ /^homog/i)) {
	    print $out "\tni+\n";
	    for $row (1..$row_nb) {
		print $out ";B$row";
		for $col (1..$col_nb) {
		    $offset = ($row-1) * $col_nb + $col -1;
		    print $out "\t$values[$offset]";
		}
		print $out "\t$col_sum[$row]\n";
	    }
	    print $out ";n+j";
	    for $col (1..$col_nb) {
		print $out "\t$row_sum[$col]";
	    }
	    print $out "\t$N\n";
	} else {
	    print $out "\n;obs";
	    for $col (1..$col_nb) {
		print $out "\t$values[$col-1]";
	    }
	    print $out "\n;exp";
	    for $col (1..$col_nb) {
		print $out "\t$values[$col_nb + $col-1]";
	    }
	    print $out "\n";
	}
    }
    if ($not_valid) {
	$answer = sprintf "(%.3f)", $chi_square;
    } else {
	$answer = sprintf "%.3f", $chi_square;
    }
    return $answer;
} ### end ChiSquare



sub LogLikelihood {
#### calculates log-likelihood statistics for a table of numbers
#### Usage
#### =====
#### $log_likelihood = &LogLikelihood($row_nb, $col_nb, @values);
####
#### where
####	$row_nb is the number of rows
####	$col_nb is th number of columns
####	@values is the list of values
#### all values must be real numbers
#### the number of values must equal the product of col_nb by row_nb
####
#### the first step is to calculate the marginal sums:
#### ni+ = sum of all values from the ith row
#### n+j = sum of all values from the jth column
#### N = sum of all values from the table
#### 
#### The log-likelihood value is then calculated by:
####
####                   
#### LogLikelihood = N*log(N) + SUM SUM nij*log(nij)
####                             i   j                    
####
####                          - SUM ni+*log(ni+) - SUM n+j*log(n+j)
####                             i                  j
####
####
#### the input data are reported together with all marginal sums
#### by setting a global variable called $report_data to 1 

    my($N);
    my($row); 
    my($col);
    my(@col_sum);
    my(@row_sum);
    my($offset);
    my($i);
    my($log_likelihood);
    my($row_nb) = shift;
    my($col_nb) = shift;
    my(@values) = @_;
    my($val_nb) = $#values + 1;
    my($obs);
    my($deg_freedom) = ($row_nb - 1)*($col_nb - 1);

    if (($row_nb < 2) || ($col_nb < 2)) {
	return ";Error: at least 2 rows and 2 columns are required"; # too few rows or columns
    }
    unless ($val_nb == $row_nb * $col_nb) {
	return ";Error: invalid number of numeric values"; # inappropriate number of values provided
    }
    foreach $v (@values) {
	return ";Error: $v is not a real number" unless &IsReal($v); # invalid values
    }

#    foreach $v (@values) {
#	return ";Error: ($v) all values must be strictly positive" unless ($v > 0); # invalid values
#    }

    #### calculate marginal sums ni+, n+j, and N ###
    $N = 0;
    for $row (1..$row_nb) {
	$col_sum[$row] = 0;
	for $col (1..$col_nb) {
	    $offset = ($row-1) * $col_nb + $col -1;
	    $col_sum[$row] += $values[$offset];
	}
	$N += $col_sum[$row];
    }
    for $col (1..$col_nb) {
	$row_sum[$col] = 0;
	for $row (1..$row_nb) {
	    $offset = ($row-1) * $col_nb + $col -1;
	    $row_sum[$col] += $values[$offset];
	}
    }

    #### calculate the log likelihood value ####
    $log_likelihood = - $N * log($N);
    for $row (1..$row_nb) {
        for $col (1..$col_nb) {
	    $offset = ($row-1) * $col_nb + $col -1;
	    $obs = $values[$offset];
	    $log_likelihood -= $obs * log($obs) unless ($obs <= 0);
        }
    }
    for $row (1..$row_nb) {
	$log_likelihood += $col_sum[$row] * log($col_sum[$row]) unless ($col_sum[$row] <= 0);
    }
    for $col (1..$col_nb) {
	$log_likelihood += $row_sum[$col] * log($row_sum[$col]) unless ($row_sum[$col] <= 0);;
    }
    $log_likelihood = 0 if ($log_likelihood > 0);

    ### data report ###
    if ($report_data) {
	print $out ";Log-likelihood statistics with $row_nb rows and $col_nb col ($val_nb values)\n";
	print $out ";DATA REPORT\n";
	print $out ";";
	for $col (1..$col_nb) {
	    print $out "\tA$col";
	}
	print $out "\tni+\n";
	for $row (1..$row_nb) {
	    print $out ";B$row";
	    for $col (1..$col_nb) {
		$offset = ($row-1) * $col_nb + $col -1;
		print $out "\t$values[$offset]";
	    }
	    print $out "\t$col_sum[$row]\n";
	}
	print $out ";n+j";
	for $col (1..$col_nb) {
	    print $out "\t$row_sum[$col]";
	}
	print $out "\t$N\n";
	print $out ";$deg_freedom degrees of freedom\n";
	print $out ";-2log(L) = ",-2*$log_likelihood,"\n";
    }
    return $log_likelihood;
} ### end LogLikelihood


1;
