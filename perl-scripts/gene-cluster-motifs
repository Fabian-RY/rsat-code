#!/usr/bin/perl
############################################################
#
# $Id: gene-cluster-motifs,v 1.44 2004/01/23 00:10:52 jvanheld Exp $
#
# Time-stamp: <2003-10-21 01:19:12 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
  push (@INC, "$`lib/");
}

require "RSA.lib";
require "RSA.help.pl";
require "RSA.cgi.lib";
require "RSA.classes";
push @INC, "$RSA/perl-scripts/parsers/";
require "lib/load_classes.pl";
require "lib/util.pl";
require "lib/parsing_util.pl";
require "$RSA/perl-scripts/lib/RSA.classes";


################################################################
## initialisations	    
$die_on_error = 1;
%dir = ();
$dir{main} = `pwd`;
$dir{calib} = "calibrations2"; 
chomp($dir{main});

@supported_tasks = qw (upstream purge calibrate oligos maps dyads merge slide synthesis sql clean all);
foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
}
$supported_tasks = join ",", @supported_tasks;

%supported_sort_key = (
			"score"=>1,
			"name"=>1
			);
$supported_sort_keys  = join ",", sort keys %supported_sort_key;

%supported_background = (
			"intergenic"=>1,
			"upstream"=>1,
			"upstream-noorf"=>1,
			"calib"=>1,
			);
$supported_background  = join ",", sort keys %supported_background;

## input files
$family_file = "";
$sequene_file_list = "";

## feature-map options
$htmaps=0;
$draw_maps=1;
$scalestep = 100; 

## retrieve-seq options
$noorf = 1; 
$seq_format = "fasta";
$seq_dir = "";
$seq_ext = "fasta";

## pattern discovery options
$background = "upstream-noorf";
$min_oligo_len = 6;
$max_oligo_len = 6;
$monad_length = 3;
$noov = "-noov";
$min_sp = 0;
$max_sp = 20;
$sort_key = "score";

## Comparison between discovered and known motifs
$known_site_file = "";
$known_sites_provided = 0;
$min_matching_score = 4;

## misc
$start_date = `date`;
$verbose = 0;

#### data export options
$schema = "multifam";
$host="localhost";
$user = getlogin();
$password="";

################################################################
### MAIN

#### Read arguments
&ReadArguments();

#### Check parameters
&CheckParameters();


################################################################
## Read data
&ReadKnownSites($known_site_file);
#&ReadSiteLibrary("known_sites.tab");

if ($sequence_file_list) {
    $task{upstream} = 0; 
    &ReadSequenceList();
} else {
    
    ### Read family file
    %family = &ReadClasses($family_file, 1);
    @families = sort keys %family;

    ### read gene name and identifiers
    warn "; Reading ORF information ...\n" 
	if ($verbose >= 1);
    &ReadFeatures($organism_name);
    &ReadSynonyms($organism_name);
}

### write composition of the families in the separated directories
&SetFileNames();

&CheckOutDir($dir{output});
chdir($dir{output});

&MakeDirectories();

#### verbose
$verbose_message = &Verbose() if ($verbose >= 1);


### perform analysis
&AnalyzeFamilies();
&SyntheticTable() if ($task{synthesis});
&ExportSQL() if ($task{sql});

### Remind output dir
warn "; Results are stored in directory\t$dir{output}\n" if ($main::verbose >= 1);

#### report execution time 
if ($verbose >= 1) {
  $done_date = `date`;
  print ";Job started\t$start_date";
  print ";Job done\t", `date`;
}

exit(0);


################################################################
#
#                 SUBROUTINE DEFINITION
#
################################################################

#### set the file names as a function of parameters
sub SetFileNames {
    $sp = "$min_sp-$max_sp";
    $dyad_options = "-v ";
    $dyad_options .= " -sort ";
    $dyad_options .= " ${strands} ";
    $dyad_options .= " -type $dyad_type ";
    $dyad_options .= " ${noov}" ;
    $dyad_options .= " -l $monad_length ";
    $dyad_options .= " -thosig $th ";
    $dyad_options .= " -sp $sp ";
    
    $dyad_suffix = "_dyads";
    if ($markov) {
	$dyad_suffix .= "_monad"; ### TEMP
    } elsif ($background) {
	$dyad_suffix .= "_bg_${background}"; ### TEMP
    }
    $dyad_suffix .= "_l${monad_length}";
    $dyad_suffix .= "_sp${sp}";
    $dyad_suffix .= "$strands";
    $dyad_suffix .= "_${dyad_type}";
    $dyad_suffix .= "_sig${th}";
    $dyad_suffix .= "${noov}";

    #### expected frequency model
    if ($markov) {
	## do nothing. Expected dyad frequencies will be calculated on the basis of monad frequencies
    } elsif ($exp_freq_file{dyads}) {
	$dyad_options .= " -expfreq $exp_freq_file{dyads}";
    } elsif ($background) {
	$dyad_options .= " -bg $background ";
	$dyad_options .= " -org $organism_name ";
#      $dyad_suffix .= "_ncf";
    } elsif ($background eq "mncf") {
	$dyad_options .= " -mncf ";
	$dyad_options .= " -org $organism_name ";
	$dyad_suffix .= "_mncf";
    }
#  $dyad_suffix .= "_ncf" if ($background); ### TEMP

    #### suffix for the oligo-analysis file
    $noorf_string = "_noorf" if ($noorf);
    $oligo_suffix = "_oligos";
    if ($markov) {
	$oligo_suffix .= "_mkv${markov_order}";
    } elsif ($background) {
	$oligo_suffix .= "_bg_${background}";
    }
    $oligo_suffix .= "_${min_oligo_len}-${max_oligo_len}nt";
    $oligo_suffix .= "$strands";
    $oligo_suffix .= "_sig${th}${noov_string}";

    foreach my $family_name (@families) {
	$family{$family_name}->{family_file} = "$family_name/${family_name}.fam";
	$family{$family_name}->{known_site_file} = "$family_name/${family_name}_known_sites";
	$family{$family_name}->{file_prefix} = "${family_name}";
	$family{$family_name}->{file_prefix} .= "_up${seq_length}" unless ($sequence_file_list);
	$family{$family_name}->{file_prefix} .= "${noorf_string}"; 
	unless ($sequence_file_list) {
	    $family{$family_name}->{seq_file} = $family_name."/".$family{$family_name}->{file_prefix}.".${seq_format}";
	    $family{$family_name}->{seq_file_purged} = $family_name."/".$family{$family_name}->{file_prefix}."_purged.${seq_format}";
	}
	$family{$family_name}->{seq_len_file} = $family_name."/".$family{$family_name}->{file_prefix}."_seq_len.tab";
#      $family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}."_oligos_${min_oligo_len}-${max_oligo_len}nt$strands_sig${th}${noov_string}";
	$family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix; ## TEMP
	$family{$family_name}->{oligo_assembly_file} = $family{$family_name}->{oligo_file}."_contigs";
	$family{$family_name}->{oligo_ft_file} = $family{$family_name}->{oligo_file}.".ft";
	

	$family{$family_name}->{dyad_file} = "$family_name/dyads_${family_name}/".$family{$family_name}->{file_prefix}.$dyad_suffix;
	$family{$family_name}->{dyad_assembly_file} = $family{$family_name}->{dyad_file}."_contigs";
	$family{$family_name}->{dyad_ft_file} = $family{$family_name}->{dyad_file}.".ft";

	$family{$family_name}->{fmap_file} = $family{$family_name}->{dyad_file}.".${IMG_FORMAT}";
	$family{$family_name}->{htmap_file} = $family{$family_name}->{dyad_file}.".html";

	$family{$family_name}->{merged_file} =  "${family_name}/merged_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix.$dyad_suffix;
	$family{$family_name}->{merged_ft_file} = $family{$family_name}->{merged_file}.".ft";
    }  

    if ($family_file) {
	$table_suffix = $family_file;
    } elsif ($sequence_file_list) {
	$table_suffix .= $sequence_file_list;
	$table_suffix =~  s/\.tab$//;
	$table_suffix =~  s/\.txt$//;
    } else {
	$table_suffix = $organism_name;
    }
    if ($markov) {
	$table_suffix .= "_mkv${markov_order}";
    } elsif ($background) {
	$table_suffix .= "_bg_${background}";
    }

    if ($family_file) {
	$table_suffix .= "_up".$from     if (defined($from));
	$table_suffix .= "_".$to     if (defined($to));
	$table_suffix .= $noorf_string;
    }
    $table_suffix .= $noov;
    $table_suffix .= "_".$strands;
    $table_suffix = `basename $table_suffix`;
    chomp $table_suffix;
}

################### SUBROUTINE DEFINITION ###################"


################################################################
#### retrieve upstream sequences
sub UpstreamSequences {
    warn ";\tRetrieving upstream sequences for family $family_name\n" if ($verbose >= 1);
    $command = "retrieve-seq -type upstream -org $organism_name";
    $command .= " -noorf " if ($noorf);
    $command .= " -i $family{$family_name}->{family_file}";
    $command .= " -o $family{$family_name}->{seq_file}";
    $command .= " -from $from" if (defined($from));
    $command .= " -to $to " if (defined($to));
    $command .= " -label orf_gene ";
    $command .= " -feattype $feature_types " if ($feature_types);
    $command .= " -format $seq_format";
    &doit($command,$dry_run, $die_on_error);
}

################################################################
#### Purge input sequences
sub PurgeSequences {
    warn ";\tPurging sequences for family $family_name\n" if ($verbose >= 1);
    $command = "purge-sequence -ml 40 -mis 3";
    $command .= " -i $family{$family_name}->{seq_file}";
    $command .= " > $family{$family_name}->{seq_file_purged}";
    &doit($command,$dry_run, $die_on_error);
}


################################################################
### oligo-analysis
sub OligoAnalysis {
    warn join ("\t", 
	       ";\tAnalyzing oligonucleotides for family $family_name",
	       "min len: $min_oligo_len",
	       "max len: $max_oligo_len"), "\n" if ($verbose >= 1);
    my $dir = "${family_name}/oligos_${family_name}";

    &CheckOutDir($dir);
    die "Error : cannot read file $family{$family_name}->{seq_file_purged}\n" unless (-r $family{$family_name}->{seq_file_purged});
    
    ## initialize the oligo file
    system "echo '' > $family{$family_name}->{oligo_file}"; # if ($verbose >=1);
    
    for $oligo_len ($min_oligo_len..$max_oligo_len) {
	$oligo_options = "-v ";
	$oligo_options .= " -pseudo ".$pseudo if ($pseudo);
	$oligo_options .= " -sort ";
	$oligo_options .= " ".$strands;
	$oligo_options .= " -l ".$oligo_len;
	$oligo_options .= " -thosig ".$th;
	if ($markov) {
	    $oligo_options .= " -markov ".$markov_order;
	} elsif ($exp_freq_file{oligos}) {
	    $oligo_options .= " -expfreq ".$exp_freq_file{oligos};
	} elsif ($background eq "calib") {
	    my $calib_length = $family{$family_name}->{calib_length};
	    my $calib_file = &CalibrationPrefix($calib_length, $oligo_len);
	    $calib_file .= "_negbin.tab";
	    $oligo_options .= " -calib1 ".$calib_file;
#	    die join ("\t", "; Oligonucleotide calibration", $calib_length, $calib_file), "\n";
	} else {
	    $oligo_options .= " -org ".$organism_name;
	    $oligo_options .= " -bg ".$background;
	}
	$oligo_options .= " -return occ,proba,mseq,rank";
	$oligo_options .= " ".${noov};
	
	$oligo_suffix = "_oligos";
	$oligo_suffix .= "_${oligo_len}nt";
	$oligo_suffix .= $strands;
	$oligo_suffix .= "_sig${th}";
	$oligo_suffix .= $noov;
	
	$oligo_file = "$family_name/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix;    
	$command = "oligo-analysis -i $family{$family_name}->{seq_file_purged} -format $seq_format -o $oligo_file $oligo_options";
	
	&doit($command,$dry_run, $die_on_error);
	system "cat $oligo_file >> $family{$family_name}->{oligo_file}";
    }
    
    ### fragment assembly
    $command = "pattern-assembly -i $family{$family_name}->{oligo_file} ${strands} -v -o $family{$family_name}->{oligo_assembly_file} -maxfl 1 -maxpat 200 -subst 1";
    
    &doit($command,$dry_run, 0);
}



################################################################
#### draw feature-map for the result of oligo-analysis
sub DrawOligoFeatureMap {
    warn ";\tDrawing feature-map with results of oligo-analysis for family $family_name\n" if ($verbose >= 1);
    ### pattern matching
    die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
    $fmap_file = $family{$family_name}->{oligo_file}.".${IMG_FORMAT}";
    $htmap_file = $family{$family_name}->{oligo_file}.".html";
    $origin = "-0";
    my $command = "dna-pattern -i $family{$family_name}->{seq_file} -format $seq_format -pl $family{$family_name}->{oligo_file} -origin $origin -N 4 ";
    $command .= " | features-from-dnapat -o $family{$family_name}->{oligo_ft_file} ";
    my $error = &doit($command,$dry_run, 0);
    if ($error) {
	warn "; WARNING: Feature map skipped because dna-pattern returned an error\n";
	return;
    }

    ## feature-map drawing
    $command = "feature-map -i $family{$family_name}->{oligo_ft_file} -scalebar -scalestep $scalestep -legend ";
    $command .= " -from $from" if (defined($from));
    $command .= " -to $to" if (defined($to));
    $command .= " -o $fmap_file -scorethick ";
    if ($htmaps) {
	$command .= " -htmap > $htmap_file ";
    };
    
    &doit($command,$dry_run, 0);
}

################################################################
### dyad analysis
sub DyadAnalysis {
    warn join( "\t", 
	       ";\tAnalyzing dyads for family $family_name",
	       "monad length: $monad_length",
	       "min_sp: $min_sp",
	       "max_sp: $max_sp",
	       ), "\n" if ($verbose >= 1);
    $dir = "${family_name}/dyads_${family_name}";
    &CheckOutDir($dir);
    die "Error : cannot read file $family{$family_name}->{seq_file_purged}\n" unless (-r $family{$family_name}->{seq_file_purged});
    $command = "dyad-analysis -return occ,proba,rank -i $family{$family_name}->{seq_file_purged} -format $seq_format -o $family{$family_name}->{dyad_file} $dyad_options";
    
    &doit($command,$dry_run, $die_on_error);
    
    ### fragment assembly
    $command = "pattern-assembly -v -i $family{$family_name}->{dyad_file} -o $family{$family_name}->{dyad_assembly_file} ${strands} -maxfl 1 -maxpat 200 ";
    
    &doit($command,$dry_run, 0);
    
}


################################################################
## Merge patterns detected by oligo-analysis and dyad-analysis
sub MergePatterns {
    my $filter_dyads = 1;
    warn join ("\t", 
	       ";\tMerging oligonucleotides and dyads for family ",
	       $family_name,
	       $family{$family_name}->{merged_file}
	       ), "\n" if ($verbose >= 1);

    my $dir = "${family_name}/merged_${family_name}";
    &CheckOutDir($dir);
    my $command = "cat $family{$family_name}->{oligo_file}";
#    $command .= " | grep -v '^;'";
    $command .= " > $family{$family_name}->{merged_file};";
    $command .= " cat $family{$family_name}->{dyad_file}";
#    $command .= " | grep -v '^;'";
    if ($filter_dyads) {
	$command .= " | grep -v '\{0\}'";
    } else {
	$command .= " | perl -pe 's/n\{0\}//g'";
    }
    $command .= " >> $family{$family_name}->{merged_file};";
    $command .= " wc $family{$family_name}->{merged_file}";
    &doit($command);
    &DrawMergedFeatureMap() if ($task{map});
}


################################################################
#### draw feature-map for the result of merged oligonucleotides and dyads
sub DrawMergedFeatureMap {
    warn ";\tDrawing feature-map with results of merged oligonucleotides and dyads for family $family_name\n" if ($verbose >= 1);
    ### pattern matching
    die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
    $fmap_file = $family{$family_name}->{merged_file}.".${IMG_FORMAT}";
    $htmap_file = $family{$family_name}->{merged_file}.".html";
    $origin = "-0";
    my $command = "dna-pattern -i $family{$family_name}->{seq_file} -format $seq_format -pl $family{$family_name}->{merged_file} -origin $origin -N 4 ";
    $command .= " | features-from-dnapat -o $family{$family_name}->{merged_ft_file} ";
    my $error = &doit($command,$dry_run, 0);
    if ($error) {
	warn "; WARNING: Feature map skipped because dna-pattern returned an error\n";
	return;
    }

    ## feature-map drawing
    $command = " feature-map -i $family{$family_name}->{merged_ft_file} -scalebar -scalestep $scalestep -legend ";
    $command .= " -from $from" if (defined($from));
    $command .= " -to $to" if (defined($to));
    $command .= " -o $fmap_file -scorethick ";
    if ($htmaps) {
	$command .= " -htmap > $htmap_file ";
    };
    
    &doit($command,$dry_run, 0);
}

## ##############################################################
## Scan merged patterns with a sliding window (dna-pattern)
sub SlidingWindow {
    
}

################################################################
### Read known known_site for each family
sub ReadKnownSites {
    my ($known_site_file) = @_;
    %known_site = ();
    %known_site_source = ();
    if (-e $known_site_file) {
	$known_sites_provided = 1;
	open KNOWN_SITE, $known_site_file;
	while (<KNOWN_SITE>) {
	    next if (/^;/);
	    next if (/^\#/);
	    next unless (/\S/);
	    chomp;
	    @fields = split "\t";
	    $family_name = $fields[0];
	    $known_site = uc($fields[1]);
	    $source = $fields[2];
	    #$known_site = uc(&compress_pattern($known_site,"n"));
	    $known_site =~ s/N/n/g;
	    push @{$known_site{$family_name}}, $known_site;
	    push @{$known_site_source{$family_name}}, $source;
	}
	close KNOWN_SITE;
    }
}


#  ################################################################
#  ## Read known sites from a tab-delimited file
#  ## Obsolete : has been replaced by ReadKnownSites
#  sub ReadSiteLibrary {
#      my ($library_file) = @_;
#      @site_library = ();
#      if (-e $library_file) {
#  	open LIBRARY, $library_file;
#  	while (<LIBRARY>) {
#  	    next if (/^;/);
#  	    next if (/^\#/);
#  	    next unless (/\S/);
#  	    chomp;
#  	    my @fields = split "\t";
#  	    my $source = $fields[2] || $library_file;
#  	    my $id = uc($fields[1]);
#  	    my $sequence = uc($fields[0]);
#  	    $sequence =~ s/N/n/g;
	    
#  	    $pattern = RSA::pattern->new(id=>$id,
#  					 sequence=>$sequence,
#  					 source=>source);
#  	    push @site_library, $pattern;
#  	}
#  	close LIBRARY;
#      }
#  }


################################################################
### Generate a synthetic table
sub SyntheticTable {
    my $dir = "synthetic_tables";
    
    my $table_file = $dir."/".$table_suffix;
    $table_file .= "_tr" if ($transpose);

    warn "; Generating synthetic table $table_file\n" if ($verbose >= 1);
    
    unless (-d $dir) {
	mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
    }
    
    ### synthesize the results of all families into a single file
    
    ### headers
    $row = 0;
    $row{f} = $row++;
    $row{family} = $row++;
    $row{size} = $row++;
    $row{genes} = $row++;
    $row{known} = $row++ if ($known_sites_provided);
    $row{oligo} = $row++;
    $row{dyad} = $row++;
    $row_num = $row-1;
    while (($header,$row) = each %row) {
	$table[$row][0] = "<B>$header</B>";
    }
    my $col = 0;

    foreach $family_name (@families) {
	$col++;
	
	#### remember which column is associated to each family
	$column{$family_name} = $col;

	### check directory
	$dir = "${family_name}/dyads_${family_name}";
	unless (-d $dir) {
	    &Warning ("Cannot find directory $dir\n");
	}
	
	### family number
	$table[$row{f}][$col] = "<B>$col</B>";
	
	### family name
	$table[$row{family}][$col] = "<B><a href='../$family_name'>$family_name</a></B>";
	
	#### number of genes
	$table[$row{size}][$col] = scalar(@{$family{$family_name}->{members}});

	### list of genes
	$table[$row{genes}][$col] = "<a href='../".$family{$family_name}->{family_file}."'>";
	$table[$row{genes}][$col] .= join " ", @{$family{$family_name}->{members}};
	$table[$row{genes}][$col] .= "</a>";
	
	### known patterns
	if ($known_sites_provided) {
	    $table[$row{known}][$col] = "";
	    for $c (0..$#{$known_site{$family_name}}) {
		$table[$row{known}][$col] .= ${known_site{$family_name}}[$c];
		$table[$row{known}][$col] .= "<BR>(".${known_site_source{$family_name}}[$c].")" if (${known_site_source{$family_name}}[$c]);
		$table[$row{known}][$col] .= "<P>";
	    }
	} 
	
	#### oligo-analysis
#	open OLIGOS, "$family{$family_name}->{oligo_assembly_file}";
        if ($htmaps) {
          $map_link = "<A HREF=../$family{$family_name}->{oligo_file}.html>\n";
        } else {
	  $map_link = "<A HREF=../$family{$family_name}->{oligo_file}.${IMG_FORMAT}>\n";
        }
 	warn ";\tExtracting info from\t$family{$family_name}->{oligo_assembly_file}\n" if ($verbose >= 2);
	undef @patterns;
	undef @sorted_patterns;
	undef %rc;
	undef %score;
	undef %type;

	if (-e $family{$family_name}->{oligo_assembly_file}) {
	    my ($olig, $input_dir) = &OpenInputFile($family{$family_name}->{oligo_assembly_file});
	    while (<$olig>) {
		chomp;
		next if (/^;/);
		next if (/^\#/);
		next unless (/\S/);
		if ((/contig/) || (/consensus/) || (/isol/)) {
		    @fields = split "\t";
		    my $sequence = shift (@fields);
		    $pattern = new RSA::pattern(sequence=>$sequence);
		    push @patterns, $pattern;
		    if ($strands eq "2str") {
			$rc{$pattern} = shift @fields;
#			$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
		    }
		    $score{$pattern} = shift @fields;
		    $type{$pattern} = shift @fields;
		    $max_score{$family_name} = &max($max_score{$family_name}, $score{$pattern});
		}
	    }
	} else {
	    &Warning(join ( "\t", 
			    "Family $family_name\t",  
			    "oligo-analysis file ", $family{$family_name}->{oligo_assembly_file}, 
			    " does not exist. Skipped."));

	}
	@sorted_patterns = sort { $score{$b} <=> $score{$a} } @patterns;
	$table[$row{oligo}][$col] = "<TABLE>\n";
	$table[$row{oligo}][$col] .= "<TR>\n";
	
	### print oligo sequence
	$table[$row{oligo}][$col] .= "<TD>\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= $sorted_patterns[$p]->get_attribute("sequence"); 
	    $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{oligo}][$col] .= "</TD>\n";
	
	### print reverse complementary oligo
	if ($strands eq "2str") {
	    $table[$row{oligo}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		$table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
		$table[$row{oligo}][$col] .= $rc{$sorted_patterns[$p]};
		$table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
		$table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{oligo}][$col] .= "</TD>\n";
	}

	### print oligo score
	$table[$row{oligo}][$col] .= "<TD>$map_link\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "$score{$sorted_patterns[$p]}";
	    $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{oligo}][$col] .= "</A></TD>\n";
	
	### print matching patterns
	if ($known_sites_provided) {
	    $table[$row{oligo}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		my @matches = ();
		foreach $site (@site_library) {
		    if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
			($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
			#my $match = $site->get_attribute("sequence");
			my $match = $site->get_id();
			push @matches, $match;
		    }
		}
		$table[$row{oligo}][$col] .= join(";",@matches);
		$table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{oligo}][$col] .= "</TD>\n";
	}
	
	$table[$row{oligo}][$col] .= "</TR>\n";
	$table[$row{oligo}][$col] .= "</TABLE>\n";
	close $olig;
	
	### dyad analysis
        if ($htmaps) {
	  $map_link = "<A HREF=../$family{$family_name}->{dyad_file}.html>\n";
        } else {
	  $map_link = "<A HREF=../$family{$family_name}->{dyad_file}.${IMG_FORMAT}>\n";
        }
	warn ";\tExtracting info from\t$family{$family_name}->{dyad_assembly_file}\n" if ($verbose >= 2);
	undef @patterns;
	undef @sorted_patterns;
	undef %rc;
	undef %score;
	undef %type;

	if (-e $family{$family_name}->{dyad_assembly_file}) {
	    my ($dyadhandle) = &OpenInputFile($family{$family_name}->{dyad_assembly_file});
#	open DYADS, "$family{$family_name}->{dyad_assembly_file}";
	    while (<$dyadhandle>) {
		chomp;
		next if (/^;/);
		next if (/^\#/);
		next unless (/\S/);
		if ((/contig/) || (/consensus/) || (/isol/)) {
		    @fields = split "\t";
		    my $sequence = shift @fields;
		    $pattern = new RSA::pattern(sequence=>$sequence);
		    push @patterns, $pattern;
		    if ($strands eq "2str") {
			$rc{$pattern} = shift @fields;
#			$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
		    }
		    $score{$pattern} = shift @fields;
		    $type{$pattern} = shift @fields;
		}
	    }
	} else {
	    &Warning(join( "\t", 
			   "Family $family_name", 
			   "dyad-analysis file ", $family{$family_name}->{dyad_assembly_file}, 
			   " does not exist. Skipped."));
	}
	@sorted_patterns = sort {$score{$b} <=> $score{$a}} @patterns;
	$table[$row{dyad}][$col] = "<TABLE>\n";
	$table[$row{dyad}][$col] .= "<TR>\n";
	
	### print dyad sequence
	$table[$row{dyad}][$col] .= "<TD>\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $sequence = $sorted_patterns[$p]->get_attribute("sequence");
	    $compressed = &compress_pattern($sequence, "n");
	    $compressed =~ s/N/n/g;
	    $table[$row{dyad}][$col] .= $compressed;
	    $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{dyad}][$col] .= "</TD>\n";
	
	### reverse complementary dyad
	if ($strands eq "2str") {
	    $table[$row{dyad}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		$table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
		$compressed = &compress_pattern($rc{$sorted_patterns[$p]},"n");
		$compressed =~ s/N/n/g;
		$table[$row{dyad}][$col] .= $compressed;
		$table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
		$table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{dyad}][$col] .= "</TD>\n";
	}

	### dyad scores
	$table[$row{dyad}][$col] .= "<TD>$map_link\n";
	for $p (0..$#sorted_patterns) {
	    $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "$score{$sorted_patterns[$p]}";
	    $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
	    $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	}
	$table[$row{dyad}][$col] .= "</A></TD>\n";
	
	### print matching patterns
	if ($known_sites_providde) {
	    $table[$row{dyad}][$col] .= "<TD>\n";
	    for $p (0..$#sorted_patterns) {
		my @matches = ();
		foreach $site (@site_library) {
		    if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
			($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
			#my $match = $site->get_attribute("sequence");
			my $match = $site->get_id();
			push @matches, $match;
		    }
		} 
		$table[$row{dyad}][$col] .= join(";",@matches);
		$table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
	    }
	    $table[$row{dyad}][$col] .= "</TD>\n";
	}
	
	$table[$row{dyad}][$col] .= "</TR>\n";
	$table[$row{dyad}][$col] .= "</TABLE>\n";
	close $dyadhandle;
    }
    
    open TABLE, "> ${table_file}.html" 
	|| die "Error: cannot write file $table_file\n";
    print TABLE "<HTML>\n";
    print TABLE "<TITLE>",${table_file}, "</TITLE>","\n";
    print TABLE "<BODY>\n";
    print TABLE "<H1>$table_file</H1>\n";
    
    print TABLE join( "\n",
		      "<PRE>",
		      $verbose_message,
		      "</PRE>"
		      ), "\n";


    print TABLE "<TABLE BORDER=1>\n";
    

    if ($sort_key eq "score") {
	#### sort families by score
	#### decreasing order
	@sorted_families = sort {$max_score{$b} <=> $max_score{$a}} @families; 
# 	foreach my $f (@sorted_families) {
# 	    warn join "\t", $f, $max_score{$f}, "\n";
# 	}

    } else {
	#### sort families by family name
	@sorted_families = sort @families;
    }
    
    if ($transpose) {
	foreach $r (0..$row_num) {
	    print TABLE "<TR>\n";
#		foreach $c (0..$col) {
	    foreach $f (@sorted_families) {
		my $c = $column{$f};
		print TABLE "<TD>", $table[$r][$c], "</TD>\n";
	    }
	    print TABLE "</TR>\n";
	}
    } else {
	
	
	#### print table header
	foreach $r (0..$row_num) {
	    print TABLE "<TH>", $table[$r][0], "</TH>\n";
	}
	#### print table content
#	foreach $c (0..$col) {
	foreach $f (@sorted_families) {
	    my $c = $column{$f};
	    print TABLE "<TR>\n";
	    foreach $r (0..$row_num) {
		print TABLE "<TD>", $table[$r][$c], "</TD>\n";
	    }
	    print TABLE "</TR>\n";
	}
    }
    
    print TABLE "</TABLE>\n";
    print TABLE "<HR>", &AlphaDate;
    print TABLE "</BODY>\n";
    print TABLE "</HTML>\n";
    close TABLE;
    chdir "synthetic_tables";
#  system "html_dir.csh > index.html";
    chdir "../";
}


################################################################
#### Draw feature maps
sub DrawDyadFeatureMap {
    warn ";\tDrawing feature-map with results of dyad-analysis for family $family_name\n" if ($verbose >= 1);
    die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});

    ## pattern matching
    $origin = "-0";
    my $command = "dna-pattern -pl $family{$family_name}->{dyad_file} -format $seq_format -i $family{$family_name}->{seq_file} -origin $origin -N 4 ";
    $command .= "| features-from-dnapat -o $family{$family_name}->{dyad_ft_file} ";
    my $error = &doit($command,$dry_run, 0);
    if ($error) {
	warn "; WARNING: Feature map skipped because dna-pattern returned an error\n";
	return;
    }

    ## feature-map drawing
    $command = "feature-map -i $family{$family_name}->{dyad_ft_file} -o $family{$family_name}->{fmap_file} ";;
    $command .= " -from $from" if (defined($from));
    $command .= " -to $to " if (defined($to));
    $command .= "-legend ";
    $command .= "-scalebar -scalestep $scalestep ";
    $command .= "-scorethick ";
    $command .= "-mlen 520 ";
    $command .= "-title '${family_name}$dyad_suffix' ";
    if ($htmaps) {
	$command .= "-htmap >  $family{$family_name}->{htmap_file}";
    }
    #  $command .= " ;  xv -o $family{$family_name}->{fmap_file} &";
    &doit($command,$dry_run, 0);
}


################################################################
#### check parameters
sub CheckParameters {

    #### accepted feature types
    unless (defined %accepted_feature_types) {
	$accepted_feature_types{cds} = 1;
    }
    $feature_types = join ",", keys (%accepted_feature_types);


    #### check selected tasks
    unless (defined(%task)) {
	&FatalError("You should select at least one task.");
    }
    if ($task{all}) {
	foreach my $t (@supported_tasks) {
	    $task{$t} = 1;
	}
	unless ($draw_maps) {
	    $task{maps} = 0;
	}
    }
    
    ### family file ###
    unless (($family_file) || ($sequence_file_list)) {
	die "Error: you should specify either a family file or a sequence file list\n";  
    } 
    
    ### organism ###
    unless ($organism_name) {
	die "Error: you should specify an organism\n$supported_organisms\n";  
    } 
    unless ($supported_organism{$organism_name}) {
	die ("Error: organism $organism_name is not supported\n",
	     "Supported organisms:\n$supported_organisms\n");
    }

    
#    $from = $default{from} unless defined($from);
#    $to = $default{to} unless defined($to);

    $from = $supported_organism{$organism_name}->{'up_from'}  unless defined($from);
    $to = $supported_organism{$organism_name}->{'up_to'}  unless defined($to);

    $seq_length = abs($to - $from) + 1;
    $dyad_type = "any" unless ($dyad_type);

    if (defined($force{strands})) {
	$strands = $force{strands}; ### force
    } else {
	$strands = "2str";
    }
    if (defined($force{exp})) {
	$exp = $force{exp}; ### force
    }
    if (&IsReal($force{th})) {
	$th = $force{th}; ### force
    } elsif ($#families > 0) {
	$th = &round(10*abs(log($#families + 1)/log(10)))/10;
    } else {
	$th = 0;
    } 
}


################################################################
## Analyze all the families    
sub AnalyzeFamilies {
    my $fam_count=0;
    my $fam_nb = $#families+1;

    ### Calibrate oligonucleotides for each sequence length
    if ($task{calibrate} || ($background eq "calib")) {
	my @calib_lengths = &CalcCalibrationLengths();
	&CalibrateOligos(@calib_lengths) if ($task{calibrate});
    }

    foreach $family_name (@families) {
	$fam_count++;
	warn ";\n; Treating family $family_name ($fam_count of $fam_nb)\t", `date` if ($verbose >=1);
	
	### retrieve upstream sequences of the family
	&UpstreamSequences() if ($task{upstream});

	### purge upstream sequences of the family
	&PurgeSequences() if ($task{purge});
	
	### oligo-analysis
	&OligoAnalysis() if ($task{oligos});
	
	### dyad feature-maps
	&DrawOligoFeatureMap() if ($task{maps});

	### dyad analysis
	&DyadAnalysis() if ($task{dyads});

	### dyad feature-maps
	&DrawDyadFeatureMap() if ($task{maps});
	
	### merge oligo-analysis and dyad-analysis results
	&MergePatterns() if ($task{merge});

	### dyad feature-maps
	&DrawOligoFeatureMap() if ($task{maps});

	### Match all patterns together with a sliding window
	&SlidingWindow() if ($task{slide});
		
	### delete upstream sequence file
	if ($task{clean}) {
	    warn ";\tCleaning files from the hard drive for family $family_name\n" if ($verbose >=1);
	    foreach my $file ($family{$family_name}->{seq_file},
			      $family{$family_name}->{seq_file_purged},
			      $family{$family_name}->{oligo_ft_file},
			      $family{$family_name}->{dyad_ft_file}
			      ) {
		warn ";\t\t$file\n" if ($verbose >=1);
		system "rm -f $file" ;
	    }
	}
	
    }
}

################################################################
## Execute a command, with optional echo
#sub doit {
#    my ($command) = @_;
#    print "\n$command\n" if ($verbose >= 2);
#    system $command unless $dry_run;
#}


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
    $HELP_FAMILY_FILE = &help_message("family file");
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
	multiple-family-analysis

        1999 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        multiple-family-analysis [-i inputfile] [-v]

DESCRIPTION
	Runs a combination of programs in order to discover significant
	patterns in the upstream regions of several gene families.

	This script is a way to auto;atize the systematic analysis of
	multiple clusters of co-regulated genes, such as those
	obtained with DNA chip experiments.

	The program reads the composition of several families in a
	single text file, then executes different program discovery
	programs, and generates a summary report.

	Results are subdifided in directories created on the fly, one
	directory per family plus one summary directory.
	
CATEGORY
	sequences
	pattern discovery

OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-i	family file (incompatible with -seq)
	-seq	sequence file (incompatible with -i)
	-outdir	output directory

    Sequence retrieval options
	-org	organism
	-noorf	exclude upstream ORFs from upstream sequences
	-from	upstream region left limit
	-to	upstream region right limit
        -feattype
		feature type (e.g. CDS, mRNA)

    oligo-analysis and dyad-analysis options
	-1str   strand-sensitive analysis
	-2str   strand-insensitive analysis
	-htmaps	draw html maps (dynamic map with pointers to the features)
		These html files take space on the hard drive, so I
		suppressed them from the default output.
	-noov	prevent overlapping matches for self-overlapping patterms
		(default)
	-ovlp	allow overlapping matches for self-overlapping patterms
	-nomap	do not draw feature maps (for saving time and hard disk space)
	-bg	background frequency model
		This parameter indicates which background model has to
		be used for the estimation of expected pattern
		frequencies.
		Supported: $supported_background

    oligo-analysis options
	-maxol	maximum oligonucleotide length
	-minol	minimum oligonucleotide length
	-oligo_exp_freq
		name of a file containing the expected frequencies for
		oligo-analysis.
	-pseudo	pseudo-weight (see oligo-analysis manual)
	-markov #	
		calculate expected frequencies on the basis of a
		Markov chain model of order #

    dyad-analysis options
	-monad  monad length for dyad-analysis
	-minsp	maximum spacing for dyad-analysis
	-maxsp	maximum spacing for dyad-analysis
	-dyad_exp_freq
		name of a file containing the expected frequencies for
		dyad-analysis.

    Output options
	-transp	transpose synthetic result table (columns become rows)
	-sort sort_key
	        sort key for the synthetic table
		Supported: $supported_sort_keys

   Options for the automaticaly generated SQL scripts
	-schema database schema (default: $schema)
	-host	database host (default: $host)
	-user	database user (default: $user)
	-password	
		database password (default: $password)

    Other options
	-task selected_task
		Select the tasks to be performed.
		Supported tasks: $supported_tasks

		Can be used iteratively on the same command line to 
		select multiple tasks.  

		Example:
		    -task upstream -task oligos -task synthesis
		For a full analysis, simply type 
		    -task all
		
		See details below (TASK DESCRIPTION)

	-known	known_site_file
		A file containing a list of known sites/motifs for
		each of the gene families. These known sites are NOT
		used during the pattern discovery. They are simply
		displayed besides the discovered patterns, for the
		sake of comparison.
		
		Format: the known site file is a tab-delimited text
		files, with the collofing column content :
		       1) family
		       2) site/motif
		       3) source (optional)

FILE FORMAT
    $HELP_FAMILY_FILE
QUICK START
    1) create a directory for the set of families

    2) witin this directory, create a text file contaning the
       description of family composition, as described above
    
    3) run the command. For example, with a bacterial genome :

       multiple-family-analysis -org organism -i family_file \
           -v -from -200 -to 49 -task all

    4) With a web browser (e.g. Netscape), open the folder
       'synthetic_tables'. There should be a HTML file with the name
       of your family ile as prefix, and the suffix indicating the
       other analysis parameters. Open this file and analyze the
       result.

TASK DESCRIPTION

    all		Perform all the tasks below.

    upstream	Retrieve upstream sequences for the families.
		(retrieve-seq)

    purge	Purge upstream sequences for the family.
		(purge-sequences)

    calibrate   Perform a family-secific calibration of expected
		frequencies, by calculating oligonucleotide
		distributions in the whole genome set of upstream
		sequences of the same size. Beware: this takes time,
		but it gives much less false positives with when
		analyzing higher organisms.
   
    oligos	Run oligo-analysis on each family.

    dyads	Run dyad-analysis on each family.

    maps	Draw feature maps with the results of oligo-analysi and
		dyad-analysis.
		(feature-map)

    merge	Merge the results of oligo-analysis and dyad-analysis.

    slide	Match discovered patterns with a sliding window.
		(dna-pattern)

    synthesis	Generate a HTML report in the directory sythetic_tables.

    sql		Export the discovered patterns in tab-delimited files, 
		and export SQL scripts for loading these tables in a
		relational database.  

    clean	Delete upstream sequences after processing, in order 
		to save disk space.  
End_of_help
  close HELP;
  exit;
}

################################################################
#### display short help message
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
multiple-family-analysis options
--------------------------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-v		verbose
-i		family file (incompatible with -seq)
-seq		sequence file (incompatible with -i)
-outdir		output directory
-org		organism
-from		upstream region left limit
-to		upstream region right limit
-noorf		exclude upstream ORFs from upstream sequences
-feattype	feature type for sequence retrieval (e.g. CDS, mRNA)
-1str   	strand-sensitive analysis
-2str   	strand-insensitive analysis
-maxol		maximum oligonucleotide length
-minol		minimum oligonucleotide length
-monad		monad length for dyad-analysis
-minsp		maximum spacing for dyad-analysis
-maxsp		maximum spacing for dyad-analysis
-n      	dry run: print commands without executing them
-exp		expected frequency file
-transp		transpose synthetic result table (columns become rows)
-sort		sort key (supported: $supported_sort_keys)
-task		selected task (supported: $supported_tasks)
-htmaps		draw html maps (dynamic map with pointers to the features)
-dyad_exp_freq	expected frequencies for dyad-analysis
-oligo_exp_freq	expected frequencies for oligo-analysis
-noov		prevent overlapping matches for self-overlapping patterms
-ovlp		allow overlapping matches for self-overlapping patterms
-pseudo		pseudo-weight (see oligo-analysis manual)
-nomap		do not draw feature maps (for saving time and hard disk space)
-bg		background frequency modelEnd_short_help
-markov #	exp. freq. calcualted with Markov chain model of order #
-known		file containing a list of known sites/motifs
-schema		database schema (default: $schema)
-host		database host (default: $host)
-user		database user (default: $user)
-password	database password (default: $password)
End_short_help
  close HELP;
  exit;
}

################################################################
#### Read arguments
sub ReadArguments {
    foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    $verbose = $ARGV[$a+1];
	    unless (&IsNatural($verbose)) {
		$verbose = 1;
	    }
	    
	    #### dry run
	} elsif ($ARGV[$a] eq "-n") {
	    $dry_run = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions;
	    
	    ### family file
	} elsif (($ARGV[$a] eq "-i") ||
		 ($ARGV[$a] eq "-fam") # for compatibility with previous versions
		 ) {
	    $family_file = $ARGV[$a+1];

	    ### sequence file list
	} elsif ($ARGV[$a] eq "-seq") {
	    $sequence_file_list = $ARGV[$a+1];

	    ### output directory
	} elsif ($ARGV[$a] eq "-outdir") {
	    $dir{output} = $ARGV[$a+1];

	    ### upstream sequence lmits
	} elsif (($ARGV[$a] eq "-from") &&
		 (&IsInteger($ARGV[$a+1]))) {
	    $from = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-to") &&
		 (&IsInteger($ARGV[$a+1]))){
	    $to = $ARGV[$a+1];

	    ### strands 
	} elsif ($ARGV[$a] eq "-1str") {
	    $force{strands} = "-1str";
	} elsif ($ARGV[$a] eq "-2str") {
	    $force{strands} = "-2str";

	    ### oligo-analysis parameters
	} elsif ($ARGV[$a] eq "-minol") {
	    $min_oligo_len = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-maxol") {
	    $max_oligo_len = $ARGV[$a+1];;
	    
	    ### dyad-analysis parameters
	} elsif ($ARGV[$a] eq "-monad") {
	    $monad_length = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-minsp") {
	    $min_sp = $ARGV[$a+1];;
	} elsif ($ARGV[$a] eq "-maxsp") {
	    $max_sp = $ARGV[$a+1];;

	    ### organism
	} elsif ($ARGV[$a] eq "-org") {
	    $organism_name = $ARGV[$a+1];

	    ### file with a collection of known motifs, for comparison between discovered and known motifs
	} elsif ($ARGV[$a] eq "-known") {
	    $known_site_file = $ARGV[$a+1];

	    #### task selection
	} elsif ($ARGV[$a] eq "-task") {
	    my @requested_tasks = split ",", $ARGV[$a+1];
	    foreach my $task (@requested_tasks) {
		next unless $task;
#	    $task = $ARGV[$a+1];
		if ($supported_task{$task}) {
		    $task{$task} = 1;
		} else {
		    &FatalError("Unsupported task '$task'. \n\tSupported: $supported_tasks");
		}
	    }

	    #### transpose synthetic table
	} elsif ($ARGV[$a] =~ /^-transp/) {
	    $transpose = 1;

	    #### sort key
	} elsif ($ARGV[$a] =~ /^-sort/) {
	    $sort_key = $ARGV[$a+1];
	    unless ($supported_sort_key{$sort_key}) {
		&FatalError("$sort_key is not supported as sort key");
	    }

	    #### clip upstream ORFs fom upstream regions
	} elsif ($ARGV[$a] =~ /^-noorf/) {
	    $noorf = 1;

	    #### threshold
	} elsif ($ARGV[$a] =~ /^-th/) {
	    $force{th} = $ARGV[$a+1];

	    #### dyad type
	} elsif ($ARGV[$a] =~ /^-type/) {
	    $force{type} = $ARGV[$a+1];

	    #### feature types
	} elsif ($ARGV[$a] eq "-feattype") {
	    my @types = split ",", $ARGV[$a+1];
	    foreach my $type (@types) {
		if ($supported_feature_types{lc($type)}) {
		    $accepted_feature_types{lc($type)}++;
		} else {
		    &FatalError("$type invalid feature type. Supported: $supported_feature_types");
		}
	    }

	    #### expected frequency file for dyad-analysis 
	} elsif ($ARGV[$a] =~ /^-dyad_exp_freq/) {
	    $exp_freq_file{dyads} = $ARGV[$a+1];

	    #### expected frequency file for oligo-analysis 
	} elsif ($ARGV[$a] =~ /^-oligo_exp_freq/) {
	    $exp_freq_file{oligos} = $ARGV[$a+1];


	    #### background model for expected frequency. 
	    #### Supported: "upstream", "upstam-noorf", "intergenic", "mncf"
	} elsif (($ARGV[$a] =~ /^-exp/) 
		 || ($ARGV[$a] =~ /^-bg/)) {
	    $background = $ARGV[$a+1];
	    $background =~ s/^ncf$/intergenic/;

	    unless ($supported_background{$background}) {
		&FatalError("$background\tInvalid value for background. Supported : $supported_background");
	    }

	    #### Markov chain estimation of expected oligo frequencies
	} elsif ($ARGV[$a] =~ /^-markov/) {
	    $markov_order = $ARGV[$a+1];
	    $markov=1;
	    
	    #### prevent self-overlap
	} elsif ($ARGV[$a] eq "-noov") {
	    $noov = "-noov";

	    #### allow self-overlap
	} elsif ($ARGV[$a] eq "-ovlp") {
	    $noov = "-ovlp";

	    #### prevent feature-map drawing
	} elsif ($ARGV[$a] eq "-nomap") {
	    $draw_maps = 0;

	    #### draw htmaps
	} elsif ($ARGV[$a] =~ /^-htmap/) {
	    $draw_maps = 1;
	    $htmaps = 1;

	    #### pseudo-weight
	} elsif ($ARGV[$a] =~ /^-pseudo/) {
	    $pseudo = $ARGV[$a+1];
	    unless ((&IsReal($pseudo)) && ($pseudo > 0)) {
		&FatalError("pseudo-weight must be a positive real number");
	    }

	    #### Optoins for the SQL scripts
	} elsif ($ARGV[$a] eq "-schema") {
	    $schema = $ARGV[$a+1];
	} elsif ($ARGV[$a] eq "-host") {
	    $host = $ARGV[$a+1];
	} elsif ($ARGV[$a] eq "-user") {
	    $user = $ARGV[$a+1];
	} elsif ($ARGV[$a] eq "-password") {
	    $password = $ARGV[$a+1];

	}
    }
}



################################################################
# Verbosity
#
sub Verbose {
    my $verbose_message = "";
    $verbose_message .= "; multiple-family-analysis ";
    $verbose_message .= &PrintArguments()."\n";
    printf "; families     \t%d\n", $#families + 1;
    foreach my $family_name (@families) {
	printf ";\t%s\t%d elements\n", $family_name, $family{$family_name}->get_size();
    }
    if ($family_file) {
	$verbose_message .= sprintf "; Family file\t%s\n", $family_file ;
	$verbose_message .= sprintf "; Upstream regions\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "Strands", $strands;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "From", $from;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "To", $to;
    } elsif ($sequence_file_list) {
	$verbose_message .= sprintf "; Sequence file list\t%s\n", $sequence_file_list;
    }
    $verbose_message .= sprintf "; %-13s\t%s\n", "Organism", $organism_name;

    if ($task{oligos}) {
	$verbose_message .= sprintf "; oligo-analysis\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "max oligo length", $max_oligo_len;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "min oligo length", $min_oligo_len;
    }
    
    if ($task{dyads}) {
	$verbose_message .= sprintf "; dyad-analysis\n";
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "monad length", $monad_length;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "min spacing", $min_sp;
	$verbose_message .= sprintf ";\t%-22s\t%d\n", "max spacing", $max_sp;
	$verbose_message .= sprintf ";\t%-22s\t%s\n", "dyad type", $dyad_type;
	$verbose_message .= sprintf ";\t%-22s\t%g\n", "sig threshold", $th;
    }

    if ($markov) {
	$verbose_message .= sprintf "; %-13s\t%s\n", "Markov chains, order", $markov_order;
    } elsif ($background) {
	$verbose_message .= sprintf "; %-13s\t%s\n", "background model", $background;
    }

    $verbose_message .= "; No overlap with upstream ORFs\n" if ($noorf);
    if ($noov eq "-noov") {
	$verbose_message .= "; Overlapping matches are discarded for self-overlapping patterns\n" ;
    } else {
	$verbose_message .= "; Overlapping matches are allowed for self-overlapping patterns\n" ;
    }
    warn $verbose_message;
    return($verbose_message);
}


################################################################
### initialize one directory for each family
sub MakeDirectories {
    foreach $family_name(@families) {
	$dir = "${family_name}/";
	unless (-d $dir) {
	    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
	}
	open FAM, ">$family{$family_name}->{family_file}" ||
	    die "Error: cannot write family file $family{$family_name}->{family_file}\n";
	foreach $id ($family{$family_name}->get_members()) {
	    print FAM "$id\t$name{$id}\n";
	    
	}
	close FAM;
    }
}


################################################################
### Generate tab files and SQL scripts for storing the results in a
### relational database
sub ExportSQL {
    warn "; Generating SQL $table_file\n" if ($verbose >= 1);
    my $test = new RSAT::Family;
    my $time_prefix = time();
    my $family_factory = classes::ClassFactory->new_class(object_type=>"RSAT::Family",
							  prefix=>$time_prefix);
    
    
#    my $pattern_prefix = "pat_".&AlphaDate()."_";
    my $pattern_factory = classes::ClassFactory->new_class(object_type=>"RSAT::Pattern",
							   prefix=>$time_prefix);
    my $table_file = $dir."/".$table_suffix;

    my %export_columns = ();

    foreach my $family_name (@families) {

	#### general family attributes
	my $family_object = $family_factory->new_object(id=>$family_name);
	my $family_id = $family_object->get_attribute("id");
	$family_object->set_attribute("name", $family_name);
	$family_object->set_attribute("size", scalar(@{$family{$family_name}->{members}}));
	$family_object->set_attribute("organism", $organism_name);
	$family_object->set_attribute("suffix", $table_suffix);

	warn join ("\t", ";\tSQL export for family", $family_name, $organism_name), "\n" if ($main::verbose >= 2);
	
	#### family members
	my @members = @{$family{$family_name}->{members}};
	foreach my $m (@members) {
	    $family_object->push_attribute("genes", $m);
	}

	#### discovered oligos
	my $oligo_file = $family{$family_name}->{oligo_file};
	if (-e $oligo_file) {
	    my %export_columns = ();
	    ($oligo_handle, $dir) = &OpenInputFile($oligo_file);
	    while (<$oligo_handle>) {
		chomp;
		if (/^;/) {
		    if ((/;\s+(\d+)\t(\S+)/) && ($2 ne "id")){
			$export_columns{$2} = $1 - 1;
		    }
		    next;
		}
		next unless (/\S/);
		my @fields = split;
		my $sequence = uc($fields[0]);
#		my %export_columns = ();
		my $oligo_object = $pattern_factory->new_object();
		warn join ("\t", "; Created object", $sequence, $oligo_object), "\n" if ($main::verbose >= 3);
		foreach $k (sort keys %export_columns) {
		    warn join ("\t", ";", "specifying attribute", 
			       $k, 
			       $export_columns{$k},
			       $fields[$export_columns{$k}],
			       ), "\n" if ($main::verbose >= 5);
		    $oligo_object->set_attribute($k, $fields[$export_columns{$k}]);
		}
		warn join ("\t", ";", "specifying sequence", $sequence), "\n" if ($main::verbose >= 5);
		$oligo_object->force_attribute("sequence", $sequence);
		$oligo_object->set_attribute("type", "oligo");
		$oligo_object->set_attribute("family_id", $family_id);
		$oligo_object->set_attribute("family", $family_name);
		if ($strands eq "2str") {
		    $oligo_object->force_attribute("rev_compl", &ReverseComplement($oligo_object->get_attribute("sequence")));
		}
	    }
	    close $oligo_handle;
	} else {
	    my $pwd = `pwd`;
	    chomp $pwd;
	    &Warning("$family_name\t$pwd\toligo file $oligo_file does not exist\tSKIPPED\n");
	}

	#### discovered dyads
	my $dyad_file = $family{$family_name}->{dyad_file};
	if (-e $dyad_file) {
	    my %export_columns = ();
	    open DYADS, $dyad_file;
	    while (<DYADS>) {
		chomp;
		if (/^;/) {
		    if ((/;\s+(\d+)\t(\S+)/) && ($2 ne "id")){
			$export_columns{$2} = $1 - 1;
		    }
		    next;
		}
		next unless (/\S/);
		my @fields = split;
		my $sequence = uc($fields[0]);
		$sequence =~ s/N/n/g;
#		$sequence =~ s/n\{0\}//g;
		my $dyad_object = $pattern_factory->new_object();
		warn join ("\t", "; Created object", $sequence, $oligo_object), "\n" if ($main::verbose >= 3);
		foreach $k (sort keys %export_columns) {
		    warn join ("\t", ";", "specifying attribute", 
			       $k, 
			       $export_columns{$k},
			       $fields[$export_columns{$k}],
			       ), "\n" if ($main::verbose >= 5);
		    $dyad_object->set_attribute($k, $fields[$export_columns{$k}]);
		}
		warn join ("\t", ";", "specifying sequence", $sequence), "\n" if ($main::verbose >= 5);
		$dyad_object->force_attribute("sequence", $sequence);
		$dyad_object->set_attribute("type", "dyad");
		$dyad_object->set_attribute("family_id", $family_id);
		$dyad_object->set_attribute("family", $family_name);
		if ($strands eq "2str") {
		    my $rc_sequence = uc( &ReverseComplement($dyad_object->get_attribute("sequence")));
		    $rc_sequence =~ s/N/n/g;
		    $dyad_object->force_attribute("rev_compl",$rc_sequence);
		}
	    }
	    close DYADS;
	} else {
	    &Warning("$family_name\tdyad file $dyad_file does not exist\tSKIPPED\n");
	}
	
	
    }

    ## Specify output fields
    $family_factory->set_out_fields(qw(id organism size name suffix genes));
    @pattern_out_fields = qw(id
			     family_id
			     family 
			     type 
			     sequence 
			     rev_compl
			     occ 
			     exp_occ
			     occ_P
			     occ_E
			     occ_sig
			     rank
			     );
    $pattern_factory->set_out_fields(@pattern_out_fields);

    #### export directory
    $dir{sql} = "sql_export";
    &CheckOutDir($dir{sql});

    ### temporary output directory
    $dir{output_bk} = $dir{output};
    $dir{output} = $dir{sql};
    my $pwd = `pwd`;
    chomp $pwd;
    warn join ("\t", $pwd , $dir{output}, $dir{output_bk}), "\n";
    #### export the result tables
    foreach my $factory ($family_factory, $pattern_factory) {
	$factory->dump_tables();
	$factory->generate_sql(schema=>$schema, 
			       host=>$host, 
			       password=>$password, 
			       user=>$user);
    }
    &ExportMakefile("family", "pattern");
#    $dir{output} = $dir{output_bk};
#    chdir($dir{output});
}

## ##############################################################
## The input is a list of sequence files instead of a family file
sub ReadSequenceList {
    ($dir{sequences}, $short_sequence_file_list) = &SplitFileName($sequence_file_list);

    ## Convert relative to absolute directory
    if ($dir{main}) {
	$dir{sequences} = $dir{main}."/".$dir{sequences};
    }

#    die $dir{sequences};

    warn "; Reading sequence file list\t", $sequence_file_list, "\n" if ($verbose >= 1);
    my ($files) = &OpenInputFile($sequence_file_list);
    my $f = 0;
    while (<$files>) {
	next if (/^;/);
	next unless (/\S/);
	chomp;
	$f++;
	my @fields = split /\s+/;
	my $sequence_file = shift @fields; ## the first word of each row is a file
	my $short_file = &ShortFileName($sequence_file);
	my $family_name = $short_file;
	$family_name =~ s|\.${seq_ext}$||;
        my $comment = join "; ", @fields;
	
#	push @families, $family_name;
#	push @sequence_files, $sequence_file;

	#### create a new family if required
	unless ($family{$family_name}) {
	    $family{$family_name} = new RSA::family(name=>$family_name);
	}

        #### Sequence file
	if ($dir{sequences}) {
	    $family{$family_name}->{seq_file} = $dir{sequences}."/".$sequence_file;
	} else {
	    $family{$family_name}->{seq_file} = $sequence_file;
	}
	$family{$family_name}->{seq_file_purged} = $family{$family_name}->{seq_file};
	$family{$family_name}->{seq_file_purged} =~ s/\.${seq_ext}$//;
	$family{$family_name}->{seq_file_purged} .= "_purged.".${seq_ext};
         
        #### Comment
        $family{$family_name}->{comment} = $comment;

	warn join ("\t", "; File $f", 
		   $sequence_file, 
		   $short_file, 
		   $family_name, 
		   $comment, 
#		   "\n", $family{$family_name}->{seq_file},
#		   "\n", $family{$family_name}->{seq_file_purged}
		   ), "\n" if ($verbose >= 2); 
	
	push @comments, $comment;
    }
    close $files;

    @families = sort keys %family;


    #### Family members are read from the sequence file (sequence IDs are used as member IDs)
    foreach my $family_name (@families) {
        my ($in, $input_dir) =  &OpenInputFile($family{$family_name}->{seq_file});
        my $seq_type = "dna";
        while ((($current_seq, $current_id, @comments) = &ReadNextSequence($in, $seq_format, $input_dir, $seq_type)) &&
	   (($current_seq) || ($current_id))) {
            $family{$family_name}->new_member($current_id);
            warn join ("\t", 
		       ";\tFile", $family{$family_name}->{seq_file}, 
		       "Family", $family_name, 
		       "member", $current_id), "\n" if ($main::verbose >= 2);
        }
        close $in;
    }
}


################################################################
## Index one sequence length per family
sub CalcCalibrationLengths {
    my %calib_lengths = ();
    warn ";\n; Calculating sequence lengths\n" if ($verbose >=1);
    foreach $family_name (@families) {
	$fam_count++;
	
	## Calculate sequence lengths
	warn join("\t", ";\tSequence lengths", 
		  $family_name, 
		  $family{$family_name}->{seq_len_file}), "\n" if ($verbose >= 3);
	my $command = "sequence-lengths -i ".$family{$family_name}->{seq_file};
	$command .= " -o ".$family{$family_name}->{seq_len_file};
	&doit($command, $dry_run, $die_on_error);
	
	## Index sequence lengths
	my ($in, $indir) = &OpenInputFile($family{$family_name}->{seq_len_file});
	while (<$in>) {
	    chomp;
	    @fields = split "\t";	    
	    my $current_len = $fields[1];
	    ## check that all sequences of one family have the same length
	    if (defined($family{$family_name}->{calib_length})) {
		unless ($family{$family_name}->{calib_length} == $current_len) {
		    &FatalError("Sequences of family $family_name have different lengths.\nThis is not incompatible with the option calibrate");
		}
	    } else {
		$family{$family_name}->{calib_length} = $current_len;
		$calib_lengths{$current_len}++;
	    }
	}
	close $in;
	warn ";\tcalibration length for family ", $family_name, "\t", $calib_lengths{$family_name}, "\n" if ($main::verbose >= 1);
    }  
    my @calib_lengths = keys %calib_lengths;
    warn "; Calibration lengths\n;\t", join( "\n;\t", @calib_lengths), "\n";
    return @calib_lengths;
}

################################################################
## Calibrate oligonucleotide occurrences (mean and variance) for each
## sequence length
sub CalibrateOligos {
    my @calib_lengths = @_;
    warn ";\n; Calibrating oligonucleotide occurrences\n" if ($verbose >=1);

    ### Analyse upstream occurrence distributions for each sequence length
    &CheckOutDir($dir{calib});
    warn "; Calculating oligonucleotide distributions in all upstream sequences\n" if ($verbose >= 1);
    foreach my $calib_length (@calib_lengths) {
	## retrieve all upstream sequence
	my $allup = $dir{calib}."/tmp_all_up_${len}.fasta";
	my $command = "retrieve-seq -org $organism_name -all -from -$calib_length -to -1 -o $allup";
#	warn ";\tRetrieving all upstream sequences\t", $allup, "\n" if ($main::verbose >= 0);
#	&doit($command, $dry_run, $die_on_error);

	for my $oligo_len ($min_oligo_len..$max_oligo_len) {

	    my $calib_prefix = &CalibrationPrefix($calib_length, $oligo_len);

	    ## Calculate occurrence distributions
	    my $distrib_file = $calib_prefix."_distrib.tab";
	    $command = "oligo-analysis -v 1 -l $oligo_len $noov $strands  -i $allup -return occ -distrib -o $distrib_file";
#	    warn ";\tAnalysing ",$oligo_len,"nt distributions\t",$distrib_file, "\n" if ($main::verbose >= 0);
#	    &doit($command, $dry_run, 0);
	    
	    ## Calculate stats and fit negbin on the distributions
	    my $fitting_file = $calib_prefix."_negbin.tab";
	    $command = "fit-distribution -v 1 -i $distrib_file -distrib negbin -o $fitting_file";
	    &doit($command, $dry_run, $die_on_error);
	}

	## Delete the file with all upstream sequences
	$command = "rm -f $allup";
#	warn ":\tCleaning all upstream sequences\t", $allup, "\n" if ($main::verbose >= 0);
#	&doit($command, $dry_run, 0);
    }

}

## ##############################################################
## Calculate the prefix of the calibration file
sub CalibrationPrefix {
    my ($calib_length, $oligo_len) = @_;
    my $calib_prefix = $dir{calib}."/";
    $calib_prefix .= $oligo_len."nt";
    $calib_prefix .= "_upstream_L".$calib_length;
    $calib_prefix .= "_".$organism_name;
    $calib_prefix .= $noov;
    $calib_prefix .= $strands;
    return $calib_prefix;
}


