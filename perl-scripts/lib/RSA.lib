#!/usr/bin/perl
#use CGI;
#require "cgi-lib.pl";

### CVS: moved ENV{SERVER_ADMIN} to the config file

$main::verbose = 0;
require "RSA.seq.lib";
require "RSA.stat.lib";
require RSAT::organism;
require RSAT::contig;
require RSAT::error;
require RSAT::util;
require RSAT::Tree;

package main;

umask 0022;

## CVS: created separate objects for handling different methods
## RSAT::organism (check_name, is_supported)
## RSAT::error (FatalError, cgiError)
## RSAT::util (IsNatureal, IsReal, IsInteger, trim, round)
## ReadFeatures became RSAT::organism::LoadFeatures

############################################################################
############################################################################
############################################################################
############################################################################
############################################################################
####                                                                    ####
####                            RSA.lib                                 ####
####                                                                    ####
#### Regulatory Sequence Analysis Tools (RSA-tools)
####  Project started in 1997 by Jacques van Helden (jvanheld@scmbb.ulb.ac.be)
####  a Perl library with diverse procedures
####  used by rsa-tools perl scripts


############################################################################
########################## PATH DEFINITION ##############################
############################################################################


#### read config files #####
if ($0 =~ /([^(\/)]+)$/) {
    $config_file = "$`../RSA.config";
    require $config_file;
    if ($ENV{'RSA_LOCAL_CONFIG'}) {
	if (-e $ENV{'RSA_LOCAL_CONFIG'}) {
	    if (-r $ENV{'RSA_LOCAL_CONFIG'}) {
		require $ENV{'RSA_LOCAL_CONFIG'};
	    } else {
		warn (";WARNING: cannot read local config file ", 
		      $ENV{'RSA_LOCAL_CONFIG'}, 
		      "\n"), 
	    }
	} else {
	    warn (";WARNING: local config file ", 
		  $ENV{'RSA_LOCAL_CONFIG'}, 
		  " does not exist\n"), 
	}
    }
} else {
    &RSAT::error::FatalError("Error: problem when opening config file. Please contact jvanheld\@scmbb.ulb.ac.be");
}

$BIN = "$RSA/bin";
$LIB = "$RSA/lib";
$TMP = "$RSA/public_html/tmp";
$LOGS = "$RSA/logs";
$SCRIPTS = "$RSA/perl-scripts";

my $login = getlogin();

################################################################
## Redirect queries to a remote server 
##
## This piece of code used to ensure load balancing between several
## machines, but it relies on rsh, which is not a safe protocol. In
## case of need, it could be adapted to work with ssh in the
## future. Anyway, this will probably be replaced by more efficient
## protocols for grid computation.
if ($REMOTE_SERVER) {
    if (($login eq "webserv") || !($login)) {
	$NICE = "nice +5";
	$RSH = "rsh -l jvanheld ${REMOTE_SERVER} $NICE";
	$SCRIPTS = "$RSH /home/rsa/rsa-tools/perl-scripts";
	$BIN = "$RSH /home/rsa/rsa-tools/bin";
    }
}


$HTML = "$RSA/public_html"; 
$WWW_TMP = "$WWW_RSA/tmp";
#$ENV{SERVER_ADMIN} = "jvanheld\@scmbb.ulb.ac.be";

$counter_file = "$LOGS/count-file";
($sec, $min, $hour,$day,$month,$year) = localtime(time);
$log_file = sprintf "$LOGS/log-file_${config_site}_%04d_%02d", $year+1900,$month+1;

$date = &AlphaDate();

############################################################################
############################ GLOBAL VARIABLES ##############################
############################################################################


############################################################################
##################### PERL SUBROUTINE DEFINITION ###########################
############################################################################



################################################################
## echo a command and send it to the system
## Usage:
##   &doit($command, $dry, $die_on_error, $verbose, $batch, $job_prefix);
sub doit {
    my ($command, $dry, $die_on_error, $verbose, $batch, $job_prefix) = @_;
    my $wd = `pwd`;
    chomp $wd;

    if ($batch) {
	## Store the command in a sh script (the job)
	my $job_dir = "jobs";
	$job_dir .= "/".`date +%Y%m%d`;
	chomp($job_dir);
	my $job_prefix = $job_prefix || "doit";
	&RSAT::util::CheckOutDir($job_dir);
	my $job = `mktemp ${job_dir}/${job_prefix}.XXXXXX`;
	chomp $job;
	open JOB, ">$job";
	print JOB "( cd ", $wd;
	print JOB "; date > ", $job, ".started"; ## Write a file called [job].started indicating the time when the job was started
        print JOB "; hostname >> ", $job,".started"; 
	print JOB "; ", $command;
	print JOB "; date > ", $job, ".done"; ## Write a file called [job].done indicating the time when the job was done
	print JOB "; hostname >> ", $job, ".done"; ## Write a file called [job].done indicating the time when the job was done
	print JOB " )", "\n";
	close JOB;
	&RSAT::message::TimeWarn(join("\t", "Job queued", $wd."/".$job)) if ($main::verbose >= 0);
	
	my $job_name = $job;
	$job_name =~ s/\//_/g;
	my $job_log = $wd."/".$job.".log";
	## Send the command to a batch queue on a PC cluster The default
	## values are for internal use in the SCMBB, but alternative values
	## can be specified by specifying the environment variables
	## CLUSTER_QUEUE and CLUSTER_MASTER
	my $cluster_queue = $ENV{CLUSTER_QUEUE} || "short";
	my $batch_mail=$ENV{BATCH_MAIL} || "a";
	my $qsub_manager=$ENV{QSUB_MANAGER} || "sge";
	$selected_nodes = " -l nodes=1:k2.6 ";
	my $qsub_cmd;


	################################################################
	## Choose the queue manager depending on the local configuration
	if ($qsub_manager eq "torque") {
	    ## qsub command functionning using Torque
	    my $cluster_master=$ENV{CLUSTER_MASTER} || "arthur.scmbb.ulb.ac.be"; ## for torque only
	    $qsub_cmd = "qsub ".$selected_nodes." -m ".$batch_mail." -q ".$cluster_master." -N ${job} -j oe -o ${job}.log ${job}";

	} else {
	    ## qsub command functionning using Sun Grid Engine (SCMBB)
	    $qsub_cmd = join(" ", "qsub", 
			     "-m",$batch_mail,
			     "-q ", $cluster_queue, 
			     " -j y ",
			     "-N ", $job_name,
			     "-o ".$job_log, $job);
	}
	&doit($qsub_cmd, $dry, $die_on_error,$verbose,0);

    } else {
	## Verbose
	if (($dry) || ($main::verbose >= 2)) {
	    warn "\n";
	    &RSAT::message::TimeWarn("Working dir", $wd) if ($main::verbose >= 3);
	    &RSAT::message::TimeWarn($command);
	}

	## Send the command to the queue
	unless ($dry) {
	    my $error = system $command;
	    if ($die_on_error) {
		if ($error == -1) {
		    &RSAT::error::FatalError("Could not execute the command\n\t$command");
		} elsif ($error) {
		    &RSAT::error::FatalError("Error", $error , "occurred during execution of the command", "\n\t".$command);
		}
	    } else {
		return ($error);
	    }
	}
    }
}



################################################################
## Name of the expected oligo frequency file, 
## given the organism, oligo length and background model
##
sub ExpectedFreqFile {
    my ($organism_name, $oligo_length, $background, %args) = @_;
    my $exp_freq_file = "";
    my $str = $args{str} || "-2str";
    my $noov = $args{noov} || "-noov";
    my $noov_suffix;
    if ($noov eq "-noov") {
      $noov_suffix = "-noov";
    } else { 
      $noov_suffix = "-ovlp";
    }
    my $type = $args{type} || "oligo";

    #### organism
    &CheckOrganism($organism_name);

    #### check oligo length
    unless ($oligo_length) {
	&FatalError("You must specify the oligonucleotide length for the background model (expected frequency file)");
    }

    unless (&IsNatural($oligo_length)) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be a natural number");
    }
    if ($oligo_length < 1) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be >= 1");
    }
    if ($oligo_length > 8) {
	&RSAT::error::FatalError("Invalid oligonucleotide length : must be <= 8");
    }

    my $data_dir = $supported_organism{$organism_name}->{'data'};
    $exp_freq_file = $data_dir."/oligo-frequencies/";
    if ($type eq "dyad") {
      ## Dyad frequencies
      $exp_freq_file = join("",
			    $data_dir,
			    "/oligo-frequencies/dyads_",$oligo_length,"nt_sp0-20_",
			    $background_model,
			    "_",
			    $organism_name,
			    $noov_suffix.$str,
			    ".freq");

    } elsif ($background eq "upstreamL") {
      ## ???
      $exp_freq_file .= "_".$organism_name;
      $exp_freq_file .= "_allup500";
      $exp_freq_file .= $oligo_length."nt";
      $exp_freq_file .= $str;
      $exp_freq_file .= $noov_suffix;
      $exp_freq_file .= "_freq.tab";

    } else {
      ## Oligonucleotide frequencies
      $exp_freq_file .= $oligo_length."nt";
      $exp_freq_file .= "_".$background;
      $exp_freq_file .= "_".$organism_name;
      $exp_freq_file .= $noov_suffix;
      $exp_freq_file .= $str;
      $exp_freq_file .= ".freq";
    }

    ## Check the existence of the exp freq file
    unless ((-e $exp_freq_file) ||
	    (-e $exp_freq_file.".gz")) {
      if ($args{warn}) {
	&RSAT::message::Warning("Cannot find expected frequency file $exp_freq_file");
      } else {
	&RSAT::error::FatalError("Cannot find expected frequency file $exp_freq_file");
      }
    }
    &RSAT::message::Info("Expected frequency file", $exp_freq_file) if ($main::verbose >= 2);
    return $exp_freq_file;
}


################################################################
# Read expected occurrences and variance from a calibration file
sub ReadCalibration {
    my ($calibration_file, $sum_rc) = @_;
    
    my ($cal) = &OpenInputFile($calibration_file);
    my $l=0;
    while (<$cal>) {
	$l++;
	chomp();
	next if (/^--/);
	next if (/^;/);
	next if (/^\#/);
	next unless (/\S/);
	my @fields =  split /\s+/;
	my $pattern_seq = lc(shift(@fields));
	my $pattern_id = $pattern_seq;

	## Check if the 1st field contains a pair of reverse complements
	if ($pattern_seq =~ /(\S+)\|/) {
	    $pattern_seq = $1;
	}
	
	## Check if the second field contains the ID
	if ($fields[0] =~ /(\S+)\|/) {
	    $pattern_id = shift(@fields);
	}

	## Expected occurrences
	my $exp_occ = $fields[0];
	&RSAT::error::FatalError("Invalid expected occurrences\t${exp_occ}") unless ((&IsReal($exp_occ)) && ($exp_occ >= 0));
	$patterns{$pattern_seq}->{exp_occ} = $exp_occ;

	## Expected variance
	my $exp_var = $fields[2];
	&RSAT::error::FatalError("Invalid expected variance") unless ((&IsReal($exp_var)) && ($exp_ocvar >= 0));
	$patterns{$pattern_seq}->{exp_var} = $exp_var;

	warn join("\t", "; calibration", $pattern_seq, 
		  $patterns{$pattern_seq}->{exp_occ},
		  $patterns{$pattern_seq}->{exp_var}), "\n" if ($main::verbose >= 5);

    }
    close $cal if ($calibration_file);
    
    #### check if reverse complements were included in the expected freq file;
    #### if not, infer them from the direct strand 
    foreach my $pattern_seq (sort keys %patterns) {
  	my $rc = lc(&SmartRC($pattern_seq));
  	if (($patterns{$rc}->{exp_occ} <= 0) &&
  	    ($patterns{$pattern_seq}->{exp_occ})) {
  	    $patterns{$rc}->{exp_occ} = $patterns{$pattern_seq}->{exp_occ};
  	    $patterns{$rc}->{exp_var} = $patterns{$pattern_seq}->{exp_var};
	    #print STDERR join "\t", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n";
  	}
    }
}



################################################################
## Read pattern frequencies
##
## Usage: 
##   my ($file_type, %patterns) = &ReadPatternFrequencies($pattern_freq_file [, $sum_rc, $rescale_freq]);
##
sub ReadPatternFrequencies {
  my ($pattern_freq_file, $sum_rc, $rescale_freq) = @_;
  &RSAT::message::TimeWarn ("Reading pattern frequency file", $pattern_freq_file) if ($main::verbose >= 2);
  
  my ($exp) = &OpenInputFile($pattern_freq_file);
  my $l=0;
  my %patterns = ();
  my $file_type = "undef";

  while (<$exp>) {
      my $line = $_;
    $l++;
    chomp();
    next if (/^--/); ## Skip comment line
    next if (/^;/); ## Skip comment line
    next if (/^\#/); ## Skip header line
    next unless (/\S/); ## Skip comment line

    my @fields =  split /\s+/;
    my $pattern_seq = lc($fields[0]);
    next unless $pattern_seq;

#    &RSAT::message::Debug( "fields", join ("\t", @fields)) if ($main::verbose >= 0);

    #### check the format and extract expected frequency
    if (&IsReal($fields[1])) {
      ### second field contains the expected frequency (old format)
      $patterns{$pattern_seq}->{exp_freq} = $fields[1];

    } elsif (($fields[1] =~ /(\S+)\|(\S+)/) && (&IsReal($fields[2]))) {
      #### second field contains the ID as a pair of reverse complements
      $file_type = "2str";
      my $fw = lc($1);
      my $rc = lc($2);
      $patterns{$rc}->{exp_freq} = $fields[2];
      $patterns{$fw}->{exp_freq} = $fields[2];

    } elsif	(($fields[1] eq $fields[0]) && (&IsReal($fields[2]))) {
      #### second field contains the ID which is identical to the pattern (single strand pattern)
      $file_type = "1str";
      $patterns{$fields[0]}->{exp_freq} = $fields[2];

    } else {
      ### unrecognized format
      &RSAT::error::FatalError("Invalid expected frequency in file $pattern_freq_file at line $l\n$line\n");
    }

    if ($patterns{$pattern_seq}->{exp_freq} < 0) {
      &RSAT::error::FatalError("Expected frequency cannot be negative\t$pattern_seq\t".$patterns{$pattern_seq}->{exp_freq});
    }
  }
  close $exp if ($pattern_freq_file);

  ################################################################
  #### Check if reverse complements were included in the fequency file;
  #### if not, infer them from the direct strand 
  if ($file_type eq "2str") {
    foreach my $pattern_seq (sort keys %patterns) {
      my $rc = lc(&SmartRC($pattern_seq));
      if ((!defined($patterns{$rc}->{exp_freq})) &&
	  ($patterns{$pattern_seq}->{exp_freq})) {
	$patterns{$rc}->{exp_freq} = $patterns{$pattern_seq}->{exp_freq};
	#	    &RSAT::message::Debug("Checking reverse complement", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n" if ($main::verbose >= 10);
      }
    }
  }

  ################################################################
  ## sum expected frequencies by reverse complements
  ## unless the input file already contained 2str counts
  if (($sum_rc) && ($file_type eq "1str")) {
    &SumExpectedFrequencies(%patterns);
  }

  #### make sure that the sum of frequencies is positive
  my $freq_sum = 0;
  foreach my $pattern_seq (keys %patterns) {
    $freq_sum += $patterns{$pattern_seq}->{exp_freq};
  }
  if ($freq_sum <= 0) {
    &RSAT::error::FatalError("Error with the expected frequency file : the sum must be strictly positive\t$freq_sum");
  }
  
  #### rescale expected frequencies to have a sum of 1
  if ($rescale_freq) {
    &RSAT::message::Info("Rescaling expected frequencies") if ($main::verbose >=2);
    foreach my $pattern_seq (keys %patterns) {
      $patterns{$pattern_seq}->{exp_freq} /= $freq_sum;
    }
  }
  return ($file_type, %patterns);
}

################################################################
# Read pattern expected frequencies from a file This does the same as
# ReadOligoFrequencies, but it modifies a global variable
# %patterns. This is not very elegant, I just maintain it temporarily,
# until I find time to implement and test a more appropriate procedure.
sub ReadExpectedFrequencies {
    my ($exp_freq_file, $sum_rc, $rescale_freq) = @_;
    &RSAT::message::TimeWarn ("Reading expected frequency file", $exp_freq_file) if ($main::verbose >= 2);
    my ($exp) = &OpenInputFile($exp_freq_file);
    my $l=0;

    while (<$exp>) {
	my $line = $_;
	$l++;
	chomp();
	next if (/^;/);
	next if (/^\#/); 
	next unless (/\S/);

	my @fields =  split /\s+/;
	my $pattern_seq = lc($fields[0]);
	next unless $pattern_seq;

	&RSAT::message::Debug( "fields", join ("\t", @fields)) if ($main::verbose >= 10);

	#### check the format and extract expected frequency
	if (&IsReal($fields[1])) {
	    ### second field contains the expected frequency (old format)
	    $patterns{$pattern_seq}->{exp_freq} = $fields[1];
	    $file_type="undef";

  	} elsif (($fields[1] =~ /(\S+)\|(\S+)/) && (&IsReal($fields[2]))) {
	    #### second field contains the ID as a pair of reverse complements
	    $file_type = "2str";
  	    $fw = lc($1);
  	    $rc = lc($2);
  	    $patterns{$rc}->{exp_freq} = $fields[2];
  	    $patterns{$fw}->{exp_freq} = $fields[2];

  	} elsif	(($fields[1] eq $fields[0]) &&(&IsReal($fields[2]))) {
	    #### second field contains the ID which is identical to the pattern (single strand pattern)
	    $file_type = "1str";
  	    $patterns{$fields[0]}->{exp_freq} = $fields[2];

	} else {
	    ### unrecognized format
	    &RSAT::error::FatalError("Invalid expected frequency in file $exp_freq_file at line $l\n$line\n");
	}

	if ($patterns{$pattern_seq}->{exp_freq} < 0) {
	    &RSAT::error::FatalError("Expected frequency cannot be negative\t$pattern_seq\t".$patterns{$pattern_seq}->{exp_freq});
	}
    }
    close $exp if ($exp_freq_file);

    #### check if reverse complements were included in the expected freq file;
    #### if not, infer them from the direct strand 
    foreach my $pattern_seq (sort keys %patterns) {
  	my $rc = lc(&SmartRC($pattern_seq));
  	if ((!defined($patterns{$rc}->{exp_freq})) &&
  	    ($patterns{$pattern_seq}->{exp_freq})) {
  	    $patterns{$rc}->{exp_freq} = $patterns{$pattern_seq}->{exp_freq};
#	    warn join "\t", $pattern_seq,  $patterns{$pattern_seq}->{exp_freq}, $rc, $patterns{$rc}->{exp_freq}, "\n" if ($main::verbose >= 10);
  	}
    }

    #### sum expected frequencies by reverse complements
    if (($sum_rc) && ($file_type eq "1str")) {
	&SumExpectedFrequencies(%patterns);
    }

    #### make sure that the sum of frequencies is positive
    my $freq_sum = 0;
    foreach my $pattern_seq (keys %patterns) {
	$freq_sum += $patterns{$pattern_seq}->{exp_freq};
    }
    if ($freq_sum <= 0) {
	&RSAT::error::FatalError("Error with the expected frequency file : the sum must be strictly positive\t$freq_sum");
    }

    #### rescale expected frequencies to have a sum of 1
    if ($rescale_freq) {
	&RSAT::message::Info("Rescaling expected frequencies") if ($main::verbose >=2);
	foreach my $pattern_seq (keys %patterns) {
	    $patterns{$pattern_seq}->{exp_freq} /= $freq_sum;
	}
    }

    &RSAT::message::TimeWarn("Expected frequencies loaded from file",$exp_freq_file,
			     "file_type=".$file_type,
			     "sum_rc=".$sum_rc,
			     "rescale_freq=".$rescale_freq,
			    ) if ($main::verbose >=2);


    return %patterns;
}


################################################################
## Sum expected frequencies
##
sub SumExpectedFrequencies {
  my (%patterns) = @_;
  my %freq_2str = ();
  &RSAT::message::TimeWarn("Summing expected frequencies") if ($main::verbose >=2);
  foreach my $pattern_seq (sort keys %patterns) {
    my $rc = lc(&SmartRC($pattern_seq));
    if ($rc eq $pattern_seq) {
      #### palindromic sequence
      $freq_2str{$pattern_seq} =   $patterns{$pattern_seq}->{exp_freq};
    } else {
      #### non-palindromic sequence : the expected frequency is the sum of the sequence + its reverse complement 
      $freq_2str{$pattern_seq} =  $freq_2str{$rc} = $patterns{$rc}->{exp_freq} + $patterns{$pattern_seq}->{exp_freq};
    }
    &RSAT::message::Debug($pattern_seq, $patterns{$pattern_seq}->{exp_freq}, $freq_2str{$pattern_seq},
			  $rc, $patterns{$rc}->{exp_freq}, $freq_2str{$rc}) if ($main::verbose >= 5);
  }

  foreach my $pattern_seq (sort keys %patterns) {
    my $rc = &SmartRC($pattern_seq);
    $patterns{$pattern_seq}->{exp_freq} = $freq_2str{$pattern_seq};
    $patterns{$rc}->{exp_freq} = $freq_2str{$pattern_seq};
  }

}


################################################################
# Calculate conditional residue probabilities on the basis of specified
# oligonucleotide frequencies
sub CalcConditionalProbabilities {
    my ($exp_freq_file) = @_;

    &ReadExpectedFrequencies($exp_freq_file) ;

    &RSAT::message::TimeWarn("Calculating Markov model from file $exp_freq_file") if ($main::verbose >= 2);
    
    foreach my $pattern_seq (keys %patterns) {
	$expected_freq{$pattern_seq} = $patterns{$pattern_seq}->{exp_freq};
    }

    #### calculate alphabet from expected frequency keys
    foreach my $pattern_seq (keys %patterns) {
	my @residues = split "|", $pattern_seq;
	foreach my $r (@residues) {
	    $letter{$r} = 1;
	}
    }
    @letters = keys (%letter);

    #### calculate subword frequencies
    %subword_freq = ();
    foreach my $oligo_seq (keys %expected_freq) {
	my $subword = substr($oligo_seq,0,-1);
	$subword_freq{$subword} += $expected_freq{$oligo_seq};
    }

    foreach $subword (keys %subword_freq) {
	for $l (0..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    if ($subword_freq{$subword} > 0) {
		$conditional_proba{$subword}[$l] =  $expected_freq{$word}/$subword_freq{$subword};
	    } else {
		$conditional_proba{$subword}[$l] =  "NA";
	    }
	}
    }

    #### calculate cumulative conditional residue probabilities
    foreach $subword (keys %subword_freq) {
	$word = lc($subword.$letters[0]);
	$cum_letter_freq{$subword}[0] = $expected_freq{$word};
	$cum_letter_freq{$subword}[0]/=$subword_freq{$subword} if $expected_freq{$word};
# 	warn (join ("\t", 
# 		    $subword, 
# 		    $subword_freq{$subword},
# 		    $word, 
# 		    $expected_freq{$word},
# 		    $cum_letter_freq{$subword}[0]
# 		    ), "\n");
	for $l (1..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    $cum_letter_freq{$subword}[$l] = $cum_letter_freq{$subword}[$l-1];
	    $cum_letter_freq{$subword}[$l] += $expected_freq{$word}/$subword_freq{$subword} if $expected_freq{$word};
#	    warn (join ("\t", 
#			$subword, 
#			$subword_freq{$subword},
#			$word, 
#			$expected_freq{$word},
#			$cum_letter_freq{$subword}[$l]
#			), "\n");
	}
    }
    @subword_keys = sort keys %subword_freq;
}

################################################################
#### increment the counter file for monitoring web access
sub UpdateCounterFile {
    my $nb_visitors = 1;

    ### read previous counter value
    if (-e $counter_file) {
	open(COUNTER, "<$counter_file");
	#flock(COUNTER, 2);
	$nb_visitors = <COUNTER>;
	#flock(COUNTER,8);
	close(COUNTER);
	$nb_visitors++;
    }
    
    ### save new counter value
    open(COUNTER, ">$counter_file");
    #flock(COUNTER,2);
    print COUNTER $nb_visitors;
    #flock(COUNTER,8);
    close(COUNTER);
    
    return $nb_visitors;
}


################################################################
### store info into a log file in a conveninent way for 
### subsequent login statistics
### Usage:
###     &UpdateLogFile();
###     &UpdateLogFile($script_name);
###     &UpdateLogFile($script_name, $message);
sub UpdateLogFile {
  my ($script_name, $message) = @_;

  unless ($script_name) {
    $script_name = &RSAT::util::ShortFileName($0);
  }

  if (open LOG, ">>$log_file") {
    #flock(LOG,2);
    $date = &AlphaDate();
    $date =~ s/\n//;
    print LOG join ("\t", 
		    $date,
		    $config_site, 
		    "$ENV{'REMOTE_USER'}\@$ENV{'REMOTE_ADDR'} ($ENV{'REMOTE_HOST'})",
		    $script_name,
		    $query->param('user_email'),
		    $message
		    ), "\n";
    #flock(LOG,8);
    close LOG;
  }
  chmod 0777, $log_file;
}



################################################################
#### send a unix command to remove a file the next day
#### Usage:
#### &DelayedRemoval($file_to_remove, $delay);
####
sub DelayedRemoval {
    my ($file_to_remove, $delay) = @_;
    $delay = "12 hours" unless ($delay);

    unless (-e $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove does not exist");
	return();
    }
    unless (-r $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove is not readable");
	return();
    }
    unless (-w $file_to_remove) {
	&MessageToAdmin("DelayedRemoval: file $file_to_remove is not writable");
	return();
    }

    &MessageToAdmin("DelayedRemoval: file $file_to_remove will be removed in $delay") if ($ECHO >= 2);

    #### TEMPORARILY INACTIVATED BECAUSE IT MOBILIZES A LOT OF MEMORY
    return();

    open REMOVE, "| at now + $delay";
    print REMOVE "rm -f $file_to_remove \n";
    close REMOVE;
}


################################################################
### prints a list of elements, one per line
sub PrintList {
    my $spacer = "\n";
    foreach $element (@_) {
	print $element;
	print $spacer;
    }

}

################################################################
#### print the command-line arguments
sub PrintArguments {
    my $local_out = $_[0];
#    unless ($local_out)  {
#	$local_out = STDOUT;
#    }
    my $argument_string = "";

    foreach my $a (@main::ARGV) {
	if (($a =~ /\s+/)  ||
	    ($a !~ /\S+/) ||
	    ($a =~ /[\(\)\>\<\&]/)) {
	    $argument_string .= " '$a'";
	} else {
	    $argument_string .= " $a";
	}
    }
    print $local_out $argument_string, "\n" if ($local_out);
    return $argument_string;
}


############################################################
###############  Genome data ###############################
############################################################

@supported_feature_types = qw (CDS mRNA tRNA rRNA scRNA);
%supported_feature_types = ();
foreach my $type (@supported_feature_types) {
    $supported_feature_types{lc($type)} = 1;
}
$supported_feature_types = join ",", @supported_feature_types;


################################################################
## Check if the specified organism name is supported on this server
sub CheckOrganismName {
    my ($organism_name) = @_;
     unless ($supported_organism{$organism_name}) {
	&RSAT::error::FatalError("Organism $organism_name is not supported.",
		    "Supported on this site : \n".&ListSupportedOrganisms());
    }
}

################################################################
## Collect all organisms belonging to a given taxon
sub GetOrganismsForTaxon {
  my ($query_taxon) = @_;
  my @organisms = ();
  foreach my $org (sort keys %supported_organism) {
    my $taxonomy = $supported_organism{$org}->{'taxonomy'};
    my @org_taxa = split /\s*;\s*/, $taxonomy;
    &RSAT::message::Debug("GetOrganismsForTaxon", $query_taxon, "checking", $org) if ($main::verbose >= 5);
    foreach my $orf_taxon (@org_taxa) {
      if (lc($orf_taxon) eq lc($query_taxon)) {
	push @organisms, $org;
	&RSAT::message::Debug("GetOrganismsForTaxon", $query_taxon, "collected", $org) if ($main::verbose >= 3);
      }
    }
  }
  return @organisms;
}

################################################################
## Check if there is at least one supported organism belonging to the
## specified taxon on this RSAT server.
sub CheckTaxon {
  my ($query_taxon) = @_;
  my @organisms = &GetOrganismsForTaxon($query_taxon);
  if (scalar(@organisms) > 0) {
    return @organisms;
  } else {
    &RSAT::error::FatalError("There is no supported organism for taxon", $taxon, 
			     "\nType supported-organisms -format full for a list of supported taxa");
  }
}

################################################################
#### Check if an organism is supported on the current installation,
#### and open streams to read its genome sequence.
####
#### Usage
#### -----
#### Automatic selection of genome and feature file : 
####    &CheckOrganism($organism_name); 
####
#### Manual specification of input files :
#### &CheckOrganism($organism_name, 
####                $annotation_table, 
####                $input_sequence_format);
sub CheckOrganism {
    my ($organism_name, $annotation_table, $input_sequence_file, $input_sequence_format) = @_;
    my $organism_object = new RSAT::organism();
    $organism_object->OpenContigs($organism_name, 
				  $annotation_table, 
				  $input_sequence_file, 
				  $input_sequence_format);
    return $organism_object;
}




################################################################
## Return a list of the supported organisms
## various formats are supported
sub ListSupportedOrganisms {
  my $out_format = $_[0] || "text";

  foreach my $key (keys %main::supported_organism) {
      $names{$key} = $main::supported_organism{$key}->{'name'};
#      print "HELLO $key\t",$main::supported_organism{$key}->{'name'}, "\t", $names{$key}, "\n";;
  }
  @sorted_names = sort values %names;
  @sorted_keys = sort keys %supported_organism;

  if ($out_format eq "html_list") {
      my $result = "<UL>\n";
      foreach my $name (@sorted_names) {
	  $result .= "<LI>";
	  $result .= $name;
	  $result .= "\n";
      }
      $result .= "</UL>\n";
      return $result;
  } elsif ($out_format eq "html_table") {
      my $result = "<TABLE>\n";
      foreach my $key (@sorted_keys) {
	  $result .= "<TR>\n";
	  $result .= "<TD>$key</TD>\n";
	  $result .= "<TD>";
	  $result .= $names{$key};
	  $result .= "</TD>\n";
	  $result .= "</TR>\n";
      }
      $result .= "</TABLE>\n";
      return $result;
  } elsif (($out_format eq "names") ||
	   ($out_format eq "array")) {
      return @sorted_names;
  } elsif ($out_format eq "keys") {
      return @sorted_keys;
  } elsif ($out_format eq "hash") {
      my %result = ();
      foreach my $ket (@sorted_keys) {
	  $result{$key} = $main::supported_organism{$key}->{name};
      }
      return %result;
  } elsif ($out_format eq "sizes") {
      #### collect the default limits for each organism
      my $result = sprintf ";\t%-35s\t%7s\t%7s\t%s\n", "Organism", "upstream from", "upstream to", "taxonomy";
      foreach my $key (sort @sorted_keys) {
	  $result .= sprintf ("\t%-35s\t%7s\t%7s\t%s\n", 
			      $key, 
			      $supported_organism{$key}->{'up_from'},
			      $supported_organism{$key}->{'up_to'}
			      );
      }
      return $result;
  } elsif ($out_format eq "full") {
      #### collect the default limits for each organism
      my $result = join ("\t", 
			 "; organism",
# 			 "taxid", 
			 "taxonomy", 
			 "last update", 
			 "upstream from", 
			 "upstream to")."\n";
      foreach my $key (sort @sorted_keys) {
	  $result .= join ("\t", 
			   $key,  
# 			   $supported_organism{$key}->{'taxid'},
			   $supported_organism{$key}->{'taxonomy'},
			   $supported_organism{$key}->{'last_update'},
			   $supported_organism{$key}->{'up_from'},
			   $supported_organism{$key}->{'up_to'}
			   )."\n";
      }
      return $result;
  } else {
      my $result = "";
      foreach $key (@sorted_keys) {
	  $result .= sprintf "\t\t%-30s", $key;
	  $result .= "\t";
	  $result .= $names{$key};
	  $result .= "\n";
      }
      return $result;
  }
}

$supported_organisms = &ListSupportedOrganisms();





# ################################################################
# ## Methods below have been transferred to RSAT::util

sub ConvertStrand {
    return &RSAT::util::ConvertStrand(@_);
}

sub OpenInputFile {
    return &RSAT::util::OpenInputFile(@_);
}

sub OpenOutputFile {
    return &RSAT::util::OpenOutputFile(@_);
}

sub IsNatural {
    return &RSAT::util::IsNatural(@_);
}

sub IsInteger {
    return &RSAT::util::IsInteger(@_);
}

sub IsReal {
    return &RSAT::util::IsReal(@_);
}

sub round {
    return &RSAT::util::round(@_);
}

sub trim {
    return &RSAT::util::trim(@_);
}

sub AlphaDate {
    return &RSAT::util::AlphaDate(@_);
}

sub SplitFileName {
    return &RSAT::util::SplitFileName(@_);
}

sub ShortFileName {
    return &RSAT::util::ShortFileName(@_);
}

sub ExtractPath {
    return &RSAT::util::ExtractPath(@_);
}

################################################################
#### Treatment of warnings and  errors
################################################################


################################################################
### Messages and errors are now passed to RSAT::message and RSAT::error
sub FatalError {
    &RSAT::error::FatalError(@_);
}

sub cgiError {
    &RSAT::error::cgiError(@_);
}


sub Warning {
    &RSAT::message::Warning(@_);
}

sub cgiWarning {
    &RSAT::message::cgiWarning(@_);
}

sub Info {
    &RSAT::message::Info(@_);
}

sub cgiMessage {
    &RSAT::message::cgiMessage(@_);
}

sub TimeWarn {
    &RSAT::message::TimeWarn(@_);
}

sub MessageToAdmin {
    &RSAT::message::MessageToAdmin(@_);
}


################################################################
## Changed the name of this method
sub ReadFamilies {
    &ReadClasses(@_);
}

## ############################################################
## Read a file with class composition (groups, families, sets).
##
## The file is supposed to contain at least two columns 
## - element (e.g. a gene ID)
## - class (e.g. a functional class, or a regulon, or a clustering result)
## additional columns are allowed, but they are ignored.
##
## By default, the first column contains the members, and the secon column the
## class names. A member can belong to several classes, and each class can
## contain one or several members.
##
## Arguments:
##
## 1) Family_file: file containing the class compositions. If not specified,
##    the STDIN is used as input.
##
## 2) get_orf_id: when the first column contain gene names, this arguments
## allow to get the corresponding IDs from the RSAT database. The next
## argument (organism ) must be specified in this case.
##
## 3) organism: only necessary if the option get_orf_idd is active. 
## 
## 4) no_subst: by default, probematic characters (white spaces,
##    semicolons, parentheses) are converted to a dot (for
##    compatibility with the folder creation in
##    multiple-family-analyss). This conversion can be inactivated by
##    entering a value (e.g.1) for the argument no_subst.
##
## 5) member_column: column containing the member names/IDs (default: 1)
##
## 6) class_column: column containing the class names/IDs (default: 2)
##
sub ReadClasses {
    my ($family_file, $get_orf_id, $organism, $no_subst,$member_column, $class_column, $score_column) = @_;

    ## Check score column
    if ($score_column) {
	unless (&IsNatural($score_column)) {
	    &RSAT::error::FatalError(join("\t", $score_column, "Invalid specification of score column for the procedure ReadClasses()"));
	}
    }

    ## Check member column
    if ($member_column) {
	unless (&IsNatural($member_column)) {
	    &RSAT::error::FatalError(join("\t", $member_column, "Invalid specification of member column for the procedure ReadClasses"));
	}
    } else {
	$member_column=1;
    }

    ## Check class column
    if ($class_column) {
	unless (&IsNatural($class_column)) {
	    &RSAT::error::FatalError(join("\t", $class_column, "Invalid specification of class column for the procedure ReadClasses"));
	}
    } else {
	$class_column=2;
    }

    &RSAT::message::TimeWarn(join ("\t", "Reading family file",$family_file))
	if ($main::verbose >=2);
    
    my %family = ();
    my ($fam) = &OpenInputFile($family_file);

    my $line = 0;
    while (<$fam>) {
	$line++;
	if (($main::verbose >= 2) && ($line % 2000 ==0)) {
	  &RSAT::message::TimeWarn( "Read", $line, "lines from family file",$family_file);
	  if ($line % 10000 == 0) {
	    &RSAT::message::psWarn( "Read", $line, "lines from family file",$family_file);
	  }
	}
	next if (/^--/);
	next if (/^;/);
	next if (/^\#/);
	next unless (/\S/);
	chomp;
	s/\r$//;
	my @fields = split /\t/;
	
	### family member
	$member_name = &trim(uc($fields[$member_column -1]));
	unless ($member_name =~ /\S/) {
	  &RSAT::message::Warning("Error family file", 
				  $family_file,  "line", 
				  $line, "member not specified") if ($main::verbose >= 1);
	  next;
	}

	### family name
	$family_name = &trim($fields[$class_column - 1]);
	unless ($family_name) {
	  &RSAT::message::Warning("Error family file", 
				  $family_file,  "line", 
				  $line, "family not specified") if ($main::verbose >= 1);
	    next;
	}

	## Substitute problematic characters
	unless ($no_subst) {
	    $subst_char = ".";
	    $family_name =~ s/ +/${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\//${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\:/${subst_char}/g; ## spaces create problems with file names in Unix
	    $family_name =~ s/\(/${subst_char}/g; ## paretheses interfere with Unix commands
	    $family_name =~ s/\)/${subst_char}/g; ## paretheses interfere with Unix commands
	}

	#### create a new family if required
	unless ($family{$family_name}) {
	    $family{$family_name} = new RSAT::Family(name=>$family_name);
	}

	################################################################
	### identify the gene on the basis of its name
	my $member_key = "";
	if (($get_orf_id) && ($organism)) {
	    ### identify the gene on the basis of its name
	    my $feature = $organism->get_feature_for_name($member_name);
	    if ($feature) {
		$member_key = $feature->get_attribute("id");
	    } else {
		&RSAT::message::Warning(join ("\t", "organism", $organism->get_attribute("name"), 
					      "has no feature with name", $member_name));
	    }
#	    $member_key = $orf_id{$member_name};
	} else {
	    $member_key = $member_name;
	}

	if ($member_key) {
	    if ($score_column) {
		### score
		local $score = &trim($fields[$score_column - 1]);
		unless (&IsReal($score)) {
		    &RSAT::error::FatalError(join("\t", $score, "Invalid score (must be a Real number).", 
						  "family file", $family_file,  
						  "line", $line,
						  "member", $member_name,
						  "family", $family_name,
						  ));
		}
		$family{$family_name}->new_member($member_key, 0, score=>$score);
#		&RSAT::message::Debug("member score", $family_name, $member_name, $score) if ($main::verbose >= 0);
	    } else {
		$family{$family_name}->new_member($member_key);
	    }
	    &RSAT::message::Warning( join ("\t",  ";", $family_name,
					   $member_name,
					   $member_key,
					   $name{$id}) ) if ($main::verbose >= 5);
#	    &RSAT::message::Debug("Scores", $family_name, $family{$family_name}->get_attribute("scores")) if ($main::verbose >= 0);
	} else {
	    &RSAT::message::Warning ($member_name." unknown gene name");
	}
    }
    close $fam if ($family_file);


    return %family;
}



#### end of the library #####
1; # return true



