#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.classes";


#### configuration #####
$line_width = 0;
$out_format = "wc";
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;



&ReadArguments();


#### accepted feature types
unless (defined %accepted_feature_types) {
    %accepted_feature_types = %supported_feature_types;
}
$feature_types = join ",", keys (%accepted_feature_types);

#### default : return sequences of all types
unless (defined(%return)) {
  $return{'pos'} = 1;
  $return{'ncs'} = 1;
  $return{'cs'} = 1;
  $return{'div'} = 1;
  $return{'conv'} = 1;
  $return{'tandem'} = 1;
  $return{'orf'} = 1;
  $return{'seq'} = 1;
}
   
#### organism
$organism = &CheckOrganism($organism_name);
&ReadFeatures($organism_name,"",$feature_types);

 
#&OldReadOrganism();


&PrintVerbose if ($verbose);

### open all output files
open NC_POSITIONS, ">${organism_name}_intergenic_segments.pos" if ($return{pos});
open NC_SEQ, ">${organism_name}_intergenic_segments.$out_format" if (($return{'ncs'}) && ($return{seq}));

open DIVERGENT_NC_SEQ, ">${organism_name}_intergenic_segments_divergent.$out_format" if (($return{'div'}) && ($return{seq}));
open CONVERGENT_NC_SEQ, ">${organism_name}_intergenic_segments_convergent.$out_format" if (($return{'conv'}) && ($return{seq}));
open TANDEM_NC_SEQ, ">${organism_name}_intergenic_segments_tandem.$out_format" if (($return{'tandem'}) && ($return{seq}));

open C_POSITIONS, ">${organism_name}_gene_segments.pos" if ($return{pos});
open C_SEQ, ">${organism_name}_gene_segments.$out_format" if (($return{'cs'}) && ($return{seq}));
open ORF_SEQ, ">${organism_name}_ORF_sequences.$out_format" if (($return{'orf'}) && ($return{seq}));

### print headers
print NC_POSITIONS ";segm_type_nb\tchr\tstart\tend\tleft\tright\n"  if ($return{pos});
print C_POSITIONS ";segm_type_nb\tORFs\tchr\tstart\tend\tleft\tright\n"  if ($return{pos});

foreach my $chromosome ($organism->get_chromosomes()) {
    ### read chromosomal sequence
    my $chr = $chromosome->get_name();
    
    my $sequence = $chromosome->get_attribute("sequence");
    if ($sequence) {
	$seq_file = $sequence->get_attribute("filename");
    } else {
	&FatalError("There is no sequence for chromosome $chr");
    }
    
    my $chr_length = $sequence->get_length();

    ### sort ORF from current chromosome
    my @genes = $chromosome->get_genes();
    printf "; %s\t%s\t%d\t%d\n", $seq_file, $chr, $chr_length, $#genes+1 
	if ($verbose);

    @sorted_orfs = sort {
	(($left{$a} <=> $left{$b}) || (($left{$a} == $left{$b}) && ($right{$a} <=> $right{$b})))
	} @genes;

    ### print ORF sequences
    foreach $id (@sorted_orfs) {
	$seq_id = "${id}_${chr}_${start{$id}}_${end{$id}}_${strand{$id}}";
	$current_seq = $sequence->get_sequence($left{$id},$right{$id});
#	warn $seq_id, "\t", $current_seq, "\n";

	if ($strand{$id} eq "R") {
	    $current_seq = &ReverseComplement($current_seq);
	}
	&PrintNextSequence(ORF_SEQ, $out_format,$line_width,$current_seq,$seq_id)  if (($return{'orf'}) && ($return{seq}));
    }
    
    #### gene and intergenic segments
    $gene_end = 0;
    $end_reached = 0;
    $orf_nb = 0;
    $nc_left_ORF = "none";
    
    do {
	### next intergenic segments
	$nc_start = $gene_end+1;
	$cluster++;
	$orf_cluster = "$sorted_orfs[$orf_nb]";
	$gene_start = $left{$sorted_orfs[$orf_nb]};
	$nc_right_ORF = $sorted_orfs[$orf_nb];
	$nc_end = $gene_start - 1;

	@comments = ("intergenic_segment_${cluster}\t$chr\t$nc_start\t$nc_end\t$nc_left_ORF\t$nc_right_ORF");
	print NC_POSITIONS "$comments[0]\n" if ($return{pos});
	$seq_id = "intergenic_segment_${cluster}_${chr}_${nc_start}_${nc_end}_l${nc_left_ORF}_r${nc_right_ORF}";
	$current_seq = $sequence->get_sequence($nc_start,$nc_end);
	&PrintNextSequence(NC_SEQ, $out_format,$line_width,$current_seq,$seq_id) if (($return{'ncs'}) && ($return{seq}));
	if ($strand{$nc_left_ORF} eq $strand{$nc_right_ORF}) {
	    &PrintNextSequence(TANDEM_NC_SEQ, $out_format,$line_width,$current_seq,$seq_id) if (($return{'tandem'}) && ($return{seq}));
	} elsif (($strand{$nc_left_ORF} eq "R") && ($strand{$nc_right_ORF} eq "D")) {
	    &PrintNextSequence(DIVERGENT_NC_SEQ, $out_format,$line_width,$current_seq,$seq_id)  if (($return{'div'}) && ($return{seq}));
	} elsif (($strand{$nc_left_ORF} eq "D") && ($strand{$nc_right_ORF} eq "R")) {
	    &PrintNextSequence(CONVERGENT_NC_SEQ, $out_format,$line_width,$current_seq,$seq_id)  if (($return{'conv'}) && ($return{seq}));
	}

	### next gene segment
	$gene_end = $right{$sorted_orfs[$orf_nb]};
	$nc_left_ORF = "";

        #### look for next ORF whose left limit is at right
	while (($orf_nb < $#sorted_orfs) && 
	       ($left{$sorted_orfs[$orf_nb+1]} <= $gene_end)) { 
	    $orf_nb++;
	    $orf_cluster .= ";$sorted_orfs[$orf_nb]";
	    $nc_left_ORF = $sorted_orfs[$orf_nb] unless ($gene_end > $right{$sorted_orfs[$orf_nb]});
	    $gene_end = &max($gene_end, $right{$sorted_orfs[$orf_nb]});
	}

	@comments = ("gene_segment_${cluster}\t$orf_cluster\t$chr\t$gene_start\t$gene_end");
	print C_POSITIONS "$comments[0]\n"  if ($return{pos});
	$seq_id = "gene_segment_${cluster}_${chr}_${gene_start}_${gene_end}";
	$current_seq = $sequence->get_sequence($gene_start,$gene_end);
	&PrintNextSequence(C_SEQ, $out_format,$line_width,$current_seq,$seq_id)  if (($return{'cs'}) && ($return{seq}));

	$nc_left_ORF = $sorted_orfs[$orf_nb] unless ($gene_end > $right{$sorted_orfs[$orf_nb]});
	$orf_nb++;

	### last intergenic segment
	if ($orf_nb > $#sorted_orfs) {
	    $end_reached = 1;
	    $nc_start = $gene_end+1;
	    $nc_end = $chr_length;

	    @comments = ("intergenic_segment_${cluster}\t$chr\t$nc_start\t$nc_end");
	    print NC_POSITIONS "$comments[0]\n"  if ($return{pos});
	    $seq_id = "intergenic_segment_${cluster}_${chr}_${nc_start}_${nc_end}";
	    $current_seq = $sequence->get_sequence($nc_start,$nc_end);
	    &PrintNextSequence(NC_SEQ, $out_format,$line_width,$current_seq,$seq_id, @comments)  if (($return{'ncs'}) && ($return{seq}));

	}
    } until $end_reached;
}

close NC_SEQ;
close DIVERGENT_NC_SEQ;
close CONVERGENT_NC_SEQ;
close TANDEM_NC_SEQ;
close NC_POSITIONS;
close C_SEQ;
close C_POSITIONS;
close ORF_SEQ;

$done_time  = `date '+%d/%m/%y %H:%M:%S %Z'`;
print "; Job started $start_time" if ($verbose);
print "; Job done    $done_time" if ($verbose);


exit(0);

### help ###
sub PrintHelp {
    open HELP, "| more ";
    print HELP "
NAME
	coding-or-not 

	1997,1998 by Jacques van Helden (jvanheld\@scmbb.ulb.ac.be).

DESCRIPTION
	Starting from a complete assembled genome, generate
	non-redundant sets of sequences, partitioned into different
	sequence types (see options).

CATEGORY
	genomics

USAGE
	coding-or-not -org organism

OPTIONS
	-org	organism. Currently supported:
$supported_organisms
	-return	type of sequences to return. 
		The following options are available
		pos	positions of the gene/intergenic segments
		seq	return sequences
			(otherwise, only position files are printed)
		ncs	intergenic segments
			These sequences are further separated into 3 
			subsets, corresponding to the options div, conv 
			and tandem
		div	intergenic sequences separating two genes
			transcribed in divergent directions
		conv	intergenic sequences separating two genes
			transcribed in convergent directions
		tandem  intergenic sequences separating two genes
			transcribed in the same direction (tandem
			genes)
		cs	gene segments
			Warning : 
			- in case of gene overlap, a single segment
			is returned encompassing the two genes in a 
			non-redundant way.
			- the segments are returned in the same strand 
			as in the genome sequence file, which is 
			sometimes the reverse complement of the gene 
			sequence.  . 
		orf	open reading frame sequences
			Contrarily to cs, orf returns every gene sequence
			from the start to the stop codon, and in the
			gene strand 
		

OUTPUT
	gene sequence coordinates are stored in a file named 
		${organism_name}_gene_segments.pos
	intergenic sequence coordinates are stored in another file named 
		${organism_name}_intergenic_segments.pos
	gene sequences are stored in a file named 
		${organism_name}_gene_segments.seq
	intergenic sequences are stored in another file named 
		${organism_name}_intergenic_segments.seq
";
    close HELP;
    exit(0);
}


sub ReadArguments {
##### read parameters ###
    for $a (0..$#ARGV) {
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	} elsif ($ARGV[$a] eq "-org") {
	    $organism_name = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-help") || 
		 ($ARGV[$a] eq "-h")) {
	    &PrintHelp;
	} elsif ($ARGV[$a] eq "-return") {
	    chomp($ARGV[$a+1]);
	    @fields_to_return = split ",", $ARGV[$a+1];
	    foreach $field (@fields_to_return) {
		if ($field eq "ncs") {
		    $return{'ncs'} = 1;
		} elsif ($field eq "cs") {
		    $return{'cs'} = 1;
		} elsif ($field eq "pos") {
		    $return{'pos'} = 1;
		} elsif ($field eq "div") {
		    $return{'div'} = 1;
		} elsif ($field eq "conv") {
		    $return{'conv'} = 1;
		} elsif (($field =~ /^par/) || 
			 ($field =~ /^tandem/)) {
		    $return{'tandem'} = 1;
		} elsif ($field =~ /^orf/) {
		    $return{'orf'} = 1;
		} elsif ($field =~ /^seq/) {
		    $return{'seq'} = 1;
		} else {
		    &FatalError ("Unrecognized request: $field");
		}	
		
	    }
	}
    }
}




################################################################
#### print some verbosity
sub PrintVerbose {
    printf "; %-16s\t%s\n", "Organism", $supported_organism{$organism_name}->{'name'};
    printf "; %-16s\t%-12s\t%s\n", "feature file", $supported_organism{$organism_name}->{'features'};
    printf "; chromosome sequence file(s)\n";
    foreach $chromosome ($organism->get_chromosomes()) {
#	print "HELLO\tChromosome\t$chromosome\n";
#	print (";\t", join ("\t", 
#			    $chromosome->get_name(),
#			    $chromosome->get_sequence()->get_attribute("filename")
#			    )
#	       , "\n");
    }
    printf "; %-16s\t%-12s\t%s\n", , "ORFs in total", $orf_count;
    printf "; chr\tlength\torfs\n";
}
