#!/usr/bin/perl

### CVS: added tab as supported input format

############################################################
#
# $Id: convert-seq,v 1.20 2006/03/08 19:53:13 jvanheld Exp $
#
# Time-stamp: <2002-09-24 21:24:13 jvanheld>
#
############################################################

if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";

#### initialise parameters ####
$start_time = `date`;
$line_width = 60;
$check_id = 1;

$accepted_input_string = join "\n\t\t\t", "", sort(keys %accepted_input_seq);
$accepted_output_string = join "\n\t\t\t", "", sort(keys %accepted_output_seq); 

%args=();

&ReadArguments();


#### check argument values ####
unless ($line_width >= 0) {
    print "\tinvalid line width\n";
    print "\ttype convert-seq -h for help\n";
    exit;

}
&CheckInputSeqFormat($in_format);
&CheckOutputSeqFormat($out_format);

if ($out_format eq "wc") {
    $line_width = 0;
}
if ($out_format eq "multi") {
    $line_width = 0;
}

### open input file ###
($in, $input_dir) = &OpenInputFile($inputfile);

### open output file ###
$out = &OpenOutputFile($outputfile);
if ($outputfile) {
    $output_dir = `dirname $outputfile`;
}
unless ($output_dir) {
    $output_dir = `pwd`;
}
chomp $output_dir;

#### verbose ####
if ($verbose) {
    print ";convert-seq result\n";
    if ($inputfile ne "") {
	print ";Input file	$inputfile\n";
    }
    if ($outputfile ne "") {
	print ";Output file	$outputfile\n";
    }
    print ";Input format\t$in_format\n";
    print ";Output format\t$out_format\n";
}

## ##############################################################
## Read the sequences and convert them
while ((($current_seq, $current_id, @comments) = &ReadNextSequence($in, $in_format, $input_dir, "",$mask, %args)) &&
       (($current_seq ne "") || ($current_id ne ""))) {

    $seq_nb++;

    ## Remove empty sequences 
    if (($noempty) && ($current_seq !~ /\S/)) {
	next;
    }

    ## Mask short sequences
    if ($mask_short) {
	my $seq_len = length($current_seq);
	if ($seq_len < $mask_short) {
	    $current_seq = "N"x$seq_len;
	}
    }

    #### case conversion
    if ($lowercases) {
        $current_seq = lc($current_seq);

    } elsif ($uppercases) {
        $current_seq = uc($current_seq);
    } 

    #### DNA only
    if ($dna) {
        $current_seq = &CleanDNA($current_seq);
    }

    if ($seq_identifier) {
	#### identifier specified with the -id option
	$current_id = $seq_identifier;
    } elsif ($in_format eq "raw") {
	#### sequence id from file name
	$current_id =~ s/\.raw$//;
    }


    ## check that the a sequence identifier is defined
    unless ($current_id) {
	$current_id = $seq_nb;
    }
    
    ## Add a prefix to the sequence ID
    if ($seq_prefix) {
	$current_id = join ("", $seq_prefix, $current_id);
    }

    if ($out_format eq "filelist") {
	#$current_id = `basename $current_id .$in_format`;
	#if ($current_id =~ /\.$in_format/) {
	#    $current_id = $';
	#}

	#### Make sure that the id is a valid filename
	chomp $current_id;
	if ($check_id) {
	    $current_id =~ s/\|/_/g;
	    $current_id =~ s/\;/_/g;
	    $current_id =~ s/\:/_/g;
	    $current_id =~ s/\&/_/g;
	}
	$one_seq_file = "$current_id.raw";
	open RAW, "> ${output_dir}/$one_seq_file"
	    || die "Error: cannot write file ${output_dir}/$one_seq_file\n";
	&PrintNextSequence(RAW, "raw", 0, $current_seq, $current_id);
	close RAW;
	print $out "$one_seq_file\t$current_id\n";
    } else {
	&PrintNextSequence($out, $out_format, $line_width, $current_seq, $current_id, @comments);
    }
    if ($add_RC) {
	$current_id .= "_reverse_complement";
	@comments = ();
	$rev_seq = &ReverseComplement($current_seq);
	if ($lowercases) {
	    $rev_seq = lc($rev_seq);
	} elsif ($uppercases) {
	    $rev_seq = uc($rev_seq);
	} 
	if ($out_format eq "filelist") {
	    $one_seq_file = "${current_id}.raw";
	    open RAW, "> $one_seq_file";
	    &PrintNextSequence(RAW, "raw", 0, $rev_seq, $current_id);
	    close RAW;
	    print $out "$one_seq_file\n";
	} else {
	    &PrintNextSequence($out, $out_format, $line_width, $rev_seq, $current_id, @comments);
	}
    }
}

###### verbose ######
if ($verbose) {
    $done_time = `date`;
    print ";Job started $start_time";
    print ";Job done    $done_time";
}


###### close input file ######
if ($inputfile ne "") {
    close $in;
}

###### close output file ######
if ($outputfile ne "") {
    close $out;
}


exit(0);



################################################################
######################### SUBROUTINES ##########################
################################################################


sub PrintHelp {
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
	convert-seq

        v1.0, 1997 by Jacques van Helden (jvanheld\@scmbb.ulb.ac.be)
	
DESCRIPTION
	Converts sequences between different formats. Optionally, also
	returns the reverse-complement of the input sequences.

CATEGORY
	util
	sequences

USAGE
        consert-seq [-i inputfile] [-o outputfile] [-v] 
	          -id identifier
                  -from inputformat -to outputformat
                  [-lw line_width]
	
OPTIONS
	-v #	verbose level

	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.

	-mask upper|lower
		Mask lower or uppercases, respecively, i.e. replace
		selected case by N characters.

	-mask_short min_seq_len
		Mask (replace by N characters) sequences shorter than
		the specified length. This can be useful to discard
		short intergenic segments from the pattern discovery
		step, especially when working with bacterial genomes,
		where short intergenic sequences generally correspond
		to intra-operon segments.

	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.

	-from   input format
		    Supported input formats : $accepted_input_string

        -to     output format
		    Supported output formats : $accepted_output_string

        -lw #   line width. A carriage return is inserted every # 
                characters within the output sequence.
                Default is 60. A 0 value indicates that no carriage 
                return must be inserted.

        -addrc  adds the reverse complement of each input sequence
                to the output file. This is usefull for programs that 
                cannot handle reverse complement (like the Gibbs Sampler).

	-lc	lowercase. the sequence is printed in lowercase.

	-uc	lowercase. the sequence is printed in uppercase.

	-dna	convert any non-acgt character into "." 
		This is to filter out partly speciied nucleotides.

	-id identifier
		sequence identifier (useful for converting a raw
		sequence from the STDIN)

	-prefix prefix
		sequence prefix (useful for converting from a multi
		sequence)

	-nocheckid
		Prevent to check sequence IDs for conversion to file list

SUPPORTED FORMATS
    INPUT $accepted_input_string
	
    OUTPUT $accepted_output_string
	
EXAMPLES
	convert-seq -i myseq.IG -from IG -to FASTA -o myseq.FASTA

End_of_help
  close HELP;
  exit(0);
}

sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_shorthelp;
consvert-seq options
--------------------
-h			detailed help message
-help			short help message (shows the present message)
-v #			verbose level
-i			inputfile
-mask upper|lower	mask upper- or lowercases, respectively
-mask_short min_seq_len	Mask sequences shorter than the specified length
-o			outputfile
-from			input format (see below for accepted formats)
-to			output format (see below for accepted formats)
-lw #			line width. 
-addrc			add the reverse complement of each input sequence
-lc			convert all letters to lowercase
-uc			convert all letters to uppercase
-dna			convert any non-acgt character into "." 
-id			sequence identifier
-prefix			sequence prefix
-nocheckid		Prevent to check sequence IDs for conversion to the format filelist.
-noempty		Remove empty sequences from the set. 
SUPPORTED FORMATS
    INPUT $accepted_input_string
	
    OUTPUT $accepted_output_string
End_shorthelp
  close HELP;
  exit(0);
}


################################################################
## Read arguments 
sub ReadArguments {
    foreach $a (0..$#ARGV) {
	
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions();
	    
	    ## Input file
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];

	    ## mask upper or lower cases
	} elsif ($ARGV[$a] eq "-mask") {
	    $mask = $ARGV[$a+1];
	    &CheckMask($mask);	    

	    ## mask short sequences
	} elsif ($ARGV[$a] eq "-mask_short") {
	    $mask_short = $ARGV[$a+1];

	} elsif ($ARGV[$a] eq "-id") {
	    $seq_identifier = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-prefix") {
	    $seq_prefix = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    

	    ## Input formaat
	} elsif ($ARGV[$a] eq "-from") {
	    $in_format = lc($ARGV[$a+1]);
	    
	    ## Output format
	} elsif ($ARGV[$a] eq "-to") {
	    $out_format = lc($ARGV[$a+1]);
	    
	    ## ID column for the tab format
	} elsif ($ARGV[$a] eq "-id_col") {
	    $args{'id_column'} = $ARGV[$a+1];
	    &RSAT::error::FatalError(join("\t", 
					  $args{"id_column"},
					  "Invalid column specification for sequence ID. ". 
					  "Must be a strictly positive natural number"))
		unless &IsNatural($args{'id_column'}) && ($args{'id_column'} > 0);


	    ## Sequence column for the tab format
	} elsif ($ARGV[$a] eq "-seq_col") {
	    $args{'seq_column'} = $ARGV[$a+1];
	    &RSAT::error::FatalError(join("\t", 
					  $args{"seq_column"},
					  "Invalid column specification for sequence. ". 
					  "Must be a strictly positive natural number"))
		unless &IsNatural($args{'seq_column'}) && ($args{'seq_column'} > 0);

	    ## Comment column for the tab format
	} elsif ($ARGV[$a] eq "-comment_col") {
	    $args{'comment_column'} = $ARGV[$a+1];
	    &RSAT::error::FatalError(join("\t", 
					  $args{"comment_column"},
					  "Invalid column specification for sequence COMMENT. ". 
					  "Must be a strictly positive natural number"))
		unless &IsNatural($args{'comment_column'}) && ($args{'comment_column'} > 0);

	    ## Line width
	} elsif ($ARGV[$a] eq "-lw") {
	    $line_width = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-lc") {
	    $uppercases = 0;
	    $lowercases = 1;
	    
	} elsif ($ARGV[$a] eq "-uc") {
	    $uppercases = 1;
	    $lowercases = 0;
	    
	} elsif ($ARGV[$a] eq "-addrc") {
	    $add_RC = 1;

	} elsif ($ARGV[$a] eq "-dna") {
	    $dna = 1;
	    
	    ## Remove empty sequences from the set
	} elsif ($ARGV[$a] eq "-noempty") {
	    $noempty = 1;
	    
	    ## Prevent to check sequence IDs for conversion to file list
	} elsif ($ARGV[$a] eq "-nocheckid") {
	    $check_id = 0;
	    
	}
    }
}
