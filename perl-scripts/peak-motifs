#!/usr/bin/perl -w
############################################################
#
# $Id: peak-motifs,v 1.3 2010/03/04 15:12:11 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

chip-seq-analysis

=head1 VERSION

$program_version

=head1 DESCRIPTION

Pipeline for discoering motifs from ChIP-seq (or ChIP-chip) peak
sequences.

=head1 AUTHORS

=over

=item Jacques van Helden <Jacques.van.Helden@ulb.ac.be>

=item Morgane Thomas-Chollier <thomas-c@molgen.mpg.de>

=item Matthieu Defrance <defrance@ccg.unam.mx>

=back


=head1 CATEGORY

Pattern discovery

=head1 USAGE

chip-seq-analysis [-i inputfile] [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

The program takes as input either one (test) or two sequence files
(test versus control).

All input sequences formats supported by convert-sequences are
supported.

=head1 OUTPUT FORMAT


=head1 SEE ALSO

=head1 WISH LIST

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "footprint.lib.pl";
use RSAT::util;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();
    $program_version = do { my @r = (q$Revision: 1.3 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
#    $program_version = "0.00";

    %main::param = ();
    @main::param_list = ();

    %main::dir = ();
    %main::infile = ();
    %main::outfile = ();

    $main::prefix = "";
    $main::verbose = 0;
    $main::out = STDOUT;

    ################################################################
    ## Supported tasks
    @supported_tasks = qw (
			   all
			   seqlen
			   purge
			   oligos
			   dyads
			   ORM
			   oligo-diff
			   matrices
			   logos
			   profiles
			   scan
			   map
			   tomtom
			   to_bed
			   clean_seq
			  );
    $supported_tasks = join ",", @supported_tasks;
    %supported_task = ();
    foreach my $task (@supported_tasks) {
      $supported_task{$task} = 1;
    }
    %task = (); ## List of tasks to be executed

    ################################################################
    ## Set default parameters
    &DefaultParameters();

    ################################################################
    ## Read argument values
    &ReadArguments();

    &CheckArguments();

    &SetOutFileNames();

    if ($task{purge}) {
      &PurgeOneSeq($infile{test_seq}, "test");
      if ($infile{control_seq}) {
	&PurgeOneSeq($infile{control_seq}, "control");
      }
    }

    &OligoAnalysis if ($task{oligos});

    &CleanSequences() if ($task{clean_seq});

    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{log});

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    ################################################################
    ## Execute the command

    ################################################################
    ## Print output


    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }


    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    if ($main::verbose >= 1) {
      &TimeWarn("Job done");
      &TimeWarn("Log file", $outfile{log});
    }
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}


################################################################
## Set parameter values for all the programs
sub DefaultParameters {
  &RSAT::message::TimeWarn("Setting default parameter values") if ($main::verbose >= 1);

  ## Sequences
  $main::param{seq_format} = "fasta"; push(@main::param_list, "seq_format");

  ## Purge-seq
  $main::param{purge_match_length} = 30; push(@main::param_list, "purge_match_length");
  $main::param{purge_mismatches} = 0; push(@main::param_list, "purge_mismatches");

  ## Pattern discovery options
  $main::param{strand} = "-2str"; push(@main::param_list, "strand");
  $main::param{noov} = "-noov"; push(@main::param_list, "noov");
  $main::param{oligo_len} = 7; push(@main::param_list, "oligo_len");

  ## Oligo-analysis
  $main::param{oligo_markov} = -2; push(@main::param_list, "oligo_markov");

}


################################################################
## Define one output file name by concatenating arguments
sub OutFileName {
    my ($extension, @name_elements) = @_;
    my $out_file_name = $dir{output}."/".$prefix;
    $out_file_name .= join ("_", @name_elements);
    $out_file_name .= $extension;
    return($out_file_name);
}



################################################################
## Set output file names
sub SetOutFileNames {
    ## Purged sequences
    $main::outfile{"purged_test"} = &OutFileName(".fasta", 
						 "test",
						 "purged",
						 "ml".$main::param{purge_match_length},
						 "mis".$main::param{purge_mismatches});
    if ($infile{control_seq}) {
	$main::outfile{"purged_control"} = &OutFileName(".fasta", 
						     "control",
						     "purged",
						     "ml".$main::param{purge_match_length},
						     "mis".$main::param{purge_mismatches});
    }

    ## oligo-analysis result
    $main::outfile{oligos} = &OutFileName(".tab", "oligos".$main::param{strand}.$main::param{noov}, 
					  $main::param{oligo_len}."nt", 
					  "mkv".$main::param{oligo_markov},
	);
}

################################################################
## Purge sequences
sub PurgeOneSeq {
  my ($seq_file, $seq_type) = @_;
  &RSAT::message::TimeWarn("Purging sequences") if ($main::verbose >= 1);
  my $cmd = "convert-seq";
  $cmd .= " -i ".$seq_file;
  $cmd .= " -from ".$main::param{seq_format};
  $cmd .= " -to fasta";
  $cmd .= " -mask non-dna";
  $cmd .= "| purge-sequence -dna";
  $cmd .= " -ml ".$main::param{purge_match_length};
  $cmd .= " -mis ".$main::param{purge_mismatches};
  $cmd .= " -o ".$main::outfile{"purged_".$seq_type};
  &one_command($cmd);
}


################################################################
## Run oligo-analysis on the test set
sub OligoAnalysis {
  &RSAT::message::TimeWarn("Running oligo-analysis") if ($main::verbose >= 1);
  my $cmd = "oligo-analysis -v 1";
  $cmd .= " -i ".$main::outfile{"purged_test"};
  $cmd .= " -format fasta";
  $cmd .= " -sort -lth occ_sig 0 -uth rank 50 -return occ,proba,rank";
  $cmd .= " ".$main::param{strand};
  $cmd .= " ".$main::param{noov};
  $cmd .= " -seqtype dna";
  $cmd .= " -l ".$main::param{oligo_len};
  $cmd .= " -markov ".$main::param{oligo_markov};
  $cmd .= " -pseudo 0.01";
  $cmd .= " -o ".$outfile{oligos};
  &one_command($cmd);
}

################################################################
## Delete purged sequence files after analysis has been completed.
sub CleanSequences {
  &RSAT::message::TimeWarn("Cleaning sequences") if ($main::verbose >= 1);
  &one_command("rm -f ".$main::outfile{"purged_test"});
  if ($infile{control_seq}) {
    &one_command("rm -f ".$main::outfile{"purged_control"});
  }
}

################################################################
## Read arguments 
sub ReadArguments {
  &RSAT::message::TimeWarn("Reading arguments") if ($main::verbose >= 1);
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }

      ## Help message

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();

      ## List of options

=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

      ## Input files

=pod

=item B<-i test_seq_file>

Test peak sequence file (mandatory).

For single-set analysis, this file contains the peak seuences of the
unique set.  For test versus control analysis, it contains the test
sequences.

=cut
    } elsif ($arg eq "-i") {
      $main::infile{test_seq} = shift(@arguments);

=pod

=item B<-ctl control_seq_file>

Control peak sequence file (optional).

This option is used only for the test versus control analysis.

=cut
    } elsif ($arg eq "-ctl") {
      $main::infile{control_seq} = shift(@arguments);

      ## Output file

=pod

=item	B<-outdir output_directory>

Output directory (mandatory).

The result files and index files produced by the different programs
will be stored in this directory.



=cut
    } elsif ($arg eq "-outdir") {
      $main::dir{output} = shift(@arguments);

      ## Tasks

=pod

=item B<-task>

Specify a subset of tasks to be executed.

By default, the program runs all necessary tasks. However, in some
cases, it can be useful to select one or several tasks to be executed
separately.

Beware: task selection requires expertise, because most tasks depends
on the prior execution of some other tasks in the workflow. Selecting
tasks before their prerequisite tasks have been completed will provoke
fatal errors.

I<Avilable Tasks.>

=over

=item I<all> (default)

Run all supported tasks.

=item I<purge>

Purge input sequences (test set and, if specified, control set) to
mask redundant fragments before applying pattern discovey
algorithms. Sequence purging is necessary because redundant fragments
would violate the hypothesis of independence underlying the binomial
significance test, resulting in a large number of false positive
patterns.

=item I<oligos>

Delete the purged sequence files after the analysis, in order to save
space.

=item I<clean_seq>

Delete the purged sequence files after the analysis, in order to save
space.

=back

=cut
    } elsif ($arg eq "-task") {
      my @requested_tasks = split ",", shift (@arguments);
      foreach my $task (@requested_tasks) {
	next unless $task;
	if ($supported_task{$task}) {
	  $task{$task} = 1;
	} else {
	  &RSAT::error::FatalError("Task '$task' is not supported. \n\tSupported: $supported_tasks");
	}
      }

      ## Strands

=pod

=item B<-l oligo_len>

Oligonucleotide lengths for word-counting approaches
(oligo-analysis, position-analysis, ORM, oligo-diff).

Note: the monad length used for dyad-analysis is specified with
another parameter (-ml).

=cut
    } elsif ($arg eq "-l") {
      $main::param{oligo_len} = shift (@arguments);

      ## Strands

=pod

=item B<-1str | -2str>

Single-strand (-1str) or double-strand (-2str) analysis.

The default is double-strand analysis, since ChIP-seq results have no
particular strand orientation.

=cut
    } elsif ($arg eq "-1str") {
      $main::param{strand} = "-1str";
    } elsif ($arg eq "-2str") {
      $main::param{strand} = "-2str";

      ## Treatment of overlapping occurrences

=pod

=item B<-noov | -ovlp>

Treatment of self-overlapping words: count (-ovlp) or do not count
(-noov) overlapping occurrences. In -noov mode, only renewing
occurrences are counted.

It is recommended to use the -noov mode (default) to avoid the effect
of self-overlap, which violates the hypothesis of independence of
successive occurrences underlying the binomial significance test
(oligo-analysis, dyad-analysis).

=cut
    } elsif ($arg eq "-noov") {
      $main::param{noov} = "-noov";
    } elsif ($arg eq "-ovlp") {
      $main::param{noov} = "-ovlp";

    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}

################################################################
## Check arguments
sub CheckArguments {
  &RSAT::message::TimeWarn("Checking arguments") if ($main::verbose >= 1);
  if ($infile{test_seq}) {
    unless (-e $infile{test_seq}) {
      &FatalError("Test sequence file does not exist", $infile{test_seq});
    }
  } else {
    &FatalError("You must define the test sequence set (option -i)");
  }

  if ($infile{control_seq}) {
    unless (-e $infile{control_seq}) {
      &FatalError("Control sequence file does not exist", $infile{control_seq});
    }
  }

  ## output directory
  if ($main::dir{output}) {
    &RSAT::util::CheckOutDir($main::dir{output});
  } else {
    &FatalError("You must define the output directory (option -outdir)");
  }

  ## Log file 
  $main::outfile{log} = &OutFileName(".txt", "log");

  ## If all tasks are requested or if no task is defined, execute all
  ## tasks.
  if ((scalar(keys(%task)) == 0) || ($task{all})) {
    %task = %supported_task;
    delete($task{all});
    delete($task{clean_seq});
  }
  foreach my $task (@supported_tasks) {
   push (@tasks, $task) if $task{$task};
  }
  &RSAT::message::Info("Tasks: ", join (",", @tasks)) if ($main::verbose >= 1);
}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; chip-seq-analysis ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }

    print $main::out "; Parameter values\n";
    foreach my $param_name (@param_list) {
	print $main::out sprintf ";\t%-22s\t%s\n", $param_name, $param{$param_name};
    }
}


__END__
