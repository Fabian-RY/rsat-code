#!/usr/bin/perl -w
############################################################
#
# $Id: taxon-frequencies,v 1.11 2007/08/15 22:36:32 jvanheld Exp $
#
############################################################

## TO DO: add the option -all, to automatically compute all the pattern frequencies for a giv en taxon (with the option -outdir)
## TO DO: add the option -install, to automatically store pattern frequencies in RSAT data directory $RSAT/data/taxon_frequencies/${TAXON}


## use strict;

=pod

=head1 NAME

taxon-frequencies

=head1 DESCRIPTION

Calculate taxon-wide oligo and dyad frequencies.

=head1 AUTHORS

jvanheld@scmbb.ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE

taxon-frequencies -taxon my_taxon [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

Oligo and dyad frequency files are loaded from $RSAT genome
directories.

=head1 OUTPUT FORMAT

The output format is a tab-delimited file with one row per pattern
(oligo or dyad).

By default, the output file contains 4 columns:

=over

=head2 pattern sequence

Pattern sequence is always a single-strand pattern description, even
though it can be used to scan sequences on both strands.

=head2 pattern ID

For single-strand frequencies, the ID is simply the pattern
sequence. For two-strand frequencies, the pattern ID includes the
direct sequence + its reverse complement, separated by a pipe
character.

=head2 frequency

Taxon-wide frequency of the pattern.

=head2 occurrences

Taxon-wide occurrences of the pattern in the considered sequence type
(upstream, upstream-noorf, intergenic).

=head2 organism-specific occurrences (optional)

When the option -occ_per_org is active, the program exports one
additional column per organism, indicating the organism-specific
number of occurrences of each pattern.

=head2 organism-specific frequencies (optional)

When the option -freq_per_org is active, the program exports one
additional column per organism, indicating the organism-specific
frequency of each pattern.

=back

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";



################################################################
## Main package
package main;
{

    ################################################################
    ## Initialize parameters
    my $start_time = &AlphaDate();

    local $taxon = "";
    local %outfile = ();
    local %infile = ();

    local $verbose = 0;
    local $out = STDOUT;

    local $pattern_type = ""; ## Supported= oligo, dyad
    local $oligo_length = 0;
    local $monad_length = 0;
    local $background_model = "upstream-noorf";
    local $str = "-1str";
    local $sum_rc = 0;
    local $noov="-noov"; ## Supported= -noov, -ovlp
    local $occ_col = 4; ## Column containing pattern occurrences in the frequency files

    local %occ_sum_per_pattern = ();
    local %occ_sum_per_organism = ();
    local %occ_sum_per_spacing = ();
    local %freq_sum_per_organism = ();
    local %pattern_freq;
    local $pattern_freq_sum = 0;
    local $total_occ = 0;

    local %patterns_per_organism = 0;

    local $occ_per_org = 0;
    local $freq_per_org = 0;
    local @organisms = ();

    local $decimals = 13; ## Decimals for printing frequencies

    #### background models
    %supported_bg = ('upstream'=>1,
		     'upstream-noorf'=>1,
		     'intergenic'=>1,
		     'upstream-rm'=>1,
		     'upstream-noorf-rm'=>1
		    );

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values

    ## Check pattern type and type-specific parameters
    if ($pattern_type eq "oligo") {
      &RSAT::error::FatalError("You must define the oligo length (option -ol)") 
	unless ($oligo_length);
    } elsif ($pattern_type eq "dyad") {
      &RSAT::error::FatalError("You must define the monad length (option -ml)") 
	unless ($monad_length);
    } else {
      &RSAT::error::FatalError("You must define pattern type (option -type dyad|oligo)")
	unless ($pattern_type);
    }

    ## Strands
    if ($str eq "-1str") {
      $sum_rc = 0;
    } elsif ($str eq "-2str") {
      $sum_rc = 1;
    } else {
      &RSAT::error::FatalError($str, "Invalid value for the strands. Supported= -1str, -2str.");
    }

    ## Check taxon and collect organisms
    @organisms = &CheckTaxon($taxon);


    ################################################################
    ## Open output stream
    $out = &OpenOutputFile($outfile{output});

    ################################################################
    ## Read background pattern frequencies
    foreach my $org (@organisms) {
      my $exp_freq_file;
      if ($pattern_type eq "oligo") {
	$exp_freq_file = &ExpectedFreqFile($org, $oligo_length, $background_model,
					  type=>'oligo',
					  noov=>$noov, str=>$str,
					  warn=>1);
      } elsif  ($pattern_type eq "dyad") {
	$exp_freq_file = &ExpectedFreqFile($org, $monad_length, $background_model,
					  type=>'dyad',
					  noov=>$noov, str=>$str, # added
					  warn=>1);
      } else {
	&RSAT::error::FatalError($pattern_type, "is not a valid pattern type. Supported: oligo,dyad");
      }

      ## Include a warning for missing files in the output file
      unless ((-e $exp_freq_file) ||
	      (-e $exp_freq_file.".gz")) {
	print $out join ("\t", "; WARNING", "Skipped missing file for org", $org, $exp_freq_file), "\n";
	next;
      }
      $infile{$org} = $exp_freq_file;

      ## Count occurrences for each frequency file
      &RSAT::message::TimeWarn("Loading pattern occurrences for organism", $org, $infile{$org}) if ($main::verbose >= 2);
      my ($in) = &OpenInputFile($infile{$org});
      my $l = 0;
      while (<$in>) {
	$l++;
	next if (/^--/); ## Skip comment lines
	next if (/^;/); ## Skip comment lines
	next if (/^#/); ## Skip header line
	next unless (/\S/); ## Skip empty lines
	my @fields = split /\s+/;
	my $pattern_seq = $fields[0];
	my $pattern_id = $fields[1];
	my $occ = $fields[$occ_col -1];
	unless (&IsNatural($occ)) {
	  ## Temporary fix for dyad, because the frequency files contain occurrences in the 5th column
	  if ($pattern_type eq "dyad") {
	    $occ = $fields[$occ_col];
	  }
	  unless (&IsNatural($occ)) {
	    &RSAT::error::FatalError($occ, "Invalid value for occurrences. Should be a Natural number", $infile{$org}, "line", $l);
	  }
	}

	## Statistics per organism
	$patterns_per_organism{$org}++; ## Increment pattern counter
	$occ_sum_per_organism{$org} += $occ;

	## store the organism-specific occurrences for the full table (can be memory costly)
	if (($occ_per_org) || ($freq_per_org)) {
	  $pattern_occ{$pattern_seq}{$org} = $occ;
	}

	$occ_sum_per_pattern{$pattern_seq} += $occ;
	if (defined($pattern_id{$pattern_seq})) {
	  if ($pattern_id{$pattern_seq} ne $pattern_id) {
	    &RSAT::error::FatalError("Inconsistency betwen pattern identifiers", $infile{$org}, $pattern_id, $pattern_id{$pattern_seq});
	  }
	} else {
	  $pattern_id{$pattern_seq} = $pattern_id;
	}
      }
      close $in if ($infile{input});
    }

    ################################################################
    ## Compute total pattern occurrences
    foreach my $pattern_seq (keys %occ_sum_per_pattern) {
      $total_occ += $occ_sum_per_pattern{$pattern_seq};

      ## Specific treatment for dyads: there is a specific total for
      ## each spacing value, and th sum of frequencies is 1 for each
      ## spacing value
      if ($pattern_type eq "dyad") {
	if ($pattern_seq =~ /n{(\d+)}/i) {
	  my $spacing = $1;
	  $occ_sum_per_spacing{$spacing} += $occ_sum_per_pattern{$pattern_seq};
	} else {
	  &RSAT::error::FatalError($pattern_seq, "Invalid sequence for a dyad");
	}
      }
    }
    foreach my $pattern_seq (sort keys %pattern_id) {
      if ($pattern_type eq "dyad") {
	if ($pattern_seq =~ /n{(\d+)}/i) {
	  my $spacing = $1;
	  $pattern_freq{$pattern_seq} = $occ_sum_per_pattern{$pattern_seq}/$occ_sum_per_spacing{$spacing};
	}
      } else {
	$pattern_freq{$pattern_seq} = $occ_sum_per_pattern{$pattern_seq}/$total_occ;
      }
      $pattern_freq_sum += $pattern_freq{$pattern_seq};
    }
    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);


    ################################################################
    ## Print output

    ## Define output fields
    my @out_fields =  ("seq", "pattern_id", "frequency", "occ");
    $field_descr{seq} = "pattern sequence";
    $field_descr{pattern_id} = "pattern identifier";
    $field_descr{frequency} = "taxon-wide patter, frequency";
    $field_descr{occ} = "taxon-wide occurrences";

    if ($main::occ_per_org) {
      foreach my $org (@organisms) {
	my $field = "N.".$org;
	push @out_fields, $field;
	$field_descr{$field} = "occurrences\t".$org;
      }
    }
    if ($main::freq_per_org) {
      foreach my $org (@organisms) {
	my $field = "F.".$org;
	push @out_fields, $field;
	$field_descr{$field} = "pattern frequencies in ".$org;
      }
    }

    ## Print column content
    if ($main::verbose >= 1) {
      print $out "; Column content\n";
      my $c = 0;
      foreach my $field (@out_fields) {
	$c++;
	print $out join ("\t", ";", $c, sprintf("%-29s", $field), $field_descr{$field}), "\n";
      }
    }

    ## Print header
    print $out "#", join( "\t", @out_fields), "\n";

    ## Print pattern occurrences
    foreach my $pattern_seq (sort keys %pattern_id) {
      print $out join( "\t", 
		       $pattern_seq,
		       $pattern_id{$pattern_seq},
		       sprintf("%.${decimals}f", $pattern_freq{$pattern_seq}),
		       $occ_sum_per_pattern{$pattern_seq},
		     );

      ## Print organism-specific occurrences
      if ($occ_per_org) {
	foreach my $org (@organisms) {
	  print $out "\t", $pattern_occ{$pattern_seq}{$org} || 0;
	}
      }

      ## Print organism-specific frequencies
      if ($freq_per_org) {
	foreach my $org (@organisms) {
	  my $freq = 0;
	  if ((defined($pattern_occ{$pattern_seq}{$org})) 
	      && (defined($occ_sum_per_organism{$org}))
	      && ($occ_sum_per_organism{$org} > 0)
	     ) {
	    $freq = $pattern_occ{$pattern_seq}{$org}/$occ_sum_per_organism{$org}
	  } else {
	    $freq = 0;
	  }
	  $freq_sum_per_organism{$org} += $freq;
	  printf $out "\t%.${decimals}f", $freq;
	}
      }
      print $out "\n";
    }

    ################################################################
    ## print totals per column
    if ($main::verbose >= 1) {
      my @totals = ("total","total",sprintf("%.${decimals}f", $pattern_freq_sum),$total_occ);
      if ($occ_per_org) {
	foreach my $org (@organisms) {
	  push @totals, $occ_sum_per_organism{$org} || 0;
	}
      }
      if ($freq_per_org) {
	foreach my $org (@organisms) {
	  push @totals, sprintf("%.${decimals}f", $freq_sum_per_organism{$org});
	}
      }
      print $out ";", join( "\t", @totals), "\n";
    }

    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $out "; Job started $start_time\n";
	print $out "; Job done    $done_time\n";
    }

    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});

    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Taxon
=pod

=item B<-taxon taxon>

Specify the taxon for which frequencies have to be computed.

=cut
	} elsif ($arg eq "-taxon") {
	    $main::taxon = shift(@arguments);

	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);

	    ### Background model
=pod

=item B<-bg background_model>

Specify a background model for expected frequencies.

  Supported: upstream-noorf, upstream, intergenic
  Default: upstream-noorf

=cut
	} elsif ($arg eq "-bg") {
	    $background_model = shift (@arguments);
	    $background_model =~ s/ncf/intergenic/;
	    $background_model =~ s/input/bernoulli/;
	    unless ($supported_bg{$background_model}) {
		&RSAT::error::FatalError("Invalid background model\t$background_model\tsupported: $supported_bg");
	    }

	    #### strands
=pod

=item B<-2str>

Collect frequencies computed on both strands.

=item B<-1str>

Collect frequencies computed on a single strand.

=cut
	} elsif ($arg eq "-1str") {
	  $str = "-1str";
	} elsif ($arg eq "-2str") {
	  $str = "-2str";

	  ## Overlap
=pod

=item B<-noov>

Do not allow mutual overlap between successive occurrences of
self-overlaping patterns (e.g. TATATATATA contains a signel occurrence
of TATATA).

=item B<-ovlp>

Allow mutual overlap between successive occurrences of
self-overlapping patterns (e.g. TATATATATA contains three occurrences
of TATATA).

=cut
	} elsif ($arg eq "-ovlp") {
	  $noov = "-ovlp";
	} elsif ($arg eq "-noov") {
	  $noov = "-noov";


	  ## Pattern type
=pod

=item B<-type oligo|dyad>

Pattern type. Supported: oligo, dyad. 

=cut
	} elsif ($arg eq "-type") {
	  $pattern_type = shift @arguments;

	  ## Oligonucleotide length
=pod

=item B<-ol #>

Oligonucleotide length.

This option is only valid when pattern type is set to 'oligo'.

=cut
	} elsif ($arg eq "-ol") {
	  $oligo_length = shift @arguments;
	  &RSAT::error::FatalError($oligo_length, 
				   "Invalid oligo length. Must be a strictly positive Natural number") 
	    unless ((&IsNatural($oligo_length)) && ($oligo_length > 0));

	  ## Monad length
=pod

=item B<-ml #>

Monad length for the dyads.

This option is only valid when pattern type is set to 'dyad'.

=cut
	} elsif ($arg eq "-ml") {
	  $monad_length = shift @arguments;
	  &RSAT::error::FatalError($monad_length, 
				   "Invalid monad length. Must be a strictly positive Natural number") 
	    unless ((&IsNatural($monad_length)) && ($monad_length > 0));

	  ## Return occurrences per organism
=pod

=item B<-occ_per_org>

Return additional columns with the organism-specific pattern
occurrences (one column per organism).

=cut
        } elsif ($arg eq "-occ_per_org") {
	  $main::occ_per_org = 1;

	  ## Return frequencies per organism
=pod

=item B<-freq_per_org>

Retun additional columns with the organism-specific pattern
frequencies (one column per organism).

=cut
        } elsif ($arg eq "-freq_per_org") {
	  $main::freq_per_org = 1;

	  ## Decimals for printing frequencies
=pod

=item B<-decimals #>

Number of decimal for printing frequencies (default 13)

=cut
        } elsif ($arg eq "-decimals") {
	  $main::decimals = shift(@arguments);
	  &RSAT::error::FatalError($main::decimals, "Invalid value for decimals. Must be a Natural number") 
	    unless (&IsNatural($main::decimals));

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; taxon-frequencies ";
    &PrintArguments($main::out);

    ## Compute the length of the largest organism name
    my $org_len = 20; ## Length of the string or printing organism names
    foreach my $org (@organisms) {
      if (length($org) > $org_len) {
	$org_len = length($org);
      }
    }

    ## Print the list of input files
    print $out "; Organisms\n";
    my $i = 0;
    print $out join ("\t", ";", "org_nb", "organism name", "nb_patt", "occ_sum", "Input file"), "\n";
    foreach my $org (@organisms) {
      if ($infile{$org}) {
	$i++;
	print $out join ("\t", ";",
			 $i,
			 sprintf("%-${org_len}s", $org),
			 $patterns_per_organism{$org} || 0,
			 $occ_sum_per_organism{$org} || 0,
			 $infile{$org},
			), "\n";
      }
    }

    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=head2 supported-organisms

To get a list of supported organisms + their respective taxa, type
I<supported-organisms -format full>.

=head2 oligo-analysis

Taxon-wide oligo frequency files can be used as expected frequencies
for pattern discovery with I<oligo-analysis>.

=head2 dyad-analysis

Taxon-wide dyad frequency files can be used as expected frequencies
for pattern discovery with I<dyad-analysis>.

=head2 convert-background-model

Oligo and dyad frequencies can be converted into background model for
third parties pattern detection programs (MEME, MotifSampler).

=cut
