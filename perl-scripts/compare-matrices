#!/usr/bin/perl -w
############################################################
#
# $Id: compare-matrices,v 1.6 2008/02/25 00:47:33 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

compare-matrices

=head1 VERSION

$program_version

=head1 DESCRIPTION

Compare two or more position-specific scoring matrices (PSSM), and
return various similarity statistics.

=head1 AUTHORS

Jacques.van.Helden@ulb.ac.be

=head1 CATEGORY

=over

=item sequences

=item pattern matching

=item PSSM

=back

=head1 USAGE

compare-matrices -fil1 inputfile1 -fiel2 inputfile2 [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

The user has to specify exactly input files (options I<-file1> and
I<-file2>), each containing one or several PSSMs. Each matrix of file
one is compared with each matrix of file2.

Any PSSM format supported in RSAT (type I<convert-matrix -h> for a
description).

=head1 OUTPUT FORMAT

By default, the output format is a tab-delimited file with one row per
matrix comparison, and one column per statistics.

=head2 ALGORITHM

The program successibely computs one or several (dis)similiraty
metrics between each matrix of the first input file and each matrix of
the secnd input file.

Since the matrices are not supposed to be in phase, for each pair of
matrix, the program tests all possible I<offset> (shift) values
between the two matrices.

=head1 (DIS)SIMLARITY METRICS

In the formulae below, symbols are defined as follows

=over

=item I<w>

length of the alignment (depends on the offset between the two
matrices).

=item I<r>

residue belonging to the alphabet (A,C,G,T for DNA motifs).

=item I<j>

index of a column of the aligned PSSM.

=item I<F1>

frequency of residue r in the jth column of the aligned subset of the
first matrix (taking the offset into account).

=item I<F2>

frequency of residue r in the jth column of the aligned subset of the
second matrix (taking the offset into account).

=head2 Euclidian distance (dEucl)

 dEucl = 1/w * SUM{r} SUM{j=1->w1} (F1_{r,j} - F2_{r,j})^2

Note that our Euclidian distance is relativized by the number of
aligned columns (I<w>). This differs from the definition provided in
UJ Pape et al.

=back

=head2 Covariance (cov)

=head2 Coefficient of correlation (cor)

=head2 Kullback-Leibler distance (dKL)

Note that our KL distance is relativized by the number of
aligned columns (I<w>). This differs from the definition provided in
UJ Pape et al.

=head1 REFERENCES

=over

=item Pape, U.J., Rahman, S., and Vingron, M. (2008). Natural
similarity measures between position frequency matrices with an
application to clustering. Bioinformatics 24 (3) pp. 350-7.

=back

=cut


BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}
require "RSA.lib";
use RSAT::matrix;
use RSAT::MatrixReader;
use RSAT::stats;



################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  my $start_time = &AlphaDate();
  $program_version = do { my @r = (q$Revision: 1.6 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  %main::infile = ();
  %main::outfile = ();

  $main::verbose = 0;
#  $main::in = STDIN;
  $main::out = STDOUT;


  ## Return fields
  my %supported_return_fields = (
      "dEucl"=>1, ## Euclidian distance
      "dKL"=>1, ## Kullback-Leibler distance
      "cor"=>1, ## Coefficient of correlation
      "cov"=>1, ## Covariance
      "consensus"=>1,
      );
  my %return_field = %supported_return_fields; ## Temporary

  ## Sort field
  local $sort_field = "offset";

  ## Threshold parameters
  local %lth = ();		# lower threshold values
  local %uth = ();		# upper threshold values
  @supported_thresholds = qw (
			      offset
			      ali_len
			      dEucl
			      dKL
			      cov
			      cor
			      rank
			     );
  $supported_thresholds = join ",", @supported_thresholds;
  %supported_threshold = ();
  foreach my $thr (@supported_thresholds) {
    $supported_threshold{$thr} = 1;
  }


  ## Matrices
  local @matrices1 = ();
  local @matrices2 = ();

  ## input formats
  %supported_input_format = %RSAT::MatrixReader::supported_input_format;
  $supported_input_formats = join ",", sort keys %supported_input_format;
  local $input_format1 = "";
  local $input_format2 = "";


  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values
  unless (($infile{file1}) && ($infile{file2})) {
    &RSAT::error::FatalError("You must define two input files (options -file1 and -file2)");
  }

  unless (($input_format1) && ($input_format2)) {
    &RSAT::error::FatalError("You must define two input format(s) (option -format, or options -format1 and -format2)");
  }

  ################################################################
  ## Treat dependencies between fields to compute

  ## All return fields should be computed
  my %calc_field = %return_field;

  ## All fields having thresholds must be computed
  foreach my $field (keys %lth) {
    $calc_field{$field} = 1;
  }
  foreach my $field (keys %uth) {
    $calc_field{$field} = 1;
  }

  ## The sorting field must be computed
  $calc_field{$sort_field} = 1;

  ## Some fields must be computed as intermediate results for other fields
  $calc_field{cov} = 1 if ($calc_field{cor});

  ################################################################
  ## Open output stream
  $main::out = &OpenOutputFile($main::outfile{output});

  ################################################################
  ## Read input
  @matrices1 = &RSAT::MatrixReader::readFromFile($infile{file1}, $input_format1);
  &RSAT::message::TimeWarn(scalar(@matrices1), "Matrices loaded from file 1", $infile{file1})
      if ($main::verbose >= 2);
      @matrices2 = &RSAT::MatrixReader::readFromFile($infile{file2}, $input_format2);
  &RSAT::message::TimeWarn(scalar(@matrices2), "Matrices loaded from file 2", $infile{file2})
      if ($main::verbose >= 2);

  ## Calculate the consensus for each matrix
  if ($return_field{consensus}) {
      foreach my $matrix (@matrices1, @matrices2) {
	  $matrix->calcConsensus();
      }
  }

  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose);

  ################################################################
  ## Print the header
  my @header = ();
  push (@header, "m1", "m2");
  push (@header, "offset", "direct", "ali_len");
  push (@header, "start1", "end1", "start2", "end2");
  push (@header, "dEucl") if ($return_field{dEucl});
  push (@header, "dKL") if ($return_field{dKL});
  push (@header, "cov") if ($return_field{cov});
  push (@header, "cor") if ($return_field{cor});
  push (@header, "consensus1", "consensus2") if ($return_field{consensus});

  ## Print a description of the output fields
  if ($main::verbose >= 1) {
      my %description = ();
      $description{m1} = "matrix number in file 1";
      $description{m2} = "matrix number in file 2";
      $description{offset} = "shift of the second matrix relative to the first matrix (negative:left; positive: right)";
      $description{direct} = "direction of matrix 2 relative to matrix 1 (D=direct;  R=reverse)";
      $description{ali_len} = "Alignment length (overlap between matrix 1 and matrix 2, taking the offset into account";
      $description{start1} = "Start position of the alignment in matrix 1";
      $description{end1} = "End position of the alignment in matrix 1";
      $description{start2} = "Start position of the alignment in matrix 2";
      $description{end2} = "End position of the alignment in matrix 2";
      $description{dEucl} = "Euclidian distance";
      $description{dKL} = "Kullback-Leibler distance";
      $description{cov} = "Covariance";
      $description{cor} = "Coefficient of correlation";
      $description{consensus1} = "IUPAC consensus of matrix 1";
      $description{consensus2} = "IUPAC consensus of matrix 2";

      print $out "; Column content\n";
      my $c = 0;
      foreach my $field (@header) {
	$c++;
	printf $out ";\t%d\t%-13s\t%s\n", $c, $field, $description{$field};
      }
    }
  print $out "#", join("\t", @header), "\n";

  ################################################################
  ## compare the matrices and print the result
  my $m1 = 0;
  foreach my $matrix1 (@matrices1) {
    $m1++;
    &RSAT::message::TimeWarn("File 1", "Analyzing matrix", $m1."/".scalar(@matrices1)) 
      if ($main::verbose >= 3);

    my $ncol1 = $matrix1->get_attribute("ncol");
    my $nrow1 = $matrix1->get_attribute("nrow");
    my @counts1 = $matrix1->getMatrix();
    my @crude_freq1 = $matrix1->getCrudeFrequencies();


    my $m2 = 0;
    foreach my $matrix2 (@matrices2) {
      $m2++;
      &RSAT::message::TimeWarn("Comparing matrices", 
			       "file1", $m1."/".scalar(@matrices1),
			       "file2", $m2."/".scalar(@matrices2),
			      )
	if ($main::verbose >= 4);
      my $ncol2 = $matrix2->get_attribute("ncol");
      my $nrow2 = $matrix2->get_attribute("nrow");

      ## Check that both matrices have the same number of rows
      unless ($nrow2 == $nrow1) {
	&RSAT::error::FatalError("Input matrices must have the same number of residues rows)", $nrow1, $nrow2);
      }
      my @counts2 = $matrix2->getMatrix();
      my @crude_freq2 = $matrix2->getCrudeFrequencies();

      ## Compute offsets for sliding one matrix along the othe one
      my $offset_min = 1 - $ncol2;
      my $offset_max = &RSAT::stats::min($ncol1, $ncol2) -1;

      ## Prepare output variables
      my %cov = (); ## Covariances as a function of the offset
      my %cor = (); ## Correlations
      my %dEucl = (); ## Euclidian distances
      my %dKL = (); ## Kullback-Leibler distances
      my %out_line = (); ## Output line for each offset value
      my @output_offset = (); ## Offsets passing the thresholds
      my $direction = "D";

      ## Slide matrix2 along matrix1
      foreach my $offset ($offset_min..$offset_max) {

	## Compute aligned matrix positions
	my $ali_len = 0;
	$ali_len = &RSAT::stats::min(($ncol2 - abs($offset)), $ncol1);
	next unless (&CheckThresholds("ali_len", $ali_len));

	my $end1 = &RSAT::stats::min($ncol1, $ncol1+$offset);
	my $start1 = &RSAT::stats::min($ncol1, $end1-$ali_len+1);
	my $start2 = &RSAT::stats::max(1- $offset, 1);
	my $end2 = &RSAT::stats::min($start2+$ali_len-1, $ncol2);

	## Highlight alignment in consensus
	$consensus1 = join ("",
			    #				  substr($matrix1->get_attribute("consensus.IUPAC"), 0, $start1-1),
			    substr($matrix1->get_attribute("consensus.IUPAC"), $start1-1, $ali_len),
			    "."x($start1-1),
			    "."x($ncol1-$end1)
			    #				  substr($matrix1->get_attribute("consensus.IUPAC"), $end1),
			   );
	$consensus2 = join ("",
			    #				  substr($matrix2->get_attribute("consensus.IUPAC"), 0, $start2-1),
			    substr($matrix2->get_attribute("consensus.IUPAC"), $start2-1, $ali_len),
			    "."x($start2-1),
			    "."x($ncol2-$end2)
			    #				  substr($matrix2->get_attribute("consensus.IUPAC"), $end2),
			   );


	## Compute the Euclidian distance between the matrices
	## (cf Tomtom)
	my $dEucl = 0;
	my $dKL = 0;
	my $cov = 0;
	my $cor = 0;
	my $sum_f1 = 0;
	my $sum_f2 = 0;
	my $sum_f1f2 = 0;
	my $sum_sq_f1 = 0;
	my $sum_sq_f2 = 0;
	foreach my $pos (1..$ali_len) {
	  my $col1 = $start1+$pos-1;
	  my $col2 = $start2+$pos-1;
	  for my $r (0..($nrow1-1)) {
	    my $f1 = $crude_freq1[$col1-1][$r];
	    my $f2 = $crude_freq2[$col2-1][$r];

	    ## Update sum for Euclidian distance
	    if ($calc_field{dEucl}) {
	      $dEucl +=  ($f1 - $f2)**2;
	    }

	    ## Update sum for Kullback-Leibler distance
	    if ($calc_field{dKL}) {
	      if ($f1*$f2 > 0) {
		$dKL += $f1*log($f1/$f2) + $f2*log($f2/$f1);
	      }
	    }

	    ## Update sums for correlations
	    if (($calc_field{cov}) || ($calc_field{cor})){
	      $sum_f1 += $f1;
	      $sum_f2 += $f1;
	      $sum_sq_f1 += $f1**2;
	      $sum_sq_f2 += $f2**2;
	      $sum_f1f2 += $f1*$f2;
	    }
	  }
	}

	## Compute Euclidian distance
	if ($calc_field{dEucl}) {
	  $dEucl = sqrt($dEucl);
	  $dEucl /= $ali_len if ($ali_len > 0); ## Relativize Euclidian distance with respect to the column number
	}
	next unless (&CheckThresholds("dEucl", $dEucl)); $dEucl{$offset} = $dEucl;

	## Compute Kullback-Leibler distance
	if ($calc_field{dKL}) {
	  $dKL /= 2;
	  $dKL /= $ali_len if ($ali_len > 0); ## Relativize KL distance with respect to the column number
	}
	next unless (&CheckThresholds("dKL", $dKL)); $dKL{$offset} = $dKL;

	## Compute coefficient of correlation
	my $n = 0;
	my $v1 = 0;
	my $v2 = 0;
	if (($calc_field{cov}) || ($calc_field{cor})){
	  $n = $nrow1*$ali_len;
	  $v1 = $sum_sq_f1/$n - ($sum_f1/$n)**2;
	  $v2 = $sum_sq_f2/$n - ($sum_f2/$n)**2;
	  $cov = $sum_f1f2/$n - $sum_f2*$sum_f2/$n**2;
	  $cor = $cov/sqrt($v1*$v2);
	}
	next unless (&CheckThresholds("cov", $cov)); $cov{$offset} = $cov;
	next unless (&CheckThresholds("cor", $cor)); $cor{$offset} = $cor;

	## Generate the output line
	my @out_fields = ($m1, $m2);
	push (@out_fields, $offset, $direction, $ali_len);
	push (@out_fields, $start1, $end1, $start2, $end2);
	push (@out_fields, sprintf("%.5f", $dEucl)) if ($return_field{dEucl});
	push (@out_fields, sprintf("%.5f", $dKL)) if ($return_field{dKL});
	push (@out_fields, sprintf("%.4f", $cov)) if ($return_field{cov});
	push (@out_fields, sprintf("%.4f", $cor)) if ($return_field{cor});
	push (@out_fields,
	      $consensus1,
	      $consensus2) if ($return_field{consensus});
	push @output_offset, $offset;
	$out_line{$offset} =  join("\t", @out_fields);
      }

      ## Sort the results
      my @sorted_offset;

	## Euclidian distance is sorted in ascending order
      if ($sort_field eq "dEucl") {
	@sorted_offset = sort {$dEucl{$a} <=> $dEucl{$b}} @output_offset;

	## Kullback-Leibler distance is sorted in ascending order
      } elsif ($sort_field eq "dKL") {
	@sorted_offset = sort {$dKL{$a} <=> $dKL{$b}} @output_offset;

	## covariance is sorted in descending order
      } elsif ($sort_field eq "cov") {
	@sorted_offset = sort {$cov{$b} <=> $cov{$a}} @output_offset;

	## Correlation is sorted in descending order
      } elsif ($sort_field eq "cor") {
	@sorted_offset = sort {$cor{$b} <=> $cor{$a}} @output_offset;

      } else {
	@sorted_offset = @output_offset;
      }

      ## Print the output
      foreach my $offset (@sorted_offset) {
	print $out  $out_line{$offset};
#	print $out "\t", $rank if ($return_field{rank});
	print $out "\n";
      }
    }
  }


  ################################################################
  ## Print output


  ################################################################
  ## Finish verbose
  if ($main::verbose >= 1) {
    my $done_time = &AlphaDate();
    print $main::out "; Job started $start_time\n";
    print $main::out "; Job done    $done_time\n";
  }


  ################################################################
  ## Close output stream
  close $main::out if ($main::outfile{output});


  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

    ## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
      if ($arg eq "-v") {
	if (&IsNatural($arguments[0])) {
	  $main::verbose = shift(@arguments);
	} else {
	  $main::verbose = 1;
	}

	## Help message
=pod

=item B<-h>

Display full help message

=cut
      } elsif ($arg eq "-h") {
	&PrintHelp();

	## List of options
=pod

=item B<-help>

Same as -h

=cut
      } elsif ($arg eq "-help") {
	&PrintOptions();

	## Input files
=pod

=item B<-file1 matrix_file1>

The first input file containing one or several matrices.

=cut
      } elsif ($arg eq "-file1") {
	$main::infile{file1} = shift(@arguments);

=pod

=item B<-file2 matrix_file2>

The second input file containing one or several matrices.

=cut
      } elsif ($arg eq "-file2") {
	$main::infile{file2} = shift(@arguments);

	### Input format 
=pod

=item B<-format matrix_format>

Specify the matrix format for both input files (alternatively, see
options -format1 and -format2).

=cut
      } elsif ($arg eq "-format") {
	$input_format1 = shift(@arguments);
	$input_format2 = $input_format1;
	unless ($supported_input_format{$input_format1}) {
	  &RSAT::error::FatalError("$input_format1\tInvalid format for input matrices\tSupported: ".$supported_input_formats);
	}

	### Input format for file1 only
=pod

=item B<-format1 matrix_format1>

Specify the matrix format for the first input file only (requires
-format2).

=cut
      } elsif ($arg eq "-format1") {
	$input_format1 = shift(@arguments);
	unless ($supported_input_format{$input_format1}) {
	  &RSAT::error::FatalError("$input_format1\tInvalid format for input matrices\tSupported: ".$supported_input_formats);
	}

	### Input format for file2 only
=pod

=item B<-format2 matrix_format2>

Specify the matrix format for the second input file only (requires
-format1).

=cut
      } elsif ($arg eq "-format2") {
	$input_format2 = shift(@arguments);
	unless ($supported_input_format{$input_format2}) {
	  &RSAT::error::FatalError("$input_format2\tInvalid format for input matrices\tSupported: ".$supported_input_formats);
	}

	## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
      } elsif ($arg eq "-o") {
	$main::outfile{output} = shift(@arguments);

	## Sort field
=pod

=item	B<-sort sort_field>

Field to sort the results.

Supported: dEucl, cor, cov

=cut
      } elsif ($arg eq "-sort") {
	$main::sort_field = shift(@arguments);

	## Thresholds
=pod

=item	B<-lth param lower_threshold>

=item	B<-uth param upper_threshold>

Threshold on some parameter (-lth: lower, -uth: upper threshold). 

Supported threshold fields : rank, dEucl, cor, cov, ali_len, offset

=cut

	    ### Lower threshold
	} elsif ($arg eq "-lth") {
	    my $thr_field = lc(shift(@arguments));
	    my $thr_value =  lc(shift(@arguments));
	    unless ($supported_threshold{$thr_field}) {
		&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
	    }
	    &RSAT::error::FatalError($thr_value, "Invalid value for a lower threshold. Should be a real number. ") 
	      unless (&RSAT::util::IsReal($thr_value));
	    $lth{$thr_field} = $thr_value;

	    ### Upper threshold
	} elsif ($arg eq "-uth") {
	    my $thr_field = lc(shift(@arguments));
	    my $thr_value = lc(shift(@arguments));
	    unless ($supported_threshold{$thr_field}) {
		&RSAT::error::FatalError("Invalid threshold field $thr_field. Supported: $supported_thresholds");
	    }
	    &RSAT::error::FatalError($thr_value, "Invalid value for an upper threshold. Should be a real number. ") 
	      unless (&RSAT::util::IsReal($thr_value));
	    $uth{$thr_field} = $thr_value;


      } else {
	&FatalError(join("\t", "Invalid option", $arg));

      }
  }


=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; compare-matrices ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-6s\t%s\n", $key, $value;
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    print $main::out "; Number of matrices per file\n";
    printf $main::out ";\t%-6s\t%d\t%s\n", "file1", scalar(@matrices1), $infile{file1};
    printf $main::out ";\t%-6s\t%d\t%s\n", "file2", scalar(@matrices2), $infile{file2};

    print $main::out "; Thresholds\n";
}


################################################################
#### check threshold on some parameter
sub CheckThresholds {
  my ($key, $value) = @_;

  ## Lower threshold
  if (defined($lth{$key})) {
    if ($value < $lth{$key}) {
      return (0);
    }
  }

  ## Upper threshold
  if (defined($uth{$key})) {
    if ($value < $uth{$key}) {
      return (0);
    }
  }

  return(1);
}


__END__

=pod

=head1 SEE ALSO

=over

=item B<convert-matrix>

=item B<matrix-scan>

=back

=head1 WISH LIST

=over

=item implement other metrics

=item add comparison of m1 with reverse complement of m2

=item -table metrics

Export a table with one row per matrix of the file 1, one column per
matrix of file 2, and where each cell indicates the value of the
selected (dis)similarity metrics.

=back

=cut
