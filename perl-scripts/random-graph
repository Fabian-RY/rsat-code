#!/usr/bin/perl -w
############################################################
#
# $Id: random-graph,v 1.7 2007/05/09 07:08:03 rsat Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

random-graph

=head1 DESCRIPTION

Generate random graphs either from an existing graph or from scratch.

=head1 AUTHORS

Sylvain Brohee <sylvain@scmbb.ulb.ac.be>

=head1 CATEGORY

util

=head1 USAGE
    
random-graph [-node #] [-edge #] [-o outputfile] [-n #] [-self] [-duplicated] [-nodefile] [-n] [-random_type scratch|node_degree|node_degree_distrib] [-i input_graph_file] [-scol #] [-tcol #] [-wcol #]


=head1 INPUT FORMAT

A graph (in TAB or GML format) to be mixed or whose nodes have to be used to create a random graph from scratch.

A list of nodes (-nodefile) may also be given as input file.

=head1 OUTPUT FORMAT

Graph in GML, TAB or DOT format (to be specified by the -out_format option)

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "RSA.stat.lib";
require RSAT::Graph2;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();


    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::out = STDOUT;
    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	tab=>1,
	gml=>1
    );
    $supported_input_formats = join (",", keys %supported_input_format);
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;

    ## Output formats
    local $output_format = "tab";
    %supported_output_format =(
			       dot=>1,
			       gml=>1,
			       tab=>1
			       
    );
    $supported_output_formats = join (",", keys %supported_output_format);

    # number of required nodes
    $req_nodes = 0;
    
    # number of required edges
    $req_edges = 0;

    # number of required edges
    $self = 0;
    
    # maxium degree
    $max_degree = -1;
    
    # duplicated edges
    $duplicated = 0;
    
    # directed edges
    $directed = 0;
    
    # nodes and weights
    @nodes = ();
    @weights = ();
    
    
    # number of random graphs to create (by default = 1)
    $n = 1;

    # mean value of the weight of the edges
    $mean = "null";
    
    # sd deviation of the weight of the edges
    $sd = "null";
    
    # nodes
    $random_type = "";
    
    # normal
    $normal = 0;
    
    %supported_random_type =(
			       scratch=>1,
			       node_degree=>1, 
			       node_degree_distrib=>1,
			       ER=>1
    );
    
    $supported_random_type = join (",", keys %supported_random_type);        
    
    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values
    if ($req_nodes == 0 && !$main::infile{input}) {
       &RSAT::error::FatalError("When using no starting graph, you must specify the number of requested edges (-edge)");
    }
    if ($main::infile{input} && !-e $main::infile{input}) {
      &RSAT::error::FatalError("\t", "File", $main::infile{input}, "does not exist");
    }
    if ($n > 1 && !$main::outfile{output}) {
      &RSAT::error::FatalError("\t", "You must specify an prefix for the output files when requiring more than one output random graph");
    }
    if ($main::infile{nodefile} && !-e $main::infile{nodefile}) {
      &RSAT::error::FatalError("\t", "File", $main::infile{nodefile}, "does not exist");
    }
    if ($main::infile{nodefile} && $main::infile{input}) {
      &RSAT::error::FatalError("\t", "Cannot specify both a file containing node names and a graph file");
    }
    if ($sd ne 'null' && $mean ne 'null' && ($random_type eq "node_degree" || $random_type eq "node_degree_distrib")) {
      &RSAT::error::FatalError("\t", "You must not specify randomization type", $random_type, "with -sd and -mean option");
    }
    if (($sd ne 'null' && $mean eq 'null') || ($sd eq 'null' && $mean ne 'null')) {
      &RSAT::error::FatalError("\t", "You must specify both standard deviation and mean value for the edge weight");
    }    
    if ($random_type eq "") {
      &RSAT::error::FatalError("\t", "You must specify a randomization type.");
    } elsif (($random_type eq "node_degree" || $random_type eq "node_degree_distrib" || $random_type eq "ER") && !exists($main::infile{input})) {
      &RSAT::error::FatalError("\t", "You must specify an input graph when using randomization type", $random_type);
    } elsif (($random_type eq "node_degree" || $random_type eq "node_degree_distrib") && ($duplicated || $self || $directed || $max_degree > 0)) {
      &RSAT::error::FatalError("\t", "Option -duplicate, -self, -max_degree and -directed are not compatible with randomization type", $random_type);
    }

    ################################################################
    ## Read an input graph if available
    my $graph = new RSAT::Graph2();
    if ($main::infile{input}) {
      $graph->graph_from_text($input_format,$main::infile{input}, $source_col, $target_col, $weight_col);
      @nodes =  $graph->get_nodes();
    }
    
    ################################################################
    ## Read the nodes of the node file
    if ($infile{nodefile}) {
      my $l = 0;
      &RSAT::message::TimeWarn("Reading nodes from file", $infile{nodefile}) if ($main::verbose >= 2);
      my ($node_handle) = &OpenInputFile($infile{nodefile});
      while (my $line = <$node_handle>) {
	$l++;  
	next if ($line =~ /^\#/); ## Skip header lines
	next if ($line =~ /^--/); ## Skip comment lines
	next if ($line =~ /^;/); ## Skip comment lines
	next unless ($line =~ /\S/); ## Skip empty lines
	chomp($line);
	my @fields = split /\s+/, $line;
	my $node =  $fields[0];
	if ($node) {
	  push @nodes, $node;
	} else {
	  &RSAT::message::Warning("Line", $l, "starts with a space. Skipped.");
	}
      }
      close $node_handle;
    }
    
    ################################################################
    ## Count the number of edges and nodes for an erdos-renyi randomization
    if ($random_type eq 'ER') {
      $req_edges = scalar ($graph->get_attribute("arcs"));
      $req_nodes = scalar @nodes;
      ## calculate the mean and the sd deviation of the weights
      my @arcs =  $graph->get_attribute("arcs");
      for (my $i = 0; $i < scalar(@arcs); $i++) {
        push @weights, $arcs[$i][2];
      }
      my %summary = &summary(@weights);
      $mean = $summary{mean};
      $sd = $summary{sd};
      &RSAT::message::Info("Mean node degree of the edges",$mean,"with deviation",$sd) if ($main::verbose >= 2);
    }
      
    ################################################################
    $out_file_name = $main::outfile{output};

    ################################################################
    ## Create the random graph
    for (my $i = 1; $i <= $n; $i++) {
      &RSAT::message::psWarn("\t","Creating random graph",$i,"on",$n) if ($main::verbose >= 2);
      ## Create output file name if more than one random graph is requested
      if ($n > 1) {
        $out_file_name = $main::outfile{output};
        $out_file_name.= "_".$i.".".$output_format;
      }
      ## Open output stream
      $main::out = &OpenOutputFile($out_file_name);
      if ($output_format eq "tab") {
        $main::verbose_out = $main::out;
      } else {
        $main::verbose_out = STDOUT;
      }
      if ($random_type eq 'scratch' || $random_type eq 'ER') {
        my $nodes_ref = \@nodes;
        $rdm = $graph->create_random_graph($nodes_ref, $req_nodes, $req_edges, $self, $duplicated, $directed, $max_degree, $mean, $sd, $normal, @weights);
      } elsif ($random_type eq 'node_degree') {
        $rdm = $graph->randomize();
      } elsif ($random_type eq 'node_degree_distrib') {
        $rdm = $graph->random_graph_degree_distrib();
      }
      ## Print verbose
      &Verbose() if ($main::verbose);
      ## Print output
      print $out $rdm->to_text($output_format);
      ## Finish verbose
      if (($main::verbose >= 1 && $main::verbose_out ne 'STDOUT') || $i == $n) {
        my $done_time = &AlphaDate();
        print $main::verbose_out "; Job started $start_time\n";
        print $main::verbose_out "; Job done    $done_time\n";
      }
      ## Close output stream
      close $main::out if ($main::outfile{output});
    }
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Input file
=pod

=item B<-i inputfile>

Input graph file.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);

	    ## number of random graphs to create, by default = 1
=pod

=item B<-n #>

Number of random graphs to create. By default, n = 1. If n is > 1, then you must specify an output prefix for the output files (-o option). In this case, the name of the files will be prefix_graph_number.[tab|gml|dot] according to the output format.

=cut
	} elsif ($arg eq "-n") {
	    $main::n = shift(@arguments);
	    unless (&IsNatural($n) && ($n > 0)) {
		&RSAT::error::FatalError(join("\t", $n, "Invalid value for the number of random-graphs. Must be a strictly positive natural number > 0"));
	    }
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe. In case, more than one random graph is 
required, you must specify a prefix for the output files.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ### Input format  
=pod

=item B<-input_format input_format>

Input format. Supported: tab, gml. By default, the output format is tab.

=cut
	} elsif ($arg eq "-in_format") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});
=pod

=item B<-random_type >

Randomization type. Supported: scratch, node_degree, node_degree_distrib, ER

From scratch, builds a graph totally at random. You may specify the nodes names either by indicating an input graph file (-i option) or a file containing nodes name (-nodefile option). The edges are generated using the Erdos-Renyi distribution. You may compute edge weight values by specifying a mean and a standard deviation. Weight will the be attributed according to the normal distribution.

ER (Erdos-Renyii randomization), corresponds to the randomization of a input graph, keeping the nodes and the number of edges but changing its characteristics (node degree, clustering coefficient, ...). If you specify a weight column for the input graph, the weights of the output graph will be computed according to these values following the normal distribution (considering the weight distribution of the original graph). If nor the weight column is specified nor the wished mean and standard deviation of the weights  of the edges of the output graph, no weight will be added.

With the node_degree randomization type, each node will keep the same degree that in the input graph (edge randomization).

With the node_degree_distrib randomization type, the global distribution of node degree will remain the same as in the input graph but the deree of each individual will be changed.


=cut
	} elsif ($arg eq "-random_type") {
	    $random_type = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid randomization type. Supported: $supported_random_type")
		unless ($supported_random_type{$random_type});

	    ### Output format  
=cut

=item B<-output_format output_format>

Output format. Supported: tab, dot, gml. By default, the output format is tab.

=cut 
	} elsif ($arg eq "-out_format") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});


	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes. 

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes. 

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight nodes. 

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }	    
	    ##  number of edges
=pod

=item B<-edges #>

Number of requested edges.

=cut
	} elsif ($arg eq "-edges") {
	    $req_edges = shift (@arguments);
	    unless (&IsNatural($req_edges) && ($req_edges > 0)) {
		&RSAT::error::FatalError(join("\t", $req_edges, "Invalid value for the number of requested edges. Must be a strictly positive natural number"));
	    }
	    ##  number of nodes
=pod

=item B<-nodes #>

Number of requested nodes

=cut
	} elsif ($arg eq "-nodefile") {
          $main::infile{nodefile} = shift(@arguments);
          
	    ## File containing nodes name
=pod

=item B<-nodefile #>

Specification of a file containing node names. This file must be in the tab-delimited format.
The first word of each line will be considered as a name.

=cut
	} elsif ($arg eq "-nodes") {
	    $req_nodes = shift (@arguments);
	    unless (&IsNatural($req_nodes) && ($req_nodes > 0)) {
		&RSAT::error::FatalError(join("\t", $req_nodes, "Invalid value for the number of requested nodes. Must be a strictly positive natural number"));
	    }
	    ## File containing nodes name
=pod

=item B<-mean #>

Mean value on the weight of the arcs.
This argument can only be used with the scratch and ER randomization type and must be combined with the -sd option.

=cut
	} elsif ($arg eq "-mean") {
	    $main::mean = shift (@arguments);
	    unless (&IsReal($mean)) {
		&RSAT::error::FatalError(join("\t", $mean, "Invalid value for mean weight of the edge"));
	    }
	    ## File containing nodes name
=pod

=item B<-nodefile #>

Standard deviation value of the weight of the arcs.
This argument can only be used with the scratch and ER randomization type and must be combined with the -mean option.

=cut
	} elsif ($arg eq "-sd") {
	    $main::sd = shift (@arguments);
	    unless (&IsReal($sd)) {
		&RSAT::error::FatalError(join("\t", $sd, "Invalid value for mean standard deviation of the edge"));
	    }   

	    ##  maximal degree of the nodes
=pod

=item B<-degree #>

Maximal degree of the nodes in the random graph

=cut
	} elsif ($arg eq "-degree") {
	    $max_degree = shift (@arguments);
	    unless (&IsNatural($max_degree) && ($max_degree > 0)) {
		&RSAT::error::FatalError(join("\t", $max_degree, "Invalid value for the number of requested nodes. Must be a strictly positive natural number"));
	    }	
	    	   ## Directed option
=pod

=item B<-directed>

Specifies whether the edges must be considered as directed, i.e., an edge 
from node A to node B is different from an edge from B to A (by default, edges are not directed).

=cut
	    	    
	} elsif ($arg eq "-directed") {
	    $directed = 1;
	    	   ## Normal option
	   
=pod

=item B<-normal>

This option can only be used with ER randomization type and if the input graph is weighted.
Using this option will generate randomly the weight of the output random graph according to a normal distribution of 
weights. The mean and standard deviation can then be chosen (-mean and -sd option) or will be calculated according to the 
weights the input graph. 

=cut
	    	    
	} elsif ($arg eq "-normal") {
	    $normal = 1;
	    
=pod

=item B<-duplicate>

Specifies whether more than one edge may link two nodes.

=cut
	    	    
	} elsif ($arg eq "-duplicate") {
	    $duplicated = 1;
=pod
=item B<-self>

Allows self loops (by default, self loops are not permitted)


=cut	    
	} elsif ($arg eq "-self") {
	    $main::self = 1;
	    

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}

     }

}


################################################################
#### verbose message
sub Verbose {
    print $main::verbose_out "; convert-graph ";
    &PrintArguments($main::verbose_out);
    if (defined(%main::infile)) {
	print $main::verbose_out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::verbose_out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
}

__END__

=pod

=head1 SEE ALSO

=item I<compare-graphs>

=item I<compare-graph-clusters>

=item I<convert-graph>

=item I<graph-get-clusters>

=item I<graph-neighbours>

=item I<graph-node-degree>

=item I<graph-set-attributes>

=cut
