%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Running web services with RSAT

\chapter{Using RSAT web services}

\section{Introduction}

\RSAT facilities can be used as web services (\concept{WS}), i.e. external developers
(you) can use \RSAT facilities in their own code. One important
advantage of web services is that they are using a standard
communication interface between client and server, and the libraries
exist in various languages (Perl, Python, java).

We explain below how to implement a WS client in Perl. 

\section{Requirements}

Before using a WS client, You need to install the Perl modules
\program{SOAP::Lite} and \program{SOAP::WSDL}. Perl modules can be installed with the program
\program{cpan}, but for this you need root privileges. If this is not
your case, please ask your system administrator to install them for
you.

\section{Examples of WS client in Perl}

We show hereafter some simple examples of clients written in perl.

\subsection{Retrieving sequences from RSATWS}

The following example is a script to retrieve the start codons of three Escherichia coli genes. It uses \program{retrieve-seq} to do so. The various parameters are passed as a hash table to the method. If there is an error ,it will be displayed, otherwise the result is displayed, toghether with the full command generated on the server and the name of the temporary file created on the server to hold the result localy. This file is useful when one wants to feed another program with that output, whithout paying the cost of a useless data transport back and forth between the server and the client.

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/perl -w
# retrieve-seq_client_soap-wsdl.pl - Client retrieve-seq using the SOAP::WSDL module

################################################################
##
## This script runs a simple demo of the web service inerface to the
## RSAT tool retrieve-seq. It sends a request to the server for
## obtaining the start codons of 3 E.coli genes.
##
################################################################

use strict;
use SOAP::WSDL;
# import SOAP::Lite +trace;

## WSDL location
my $WSDL = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.wsdl';
my $proxy = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.cgi';

my $soap=SOAP::WSDL->new(wsdl => $WSDL)->proxy($proxy);

$soap->wsdlinit;

# $soap->wsdl_checkoccurs(0);

## Return option
my $return_choice = 'both';  ## Accepted values: 'file', 'result', 'both'

## Retrieve-seq parameters
my $organism = '-org Escherichia_coli_K12';  ## Name of the query organism
# my $organism = '-org Escherichia_colix_K12';
my @gene = ("metA", "metB", "metC");  ## List of query genes
# my @gene = ("zorglB");
my $all = '';  ## the -all option. This option is incompatible with the query list @gene (above)
my $noorf = '-noorf';  ## Clip sequences to avoid upstream ORFs
my $from = '-from 0';  ## Start position of the sequence
my $to = '-to 2';  ## End position of the sequence
my $feattype = '';  ## The -feattype option value is  not specified, the default is used
my $type = '';  ## The -type option value; other example:'-type downstream'
my $format = '';  ## The -format option value. We use the default (fasta), but other formats could be specified, for example 'multi'
my $label = '-label id,name';  ## Choice of label for the retrieved sequence(s)
my $label_sep = '';  ## Choice of separator for the label(s) of the retrieved sequence(s)
my $nocom = '';  ## Other possible value = '-nocom', to get sequence(s) whithout comments
my $repeat =  '';  ## Other possible value = '-rm', to have annotated repeat regions masked

my %args = ('return' => $return_choice,
	    'organism' => $organism,
	    'query' => \@gene,  ## An array in a hash has to be referenced (correct?)
	    'noorf' => $noorf,
	    'from' => $from,
	    'to' => $to,
	    'feattype' => $feattype,
	    'type' => $type,
	    'format' => $format,
	    'label' => $label,
	    'label_sep' => $label_sep,
	    'nocom' => $nocom,
	    'repeat' => $repeat);

## Send the request to the server
print "Sending request to the server\n";
my $som = $soap->call('retrieve_seq' => 'request' => \%args);

## Get the result
if ($som->fault){ ## Report error if any
    printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
    my $results_ref = $som->result;  ## A reference to the result hash table
    my %results = %$results_ref;  ## Dereference the result hash table

    ## Report the remote command
    my $command = $results{'command'};
    print "Command used on the server: ".$command, "\n";

    ## Report the result
    if ($return_choice eq 'file') {
	my $server_file = $results{'file'};
	print "Result file on the server: ".$server_file;
    } elsif ($return_choice eq 'result') {
	my $result = $results{'result'};
	print "Retrieved sequence(s): \n".$result;
    } elsif ($return_choice eq 'both') {
	my $server_file = $results{'file'};
	my $result = $results{'result'};
	print "Result file on the server: ".$server_file;
	print "Retrieved sequence(s): \n".$result;
    }
}
\end{verbatim}
\end{footnotesize}

\subsection{Work flow using RSATWS}

The following example is the script of a typical workflow of RSA Tools
programs. First, the upsrteam sequences of five Saccharomyces
cerevisiae genes are retrieved with \program{retrieve-seq}. Then,
\program{purge-sequence} is applyed to remove any redundancy in the
set of sequences. Finally, \program{oligo-analysis} is applied to
discover over-represented six letters words. The result of step 1 and
2 are stored on the server, so that the file name can be sent to the
following step as input and only the final result needs to be
transported from the server to the client.

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/perl -w
# retrieve_purge_oligos_client_wsdl.pl - Client retrieve-seq + purge-sequence + oligo-analysis

################################################################
##
## This script runs a simple demo of the web service interface to the
## RSAT tools retrieve-seq, purge-sequence and oligo-analysis linked in a workflow.
##  It sends a request to the server for discovering 6 letter words
## in upstream sequences of 5 yeast genes. The sequences are first
## retrieved and purged for repeated segments
##
################################################################

Use strict;
use SOAP::WSDL;
#use SOAP::Lite +trace;

## Service location
my $WSDL = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.wsdl';
my $proxy = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.cgi';

my $soap=SOAP::WSDL->new(wsdl => $WSDL)->proxy($proxy);

$soap->wsdlinit;

#################################################
## Retrieve-seq part

## Return option
my $return_choice = 'file';

## Parameters
my $organism = '-org Saccharomyces_cerevisiae';  ## Name of the query organism
my @gene = ("PHO5", "PHO8", "PHO11", "PHO81", "PHO84");  ## List of query genes
my $all = '';  ## -all option. This option is incompatible with the query list @gene (above)
my $noorf = '-noorf';  ## Clip sequences to avoid pstream ORFs
my $from = '';  ## Start position of the sequence
my $to = '';  ## End position of te sequence
my $feattype = '';  ## -feattype option value is not defined, default is used
my $type = '';  ## -type option value; other example:'-type downstream'
my $format = '-format fasta';  ## the format of the retrieved sequence(s)
my $label = '';  ## Choice of label for the retrieved sequence(s)
my $label_sep = '';  ## Choice of separator for the label(s) of the retrieved sequence(s)
my $nocom = '';  ## Other possible value = '-nocom'

my %args = ('return' => $return_choice,
	    'organism' => $organism,
	    'query' => \@gene,  ## An array in a hash has to be referenced
	    'noorf' => $noorf,
	    'from' => $from,
	    'to' => $to,
	    'feattype' => $feattype,
	    'type' => $type,
	    'format' => $format,
	    'all' => $all,
	    'label' => $label,
	    'label_sep' => $label_sep,
	    'nocom' => $nocom);

## Send request to the server
print "Retrieve-seq: sending request to the server\n";
my $som = $soap->call('retrieve_seq' => 'request' => \%args);

## Get the result
my $server_file;  ## That variable needs to be declared outside the if..else block
if ($som->fault){  ## Report error if any
    printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
    my $results_ref = $som->result;  ## A reference to the result hash table
    my %results = %$results_ref;  ## Dereference the result hash table
    
    ## Report the remote command
    my $command = $results{'command'};
    print "Command used on the server: ".$command, "\n";
    
    ## Report the result file name on the server
    $server_file = $results{'file'};
    print "Result file on the server: ".$server_file;
}
#################################################
## Purge-sequence part

## Define hash of parameters
%args = ('return' => $return_choice,  ## Same 'file' return option
	 'tmp_infile' => $server_file);  ## Output from retrieve-seq part is used as input here

## Send the request to the server
print "Purge-sequence: sending request to the server\n";
$som = $soap -> call('purge_seq' => 'request' => \%args);

## Get the result
if ($som->fault){  ## Report error if any
    printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
    my $results_ref = $som->result;  ## A reference to the result hash table
    my %results = %$results_ref;  ## Dereference the result hash table
    
    ## Report the remote command
    my $command = $results{'command'};
    print "Command used on the server: ".$command, "\n";

    ## Report the result file name on the server
    $server_file = $results{'file'};
    print "Result file on the server: ".$server_file;
}
#################################################
## Oligo-analysis part

## Return option
$return_choice = 'both';
## Parameters
$format = '-format fasta';  ## The format of input sequences
my $length = '-l 6';  ## Length of patterns to be discovered
my $background = '-bg upstream-noorf';  ## Type of background used
my $stats = '-return occ,proba,rank';  ## Returned statistics
my $noov = '-noov';  ## Do not allow overlapping patterns
my $str = '-2str';  ## Search on both strands
my $sort = '-sort';  ## Sort the result according to score
my $lth = '-lth occ_sig 0';  ## Lower limit to score is 0, less significant patterns are not displayed

%args = ('return' => $return_choice, 
	 'tmp_infile' => $server_file, 
	 'format' => $format,
	 'length' => $length,
	 'organism' => $organism, 
	 'background' => $background,
	 'stats' => $stats,
	 'noov' => $noov,
	 'str' => $str,
	 'sort' => $sort,
	 'lth' => $lth);

## Send request to the server
print "Oligo-analysis: sending request to the server\n";
$som = $soap->call('oligo_analysis' => 'request' => \%args);

## Get the result
if ($som->fault){  ## Report error if any
    printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
    my $results_ref = $som->result;
    my %results = %$results_ref;
    
    ## Report remote commande
    my $command = $results{'command'};
    print "Command used on the server: ".$command, "\n";
    
    ## Report the result
    if ($return_choice eq 'file') {
	$server_file = $results{'file'};
	print "Result file on the server: ".$server_file;
    } elsif ($return_choice eq 'result') {
	my $result = $results{'result'};
	print "Discovered oligo(s): \n".$result;
    } elsif ($return_choice eq 'both') {
	$server_file = $results{'file'};
	my $result = $results{'result'};
	print "Result file on the server: ".$server_file;
	print "Discovered oligo(s): \n".$result;
    }
}
\end{verbatim}
\end{footnotesize}

\section{Examples of WS client in java}


\section{Full documentation of the RSATWS interface}

