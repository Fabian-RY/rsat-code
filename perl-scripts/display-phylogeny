#!/usr/bin/perl -w
############################################################
#
# $Id: display-phylogeny,v 1.5 2011/04/14 13:49:42 rsat Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

display-phylogeny

=head1 VERSION

$program_version

=head1 DESCRIPTION

Template for writing new perl scripts.

=head1 AUTHORS

sylvain@bigre.ulb.ac.be

=head1 CATEGORY

phylogeny tools

=over

=item util

=back

=head1 USAGE

display-phylogeny -i inputfile [-phyloprofile value_file] -o radical [-out_format pdf|ps] [-v #] [-q] [...]

=head1 INPUT FORMAT



=head1 OUTPUT FORMAT

From a newick representation of a tree returns phylogenetic tree in the postscript format.

A value file can also be given as argument. Using it, labels of the tree will be displayed using a color scale.

=head1 SEE ALSO
supported-organisms

=head1 WISH LIST

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require PostScript::Simple;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    local $start_time = &RSAT::util::StartScript();
    $program_version = do { my @r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
#    $program_version = "0.00";

    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::groupdraw  = 0;
    $main::in = STDIN;
    $main::out = STDOUT;
    @main::newick = ();
    $main::out_format = "pdf";
    my $top_margin = 7;
    my %taxon_prot = ();
    our %xy = ();
    our %group_names = ();
    our %sons = ();
    our $grandfather = "";
    our $maxlevel = 0;
    our %pos = ();
    our %levels = ();
    our %leaves = ();
    our $level_height = 50;
    $level_height = 115 if ($groupdraw);
    our %children_number = ();
    our @count = (-45, -30, -15, 0, 15, 30, 45);

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values
    if ($infile{input} && scalar @newick > 0) {
      &FatalError("You must either submit a file (-i option) or a set of newick trees (-q option) not both)");
    }
    if ($infile{input} && (! -e $infile{input} || -z $infile{input})) {
      &FatalError("File ".$infile{input}." does not exist or is not valid... Please check");
    }
    if (!$outfile{output}) {
      &FatalError("Please, specify a valid output file name or prefix");
    }

    ################################################################
    ## Read input
    if ($main::infile{input}) {
      ($main::in) = &OpenInputFile($main::infile{input});
      while (my $ligne = <$main::in>) {
	chomp $ligne;
	# Check if it is a valid newick format (TO BE IMPLEMENTED)
	push @newick, $ligne;

      }
      close $main::in if ($main::infile{input});
    }
    ## Read values
    if ($main::infile{phyloprofile}) {
      ($main::inphyloprofile) = &OpenInputFile($main::infile{phyloprofile});
      my @header = ();
      while (my $ligne = <$main::inphyloprofile>) {
	chomp $ligne;
	my @lignecp = split /\t/, $ligne; 
	if ($ligne =~ /^#/) {
	  # this is the header
	  for (my $i = 1; $i < scalar @lignecp; $i++) {
	    push @header, $lignecp[$i];
	  }
	} else {
	  my $protein = $lignecp[0];
	  for (my $i = 1; $i < scalar @lignecp; $i++) {
	    ${$taxon_prot{$header[$i-1]}}{$protein} = $lignecp[$i];
	  }	  
	}
      }
      close $main::in if ($main::infile{phyloprofile});
    }
    my $protnb = scalar keys %taxon_prot;
    

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    ################################################################
    ## Execute the command
    my $iteration = 1;
    my $maxheight = 0;
    foreach my $string_val (@newick) {
      %sons = ();
      $grandfather = "";
      $maxlevel = 0;
      %pos = ();
      %levels = ();
      %group_names = ();
      %children_number = ();
      my $iterationid = "output"."_$iteration";
      $outfile{$iterationid} = $outfile{"output"};
      if (scalar @newick > 1) {
        $outfile{$iterationid} = $outfile{"output"}."_".$iteration.".$out_format";
      } 
      $string_val = "(".$string_val.")";
      $string_val =~ s/\)/\,\)/g;
      $string_val =~ s/\(/\(\,/g;
      my @string = split /\,/, $string_val;
      &find_node_levels(\@string, 0, 0);
      
      &count_children($grandfather);
      

      
      # computes the maximal coordinates of x and y
      my $x_width = (scalar keys %sons) *100 +100;
      my $y_width = $maxlevel * ($level_height+30);
      &dispose_nodes($grandfather, 0, 0, $x_width);
      # create the picture
      my $table_size = 10 * $protnb;
      my $margin = 40;
      $p = new PostScript::Simple(xsize=>$x_width + 2*$margin, ysize=>$y_width + $table_size, colour => 1, eps => 0, units => "pt");
      # create a new page
      $p -> newpage;
      # first draw the edges
      foreach my $node (keys %sons) {
	my @sons = @{$sons{$node}};
	foreach my $son (@sons) {
	  my $source_xpos = $pos{$node}{'x'}+$margin;
	  my $source_ypos = $pos{$node}{'y'}+$top_margin;
	  my $target_xpos = $pos{$son}{'x'}+$margin;
	  my $target_ypos = $pos{$son}{'y'}+$top_margin;;
	  &RSAT::message::Info(join "\t", $node, $son, $source_xpos, $source_ypos, $target_xpos, $target_xpos) if ($main::verbose >= 2);
	  $p->line($source_xpos,$source_ypos, $target_xpos, $target_ypos, 0, 0, 0);
	}
      }
      # then draw the nodes
      $p->setfont("Arial", 12);
      foreach my $node (sort keys %pos) {
        my $length_name = length($node) * 6;
	my $xpos = $pos{$node}{'x'}+$margin;
	my $ypos = $pos{$node}{'y'}+$top_margin;
        # draw a black box around the node label
        if ($leaves{$node}) {
          $p->setcolour("black");
          $p->text({rotate => 90}, $xpos, $ypos+8, $node);
          my $height =  length($node) * 10 + $pos{$node}{'y'} + 10;
          $maxheight = $height if ($height > $maxheight);
        } elsif ($groupdraw && $group_names{$node}) {
          $node = $group_names{$node} || $node;
          $length_name = length($node) * 7;
          $p->setcolour("black");
          $p->box({filled=>1},$xpos-$length_name/2, $ypos-5, $xpos + $length_name/2, $ypos+12);
          $p->setcolour("white");
          $p->box({filled=>1},$xpos-$length_name/2+1, $ypos-4, $xpos + $length_name/2-1, $ypos+11);
          $p->setcolour("black");
          $p->text($xpos-$length_name/2+2,  $ypos-2, $node);
        }
      }
      
      # draw the phylogenetic profile (if any)
      $p->setfont("Arial", 10);
      if (scalar keys %taxon_prot > 0) {
        my $firstcol = 1;
	foreach my $node (sort keys %pos) {
	  next if (!$leaves{$node});
	  my $xpos = $pos{$node}{'x'}+$margin;
	  my $previous_height = $maxheight;
	  my $j = 0;
	  foreach my $protein (sort keys %{$taxon_prot{$node}}) {
	    my $ypos = $previous_height;
	    my $result = $taxon_prot{$node}{$protein};
	    $p->setcolour("red");
	    $p->setcolour("green") if ($result);
	    $p->box( {filled => 1}, $xpos,$ypos, $xpos+8,$ypos+8);
	    if ($firstcol) {
	      $p->setcolour("black");
	      $p->text(5, $ypos, $protein);
	    }
	    $previous_height = $ypos+8;
	  }
	  $firstcol = 0;
	}      
      }      
      
      my $outputfile = $main::outfile{output};
      if ($out_format eq "pdf") {
        $outputfile = `mktemp temp.XXXXX`;
        chomp $outputfile;
      }
      $p->output($outputfile);
      if ($out_format eq "pdf") {
        system("pstoedit -f pdf $outputfile ".$outfile{$iterationid});
        system("rm $outputfile");
      }
      $iteration++;
    }
    
    ##########################
    ######################################
    ## Insert here output printing

    ################################################################
    ## Report execution time and close output stream
    my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
    print $main::out $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified
    close $main::out if ($main::outfile{output});

    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }


=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();


=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-out_format>

pdf or ps

=cut
    } elsif ($arg eq "-out_format") {
      $main::out_format = shift(@arguments);
      
      
=pod

=item B<-q>

taxonomy in the newick format (between quotes). This option can be used iteratively.

=cut
    } elsif ($arg eq "-q") {
      my $q = shift(@arguments);
      push @newick, $q;
=pod

=item B<-i inputfile>

file containing a list of taxonomies in the newick format

=cut
    } elsif ($arg eq "-i") {
      $main::infile{input} = shift(@arguments);


=pod

=item B<-phyloprofile valuesfile>

Tab-delimited File containing one value for every taxon. The first column contains the taxon name, the second column the score.

=cut
    } elsif ($arg eq "-phyloprofile") {
      $main::infile{phyloprofile} = shift(@arguments);

=pod

=item B<-groupdraw>

Draw the group names (when present in the Newick input).

=cut
    } elsif ($arg eq "-groupdraw") {
      $main::groupdraw = 1;

=pod

=item	B<-o outputfile>

Name of the output file. If more than one tree is required, you have to give a prefix as argument.

=cut
    } elsif ($arg eq "-o") {
      $main::outfile{output} = shift(@arguments);

    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}
################################################################
## Parse the tree in newick format and returns the node levels 
sub find_node_levels {
  my ($string_ref, $start, $level) = (shift, shift, shift);
  my @string = @{$string_ref};
  my $group = "";
  my @groups = ();
  for (my $i = $start; $i < scalar @string; $i++) {
    my $current_char = $string[$i];
    if ($current_char =~ /\)(.*)$/) {
      $levels{$group} = $level if (!defined $levels{$group});
      if ($1 ne "") {
        $group_names{$group} = $1;
      }
      foreach my $subgroup (@groups) {
        push @{$sons{$group}}, $subgroup if ($subgroup ne $group);
      }
      $grandfather = $group;
      return ($i, $group);
    } elsif ($current_char eq "(") {
      my ($newpos, $group_here) = &find_node_levels(\@string, $i+1, $level+1);
      $maxlevel = ($level+1) if (($level+1) > $maxlevel);
      $i = $newpos;
      $group .= $group_here;
      push @groups, $group_here;
    } else {
      $levels{$current_char} = $level if (!defined $levels{$current_char});
      push @groups, $current_char;
      $leaves{$current_char}++;
      $group .= $current_char;
    }
  }
}

################################################################
## Computes the position of the nodes
sub dispose_nodes {
  my ($node, $level, $xstart, $xend) = (shift, shift, shift, shift);
  if (defined ($sons{$node})) {
    my @children = @{$sons{$node}};
    @children = sort @children;
    my $children_nb = scalar @children;
    my $length = ($xend - $xstart);
    my $total_children_nb = $children_number{$node};
    my $start_xpos = $xstart;
    my $end_xpos = $xstart + $length * ((1 + $children_number{$children[0]}) / $total_children_nb);
    for (my $i = 0; $i < $children_nb; $i ++) {
      my $child = $children[$i];
      &dispose_nodes($child, $level+1, $start_xpos, $end_xpos);
      $start_xpos = $end_xpos;
      if (defined $children[$i+1]) {
        $end_xpos = $end_xpos + $length * ((1 + $children_number{$children[$i+1]}) / $total_children_nb);
      } else {
        $end_xpos = $xend;
      }

    }
  }
  my $posx = ($xstart + $xend) / 2;
  my $posy = $level*$level_height;
  # check if this place has not already been taken
  if (defined ($sons{$node}) && defined $xy{$posy}) {
    my @x = @{$xy{$posy}};
    for (my $i = 0; $i < scalar @x; $i++) {
      print "$x[$i] $posx\n";
      if (abs($x[$i]-$posx) < 300) {
        my $this_count = int(rand(scalar @count));
        $posy += $count[$this_count];
        last;
      }
    }
  } 
  $pos{$node}{'x'} = $posx;
  $pos{$node}{'y'} = $posy;
  push @{$xy{$posy}}, $posx;
}

################################################################
## Computes the total number of children (and grand children) for a node
sub count_children {
  my $node = shift;
  if (defined ($sons{$node})) {
    my @children = @{$sons{$node}};
    foreach my $child (@children) {
      &count_children($child);
      $children_number{$node} += $children_number{$child} + 1;
    }
  } else {
    $children_number{$node} = 0;
  }
}


################################################################
## Verbose message
sub Verbose {
    print $main::out "; display-phylogeny ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (%main::infile) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    if (%main::outfile) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
}


__END__
