#!/usr/bin/perl -w
############################################################
#
# $Id: chip-motifs,v 1.11 2010/03/07 02:09:57 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

chip-seq-analysis

=head1 VERSION

$program_version

=head1 DESCRIPTION

Pipeline for discoering motifs from ChIP-seq (or ChIP-chip) peak
sequences.

=head1 AUTHORS

=over

=item Jacques van Helden <Jacques.van.Helden@ulb.ac.be>

=item Morgane Thomas-Chollier <thomas-c@molgen.mpg.de>

=item Matthieu Defrance <defrance@ccg.unam.mx>

=item Olivier Sand <oly@bigre.ulb.ac.be> for the Web services

=back


=head1 CATEGORY

Pattern discovery

=head1 USAGE

chip-seq-analysis [-i inputfile] [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

The program takes as input either one (test) or two sequence files
(test versus control).

All input sequences formats supported by convert-sequences are
supported.

=head1 OUTPUT FORMAT

The pipeline runs a series of programs generating each one or several
result file. An HTML index is generated in order to synthesize the
results and give access to the individual result files. 

The index file is formed from the output directory (option -outdir)
and the file prefix (option -prefix).

  [output_dir]/[prefix]_synthesis.html

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "footprint.lib.pl";
use RSAT::util;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();
    $program_version = do { my @r = (q$Revision: 1.11 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
#    $program_version = "0.00";

    %main::param = ();
    @main::param_list = ();

    %main::dir = ();
    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::out = STDOUT;

    ################################################################
    ## Supported tasks
    @supported_tasks = qw (
			   all
			   seqlen
			   purge
			   oligos
			   dyads
			   profiles
			   synthesis
			   clean_seq
			  );

    my @future_tasks = qw(
			  ORM
			  oligo-diff
			  tomtom
			  to_bed
		      );
    $supported_tasks = join ",", @supported_tasks;
    %supported_task = ();
    foreach my $task (@supported_tasks) {
      $supported_task{$task} = 1;
    }
    %task = (); ## List of tasks to be executed

    ################################################################
    ## Set default parameters
    &DefaultParameters();

    ################################################################
    ## Read argument values
    &ReadArguments();

    &CheckArguments();

    &SetOutFileNames();

    if ($task{purge}) {
      &PurgeOneSeq($infile{test_seq}, "test");
      if ($infile{control_seq}) {
	&PurgeOneSeq($infile{control_seq}, "control");
      }
    }

    &SequenceLengths if ($task{seqlen});

    &OligoAnalysis if ($task{oligos});

    &DyadAnalysis if ($task{dyads});

    &PositionAnalysis if ($task{profiles});

    &CompositionProfiles if ($task{profiles});

    &Synthesis if ($task{synthesis});

    &CleanSequences() if ($task{clean_seq});

    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{log});

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    ################################################################
    ## Execute the command

    ################################################################
    ## Print output


    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }


    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    if ($main::verbose >= 1) {
      &TimeWarn("Job done");
      &TimeWarn("Log file", $outfile{log});
    }
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}


################################################################
## Set parameter values for all the programs
sub DefaultParameters {
  &RSAT::message::TimeWarn("Setting default parameter values") if ($main::verbose >= 1);

  ## Formats
  $main::param{seq_format} = "fasta"; push(@main::param_list, "seq_format");
  $main::param{img_format} = "png"; push(@main::param_list, "img_format");

  ## Purge-seq
  $main::param{purge_match_length} = 30; push(@main::param_list, "purge_match_length");
  $main::param{purge_mismatches} = 0; push(@main::param_list, "purge_mismatches");

  ## Pattern discovery options
  $main::param{strand} = "-2str"; push(@main::param_list, "strand");
  $main::param{noov} = "-noov"; push(@main::param_list, "noov");
  $main::param{oligo_len} = 7; push(@main::param_list, "oligo_len");

  ## oligo-analysis
  $main::param{oligo_markov} = -2; push(@main::param_list, "oligo_markov");

  ## dyad-analysis

  ## matrix-from-patterns
  $main::param{matrix_nmotifs} = 5; push(@main::param_list, "matrix_nmotifs");

  ## residue profiles (position-analysis)
  $main::param{profiles_ci} = 5; push(@main::param_list, "profiles_ci");
  $main::param{profiles_strand} = "-1str"; push(@main::param_list, "profiles_strand");
  @main::profiles_oligo_lengths = (1,2,6);
  $main::param{profiles_oligo_lengths} = join(',',@profiles_oligo_lengths); push(@main::param_list, "profiles_oligo_lengths");

}


################################################################
## Define one output file name by concatenating arguments
sub OutFileName {
    my ($extension, @name_elements) = @_;
    my $out_file_name = $dir{output}."/".$main::param{prefix};
    $out_file_name .= join ("_", @name_elements);
    $out_file_name .= $extension;
    return($out_file_name);
}



################################################################
## Set output file names
sub SetOutFileNames {
    ## Purged sequences
    $main::outfile{"purged_test"} = &OutFileName(".fasta", 
						 "test",
						 "purged",
						 "ml".$main::param{purge_match_length},
						 "mis".$main::param{purge_mismatches});
    if ($infile{control_seq}) {
	$main::outfile{"purged_control"} = &OutFileName(".fasta", 
						     "control",
						     "purged",
						     "ml".$main::param{purge_match_length},
						     "mis".$main::param{purge_mismatches});
    }

    ## Sequence lengths
    $main::outfile{"test_seqlen"} = &OutFileName(".tab", "test_seqlen");
    $main::outfile{"test_seqlen_distrib"} = &OutFileName(".tab", "test_seqlen_distrib");
    $main::outfile{"test_seqlen_distrib_graph"} = &OutFileName(".".$param{img_format}, "test_seqlen_distrib");
    if ($infile{control_seq}) {
	$main::outfile{"control_seqlen"} = &OutFileName(".tab", "control_seqlen");
	$main::outfile{"control_seqlen_distrib"} = &OutFileName(".tab", "control_seqlen_distrib");
	$main::outfile{"control_seqlen_distrib_graph"} = &OutFileName($param{img_format}, "control_seqlen_distrib");
    }

    ## oligo-analysis result
    $main::outfile{oligos} = &OutFileName(".tab", "oligos".$main::param{strand}.$main::param{noov}, 
					  $main::param{oligo_len}."nt",
					  "mkv".$main::param{oligo_markov});
    $main::outfile{oligos_pssm} = $main::outfile{oligos};
    $main::outfile{oligos_pssm} =~ s/\.tab$//;
    $main::outfile{oligos_pssm} .= "_pssm";

    ## dyad-analysis result
    $main::outfile{dyads} = &OutFileName(".tab", "dyads".$main::param{strand}.$main::param{noov}, 
					  "3nt_sp0-20_bg_monads");
    $main::outfile{dyads_pssm} = $main::outfile{dyads};
    $main::outfile{dyads_pssm} =~ s/\.tab$//;
    $main::outfile{dyads_pssm} .= "_pssm";

    ## Position-analysis
    for my $ol (@profiles_oligo_lengths) {
      $main::outfile{$ol."nt_profiles"} = &OutFileName(".tab", "profiles".$main::param{profiles_strand}.$main::param{noov},$ol."nt",
						       "ci".$main::param{profiles_ci});
    }

    ## Compositional profiles
    for my $ol (1,2) {
      $outfile{$ol."nt_profiles_graph"} = $main::outfile{$ol."nt_profiles"};
      $outfile{$ol."nt_profiles_graph"} =~ s/\.tab$//;
      $outfile{$ol."nt_profiles_graph"} .= ".".$main::param{img_format};
    }
  }

################################################################
## Purge sequences
sub PurgeOneSeq {
  my ($seq_file, $seq_type) = @_;
  &RSAT::message::TimeWarn("Purging sequences") if ($main::verbose >= 1);
  my $cmd = "convert-seq";
  $cmd .= " -i ".$seq_file;
  $cmd .= " -from ".$main::param{seq_format};
  $cmd .= " -to fasta";
  $cmd .= " -mask non-dna";
  $cmd .= "| purge-sequence -dna";
  $cmd .= " -ml ".$main::param{purge_match_length};
  $cmd .= " -mis ".$main::param{purge_mismatches};
  $cmd .= " -o ".$main::outfile{"purged_".$seq_type};
  &one_command($cmd);
}


################################################################
## Compute sequence lengths
sub SequenceLengths {
  &RSAT::message::TimeWarn("Computing sequence lengths") if ($main::verbose >= 1);
  my $cmd = "sequence-lengths";
  $cmd .= " -i ".$main::infile{test_seq};
  $cmd .= " -o ".$main::outfile{test_seqlen};
  $cmd .= " ; cut -f 2 ".$main::outfile{test_seqlen};
  $cmd .= " | classfreq -v 1 -ci 10 -o ".$main::outfile{test_seqlen_distrib};
  $cmd .= " ; XYgraph -lines -legend "; 
  $cmd .= " -format ".$main::param{img_format};
  $cmd .= " -title '".$main::param{title}." Sequence lengths'" if ($main::param{title});
  $cmd .= " -ysize 200 -ycol 4 -yleg1 'Number of peaks'";
  $cmd .= " -xsize 800 -xcol 3 -xleg1 'Peak length'";
  $cmd .= " -i ".$main::outfile{test_seqlen_distrib};
  $cmd .= " -o ".$main::outfile{test_seqlen_distrib_graph};
  &one_command($cmd);
}


################################################################
## Run oligo-analysis on the test set
sub OligoAnalysis {
  &RSAT::message::TimeWarn("Running oligo-analysis") if ($main::verbose >= 1);
  my $cmd = "oligo-analysis -v 1";
  $cmd .= " -i ".$main::outfile{"purged_test"};
  $cmd .= " -format fasta";
  $cmd .= " -sort -lth occ_sig 0 -uth rank 50 -return occ,proba,rank";
  $cmd .= " ".$main::param{strand};
  $cmd .= " ".$main::param{noov};
  $cmd .= " -seqtype dna";
  $cmd .= " -l ".$main::param{oligo_len};
  $cmd .= " -markov ".$main::param{oligo_markov};
  $cmd .= " -pseudo 0.01";
  $cmd .= " -o ".$outfile{oligos};
  &one_command($cmd);
  &MatrixFromPatterns($outfile{oligos}, $outfile{oligos_pssm}, "oligos");
}


################################################################
## Run dyad-analysis on the test set
sub DyadAnalysis {
  &RSAT::message::TimeWarn("Running dyad-analysis") if ($main::verbose >= 1);
  my $cmd = "dyad-analysis -v 1";
  $cmd .= " -i ".$main::outfile{"purged_test"};
  $cmd .= " -format fasta";
  $cmd .= " -sort -lth occ_sig 0 -uth rank 50 -return occ,proba,rank";
  $cmd .= " ".$main::param{strand};
  $cmd .= " ".$main::param{noov};
  $cmd .= " -seqtype dna";
  $cmd .= " -l 3 -sp 0-20 ";
  $cmd .= " -bg monads";
  $cmd .= " -pseudo 0.01";
  $cmd .= " -o ".$outfile{dyads};
  &one_command($cmd);
  &MatrixFromPatterns($outfile{dyads}, $outfile{dyads_pssm}, "dyads");
}


################################################################
## Convert a list of patterns into PSSMs
sub MatrixFromPatterns {
  my ($pattern_file, $pssm_file, $type) = @_;
  &RSAT::message::TimeWarn("\tMatrix from patterns", $type) if ($verbose >= 1);
  my $cmd = "matrix-from-patterns -v 1 ";
  $cmd .= " -seq ".$infile{test_seq};
  $cmd .= " -pl ".$pattern_file;
  $cmd .= " -bginput -markov 1 ";
  $cmd .= " -max_asmb_nb ".$main::param{matrix_nmotifs};
  $cmd .= " -gibbs_flanks 2";
  $cmd .= " -gibbs_iter 2";
  $cmd .= " -gibbs_msps 0.5";
  $cmd .= " -logo -links";
  $cmd .= " -o ".$pssm_file;
  &one_command($cmd);
}


################################################################
## Run position-analysis on the test set
sub PositionAnalysis {
  &RSAT::message::TimeWarn("Running position-analysis") if ($main::verbose >= 1);
  for my $ol (@profiles_oligo_lengths) {
    my $cmd = "position-analysis -v 1";
    $cmd .= " -i ".$main::outfile{"purged_test"};
    $cmd .= " -format fasta";
    $cmd .= " -sort ";
    $cmd .= " -return chi,sig,distrib,graphs,rank";
    $cmd .= " -max_graphs 50";
    $cmd .= " ".$main::param{profiles_strand};
    $cmd .= " ".$main::param{noov};
    $cmd .= " -seqtype dna";
    $cmd .= " -l ".$ol;
    $cmd .= " -ci ".$main::param{profiles_ci};
    $cmd .= " -img_format ".$main::param{img_format};
    $cmd .= " -title '".$main::param{title}."'";
    $cmd .= " -origin center ";
    $cmd .= " -o ".$outfile{$ol."nt_profiles"};
    &one_command($cmd);
  }
}


################################################################
## CompositionProfiles
sub CompositionProfiles {
  for my $ol (1,2) {
    my $col_nb = 4**$ol + 1;
    my $cmd = 'grep -v ";" '.$outfile{$ol."nt_profiles"}.' | transpose-table | grep -P \'(^id)|(^\-?\d+)\'';
    $cmd .= " | XYgraph -xcol 1 -ycol 2-".$col_nb;
    $cmd .= " -lines -legend -header ";
    $cmd .= " -title 'Peak composition profiles : ".$ol."nt'";
    $cmd .= " -xleg1 'Position' -xsize 800";
    $cmd .= " -yleg1 'Occurrences' -ysize 400";
    $cmd .= " -o ".$outfile{$ol."nt_profiles_graph"};
    &one_command($cmd);
  }
}


################################################################
## Generate a synthetic table summarizing the main results with links
## to the iriginal result files.
sub Synthesis {
  &RSAT::message::TimeWarn("Generating synthesis", $main::outfile{synthesis}) if ($main::verbose >= 1);
  local $syn = &OpenOutputFile($main::outfile{synthesis});
  local $synthesis_path = `dirname $main::outfile{synthesis}`;
  chomp($synthesis_path);

  ## HTML Header and title
  print $syn "<html>\n";
  print $syn "<head>\n";
  print $syn "<title>chip-seq-analysis ".$main::param{title}."</title>\n";

  ## Page styles
  print $syn "<style type='text/css'>\n";
  print $syn `cat $ENV{RSAT}/perl-scripts/lib/results.css`;
  print $syn "</style>\n";
#  print $syn "<link rel='stylesheet' type='text/css' href='".$ENV{RSAT}."/public_html/main.css'/>\n";

  print $syn "</head>\n";
  print $syn "<body>\n";
  print $syn "<h1>Result: chip-seq-analysis ".$main::param{title}."</h1>\n";


  ## Header of the synthetic table
  print $syn "<h2>Synthetic report</h2>";
  print $syn "<p><table class='sortable'>\n";

  &SynthesisSequenceComposition();

  ## Log file
  &SyntheticTableAddRow("Log file",
			"",
 			"txt"=>$main::outfile{"log"},
 		       );


  ## Close the synthetic table
  print $syn "</table></p>\n";

  ## Log file
  print $syn "<h2>Log</h2>";
  print $syn "<pre>";
  print $syn `cat $main::outfile{log}`;
  print $syn "</pre>";

  ## End of the HTML file
  print $syn "</body>\n";
  print $syn "</html>\n";
  close $syn;
}

################################################################
## Compute a file path relative to the synthesis file
sub RelativePath {
  my ($file) = @_;
  $file =~ s|${synthesis_path}/||;
  return ($file);
}

################################################################
## Add a row to the syhnthetic table
sub SyntheticTableAddRow {
  my ($type, $summary, @files) = @_;
  print $syn "<tr>\n";
  print $syn "<td>$type</td>\n";
  print $syn "<td>$summary</td>\n";
  print $syn "<td>\n";
  my $key;
  my $file;
  while ($key = shift (@files)){
    last unless $key;
    $file = shift(@files);
    &RSAT::message::Debug($key, $file) if ($main::verbose >= 5);
    $file = &RelativePath($file);
    print $syn "<a href='".$file."'>[".$key."]</a><br>\n";
  } 
  print $syn "</td>\n";
  print $syn "</tr>\n";
}


################################################################
## Add a header row to the synthetic table
sub SyntheticTableAddHeaderRow {
  my ($header) = @_;
  print $syn "<tr>\n";
  print $syn "<th colspan=3>\n";
  print $syn $header;
  print $syn "</th>\n";
  print $syn "</tr>\n";
}

################################################################
## Add sequence composition on the synthetic report
sub SynthesisSequenceComposition {

  ## Header line
  &SyntheticTableAddHeaderRow("Sequence composition");

  ## Get number of peaks from sequence length distribution
  my $peak_nb = `grep ';count:' $main::outfile{"test_seqlen_distrib"}`;
  chomp($peak_nb);
  $peak_nb =~ s/.*count:\s*//;

  ## Get total sequence size from sequence length distribution
  my $seq_size = `grep ';sum:' $main::outfile{"test_seqlen_distrib"}`;
  chomp($seq_size);
  $seq_size =~ s/.*sum:\s*//;
  $seq_size = round($seq_size/1000);

  ## Sequence lengths
  my $img = &RelativePath($main::outfile{"test_seqlen_distrib_graph"});
  &SyntheticTableAddRow("Nb of peaks: ".$peak_nb."<br>\nTotal seq. size: ".$seq_size." kb",
			"<a  href='".$img."'><img height=150 src='".$img."'></a>",
			"lengths",$main::outfile{"test_seqlen"},
			"distrib",$main::outfile{"test_seqlen_distrib"},
			"plot",$main::outfile{"test_seqlen_distrib_graph"},
		       );


  ## Residue composition
  $img = &RelativePath($outfile{"1nt_profiles_graph"});
  &SyntheticTableAddRow("Nb of peaks: ".$peak_nb."<br>\nTotal seq. size: ".$seq_size." kb",
			"<a  href='".$img."'><img height=150 src='".$img."'></a>",
			"table",$outfile{"1nt_profiles_graph"},
			"individual graphs",$main::outfile{"test_seqlen_distrib"},
			"plot",$main::outfile{"test_seqlen_distrib_graph"},
		       );
}

################################################################
## Delete purged sequence files after analysis has been completed.
sub CleanSequences {
  &RSAT::message::TimeWarn("Cleaning sequences") if ($main::verbose >= 1);
  &one_command("rm -f ".$main::outfile{"purged_test"});
  if ($infile{control_seq}) {
    &one_command("rm -f ".$main::outfile{"purged_control"});
  }
}


################################################################
## Read arguments 
sub ReadArguments {
  &RSAT::message::TimeWarn("Reading arguments") if ($main::verbose >= 1);
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();

=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-i test_seq_file>

Test peak sequence file (mandatory).

For single-set analysis, this file contains the peak seuences of the
unique set.  For test versus control analysis, it contains the test
sequences.

=cut
    } elsif ($arg eq "-i") {
      $main::infile{test_seq} = shift(@arguments);

=pod

=item B<-ctl control_seq_file>

Control peak sequence file (optional).

This option is used only for the test versus control analysis.

=cut
    } elsif ($arg eq "-ctl") {
      $main::infile{control_seq} = shift(@arguments);

=pod

=item	B<-outdir output_directory>

Output directory (mandatory).

The result files and index files produced by the different programs
will be stored in this directory.



=cut
    } elsif ($arg eq "-outdir") {
      $main::dir{output} = shift(@arguments);


=pod

=item	B<-prefix output_prefix>

Prefix for the output files

=cut
    } elsif ($arg eq "-prefix") {
      $main::param{prefix} = shift(@arguments);

=pod

=item	B<-title graph_title>

Title displayed on top of the graphs.

=cut
    } elsif ($arg eq "-title") {
      $main::param{title} = shift(@arguments);

=pod

=item	B<-img_format img_format>

Image format. 

All the formats supported by XYgraph can be used.

=cut
    } elsif ($arg eq "-img_format") {
      $main::param{img_format} = shift(@arguments);

=pod

=item B<-task>

Specify a subset of tasks to be executed.

By default, the program runs all necessary tasks. However, in some
cases, it can be useful to select one or several tasks to be executed
separately.

Beware: task selection requires expertise, because most tasks depends
on the prior execution of some other tasks in the workflow. Selecting
tasks before their prerequisite tasks have been completed will provoke
fatal errors.

I<Avilable Tasks.>

=over

=item I<all> (default)

Run all supported tasks.

=item I<purge>

Purge input sequences (test set and, if specified, control set) to
mask redundant fragments before applying pattern discovey
algorithms. Sequence purging is necessary because redundant fragments
would violate the hypothesis of independence underlying the binomial
significance test, resulting in a large number of false positive
patterns.

=item I<seqlen>

Compute sequence lengths and their distribution. 

Sequence lengths are useful for the negative control (selection of
random genome fragments).

Sequence length distribution is informative to get an idea about the
variability of peak lengths.

=item I<oligos>

Run I<oligo-analysis> to detect over-represented oligonucleotides of a
given length (k, specified with option -l) in the test set. Prior
frequencies of oligonucleotides are taken from Markov model of order m
(option -markov) estimated from the test set sequences themselves.


=item I<dyads>

Run I<dyad-analysis> to detect over-represented dyads, i.e. pairs of
short oligonucleotides (monads) spaced by a region of fixed width but
variable content. By default, chip-seq-analysis analyzes pairs of
trinucleotides with any spacing between 0 and 20.

The expected frequency of each dyad is estimated as the product of its
monad frequencies in the input sequences (option -bg monads of
dyad-analysis).

=item I<profiles>

Compute profiles of residue and oligonucleotide frequencies per
position (using I<position-analysis>). 

Residue profiles may reveal composition biases in the neighborhood of
the peak sequences. Dinucleotide profiles can reveal (for example) an
enrichment in CpG island.

Positional biases for larger oligonucleotides (e.g. hexanucleotides)
can reveal

=item I<synthesis>

Generate the HTML file providing a synthesis of the results and
pointing towards the individual result files.

=item I<clean_seq>

Delete the purged sequence files after the analysis, in order to save
space.

This task is executed only when it is called explicitly. It is not
part of the tasks running with the option "-task all".

=back

=cut
    } elsif ($arg eq "-task") {
      my @requested_tasks = split ",", shift (@arguments);
      foreach my $task (@requested_tasks) {
	next unless $task;
	if ($supported_task{$task}) {
	  $task{$task} = 1;
	} else {
	  &RSAT::error::FatalError("Task '$task' is not supported. \n\tSupported: $supported_tasks");
	}
      }

=pod

=item B<-l oligo_len>

Oligonucleotide lengths for word-counting approaches
(oligo-analysis, position-analysis, ORM, oligo-diff).

Note: the monad length used for dyad-analysis is specified with
another parameter (-ml).

=cut
    } elsif ($arg eq "-l") {
      $main::param{oligo_len} = shift (@arguments);

=pod

=item B<-1str | -2str>

Single-strand (-1str) or double-strand (-2str) analysis.

The default is double-strand analysis, since ChIP-seq results have no
particular strand orientation.

=cut
    } elsif ($arg eq "-1str") {
      $main::param{strand} = "-1str";
    } elsif ($arg eq "-2str") {
      $main::param{strand} = "-2str";

=pod

=item B<-noov | -ovlp>

Treatment of self-overlapping words: count (-ovlp) or do not count
(-noov) overlapping occurrences. In -noov mode, only renewing
occurrences are counted.

It is recommended to use the -noov mode (default) to avoid the effect
of self-overlap, which violates the hypothesis of independence of
successive occurrences underlying the binomial significance test
(oligo-analysis, dyad-analysis).

=cut
    } elsif ($arg eq "-noov") {
      $main::param{noov} = "-noov";
    } elsif ($arg eq "-ovlp") {
      $main::param{noov} = "-ovlp";

=pod 

=item B<-ci class_interval>

Class interval for I<position-analysis>.

=cut

    } elsif ($arg eq "-ci") {
      $main::param{profiles_ci} = shift(@arguments);
      &RSAT::error::FatalError($main::param{profiles_ci}, "is not a valid value for class interval. Should be a strictly positive Natural number.")
	unless ((&IsNatural($main::param{profiles_ci})) && ($main::param{profiles_ci} > 0));

      ## Other parameters are not accepted
    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}

################################################################
## Check arguments
sub CheckArguments {
  &RSAT::message::TimeWarn("Checking arguments") if ($main::verbose >= 1);
  if ($infile{test_seq}) {
    unless (-e $infile{test_seq}) {
      &FatalError("Test sequence file does not exist", $infile{test_seq});
    }
  } else {
    &FatalError("You must define the test sequence set (option -i)");
  }

  if ($infile{control_seq}) {
    unless (-e $infile{control_seq}) {
      &FatalError("Control sequence file does not exist", $infile{control_seq});
    }
  }

  ## output directory
  if ($main::dir{output}) {
    &RSAT::util::CheckOutDir($main::dir{output});
  } else {
    &FatalError("You must define the output directory (option -outdir)");
  }

  ## Log file 
  $main::outfile{log} = &OutFileName(".txt", "log");

  ## Synthesis file 
  $main::outfile{synthesis} = &OutFileName(".html", "synthesis");

  ## If all tasks are requested or if no task is defined, execute all
  ## tasks.
  if ((scalar(keys(%task)) == 0) || ($task{all})) {
    %task = %supported_task;
    delete($task{all});
    delete($task{clean_seq});
  }
  foreach my $task (@supported_tasks) {
   push (@tasks, $task) if $task{$task};
  }
  &RSAT::message::Info("Tasks: ", join (",", @tasks)) if ($main::verbose >= 1);
}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; chip-seq-analysis ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }

    print $main::out "; Parameter values\n";
    foreach my $param_name (@param_list) {
	print $main::out sprintf ";\t%-22s\t%s\n", $param_name, $param{$param_name};
    }
}

=pod

=head1 REFERENCES

The program I<chip-seq-analysis> combines a series of tried-and-tested
programs which have been detailed in the following publications.

=over

=item I<oligo-analysis>

van Helden, J., Andre, B. and Collado-Vides, J. (1998). Extracting
regulatory sites from the upstream region of yeast genes by
computational analysis of oligonucleotide frequencies. J Mol Biol 281,
827-42.

=item I<dyad-analysis>

van Helden, J., Rios, A. F. and Collado-Vides, J. (2000). Discovering
regulatory elements in non-coding sequences by analysis of spaced
dyads. Nucleic Acids Res 28, 1808-18.

=item I<position-analysis>

van Helden, J., del Olmo, M. and Perez-Ortin,
J. E. (2000). Statistical analysis of yeast genomic downstream
sequences reveals putative polyadenylation signals. Nucleic Acids Res
28, 1000-10.

=item I<matrix-scan>

Turatsinze, J. V., Thomas-Chollier, M., Defrance, M. and van Helden,
J. (2008). Using RSAT to scan genome sequences for transcription
factor binding sites and cis-regulatory modules. Nat Protoc 3,
1578-88.

=back

=head1 SEE ALSO

=over

=item I<oligo-analysis>

=item I<dyad-analysis>

=item I<position-analysis>

=item I<matrix-scan>


=back

=head1 WISH LIST

=cut

__END__
