%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Running web services with RSAT

\chapter{Using RSAT web services}

\section{Introduction}

\RSAT facilities can be used as web services (\concept{WS}), i.e. external developers
(you) can use \RSAT facilities in their own code. One important
advantage of web services is that they are using a standard
communication interface between client and server, and the libraries
exist in various languages (Perl, Python, java).

We explain below how to implement a WS client in Perl. 

\section{Requirements}

Before using a WS client, You need to install the Perl modules
\program{SOAP::Lite} and \program{SOAP::WSDL}. Perl modules can be installed with the program
\program{cpan}, but for this you need root privileges. If this is not
your case, please ask your system administrator to install them for
you.

\section{Examples of WS client in Perl}

We show hereafter some simple examples of clients written in perl.

\subsection{Getting gene-info from RSATWS}

The following script allows to get information about three Escherichia coli genes from RSAT. The program \program{gene-info} is used to do so. A list of genes is provided and the info about those genes is returned.

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/perl -w
# gene-info_client_soap-wsdl.pl - Client gene-info using the SOAP::WSDL module

################################################################
##
## This script runs a simple demo of the web service interface to the
## RSAT tool gene-info. It sends a request to the server for
## obtaining information on 3 E. coli genes.
##
################################################################

use strict;
use SOAP::WSDL;

## Service location
my $WSDL = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.wsdl';
my $proxy = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.cgi';

## Call the service
my $soap=SOAP::WSDL->new(wsdl => $WSDL)->proxy($proxy);
$soap->wsdlinit;

## Gene-info parameters
my $organism = 'Escherichia_coli_K12';  ## Name of the query organism
my @gene = ("metA", "metB", "metC");  ## List of query genes
my $full = 'full';  ## Looking for full match, not substring match.
my $noquery = '';  ## Not used here.
my $descr = '';  ## Accepted value: 'descr'. Not used here.
my $feattype = '';  ## If the -feattype option value is not specified, the default is used (CDS for E. coli)

my %args = ('organism' => $organism,
	    'query' => \@gene,
	    'full' => $full,
	    'noquery' => $noquery,
	    'descr' => $descr,
	    'feattype' => $feattype);

## Send the request to the server
print "Sending request to the server\n";
my $som = $soap->call('gene_info' => 'request' => \%args);

## Get the result
if ($som->fault){ ## Report error if any
    printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
    my $results_ref = $som->result;  ## A reference to the result hash table
    my %results = %$results_ref;  ## Dereference the result hash table

    ## Report the remote command
    my $command = $results{'command'};
    print "Command used on the server: ".$command, "\n";

    ## Report the result
    my $result = $results{'client'};
    print "Gene(s) info(s): \n".$result;
}
\end{verbatim}
\end{footnotesize}


\subsection{Retrieving sequences from RSATWS}

The following example is a script to retrieve the start codons of three Escherichia coli genes. It uses \program{retrieve-seq} to do so. The various parameters are passed as a hash table to the method. If there is an error ,it will be displayed, otherwise the result is displayed, toghether with the full command generated on the server and the name of the temporary file created on the server to hold the result localy. This file is useful when one wants to feed another program with that output, whithout paying the cost of a useless data transport back and forth between the server and the client.

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/perl -w
# retrieve-seq_client_soap-wsdl.pl - Client retrieve-seq using the SOAP::WSDL module

################################################################
##
## This script runs a simple demo of the web service interface to the
## RSAT tool retrieve-seq. It sends a request to the server for
## obtaining the start codons of 3 E.coli genes.
##
################################################################

use strict;
use SOAP::WSDL;

warn "\nThis demo script retrieves the start codons for a set of query genes\n\n";

## WSDL location
my $server = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/';
my $WSDL = $server.'RSATWS.wsdl';
my $proxy = $server.'RSATWS.cgi';

## Service call
my $soap=SOAP::WSDL->new(wsdl => $WSDL)->proxy($proxy);
$soap->wsdlinit;

# $soap->wsdl_checkoccurs(0);

## Output option
my $output_choice = 'both';  ## Accepted values: 'server', 'client', 'both'

## Retrieve-seq parameters
my $organism = 'Escherichia_coli_K12';  ## Name of the query organism
my @gene = ("metA", "metB", "metC");  ## List of query genes
my $all = '';  ## the -all option. This option is incompatible with the query list @gene (above)
my $noorf = 'noorf';  ## Clip sequences to avoid upstream ORFs
my $from = 0;  ## Start position of the sequence
my $to = 2;  ## End position of the sequence
my $feattype = '';  ## The -feattype option value is  not specified, the default is used
my $type = '';  ## The -type option value; other example:'-type downstream'
my $format = '';  ## The -format option value. We use the default (fasta), but other formats could be specified, for example 'multi'
my $lw = 0;  ## Line width. 0 means all on one line
my $label = 'id,name';  ## Choice of label for the retrieved sequence(s)
my $label_sep = '';  ## Choice of separator for the label(s) of the retrieved sequence(s)
my $nocom = '';  ## Other possible value = '-nocom', to get sequence(s) whithout comments
my $repeat =  '';  ## Other possible value = '-rm', to have annotated repeat regions masked
my $imp_pos = '';  ## Admit imprecise position (value = 'imp_pos' to do so)

my %args = (
	    'output' => $output_choice,
	    'organism' => $organism,
	    'query' => \@gene,  ## An array in a hash has to be referenced
	    'noorf' => $noorf,
	    'from' => $from,
	    'to' => $to,
	    'feattype' => $feattype,
	    'type' => $type,
	    'format' => $format,
	    'lw' => $lw,
	    'label' => $label,
	    'label_sep' => $label_sep,
	    'nocom' => $nocom,
	    'repeat' => $repeat,
	    'imp_pos' => $imp_pos
	    );

## Send the request to the server
print "Sending request to the server\n";
my $som = $soap->call('retrieve_seq' => 'request' => \%args);

## Get the result
if ($som->fault){ ## Report error if any
    printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
    my $results_ref = $som->result;  ## A reference to the result hash table
    my %results = %$results_ref;  ## Dereference the result hash table

    ## Report the remote command
    my $command = $results{'command'};
    print "Command used on the server: ".$command, "\n";

    ## Report the result
    if ($output_choice eq 'server') {
	my $server_file = $results{'server'};
	print "Result file on the server: ".$server_file;
    } elsif ($output_choice eq 'client') {
	my $result = $results{'client'};
	print "Retrieved sequence(s): \n".$result;
    } elsif ($output_choice eq 'both') {
	my $server_file = $results{'server'};
	my $result = $results{'client'};
	print "Result file on the server: ".$server_file;
	print "Retrieved sequence(s): \n".$result;
    }
}
\end{verbatim}
\end{footnotesize}

\subsection{Work flow using RSATWS}

The following example is the script of a typical workflow of RSA Tools
programs. First, the upstream sequences of five Saccharomyces
cerevisiae genes are retrieved with \program{retrieve-seq}. Then,
\program{purge-sequence} is applyed to remove any redundancy in the
set of sequences. Finally, \program{oligo-analysis} is applied to
discover over-represented six letters words. The result of step 1 and
2 are stored on the server, so that the file name can be sent to the
following step as input and only the final result needs to be
transported from the server to the client.

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/perl -w
# retrieve_purge_oligos_client_wsdl.pl - Client retrieve-seq + oligo-analysis

################################################################
##
## This script runs a simple demo of the web service interface to the
## RSAT tools retrieve-seq, purge-sequence and oligo-analysis linked in a workflow.
##  It sends a request to the server for discovering 6 letter words
## in upstream sequences of 5 yeast genes. The sequences are first
## retrieved and purged for repeated segments
##
################################################################

use strict;
use SOAP::WSDL;

warn "\nThis demo script illustrates a work flow combining three requests to the RSAT web services:\n\tretrieve-seq | purge-sequence | oligo-analysis\n\n";


## Service location
my $server = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services';
my $WSDL = $server.'/RSATWS.wsdl';
my $proxy = $server.'/RSATWS.cgi';

## Service call
my $soap=SOAP::WSDL->new(wsdl => $WSDL)->proxy($proxy);
$soap->wsdlinit;

#################################################
## Retrieve-seq part

## Output option
my $output_choice = 'server'; ## The result will stay in a file on the server

## Parameters
my $organism = 'Saccharomyces_cerevisiae';  ## Name of the query organism
my @gene = ("PHO5", "PHO8", "PHO11", "PHO81", "PHO84");  ## List of query genes
my $all = '';  ## -all option. This option is incompatible with the query list @gene (above)
my $noorf = 'noorf';  ## Clip sequences to avoid upstream ORFs
my $from;  ## Start position of the sequence. Default is used (-800).
my $to;  ## End position of te sequence. Default is used (-1).
my $feattype = '';  ## -feattype option value is not defined, default is used (CDS).
my $type = '';  ## -type option value; other example:'-type downstream'
my $format = 'fasta';  ## the format of the retrieved sequence(s)
my $label = '';  ## Choice of label for the retrieved sequence(s). Default is used.
my $label_sep = '';  ## Choice of separator for the label(s) of the retrieved sequence(s). Default is used.
my $nocom = '';  ## Other possible value = '-nocom'.

my %args = ('output' => $output_choice,
    'organism' => $organism,
    'query' => \@gene,  ## An array in a hash has to be referenced
    'noorf' => $noorf,
    'from' => $from,
    'to' => $to,
    'feattype' => $feattype,
    'type' => $type,
    'format' => $format,
    'all' => $all,
    'label' => $label,
    'label_sep' => $label_sep,
    'nocom' => $nocom);

## Send request to the server
print "\nRetrieve-seq: sending request to the server\t", $server, "\n";
my $som = $soap->call('retrieve_seq' => 'request' => \%args);

## Get the result
my $server_file;  ## That variable needs to be declared outside the if..else block to be useable in the next part
if ($som->fault){  ## Report error if any
printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
my $results_ref = $som->result;  ## A reference to the result hash table
my %results = %$results_ref;  ## Dereference the result hash table

## Report the remote command
my $command = $results{'command'};
print "Command used on the server:\n\t".$command, "\n";

## Report the result file name on the server
$server_file = $results{'server'};
print "Result file on the server:\n\t".$server_file;
}

#################################################
## Purge-sequence part

## Define hash of parameters
%args = ('output' => $output_choice,  ## Same 'server' output option
 'tmp_infile' => $server_file);  ## Output from retrieve-seq part is used as input here

## Send the request to the server
print "\nPurge-sequence: sending request to the server\t", $server, "\n";
$som = $soap -> call('purge_seq' => 'request' => \%args);

## Get the result
if ($som->fault){  ## Report error if any
printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
my $results_ref = $som->result;  ## A reference to the result hash table
my %results = %$results_ref;  ## Dereference the result hash table

## Report the remote command
my $command = $results{'command'};
print "Command used on the server: \n\t".$command, "\n";

## Report the result file name on the server
$server_file = $results{'server'};
print "Result file on the server: \n\t".$server_file;
}
#################################################
## Oligo-analysis part

## Output option
$output_choice = 'both'; ## We want to get the result on the client side, as well as the server file name

## Parameters
my $format = 'fasta';  ## The format of input sequences
my $length = 6;  ## Length of patterns to be discovered
my $background = 'upstream-noorf';  ## Type of background used
my $stats = 'occ,proba,rank';  ## Returned statistics
my $noov = 'noov';  ## Do not allow overlapping patterns
my $str = '2str';  ## Search on both strands
my $sort = 'sort';  ## Sort the result according to score
my $lth = 'occ_sig 0';  ## Lower limit to score is 0, less significant patterns are not displayed

%args = ('output' => $output_choice, 
	 'tmp_infile' => $server_file, 
	 'format' => $format,
	 'length' => $length,
	 'organism' => $organism, 
	 'background' => $background,
	 'stats' => $stats,
	 'noov' => $noov,
	 'str' => $str,
	 'sort' => $sort,
	 'lth' => $lth);

## Send request to the server
print "\nOligo-analysis: sending request to the server\t", $server, "\n";
$som = $soap->call('oligo_analysis' => 'request' => \%args);

## Get the result
if ($som->fault){  ## Report error if any
    printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
    my $results_ref = $som->result;
    my %results = %$results_ref;
    
    ## Report remote commande
    my $command = $results{'command'};
    print "Command used on the server: ".$command, "\n";
    
    ## Report the result
    if ($output_choice eq 'server') {
	$server_file = $results{'server'};
	print "Result file on the server: \n\t".$server_file;
    } elsif ($output_choice eq 'client') {
	my $result = $results{'client'};
	print "Discovered oligo(s): \n".$result;
    } elsif ($output_choice eq 'both') {
	$server_file = $results{'server'};
	my $result = $results{'client'};
	print "Result file on the server: \n\t".$server_file;
	print "Discovered oligo(s): \n".$result;
    }
}
\end{verbatim}
\end{footnotesize}

\subsection{Discover patterns with RSATWS}

You can, of course, use directly the program \program{oligo-analysis}, providing your own sequences. In the following script, the upstream sequences of five yeast genes are sent as input to oligo-analysis. Overrepresented hexanucleotides are returned.

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/perl -w
# oligos_client_wsdl.pl - Client oligo-analysis using the SOAP::WSDL module

################################################################
##
## This script runs a simple demo of the web service interface to the
## RSAT tool oligo-analysis. It sends a request to the server for
## discovering 6 letter words in the upstream sequences of 5 yeast genes.
##
################################################################

use strict;
use SOAP::WSDL;


warn "\nINFO: This demo script sends a set of sequences to the RSAT web service, and runs oligo-analysis to detect over-represented oligonuclotides\n\n";

## WSDL location
my $WSDL = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.wsdl';
my $proxy = 'http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS.cgi';

my $soap=SOAP::WSDL->new(wsdl => $WSDL)->proxy($proxy);

$soap->wsdlinit;

## Output option
my $output_choice = 'both';  ## Accepted values: 'server', 'client', 'both'

## Oligo-analysis parameters
my $sequence = '>NP_009651.1    PHO5; upstream from -800 to -1; size: 800; location: NC_001134.7 430946 431745 R; upstream neighbour: NP_009652.1 (distance: 1084)
TTTTACACATCGGACTGATAAGTTACTACTGCACATTGGCATTAGCTAGGAGGGCATCCAAGTAATAATTGCGAGAAACGTGACCCAACTTTGTTGTAGGTCCGCTCCTTCTAATAATCGCTTGTATCTCTACATATGTTCTATTTACTGACCGAAAGTAGCTCGCTACAATAATAATGTTGACCTGATGTCAGTCCCCACGCTAATAGCGGCGTGTCGCACGCTCTCTTTACAGGACGCCGGAGACCGGCATTACAAGGATCCGAAAGTTGTATTCAACAAGAATGCGCAAATATGTCAACGTATTTGGAAGTCATCTTATGTGCGCTGCTTTAATGTTTTCTCATGTAAGCGGACGTCGTCTATAAACTTCAAACGAAGGTAAAAGGTTCATAGCGCTTTTTCTTTGTCTGCACAAAGAAATATATATTAAATTAGCACGTTTTCGCATAGAACGCAACTGCACAATGCCAAAAAAAGTAAAAGTGATTAAAAGAGTTAATTGAATAGGCAATCTCTAAATGAATCGATACAACCTTGGCACTCACACGTGGGACTAGCACAGACTAAATTTATGATTCTGGTCCCTGTTTTCGAAGAGATCGCACATGCCAAATTATCAAATTGGTCACCTTACTTGGCAAGGCATATACCCATTTGGGATAAGGGTAAACATCTTTGAATTGTCGAAATGAAACGTATATAAGCGCTGATGTTTTGCTAAGTCGAGGTTAGTATGGCTTCATCTCTCATGAGAATAAGAACAACAACAAATAGAGCAAGCAAATTCGAGATTACCA
>NP_010769.1    PHO8; upstream from -180 to -1; size: 180; location: NC_001136.8 1420243 1420422 R; upstream neighbour: NP_010770.1 (distance: 180)
CAGCATTGACGATAGCGATAAGCTTCGCGCGTAGAGGAAAAGTAAAGGGATTTTAGTATATAAAGAAAGAAGTGTATCTAAACGTTTATATTTTTTCGTGCTCCACATTTTGCCAGCAAGTGGCTACATAAACATTTACATATCAGCATACGGGACATTATTTGAACGCGCATTAGCAGC
>NP_009434.1    PHO11; upstream from -800 to -1; size: 800; location: NC_001133.6 224651 225450 D; upstream neighbour: NP_009431.1 (distance: 2568)
GCAGCCTCTACCATGTTGCAAGTGCGAACCATACTGTGGCCACATAGATTACAAAAAAAGTCCAGGATATCTTGCAAACCTAGCTTGTTTTGTAAACGACATTGAAAAAAGCGTATTAAGGTGAAACAATCAAGATTATCTATGCCGATGAAAAATGAAAGGTATGATTTCTGCCACAAATATATAGTAGTTATTTTATACATCAAGATGAGAAAATAAAGGGATTTTTTCGTTCTTTTATCATTTTCTCTTTCTCACTTCCGACTACTTCTTATATCTACTTTCATCGTTTCATTCATCGTGGGTGTCTAATAAAGTTTTAATGACAGAGATAACCTTGATAAGCTTTTTCTTATACGCTGTGTCACGTATTTATTAAATTACCACGTTTTCGCATAACATTCTGTAGTTCATGTGTACTAAAAAAAAAAAAAAAAAAGAAATAGGAAGGAAAGAGTAAAAAGTTAATAGAAAACAGAACACATCCCTAAACGAAGCCGCACAATCTTGGCGTTCACACGTGGGTTTAAAAAGGCAAATTACACAGAATTTCAGACCCTGTTTACCGGAGAGATTCCATATTCCGCACGTCACATTGCCAAATTGGTCATCTCACCAGATATGTTATACCCGTTTTGGAATGAGCATAAACAGCGTCGAATTGCCAAGTAAAACGTATATAAGCTCTTACATTTCGATAGATTCAAGCTCAGTTTCGCCTTGGTTGTAAAGTAGGAAGAAGAAGAAGAAGAAGAGGAACAACAACAGCAAAGAGAGCAAGAACATCATCAGAAATACCA
>NP_011749.1    PHO81; upstream from -800 to -1; size: 800; location: NC_001139.7 958214 959013 R; upstream neighbour: NP_011750.1 (distance: 1694)
AAACGAGCATGAGGGTTACAAAGAACTTCCGTTTCAAAAATGAATATAATCGTACGTTTACCTTGTGGCAGCACTAGCTAACGCTACGTGGAATGAACGTACCGTGCCCTATTATTCTTGCTTGTGCTATCTCAAGAATTGCATTTTGTAATAACAACTGCATGGGAAAAATTATATAGATTTTCTACTATTATGTCCGCCTAAGTCAGTTAACCATCTTTATCACAAAATATACAATTAACCAACTACTTAATCAATTCGGTTATATTGCTTAGTATATACGTCTTTGGCACGCGATTGAAACGCGCTAATTGCATCAGCCTATCTTTCTATGCAAGAATGCAAGAAAAATTGATGTGATGTGCCTTATCACAATTCATTACCTCCTATTTCCTCTGCAGCAACAAGTTTCCTTGATTATAAAGGTCTTTAGCGTGAGAGGTACAGGTGTTATGGCACGTGCGAATAAGGGCAGAAATTAATCAAATTTATCAACTATTTGGCGATGGCTCGAGACAGGTATAGAACCACTACTAGGTGATATTGAGGCTTTTGTACAATTTATAGCAAGTTTTTGAGAGTCCCTTCAAGTTTGTTACATAATCTTCTTTGTGCAACGTACAAGAGCAAAGTAGAAAAATTTGGTTTTTATTTTTTTAAGCAACATCAGCTGCACTAGTTGAGCTTTTGACAAGACATACTGCTCAAAAAATCTTCATAACATTATTTTTCGGTTCCACAGTGATTGAGCTTTTTGAGAGAATAACCCTTTGGAGGCAACATAGATAGATAAACGTGCA
>NP_013583.1    PHO84; upstream from -800 to -1; size: 800; location: NC_001145.2 25802 26601 R; upstream neighbour: NP_013585.1 (distance: 1128)
AAAAAAAAAGATTCAATAAAAAAAGAAATGAGATCAAAAAAAAAAAAAATTAAAAAAAAAAAGAAACTAATTTATCAGCCGCTCGTTTATCAACCGTTATTACCAAATTATGAATAAAAAAACCATATTATTATGAAAAGACACAACCGGAAGGGGAGATCACAGACCTTGACCAAGAAAACATGCCAAGAAATGACAGCAATCAGTATTACGCACGTTGGTGCTGTTATAGGCGCCCTATACGTGCAGCATTTGCTCGTAAGGGCCCTTTCAACTCATCTAGCGGCTATGAAGAAAATGTTGCCCGGCTGAAAAACACCCGTTCCTCTCACTGCCGCACCGCCCGATGCCAATTTAATAGTTCCACGTGGACGTGTTATTTCCAGCACGTGGGGCGGAAATTAGCGACGGCAATTGATTATGGTTCGCCGCAGTCCATCGAAATCAGTGAGATCGGTGCAGTTATGCACCAAATGTCGTGTGAAAGGCTTTCCTTATCCCTCTTCTCCCGTTTTGCCTGCTTATTAGCTAGATTAAAAACGTGCGTATTACTCATTAATTAACCGACCTCATCTATGAGCTAATTATTATTCCTTTTTGGCAGCATGATGCAACCACATTGCACACCGGTAATGCCAACTTAGATCCACTTACTATTGTGGCTCGTATACGTATATATATAAGCTCATCCTCATCTCTTGTATAAAGTAAAGTTCTAAGTTCACTTCTAAATTTTATCTTTCCTCATCTCGTAGATCACCAGGGCACACAACAAACAAAACTCCACGAATACAATCCAA';

my $format = 'fasta';  ## The format of input sequences
my $length = 6;  ## Length of patterns to be discovered
my $organism = 'Saccharomyces_cerevisiae';  ## Name of the query organism
my $background = 'upstream-noorf';  ## Type of background used
my $stats = 'occ,proba,rank';  ## Returned statistics
my $noov = 'noov';  ## Do not allow overlapping patterns
my $str = '2str';  ## Search on both strands
my $sort = 'sort';  ## Sort the result according to score
my $lth = 'occ_sig 0';  ## Lower limit to score is 0, less significant patterns are not displayed

my %args = ('output' => $output_choice, 
	    'sequence' => $sequence, 
	    'format' => $format,
	    'length' => $length,
	    'organism' => $organism, 
	    'background' => $background,
	    'stats' => $stats,
	    'noov' => $noov,
	    'str' => $str,
	    'sort' => $sort,
	    'lth' => $lth);

## Send request to the server
print "Sending request to the server\n";
my $som = $soap->call('oligo_analysis' => 'request' => \%args);

## Get the result
if ($som->fault){  ## Report error if any
    printf "A fault (%s) occured: %s\n", $som->faultcode, $som->faultstring;
} else {
    my $results_ref = $som->result;  ## A reference to the result hash table
    my %results = %$results_ref;  ## Dereference the result hash table

    ##Report the remote command
    my $command = $results{'command'};
    print "Command used on the server: ".$command, "\n";

    ## Report the result
    if ($output_choice eq 'server') {
	my $server_file = $results{'server'};
	print "Result file on the server: ".$server_file;
    } elsif ($output_choice eq 'client') {
	my $result = $results{'client'};
	print "Discovered oligo(s): \n".$result;
    } elsif ($output_choice eq 'both') {
	my $server_file = $results{'server'};
	my $result = $results{'client'};
	print "Result file on the server: ".$server_file;
	print "Discovered oligo(s): \n".$result;
    }
}
\end{verbatim}
\end{footnotesize}

\section{Examples of WS client in java}

To do...

\section{Full documentation of the RSATWS interface}

The full documentation can be found there:

http://rsat.scmbb.ulb.ac.be/rsat/web_services/RSATWS_documentation.pdf

Please refer to the documentation of each RSAT application for further detail on each program.
