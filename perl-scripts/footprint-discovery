#!/usr/bin/perl -w
############################################################
#
# $Id: footprint-discovery,v 1.17 2008/01/08 22:36:57 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

footprint-discovery

=head1 VERSION

$program_version

=head1 DESCRIPTION

Detect phylogenetic footprints by applying dyad-analysis in promoters
of a set of orthologous genes.

Adapted from the procedure described in Janky & van Helden (2008).

=head1 AUTHORS

=over

=item rekins@scmbb.ulb.ac.be

=item jacques.van.helden@ulb.ac.be

=back

=head1 CATEGORY

Sequences

Pattern discovery

=head1 USAGE

footprint-discovery [-i inputfile] -o [output_prefix] \
     -taxon \
     -q query_gene [-q query_gene2 ...] \
     [-v #] [...]

=head1 INPUT FORMAT

The program takes as input a taxon of interest + one or several query
genes.

=head1 OUTPUT FORMAT

The output consists in a set of files, containing the results of the
different steps of the analysis.

=over

=item [prefix]_log.txt

Log file listing the analysis parameters + output file names;

=item [prefix]_query_genes.tab

List of query genes (one or several genes can be entered)

=item [prefix]_ortho_bbh.tab

List of orthologous genes

=item [prefix]_ortho_seq.fasta

Promoter sequences of the orthologous genes

=item [prefix]_ortho_seq_purged.fasta

Purged promoter sequences (for pattern discovery)
=item [prefix]_ortho_filter_dyads.tab

Dyads found in the query genes (for dyad filtering)

=item [prefix]_ortho_dyads.tab

Significant dyads found in the promoters of orthologous genes
(the footprints)

=item [prefix]_ortho_dyads.asmb

Assembled dyads

=item [prefix]_ortho_dyads.png

Feature-map

=item NOTE : 'ortho' is replaced by 'leaders' in the filename prefix with option -infer_operons

=back

=head1 REFERENCES

Janky R, van Helden J (2008). Evaluation of phylogenetic footprint
discovery for the prediction of bacterial cis-regulatory elements. BMC
Bioinformatics, in press.

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";



################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  my $start_time = &AlphaDate();
  $program_version = do { my @r = (q$Revision: 1.17 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  %main::infile = ();
  %main::outfile = ();


  local $infer_operons = 0;
  local $dyad_return_fields = "occ,proba,rank"; ## Default return fields for dyad-analysis
  local @dyad_return_fields = (); ## User-specified return fields for dyad-analysis
  local $create_index = 0;
  local $verbose = 0;
  local $in = STDIN;
  local $taxon;
  local $organism_name;
  local @query_genes = ();
  local $img_format = "png";
  local $strands = "-2str";
  local $noov = "-noov";
  local $filter = 1;
  local $dist_thr = 55;
  local $bg_model = "taxfreq";
  local %lth = (occ=>1,occ_sig=>0);
  local %uth = (rank=>50);

  ## Options for the &doit() command;
  local $dry = 0;
  local $batch = 0;
  local $die_on_error = 1;
  local $job_prefix = "footprint_disco";
  local $cmd;

  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values

  ## Check taxon
  &RSAT::error::FatalError("You must specify a taxon (option -taxon)")
    unless ($taxon);
  my @organisms = &CheckTaxon($taxon);

  ## Check organism
  &RSAT::error::FatalError("You must specify a organism (option -org)")
    unless ($organism_name);
  $organism = new RSAT::organism();
  $organism->check_name($organism_name);
  $organism->set_attribute("name", $organism_name);

  ################################################################
  ## Read query genes from input file
  if ($infile{input}) {
    ($in) = &OpenInputFile($infile{input});
    while (<$in>) {
      next if (/^;/);
      next if (/^#/);
      next unless (/\S/);
      chomp;
      my @fields = split /\s+/;
      my $query = shift @fields;
      push @query_genes, $query;
    }
    close $in;
  }

  ################################################################
  ## Define a query prefix for the title of the feature map and for
  ## automatic output file specification
  my $query_prefix;
  if (scalar(@query_genes) == 1) {
    $query_prefix = $query_genes[0];
  } elsif (scalar(@query_genes) <= 10) {
    $query_prefix = join "_", @query_genes;
  } elsif ($outfile{prefix}) {
    $query_prefix = `basename $outfile{prefix}`;
    chomp($query_prefix);
  } elsif ($infile{input}) {
    $query_prefix = `basename $infile{input} .tab`;
  }
  &RSAT::message::Warning("Query prefix", $query_prefix) if ($main::verbose >= 2);

  ## Output prefix is mandatory
  ## If not specified by the user, define it automatically
  unless ($outfile{prefix}) {
    if ($query_prefix) {
      $outfile{prefix} = join "/", "footprints", $taxon, $organism_name, $query_prefix, $query_prefix."_".$organism_name."_".$taxon;
      &RSAT::message::Warning("Automatic definition of the output prefix", $outfile{prefix});
    } else {
      &RSAT::error::FatalError("You must define a prefix for the output files with the option -o");
    }
  }

  ## Create output directory if required
  $dir{output} = `dirname $outfile{prefix}`;
  chomp($dir{output});
  &RSAT::util::CheckOutDir($dir{output});

  ## Open output stream for the log file
  $outfile{log} = $outfile{prefix}."_log.txt";
  $out = &OpenOutputFile($outfile{log});

  ## File for storing query gene names
  $outfile{genes} = $outfile{prefix}."_query_genes.tab";
  $genes = &OpenOutputFile($outfile{genes});

  ## Specity other file names
  $outfile{orthologs} = $outfile{prefix}."_ortho_bbh.tab";
  $outfile{query_seq} = $outfile{prefix}."_query_seq.fasta";
  $outfile{filter_dyads} = $outfile{prefix}."_filter_dyads.tab";
  if ($infer_operons){
    $promoter = "leaders";
  }else{
    $promoter = "ortho"; 
  }
  $outfile{bbh} = $outfile{prefix}."_".$promoter."_bbh.tab";
  $outfile{seq} = $outfile{prefix}."_".$promoter."_seq.fasta";
  $outfile{purged} = $outfile{prefix}."_".$promoter."_seq_purged.fasta";
  $outfile{dyad_prefix} = $outfile{prefix}."_".$promoter."_dyads_3nt_sp0-20".$strands.$noov."_".$bg_model."_sig".$lth{occ_sig};
  $outfile{dyads} = $outfile{dyad_prefix}.".tab";
  $outfile{dyads_html} = $outfile{dyad_prefix}.".html";
  $outfile{asmb} = $outfile{dyad_prefix}.".asmb";
  $outfile{map} = $outfile{dyad_prefix}.".".${img_format};

  ## HTML index
  if ($create_index) {
    $outfile{index} = $outfile{prefix}."_index.html";
    $index = &OpenOutputFile($outfile{index});
    print $index "<html>\n";
    print $index "<body>\n";
    print $index "<hr size=4 color='#000088'>";
    print $index "<h1 align=center>Footprint discovery result</h1>";
    print $index "<hr size=2 color='#000088'>";
    print $index "<blockquote>";
    print $index "<table cellspacing=0 cellpadding=3 border=0>\n";
    &IndexOneFile("log", $outfile{log});
    &IndexOneFile("input", $infile{input}) if ($infile{input});
  }


  ## Background model file
  if ($bg_model eq "taxfreq") {
    $infile{bg_model} = &ExpectedFreqFile($taxon,
					  3,
					  # spacing ? 0-20
					  "upstream-noorf",
					  str=>$strands,
					  noov=>$noov,
					  type=>"dyad",
					  warn=>1,
					  taxon=>1);
  }


  ################################################################
  ## Return fields for dyad-analysis
  if (scalar(@dyad_return_fields) > 0) {
    $dyad_return_fields = join ",", @dyad_return_fields;
  }

  ################################################################
  ## Check query genes
  if (scalar(@query_genes) ==0) {
    &RSAT::error::FatalError("You must specify at least one query gene (options -q or -i)");
  }
  ## Print query genes in the gene file
  foreach my $gene (@query_genes) {
    print $genes $gene, "\t", $organism_name, "\n";
  }
  &IndexOneFile("genes", $outfile{genes}) if ($create_index);

  ################################################################
  ## Print verbose
  &Verbose() if ($verbose);

  ################################################################
  ## Retrieve promoters of the query organism
  &RSAT::message::TimeWarn("Retrieving promoter sequences for query genes", $outfile{query_seq}) if ($verbose >= 1);
  $cmd = "$SCRIPTS/retrieve-seq ";
  $cmd .= " -org ".$organism_name;
  $cmd .= " -i ".$outfile{genes};
  $cmd .= " -o ".$outfile{query_seq};
  print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  &IndexOneFile("query sequence", $outfile{query_seq}) if ($create_index);

  ################################################################
  ## Detect all dyads in promoters of query genes for dyad filtering
  if (!$nofilter){
    &RSAT::message::TimeWarn("Computing filter dyads", $outfile{filter_dyads}) if ($verbose >= 1);
    $cmd = "$SCRIPTS/dyad-analysis -v 1 -return occ -lth occ 1";
    $cmd .= " -i ".$outfile{query_seq};
    $cmd .= " -l 3 -sp 0-20";
    $cmd .= " ".$strands;
    $cmd .= " ".$noov;
    $cmd .= " -o ".$outfile{filter_dyads};
    print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
    &IndexOneFile("filter dyads", $outfile{filter_dyads}) if ($create_index);
  }

  ################################################################
  ## get orthologs
  &RSAT::message::TimeWarn("Getting orthologs", $outfile{orthologs}) if ($verbose >= 1);
  $cmd = "$SCRIPTS/get-orthologs";
  $cmd .= " -i ".$outfile{genes};
  $cmd .= " -org ".$organism_name;
  $cmd .= " -taxon ".$taxon;
  $cmd .= " -uth rank 1";	## BBH criterion
  $cmd .= " -o ".$outfile{orthologs};
  print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  &IndexOneFile("orthologs", $outfile{orthologs}) if ($create_index);


  ################################################################
  ## Get predicted leader genes
  if ($infer_operons) {
    &RSAT::message::TimeWarn("Get leaders of query genes (d<=".$dist_thr."bp)", $outfile{bbh}) if ($verbose >= 1);
    $cmd = "$SCRIPTS/get-leader-multigenome ";
    $cmd .= " -i ".$outfile{orthologs};
    $cmd .= " -o ".$outfile{bbh};
    $cmd .= " -uth interg_dist ".$dist_thr;
    print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
    &IndexOneFile("leader genes", $outfile{bbh}) if ($create_index);
  }

  ################################################################
  ## Retrieve sequences from orthologs
  &RSAT::message::TimeWarn("Retrieving promoter sequences of orthologs", $outfile{seq}) if ($verbose >= 1);
  $cmd = "$SCRIPTS/retrieve-seq-multigenome -ids_only";
  $cmd .= " -i ".$outfile{bbh};
  $cmd .= " -noorf";
  $cmd .= " -o ".$outfile{seq};
  print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  &IndexOneFile("$promoter sequences", $outfile{seq}) if ($create_index);

  ################################################################
  ## Purge sequences
  &RSAT::message::TimeWarn("Purging promoter sequences of orthologs", $outfile{purged}) if ($verbose >= 1);
  $cmd = "$SCRIPTS/purge-sequence";
  $cmd .= " -i ".$outfile{seq};
  $cmd .= " -ml 30 -mis 0 -mask_short 30";
  $cmd .= " ".$strands;
  $cmd .= " -o ".$outfile{purged};
  print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  &IndexOneFile("purged sequences", $outfile{purged}) if ($create_index);

  ################################################################
  ## Discover over-represented dyads in promoters of orthologous genes
  &RSAT::message::TimeWarn("Detecting phylogenetic footprints", $outfile{dyads}) if ($verbose >= 1);
  $cmd = "$SCRIPTS/dyad-analysis -v 1 ";
  $cmd .= " -return ".$dyad_return_fields;
  if ($bg_model eq "taxfreq"){
    $cmd .= " -expfreq ".$infile{bg_model} ;
  } elsif ($bg_model eq "monad") {
    $cmd .= " -bg monads" ;
  }
  if (!$nofilter){
    $cmd .= " -accept ".$outfile{filter_dyads};
  }
  foreach my $field (sort keys %lth) {
    $cmd .= " -lth ".$field." ".$lth{$field};
  }
  foreach my $field (sort keys %uth) {
    $cmd .= " -uth ".$field." ".$uth{$field};
  }
  $cmd .= " -i ".$outfile{purged};
  $cmd .= " -l 3 -sp 0-20";
  $cmd .= " ".$strands;
  $cmd .= " ".$noov;
  $cmd .= " -sort";
  $cmd .= " -o ".$outfile{dyads};
  print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  &IndexOneFile("dyads", $outfile{dyads}) if ($create_index);

  ## Generate a HTML table with the discovered dyads
  $cmd = "$SCRIPTS/text-to-html";
  $cmd .= " -i ".$outfile{dyads};
  $cmd .= " -font variable -chunk 1000";
  $cmd .= " -o ".$outfile{dyads_html};
  print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  &IndexOneFile("dyads [htm]", $outfile{dyads_html}) if ($create_index);

  ################################################################
  ## Assemble significant dyads
  &RSAT::message::TimeWarn("Assembling significant dyads", $outfile{asmb}) if ($verbose >= 1);
  $cmd = "$SCRIPTS/pattern-assembly -v 1";
  $cmd .= " -i ".$outfile{dyads};
  $cmd .= " -subst 0 -maxfl 1 -toppat 50";
  $cmd .= " -o ".$outfile{asmb};
  print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  &IndexOneFile("assembled dyads", $outfile{asmb}) if ($create_index);

  ################################################################
  ## Generate a feature-map of the discovered dyads
  my $map_title = join "; ", $taxon, $organism_name, $query_prefix;
  &RSAT::message::TimeWarn("Generating feature map", $outfile{map}) if ($verbose >= 1);
  $cmd = "$SCRIPTS/dna-pattern -return limits,sites -origin -0 -N 4";
  $cmd .= " -pl ".$outfile{dyads};
  $cmd .= " -format fasta -i ".$outfile{seq};
  $cmd .= " | $SCRIPTS/convert-features -from dnapat -to ft";
  $cmd .= " | $SCRIPTS/feature-map";
  $cmd .= " -title '".$map_title."'";
  $cmd .= " -format ".$img_format;
  $cmd .= " -scalebar -legend";
  $cmd .= " -scorethick";
  $cmd .= " -o ".$outfile{map};
  print $out "\n", &AlphaDate(), "\n", $cmd, "\n\n"; &doit($cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  &IndexOneFile("feature map", $outfile{map}, image=>1) if ($create_index);

  ################################################################
  ## Finish verbose
  if ($verbose >= 1) {
    my $done_time = &AlphaDate();
    print $out "; Job started $start_time\n";
    print $out "; Job done    $done_time\n";
  }

  ################################################################
  ## Close output stream
  close $out if ($outfile{log});
  close $genes if ($outfile{genes});
  if ($create_index) {
    print $index "</table>\n";
    print $index "</blockquote>";
    print $index "<hr size=2 color='#000088'>";
    print $index "</body>";
    print $index "</html>";
    close $index;
  }


  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Add one file to the index file
sub IndexOneFile {
  my ($name, $file, %args) = @_;
  $short_file = `basename $file`;
  print $index "<tr valign=top>\n";
  print $index "<td>", $name, "</td>\n<td><a href=".$short_file.">".$short_file."</a></td>\n";
  if ($args{image}) {
#    print $index "<td><a href=".$short_file."><img width=100 src=".$short_file."></a></td>\n";
    print $index "</tr><tr><td colspan=\"2\">(Click on image below)</td></tr><tr><td colspan=\"2\"><a href=".$short_file."><img width=\"100%\" src=".$short_file."></a></td>\n";
  }
  print $index ("</tr>\n\n");
}

################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
  if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Dry run
=pod

=item B<-dry>

Dry run: print the commands but do not execute them.

=cut
	} elsif ($arg eq "-dry") {
	    $main::dry = 1;;

	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);

	    ## Output prefix
=pod

=item	B<-o output_prefix>

Prefix for the output files.

If the prefix is not specified, the program can guess a default
prefix, but this is working only if there is a single query gene or
query file.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{prefix} = shift(@arguments);

	    ## Query gene
=pod

=item	B<-q query>

Query gene.

This option can be used iteratively on the command line to specify
multiple genes.

=cut
	} elsif ($arg eq "-q") {
	  push @main::query_genes, shift(@arguments);


	    ## Organism
=pod

=item	B<-org query_organism>

Query organism, to which the query genes belong.

=cut
	} elsif ($arg eq "-org") {
	  $main::organism_name = shift(@arguments);

	    ## Taxon
=pod

=item	B<-taxon reference_taxon>

Reference taxon, in which orthologous genes have to be collected.

=cut
	} elsif ($arg eq "-taxon") {
	  $main::taxon = shift(@arguments);



         ## Create HTML Index
=pod

=item B<-index>

Generate an HTML index with links to the result files. This option is
used for the web interface, but can also be convenient to index
results, especially when several genes or taxa are analyzed (options
-genes, -all_genes, -all_taxa).

=cut

	} elsif ($arg eq "-index") {
	  $main::create_index = 1;

	    ### Lower threshold
=pod

=item B<-lth field value>

Lower threshold for dyad-analysis.

See the manual of dyad-analysis for a description of the fields on
which a threshold can be imposed.

=cut
	} elsif ($arg eq "-lth") {
	    my $thr_field = shift (@arguments);
	    my $thr_value =  shift (@arguments);
	    $main::lth{$thr_field} = $thr_value;

	    ### Upper threshold
=pod

=item B<-uth field value>

Upper threshold for dyad-analysis.

See the manual of dyad-analysis for a description of the fields on
which a threshold can be imposed.

=cut
	} elsif ($arg eq "-uth") {
	  my $thr_field = shift (@arguments);
	  my $thr_value =  shift (@arguments);
	  $main::uth{$thr_field} = $thr_value;

	  ## Return fields for dyad-analysis
=pod

=item B<-return dyad_return_fields>

Return fields for dyad-analysis.  This argument is passed to
dyad-analysis for the discovery of dyads in promoters of orthologous
genes.

Multiple-fields can be entered either by calling this argument
iterativelyk or by entering multiple fields separated by commas.

Type I<dyad-analysis -help> to obtain the list of supported return
fields.

=cut
	} elsif ($arg eq "-return") {
	  push @dyad_return_fields, shift (@arguments);

	    ## Background model

=pod

=item B<-bg_model taxfreq|monad>

Allow the user to choose among alternative background model (see Janky
& van Helden, 2008).

=over

=item I<taxfreq>

Taxon-wide background model, computed by counting dyad frequencies in
all the promoters of all the genes of the reference taxon.

=item I<monad>

Expected dyad frequencies are the product of monad frequencies
observed in the input sequences.

=back

=cut
	} elsif ($arg eq "-bg_model") {
	  $main::bg_model = shift(@arguments);

	  ## Dyads filtering

=pod

=item B<-filter>

Only accept dyads found in the promoter of the query gene, in the
query organism. (option selected by default)

=cut

	} elsif ($arg eq "-filter") {
	  $main::filter = 1;

=pod

=item B<-no_filter>

Accept all dyads, even if they are not found in the promoter of the
query gene, in the query organism. (will cancel -filter option if selected)

=cut

	} elsif ($arg eq "-no_filter") {
	  $main::nofilter = 1;
	  
	  ## infer operons

=pod

=item B<-infer_operons>

Infer operons in order to retrieve the promoters of the predicted
operon leader genes rather than those located immediately upstream of
the orthologs. This method uses a threshold on the intergenic distance.

=cut

	} elsif ($arg eq "-infer_operons") {
	  $main::infer_operons = 1;

=pod

=item B<-dist_thr value> 

Specify here the intergenic distance threshold in base pairs. Pair of adjacent genes with intergenic distance equal or less than this value are predicted to be within operon. (default : 55)

=cut

	} elsif ($arg eq "-dist_thr") {
	  $main::dist_thr = shift(@arguments);

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
  my $header_verbose = "";
  $header_verbose .=  "; footprint-discovery ";
  $header_verbose .= &PrintArguments();
  $header_verbose .= "\n";
  $header_verbose .= sprintf "; %-22s\t%s\n", "Program version", $program_version;
  $header_verbose .= sprintf "; %-22s\t%s", "Working directory", `pwd`;
  $header_verbose .= sprintf "; %-22s\t%s\n", "Query organism", $organism_name;
  $header_verbose .= sprintf "; %-22s\t%s\n", "Reference taxon", $taxon;
  $header_verbose .= sprintf "; %s\n", "Promoters from predicted operon leader genes" if ($infer_operons);
  if (scalar(@query_genes) == 1) {
    $header_verbose .= sprintf "; %-22s\t%s\n", "Query gene", $query_genes[0];
  } elsif (scalar(@query_genes) <= 10) {
    $header_verbose .= sprintf "; %-22s\t%s\n", "Query genes", join "; ", @query_genes;
  } else {
    $header_verbose .= sprintf "; %-22s\t%s\n", "Query genes", scalar(@query_genes);
  }
  $header_verbose .= sprintf "; %-22s\t%s\n", "Background model", $bg_model;
  $header_verbose .= sprintf "; %-22s\t%s\n", "Dyad filtering" if ($filter);

  if (defined(%main::infile)) {
    print $main::out "; Input files\n";
    while (my ($key,$value) = each %main::infile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }
  if (defined(%main::outfile)) {
    print $main::out "; Output files\n";
    while (my ($key,$value) = each %main::outfile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }
  print $out $header_verbose;


  if ($main::create_index) {
    $header_verbose =~ s/^; //;
    $header_verbose =~ s/\n; /\n/gm;
    print $index "<pre>";
    print $index $header_verbose;
    print $index "</pre>";
  }
}


__END__

=pod

=head1 SEE ALSO

=over

=item get-orthologs

=item dyad-analysis

=back

=head1 WISH LIST


The following options are not yet implemented, but this should be done
soon.

=over

=item B<-taxa>

Specify a file containing a list of taxa, each of which will be
analyzed separately. The results are stored in a separate folder for
each taxon. The folder name is defined automatically.

=item B<-all_taxa>

Automatically analyze all the taxa, and store each result in a
separate folder (the folder name is defined automatically).

=item B<-genes>

Specify a file containing a list of genes, each of which will be
analyzed separately. The results are stored in a separate folder for
each gene. The folder name is defined automatically.

=item B<-all_genes>

Automatically analyze all the genes of a query genome, and store each
result in a separate folder (the folder name is defined
automatically).

=item B<-batch>

Generate one command per query gene, and post it on the queue of a PC
cluster.


=back

=cut
