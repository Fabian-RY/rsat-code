#!/usr/bin/perl -w
############################################################
#
# $Id: matrix-clustering,v 1.5 2013/02/19 05:35:16 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

cluster-matrices

=head1 VERSION

$program_version

=head1 DESCRIPTION

Taking as input a set of position-specific scoring matrices, identify
clusters of similar matrices and build consensus motifs by merging the
matrices that belong to the same cluster.

=head1 DEPENDENCIES

The clustering step relies on I<MCL>, the graph-based clustering
algorithm developed by Stijn Van Dongen. MCL must be installed and its
path indicated in the RSAT configuration file
($RSAT/RSAT_config.props). The installation of MCL can be done with a
RSAT makefile:

  cd $RSAT
  make -f makefiles/install_software.mk install_mcl

=head1 AUTHORS

=head2 Implementation

=item Jacques.van-Helden@univ-amu.fr

=item Jaime Castro <jcastro@lcg.unam.mx>

=head2 Conception

=item Jacques van Helden

=item Carl Herrmann

=item Denis Thieffry

=head1 CATEGORY

util

=head1 USAGE

cluster-matrices [-i inputfile] [-o outputfile] [-v #] [...]


=head1 OUTPUT FORMAT

=head1 SEE ALSO

=over

=item I<compare-matrices>

The program I<compare-matrices> is used by I<cluster-matrices> to
measure pairwise similarities and define the best alignment (offset,
strand) between each pair of matrices.

=head1 WISH LIST

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "RSA2.cgi.lib";
use RSAT::util;
use RSAT::matrix;
use RSAT::MatrixReader;

################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    local $start_time = &RSAT::util::StartScript();
    $program_version = do { my @r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
#    $program_version = "0.00";

    %main::infile = ();
    %main::outfile = ();
    %main::dir = ();
    @dirs = ();

    $main::verbose = 0;
#    $main::in = STDIN;
    $main::out = STDOUT;

    ## input formats: only accept formats supporting multiple matrices
    local @supported_matrix_formats = qw(transfac tf tab clusterbuster cb infogibbs meme stamp uniprobe);
    local %supported_matrix_format = ();
    foreach my $format (@supported_matrix_formats) {
     $supported_matrix_format{$format} = 1;
    }
    local $supported_matrix_formats = join ",", @supported_matrix_formats;

    ## Matrices
    local @matrices = ();
    local @temp = ();
    local $matrix_num = 0;


    ## Unrecognized arguments are passed to compare-matrices
    local @args_to_pass = ();
    local $args_to_pass = "";

    local $d3_base_url=$ENV{RSAT}."/public_html/lib/d3/";


    ################################################################
    ## Options used for motif comparison
    local %param = ();
    $param{matrix_compa_min_w} = 5; ## min number of aligned columns
    $param{matrix_compa_min_Wr} = 0.3; ## min relative width
    #$param{matrix_compa_min_cor} = 0.7; ## min correlation
    #$param{matrix_compa_min_Ncor} = 0.4; ## min normalizd correlation
    $param{matrix_compa_sort_field} = "Ncor"; ## sorting field
    $param{matrix_compa_metrics} = "cor,Ncor,logoDP,NIcor,NSW,match_rank";
    $param{matrix_compa_score} = "Ncor"; ## The score must be a similarity score for MCL

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values

    &RSAT::message::TimeWarn("Checking parameter values") if ($main::verbose >= 2);

    ## Non-recognized parameters are passed to compare-matrices
    if (scalar(@args_to_pass)) {
      $args_to_pass = join (" ", @args_to_pass);
      &RSAT::message::Info("Un-ecognized arguments passed to compare-matrices", $args_to_pass) if ($main::verbose >= 2);
    }


    ## Check that the  input file has been specified
    unless ($infile{matrices}) {
      &RSAT::error::FatalError("You must define the input file (option -i).");
    }

    ## Check that the  input format has been specified
    unless ($matrix_format) {
      &RSAT::error::FatalError("You must define the input matrix format (option -format).");
    }


    ## Check that the output prefix has been specified
    unless ($outfile{prefix}) {
      &RSAT::error::FatalError("You must define the output prefix (option -o).");
    }

    ## Create output dir if required
    my $basename;
    ($dir{output}, $basename) = &RSAT::util::SplitFileName($main::outfile{prefix});
    $dir{output} = "." if ($dir{output} eq "");
    &RSAT::util::CheckOutDir($dir{output});
    push @dirs, "output";

    ## Directory containing the matrix logos (to be displayed in the HTML tree)
    $dir{logos} = $main::outfile{prefix}."_pairwise_compa_logos"; push @dirs, "logos";

    ################################################################
    ## Specify output file names and open output stream
    $main::outfile{log} = $main::outfile{prefix}."_log.txt"; push @outfiles, "log";
    $main::outfile{Rlog} = $main::outfile{prefix}."_Rlog.txt"; push @outfiles, "Rlog";
    $main::out = &OpenOutputFile($main::outfile{log});


    ## Pairwise comparisons between matrices
    $main::outfile{pairwise_compa} = $main::outfile{prefix}."_pairwise_compa.tab"; push @outfiles, "pairwise_compa";
    $main::outfile{pairwise_compa_html} = $main::outfile{prefix}."_pairwise_compa.html";  push @outfiles, "pairwise_compa_html";


    ## Individual matrix descriptions
    $main::outfile{matrix_descriptions} = $main::outfile{prefix}."_pairwise_compa_matrix_descriptions.tab"; push @outfiles, "matrix_descriptions";

    ## Simliarity network between matrices
    if ($main::return_field{network}) {
      $main::outfile{matrix_network_gml} = $main::outfile{prefix}."_matrix_network.gml"; push @outfiles, "matrix_network_gml";
      $main::outfile{matrix_network_png} = $main::outfile{prefix}."_matrix_network.png"; push @outfiles, "matrix_network_png";
    }

    ## MCL clustering (by segmentation of the matrix network)
    if ($main::return_field{mcl_clusters}) {
      $main::outfile{clusters_mcl} = $main::outfile{prefix}."_clusters.mcl"; push @outfiles, "clusters_mcl";
      $main::outfile{clusters_tab} = $main::outfile{prefix}."_clusters.tab"; push @outfiles, "clusters_tab";
      $main::outfile{clusters_subgraph} = $main::outfile{prefix}."_clusters_subgraph.tab"; push @outfiles, "clusters_subgraph";
      $main::outfile{clusters_subgraph_gml} = $main::outfile{prefix}."_clusters_subgraph.gml"; push @outfiles, "clusters_subgraph_gml";
      $main::outfile{clusters_subgraph_png} = $main::outfile{prefix}."_clusters_subgraph.png"; push @outfiles, "clusters_subgraph_png";
      $main::outfile{intra_cluster_degree} = $main::outfile{prefix}."_intra_clusters_degree.tab"; push @outfiles, "intra_cluster_degree";
    }

    $main::outfile{matrix_tree_json} = $main::outfile{prefix}."_matrix_tree.json"; push @outfiles, "matrix_tree_json";
    $main::outfile{parsed_tree_json} = $main::outfile{prefix}."_parsed_tree.json"; push @outfiles, "parsed_tree_json";
#    $main::outfile{attr_json} = $main::outfile{prefix}."_matrix_descriptions.tab"; push @outfiles, "attr_json";
    $main::outfile{matrix_tree_html} = $main::outfile{prefix}."_matrix_tree.html"; push @outfiles, "matrix_tree_html";
    $main::outfile{temp} = $main::outfile{prefix}."_temporal.html";

    ## Open the HTML index file
    $main::outfile{html_index} = $main::outfile{prefix}."_index.html";
    push @outfiles, "html_index";
    $main::html_index = &OpenOutputFile($main::outfile{html_index});
    my $header = &PrintHtmlResultHeader(program=>"matrix-clustering", refresh_time=>120);
    #      &RSAT::message::Debug("header", $header) if ($main::verbose >= 10);
    print $main::html_index $header;

    ## Report command
    print $html_index "<p><tt><b>Command:</b> matrix-clustering ";
    &PrintArguments($main::html_index, 1);
    print $html_index "</tt></p>\n";


    ################################################################
    ## Read input matrices
    if ($infile{matrices}){
      @matrices = &RSAT::MatrixReader::readFromFile($infile{matrices}, $matrix_format);
      &RSAT::message::TimeWarn(scalar(@matrices), "Matrices loaded from file", $infile{matrices})
	if ($main::verbose >= 2);
    }

    ################################################################
    ## Cluster the matrices
    &CompareMatrices();

    ################################################################
    ## Cluster the matrices
    #&ClusterMotifs();
    &Hclustering();

    ################################################################
    ## Parse the JSON file
    &Add_attributes_to_JSON();

    ################################################################
    ## Creates the html template to display the tree
    &Create_html_tree_file();

    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);


    ################################################################
    ## Generate the HMTL index of input/output files
    &IndexFiles() if ($main::outfile{html_index});

    ################################################################
    ## Close output stream
    my $exec_time = &RSAT::util::ReportExecutionTime($start_time); print $main::out $exec_time if ($main::verbose >= 1);
    close $main::out if ($main::outfile{prefix});

  ## Close the HTML index file
  if ($main::outfile{html_index}) {
    print $main::html_index "<hr>";
    print $main::html_index "</body>";
    print $main::html_index "</html>";
    close $main::html_index;
  }

    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();


=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-i input matrix file>

The input file contains a set of position-specific scoring
matrices.

=cut
    } elsif ($arg eq "-i") {
      $main::infile{matrices} = shift(@arguments);

=pod

=item B<-format matrix_format>

Specify the input matrix format.


B<Supported matrix formats>

Since the program takes several matrices as input, it only accepts
matrices in formats supporting several matrices per file (transfac,
tf, tab, clusterbuster, cb, infogibbs, meme, stamp, uniprobe).

For a description of these formats, see the help of I<convert-matrix>.

=cut
    } elsif ($arg eq "-format") {
      $main::matrix_format = shift(@arguments);
      unless ($supported_matrix_format{$matrix_format}) {
	&RSAT::error::FatalError($matrix_format, "Invalid format for input matrices\tSupported: ".$main::supported_matrix_formats);
      }


=pod

=item	B<-o output_prefix>

Prefix for the output files.

Mandatory option: since the program I<cluster-matrices> returns a
list of output files (pariwise matrix comparisons, matrix clusters).

=cut
    } elsif ($arg eq "-o") {
      $main::outfile{prefix} = shift(@arguments);

    } else {
      if ($arg =~ /\s/) {
	push @args_to_pass, "'".$arg."'";
      } else {
	push @args_to_pass, $arg;
      }
#      &FatalError("Invalid option", $arg);

    }
  }

=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; cluster-matrices ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (%main::infile) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-28s\t%s\n", $key, $value;
	}
    }
    printf $main::out  "; %-28s\t%s\n", "Number of matrices", scalar(@matrices);

    if (%main::outfile) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-28s\t%s\n", $key, $value;
	}
    }
}

################################################################
## Compare each discovered motifs to each other.
sub CompareMatrices {
  ## Pariwise comparisons between discovered matrices.  We don't
  ## the option "distinct" in order to ensure that all the motifs are
  ## in the output graph even if they are not related to any other
  ## motif.
  &RSAT::message::TimeWarn("Pairwise matrix comparison.") if ($main::verbose >= 2);
  my $cmd = $SCRIPTS."/compare-matrices -v ".$main::verbose." -mode matches";
  $cmd .= " -format ".$main::matrix_format;
  $cmd .=  " -file ".$main::infile{matrices};
  $cmd .= " -DR";
#  $cmd .= " -distinct"; ## We disactivate the option "distinct" in order to ensure that all the motifs are in the output graph even if they are not related to any other motif
  $cmd .= " -sort cor";
#  $cmd .= " -lth w ".$main::param{matrix_compa_min_w}; ## Min number of aligned columns
  #$cmd .= " -lth cor ".$main::param{matrix_compa_min_cor}; ## Min correlation
  #$cmd .= " -lth Ncor ".$main::param{matrix_compa_min_Ncor}; ## Min normalized correlation
  $cmd .= " -return matrix_name,strand,offset,".$main::param{matrix_compa_metrics}.",width,consensus,matrix_desc,logos";
  $cmd .= " ".$args_to_pass;
  $cmd .= " -o ".$main::outfile{pairwise_compa};
  $cmd .= "; ".$SCRIPTS."/text-to-html -i ".$main::outfile{pairwise_compa};
  $cmd .= " -o ".$main::outfile{pairwise_compa_html};
  &RSAT::util::one_command($cmd, 1,"");

  &RSAT::message::TimeWarn("Matrix comparison table", $main::outfile{pairwise_compa}) if ($main::verbose >= 0);

=pod
  ## Use the mean_rank as score column
  open COMPA, $main::outfile{pairwise_compa};
  $main::param{score_column} = 0;
  while (<COMPA>) {
    if (/;\t(\d+)\t$param{matrix_compa_score}/) {
      $main::param{score_column} = $1;
      &RSAT::message::Info("Score", $param{matrix_compa_score}, "column", $main::param{score_column}, "file", $main::outfile{pairwise_compa}) if ($main::verbose >= 0);
      last;
    }
  }
  close COMPA;
  if ($main::param{score_column} == 0) {
    &RSAT::error::FatalError("Cannot identify score column (".$param{matrix_compa_score}.") in matrix comparison file (".$main::outfile{pairwise_compa}.").");
  }
=cut
}


###############################################################
## Run the R script "cluster_motifs.R" 
##
## This script takes as input a matrix comparison file
## (generated by compare-matrices), performs hierarchical
## clustering.
##
## It returns the resulting tree in json format
## 

sub Hclustering {
    
    &RSAT::message::TimeWarn("Clustering matrices on the basis of the selected parameter.") if ($main::verbose >= 2);


    ##################################
    ### This lines are required?
    #my $r_path = &RSAT::server::GetProgramPath("R", 0);
    #RSAT::message::Info("R path", $r_path) if ($main::verbose >= 3);

    ####################################
    ### Modify the path
    chomp(my $r_path = `which R`);


    my $cluster_motifs_script  = $ENV{RSAT}."/R-scripts/cluster_motifs.R";
    &RSAT::error::FatalError("Cannot read cluster motifs script", $cluster_motifs_script) unless (-r $cluster_motifs_script);



#  my $pos_drawing_offset = -($pos_interval-1)/2;
    my $pos_drawing_offset = 0;
    my  $cluster_motifs_cmd = "cat ".$cluster_motifs_script;
    $cluster_motifs_cmd .= " | ".$r_path;
    $cluster_motifs_cmd .= " --slave --no-save --no-restore --no-environ";
    $cluster_motifs_cmd .= " --args \"";
    $cluster_motifs_cmd .= "infile='".$main::outfile{pairwise_compa}."'";
    $cluster_motifs_cmd .= ";outfile='".$main::outfile{matrix_tree_json}."'";
    #$cluster_motifs_cmd .= ";score='Ncor'";
    $cluster_motifs_cmd .= "; \"";
    $cluster_motifs_cmd .= " > ".$main::outfile{Rlog};
    if ($r_path) {
        &doit($cluster_motifs_cmd, 0, $die_on_error, $verbose);
    } else {
        &RSAT::message::Warning("Could not run motif clustering because the program R is not available") if ($main::verbose >= 1);
    }

    return();
}


=pod

################################################################
## Identify clusters of similar motifs, and build
## consensus motifs.
#sub ClusterMotifs {

  ## Generate a GML graph with the matrix comparison result (can be opened with CytoScape or Yed)
  $cmd = $SCRIPTS."/convert-graph -i ".$main::outfile{pairwise_compa};
  $cmd .= " -ewidth -ecolors fire";
  $cmd .= " -layout spring_new";
  $cmd .= " -from tab -to gml -scol 1 -tcol 2 -wcol ".$main::param{score_column};
  $cmd .= " -o ".$main::outfile{matrix_network_gml};
  &RSAT::util::one_command($cmd, 1);

  ## Generate a figure of the motif comparison graph
  $cmd = $SCRIPTS."/display-graph";
  $cmd .= " -in_format gml -i ".$main::outfile{matrix_network_gml};
  $cmd .= " -ewidth";
  $cmd .= " -layout none";
  $cmd .= " -out_format png -o ".$main::outfile{compa_png};
  &RSAT::util::one_command($cmd, 1);

  ## Use MCL to partition the motif graph into clusters
  &RSAT::message::TimeWarn("Matrix clustering.") if ($main::verbose >= 2);
  my $mcl_dir = $ENV{mcl_dir};
  unless ($mcl_dir) {
    &RSAT::error::FatalError("Motif comparison requires to install MCL and indicate its path in the file $ENV{RSAT}/RSAT_config.props");
  }
  my $mcl = $mcl_dir."/mcl";
  $cmd = "grep -v '^;' ".$main::outfile{pairwise_compa}.">".$main::outfile{pairwise_compa}.".mcl";
  $cmd .= "; ".$mcl."/mcl ".$main::outfile{pairwise_compa}.".mcl";
  $cmd .= " -I 1.8 --abc -V all ";
  $cmd .= " -o ".$main::outfile{clusters_mcl};
  $cmd .= " >& /dev/null";
  $cmd .= " ; ${SCRIPTS}/convert-classes -i ".$main::outfile{clusters_mcl};
  $cmd .= " -from mcl -to tab ";
  $cmd .= " -o ".$main::outfile{clusters_tab};
  &RSAT::util::one_command($cmd, 1);

  ## Split the motif graph into clusters as defined by MCL, and
  ## compute the intra-cluster degree (k) and weighted degree (wk) of
  ## each node
  $cmd = $SCRIPTS."/graph-get-clusters -i ".$main::outfile{pairwise_compa};
  $cmd .= " -in_format tab -scol 1 -tcol 2 -wcol ".$main::param{score_column};
  $cmd .= " -return clusters ";
  $cmd .= " -clusters ".$main::outfile{clusters_tab};
  $cmd .= " -out_format tab -o ".$main::outfile{clusters_subgraph};
  &RSAT::util::one_command($cmd, 1);


  ## Identify graph components and count the intra-component degree of
  ## each node. Most connected nodes will serve as seeds for motif
  ## clustering.
  $cmd = $SCRIPTS."/graph-connex-components -v 1";
  $cmd .= " -i ".$main::outfile{clusters_subgraph};
  $cmd .= " -wcol ".$main::param{score_column};
  $cmd .= " -o ".$main::outfile{intra_cluster_degree};
  &RSAT::util::one_command($cmd, 1);

  ## Generate a GML graph with the matrix comparison result (can be opened with CytoScape or Yed)
  $cmd = $SCRIPTS."/convert-graph -i ".$main::outfile{clusters_subgraph};
  $cmd .= " -ewidth -ecolors fire";
  $cmd .= " -layout spring_new";
  $cmd .= " -from tab -to gml -scol 1 -tcol 2 -wcol 3";
  $cmd .= " -o ".$main::outfile{clusters_subgraph_gml};
  &RSAT::util::one_command($cmd, 1);

  ## Generate a figure of the motif comparison graph
  $cmd = $SCRIPTS."/display-graph";
  $cmd .= " -in_format gml -i ".$main::outfile{clusters_subgraph_gml};
  $cmd .= " -ewidth";
  $cmd .= " -layout none";
  $cmd .= " -out_format png -o ".$main::outfile{clusters_subgraph_png};
  &RSAT::util::one_command($cmd, 1);


  return();
}
=cut

################################################################
## Add attributes to JSON file, like links to pictures and other
## attributes
sub Add_attributes_to_JSON(){
  my ($Line, $M1, $M2, $Add_this, $Flag);
  my (@Split_line, @Parsed_JSON) = ();
  my (%matrix_info) = ();


  #############################################
  ## Create a hash with the attribute data:
  ##	key :  name
  ##	values : attribute (link, etc)

  ### Open the file with the picture's data
  open(DATA, $main::outfile{matrix_descriptions}) || &RSAT::error::FatalError( "Cannot open DATA file", $main::outfile{matrix_descriptions});
  while(<DATA>){
    next unless (/\S/); ## Skip empty rows
    next if (/^;/); ## Skip comment rows
    next if (/^#/); ## Skip header rows
    chomp();
    my $line = $_;
    @split_line = split(/\s+/, $line);
    my $matrix_id = $split_line[1];
    $matrix_info{$matrix_id}{name} = $split_line[2];
    $matrix_info{$matrix_id}{width} = $split_line[3];
    $matrix_info{$matrix_id}{consensus} = $split_line[4];
    $matrix_info{$matrix_id}{logo_file} = $split_line[5];
  }
  close(DATA);


  ############################################################
  ## Read the JSON file and add the link data to each node

  my $line = "";
  $matrix_num = 0;
#  chomp($path = `pwd`);

  ### Open the JSON file produced by R
  open(JSON, $main::outfile{matrix_tree_json}) || &RSAT::error::FatalError($main::outfile{matrix_tree_json}, "Cannot open the JSON file");
  while(<JSON>){
    
    chomp;
    $Flag = 0;
    $line = $_;
    
    ### Search the pattern separating the matrices names
    if($line =~ /\s*\"name\":\s*\"(.+)\",/){

      $matrix_num++;
      $Flag = 1;
      $Add_this = "";
      $M1 = $1;

      ## Define te URL of the logo file, relative to the location of the json file
      my $logo_link = &RSAT::util::RelativePath($main::outfile{matrix_tree_json}, $matrix_info{$M1}{logo_file});
      my $logo_url = $logo_link.".png";
#@      my $logo_url = "file://".$path."/".$matrix_info{$M1}{logo_file}.".png";
      
      ### Create the line that will be added to JSON file
      $Add_this = "\"image\" : \"${logo_url}\", ";
      $Add_this .= "\"url\" : \"${logo_url}\", ";
      $Add_this .= "\"size\" : ".$matrix_info{$M1}{width};
      #print $Add_this."\n";
    }
    push(@Parsed_JSON, $line."\n");
    
    ### Add the new line
    if ($Flag) {
      push(@Parsed_JSON, $Add_this."\n");
    }
  }
  close(JSON);
  
  ### Create the JSON parsed FILE
  open(PARSED_JSON, ">".$main::outfile{parsed_tree_json}) || &RSAT::error::FatalError("Cannot create the PARSED JSON file", $main::outfile{parsed_tree_json});
  print PARSED_JSON @Parsed_JSON;
  close(PARSED_JSON);
#  system("rm ".$main::outfile{matrix_tree_json});
  return();
}


###################################
## Create the html file to 
## display the tree
sub Create_html_tree_file(){
    
    $matrix_num += 2;
    system("cp ".$ENV{RSAT}."/public_html/lib/display_d3_tree.html ".$main::outfile{matrix_tree_html});
    open(TEMP, ">".$main::outfile{temp}) || &RSAT::error::FatalError($main::outfile{temp}, "Cannot create temporal file");
    open(TREE,$main::outfile{matrix_tree_html}) || &RSAT::error::FatalError($main::outfile{matrix_tree_html}, "Cannot found the HTML tree file");

    if ((defined($ENV{RSA_OUTPUT_CONTEXT})) &&
	($ENV{RSA_OUTPUT_CONTEXT} eq "cgi")) {
      $d3_base_url = "http://d3js.org/";
#	 $d3_base_url=$ENV{rsat_www}."/lib/d3/";
    }

    while(<TREE>){
	chomp;	

	if ((defined($ENV{RSA_OUTPUT_CONTEXT})) &&
	    ($ENV{RSA_OUTPUT_CONTEXT} eq "cgi")) {
	  $_ =~ s|$ENV{RSAT}/public_html/|$ENV{rsat_www}|g;
	}

	### Fix the d3 library path
	$_ =~ s|src=\"\"|src=\"${d3_base_url}/d3.v3.js\"|;

	### Set the height 
	$_ =~ s/\s+height =,/\t\theight = 150 * $matrix_num,/;

	### Add the JSON file name
	@temp = split(m|/|,$main::outfile{parsed_tree_json});
	$json_file_name = pop(@temp);

	$_ =~ s/^\s+d3.json\(/d3.json\(\"$json_file_name\"/;
	print TEMP $_."\n";
    }
    close(TREE);
    close(TEMP);
    system("rm ".$main::outfile{matrix_tree_html});
    system("mv ".$main::outfile{temp}." ".$main::outfile{matrix_tree_html});
    return();
}


__END__

