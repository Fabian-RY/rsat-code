#!/usr/bin/perl
############################################################
#
# $Id: purge-sequence,v 1.20 2003/09/30 21:47:02 jvanheld Exp $
#
# Time-stamp: <2003-09-30 23:46:45 jvanheld>
#
############################################################
#use strict;;
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";


my $skdir = "$RSA/bin";
my $delete_repeats=0;

#### initialise parameters ####
my $start_time = &AlphaDate();
my $convert_seq_command = "$SCRIPTS/convert-seq";
$both_strands = 1;
$inputfile = "";
$outputfile = "";
$verbose = 0;
$match_len = 40;
$mismatches = 3;
$in_format = "fasta";

&ReadArguments();


#### check argument values ####
### check input format 
&CheckInputSeqFormat($in_format);

$dir{execution} = `pwd`;
chomp $dir{execution};

if ($outputfile) {
    $basename{out} = `basename ${outputfile}`;
    $dirname{out} = `dirname ${outputfile}`;
    chomp $dirname{out};
    chdir $dirname{out};
    $dir{output} = `pwd`;
    chomp($dir{output});
}

chdir($dir{execution});

if ($inputfile) {
    $basename = `basename ${inputfile}`;
    chomp $basename;
    $dirname = `dirname ${inputfile}`;
    chomp $dirname;
    chdir $dirname;
    $dir{input} = `pwd`;
    chomp($dir{input});
#    warn join "\t", $dirname, $dir{input}, $basename, "\n"
} else {
    $dirname = ".";
    $basename = $start_time;
}



#### create a temp file to filter out non-conform lines 
$tmp_file = "tmp_".$basename.".fasta";

#$command = "cd $TMP ; ";
$command = " $convert_seq_command -from $in_format -to fasta -o ${TMP}/$tmp_file";
$command .= " -i $dir{input}/$basename" if ($inputfile);
&doit($command);


###### execute the command #########
@extensions = qw(al1 ssp bck bwt des lcp ois llv prj suf tis sds);

#### build the tree
my $mkvtree_options = "";
$mkvtree_options .= " -bck"; # bucket boundaries ???
$mkvtree_options .= " -dna"; # input is DNA sequence
$mkvtree_options .= " -tis"; # output parsed and transformed input string to file
$mkvtree_options .= " -bwt"; # output Burrows & Wheeler Transform to file
$mkvtree_options .= " -suf"; # output suffix array to file
$mkvtree_options .= " -sti1"; # output reduced inverse suffix array (sti1tab) to file
$mkvtree_options .= " -lcp"; # output longest common prefix lengths to file
$mkvtree_options .= " -ois"; # output the parsed input string to a file
$mkvtree_options .= " -pl"; # length of prefix for bucket sort (default 0)
$mkvtree_options .= " -db $tmp_file"; # sequence file
&doit("cd $TMP; $skdir/mkvtree $mkvtree_options");

#### locate the duplications
my $vmatch_options = "-s"; # show the sequence content of a match
if ($delete_repeats) {
    ## mask repeats
    $vmatch_options .= " -dbmaskmatch n "; # show all database sequence not containing a match
} else {
    ## delete repeats
    $vmatch_options .= " -dbnomatch 1 "; # show all database sequence not containing a match
}
$vmatch_options .= " keepleft"; # keep the left occurrence of each repeat
$vmatch_options .= " -l $match_len"; # specify that match must have the given length
$vmatch_options .= " -e $mismatches" if ($mismatches > 0); # specify the allowed edit distance > 0
$vmatch_options .= " -d"; # compute direct matches 
$vmatch_options .= " -showdesc 0"; # use the original sequence identifier 
if ($both_strands) {
    $vmatch_options .= " -p"; # compute reverse complemented (palindromic) matches
} 
$vmatch_options .= " $tmp_file ";
$vmatch_options .= " | grep -v '^#' ";
#$vmatch_options .= " | awk '\$1 ~ \"\>\" {print \$1 \"_\" \$2 \"_\" (\$2+\$3-1)}; \$1 !~ \"\>\" {print}'";
$vmatch_options .= " | perl -pe 's| (\\d+) |_\$1_|'";

$vmatch_options .= "> $dir{output}/$basename{out}" if ($outputfile);
&doit("cd $TMP ; $skdir/vmatch $vmatch_options");
foreach $ext  (@extensions) {
    &doit("rm -f ${TMP}/${tmp_file}.${ext}");
}

#### remove the temp file
&doit("rm -f ${TMP}/$tmp_file");


###### verbose ######
if ($verbose) {
  my $done_time = &AlphaDate;
  warn "; Job started $start_time\n";
  warn "; Job done    $done_time\n";
}


exit(0);


########################## subroutine definition ############################

sub doit {
    my ($command) = @_;
#    chdir($TMP);
    warn "; $command\n" if ($verbose);
    system $command unless $dry_run;
}

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	purge-sequence

        1999 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        purge-sequence [-i inputfile] [-o outputfile] [-v] [-2str | -1str]

DESCRIPTION

	Mask redundant fragments in a sequence. This perl script is no
	more than a wrapper to facilitate this specific usage for two
	programs developed by Stefan Kurtz : mkvtree and vmatch.

	When a fragment is duplicated, the first ocurrence is
	conserved and the second masked (or optionally deleted). 

	By default, the program also searches similarities between the
	direct and reverse complement strand.

CATEGORY
	sequences

OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-i inputfile
	        The file containing the sequence to purge.
		If inputfile is not specified, the standard input is
		used.  This allows to place the command within a pipe.
	-format sequence format
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-n	dry run
		print commands without executing them
	-ml #	match length
	-mis #	mismatches
	-1str	discard duplications on the direct strand only
	-2str	discard duplications on the reverse complement as well
	-del	delete repeats instead of masking them
End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
purge-sequence options
----------------
-h	(must be first argument) display full help message
-help	(must be first argument) display options
-i	input file
-o	output file
-v	verbose
-n	dry run
-format sequence format
-ml #	match length
-mis #	mismatches
-1str	discard duplications on the direct strand only
-2str	discard duplications on the reverse complement as well
-del	delete repeats instead of masking them
End_short_help
  close HELP;
  exit;
}


sub ReadArguments {
#### read arguments ####
    foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### dry run
	} elsif ($ARGV[$a] eq "-n") {
	    $dry_run  = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions;
	    
	    ### input file ###
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    
	    ### sequence format
	} elsif ($ARGV[$a] eq "-format") {
	    $in_format = lc($ARGV[$a+1]);
	    
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    
	    ### output file ###
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    
	    ### strands
	} elsif ($ARGV[$a] eq "-1str") {
	    $both_strands = 0;
	} elsif ($ARGV[$a] eq "-2str") {
	    $both_strands = 1;
	    
	    ### delete repeats instead of masking them
	} elsif ($ARGV[$a] eq "-del") {
	    $delete_repeats = 1;
	    
	    ### matching length
	} elsif (($ARGV[$a] eq "-ml") && (&IsInteger($ARGV[$a+1]))) {
	    $match_len = $ARGV[$a+1];
	    
	    ### mismatches
	} elsif (($ARGV[$a] eq "-mis") && (&IsInteger($ARGV[$a+1]))) {
	    $mismatches = $ARGV[$a+1];
	    
	}
    }
}

