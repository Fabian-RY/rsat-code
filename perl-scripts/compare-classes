#!/usr/bin/perl 

############################################################
#
# $Id: compare-classes,v 1.24 2006/03/20 17:28:22 jvanheld Exp $
#
# Time-stamp: <2003-09-11 12:08:41 jvanheld>
#
############################################################
#use strict;;
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.help.pl";
require RSAT::Family;
require RSAT::Graph;
require RSAT::GraphNode;
require RSAT::GraphArc;
#require "RSA.classes";

#### TO DO : add parameter -base

################################################################
#### initialise parameters
my $start_time = &AlphaDate();
local $replacement = 0;
local $symmetric = 0;
local $distinct = 0;
local @matrix_keys = ();
local $dot_file = "";
local $gml_file = "";
local $nb_tests = 0;
local $nb_ref_classes = 0;
local $nb_query_classes = 0;
local $score_column = 0; ## By default, the file is read without score
local $inf = 999;
local $base=exp(1); ## Base for the logarithms
local $null = "NA";

local $multi_cor = "nt"; ## Correction for multi-testing
%supported_multi_cor = (
    nq=>1,
    nr=>1,
    nc=>1,
    nt=>1,
);
$supported_multi_cor = join (",", sort(keys (%supported_multi_cor)));


%common = (); ### elements common to query and reference classes
%R_only = (); ### elements found in reference but not in query
%Q_only = (); ### elements found in query but not in reference

$sort_key = "name";

## Groups of calculation
%calc_groups = (
    'rank'=>'rank',

    'QR'=>'occ',
    'R'=>'occ',
    'Q'=>'occ',
    'QvR'=>'occ',


    'P(R)'=>'freq',
    'P(Q)'=>'freq',
    'QR/R'=>'freq',
    'QR/Q'=>'freq',

    'jac_sim'=>'jac_sim',

    'dotprod'=>'dotprod',

    'P_val'=>'proba',
    'E_val'=>'proba',
    'sig'=>'proba',

    'H(R)'=>'entropy',
    'H(Q)'=>'entropy',
    'H(Q,R)'=>'entropy',
    'H(Q|R)'=>'entropy',
    'H(R|Q)'=>'entropy',
    'I(Q,R)'=>'entropy',
    'U(Q|R)'=>'entropy',
    'U(R|Q)'=>'entropy',
    'IC'=>'entropy',
);
@calc_keys = keys %calc_groups;
@calc_values = values %calc_groups;


## Define supported return, sort, matrix, and threshold fields
while (my ($key,$value) = each (%calc_groups)) {
    $supported_return_fields{$value} = 1;
    $supported_threshold_fields{$key} = 1;
    $supported_matrix_fields{$key} = 1;
    $supported_sort_fields{$key} = 1;
}
$supported_return_fields{members} = 1,
$supported_sort_fields{names} = 1,
delete($supported_sort_fields{rank}),

$supported_matrix_fields = join (",", sort(keys( %supported_matrix_fields)));
$supported_sort_fields = join (",", sort(keys( %supported_sort_fields)));
$supported_return_fields = join (",", sort(keys( %supported_return_fields)));
$supported_threshold_fields = join (",", sort(keys( %supported_threshold_fields)));

%supported_catalogs = (
    MIPS=>1,
    GO=>1,
    ms_complexes=>1,
    TF_targets=>1,
    regulons=>1
);
$supported_catalogs = join (",", sort(keys( %supported_catalogs)));

local %infile = ();
local %outfile = ();

local $verbose = 0;
# local $in = STDIN;
local $out = STDOUT;

## Fields to return in the output
%return_fields = ();

## Fields to calculate can be diffferent from those to return, due to
## dependencies (e.g. returning frequencies requires the computation
## of occurrences)
%calc_fields = (occ=>1);


## Any statistics that can be computed can be returned as a matrix
%supported_matrix_fields = %calc_groups;
$supported_matrix_fields = join (",", sort(keys( %supported_matrix_fields)));

%lth = ();
%uth = ();

%member_index = ();
%ref_member_index = ();
%query_member_index = ();
$population_size = 0;

## ##############################################################
## Field formats for the output
%field_formats = ();
$field_formats{'Q'} = "%d";
$field_formats{'R'} = "%d";
$field_formats{'QR'} = "%d";
$field_formats{'QvR'} = "%d";
$field_formats{'Q!R'} = "%d";
$field_formats{'R!Q'} = "%d";
$field_formats{'!Q!R'} = "%d";
$field_formats{'QR/Q'} = "%.5f";
$field_formats{'P(R)'} = "%.5f";
$field_formats{'P(Q)'} = "%.5f";
$field_formats{'P(QR)'} = "%.5f";
$field_formats{'P(Q!R)'} = "%.5f";
$field_formats{'P(R!Q)'} = "%.5f";
$field_formats{'P(!Q!R)'} = "%.5f";
$field_formats{'jac_sim'} = "%.5f";
$field_formats{'dotprod'} = "%7g";
$field_formats{'exp_QR'} = "%7.2f";
$field_formats{'P_val'} = "%.2g";
$field_formats{'E_val'} = "%.2gf";
$field_formats{'sig'} = "%.2f";
$field_formats{'H(Q)'} = "%.5f";
$field_formats{'H(R)'} = "%.5f";
$field_formats{'H(Q,R)'} = "%.4f";
$field_formats{'H(Q|R)'} = "%.4f";
$field_formats{'H(R|Q)'} = "%.4f";
$field_formats{'I(Q,R)'} = "%.4f";
$field_formats{'IC'} = "%.4f";

&ReadArguments();

################################################################
#### check argument values
unless ($infile{query_classes}) {
    &RSAT::error::FatalError("You must specify a file containing query classes");
}

if ($catalog) {
    if ($organism_name) {
	$infile{ref_classes} = $supported_organism{$organism_name}->{'data'}."/catalogs/${organism_name}_${catalog}.tab";
    } else {
	&RSAT::error::FatalError("The option -cat requires to specify an organism");
    }
} 

unless ($infile{ref_classes}) {
    &RSAT::error::FatalError("You must specify a file containing reference classes");
}

## Dot product requires score column
if (($return_fields{dotprod}) && !($score_col)) {
    &RSAT::error::FatalError("To calcualte a dot product, you need to specify a score column (option -sc).");
}

## Logarithm base
$log_base = log($base); ## Calcualte it only once

## ##############################################################
## Fields to calculate
foreach my $field (@matrix_keys) {
    my $calc_group = $calc_groups{$field};
    $calc_fields{$calc_group} = 1;
}

foreach my $field (keys %return_fields) {
    $calc_fields{$field} = 1;
}

## Dependencies between fields
if ($calc_fields{entropy}) {
    $calc_fields{freq} = 1;
}

if ($calc_fields{jac_sim}) {
    $calc_fields{freq} = 1;
}

if ($calc_fields{dotprod}) {
    $calc_fields{occ} = 1;
}

if ($calc_fields{proba}) {
    $calc_fields{occ} = 1;
}

if ($calc_fields{freq}) {
    $calc_fields{occ} = 1;
}

&RSAT::message::Info(join("\t", "Fields to calculate", 
			  join("; ", sort(keys(%calc_fields)))
			 )) if ($main::verbose >= 0);


################################################################
### open output stream
$out = &OpenOutputFile($outfile{output});

################################################################
###### read class files

## Query classes
%query_classes = &ReadClasses($infile{query_classes},0,"",1,1,2,$score_col);
$nb_query_classes = scalar(keys %query_classes);
&RSAT::message::Info((join("\t", "Query classes", $nb_query_classes))) if ($main::verbose >= 2);

## Reference classes
%ref_classes = &ReadClasses($infile{ref_classes},0,"",1,1,2, $score_col);
$nb_ref_classes = scalar(keys %ref_classes);
&RSAT::message::Info((join("\t", "Reference classes", $nb_ref_classes))) if ($main::verbose >= 2);

## Read ref class names
if ($infile{rnames}) {
    &RSAT::message::TimeWarn("Reading reference names\t".$infile{rnames}) if ($main::verbose >= 2);
    my ($in) = &OpenInputFile($infile{rnames});
    while (<$in>) {
	chomp();
	next if (/^;/);
	next unless (/^\S/);
	my @fields = split '\t';
	my $id = $fields[0];
	my $name = $fields[1];
#	warn join ("\t", ";ref class", $id, $name), "\n" if ($main::verbose >= 10);
	if (defined($ref_classes{$id})) {
	    $ref_classes{$id}->force_attribute("name",$name);
	}
    }
}

## Read query class names
if ($infile{qnames}) {
    &RSAT::message::TimeWarn("Reading query names\t".$infile{qnames}) if ($main::verbose >= 2);
    my ($in) = &OpenInputFile($infile{qnames});
    while (<$in>) {
	chomp;
	next if (/^;/);
	next unless (/^\S/);
	my @fields = split '\t';
	my $id = $fields[0];
	my $name = $fields[1];
#	warn join ("\t", ";query class", $id, $name), "\n" if ($main::verbose >= 10);
	if (defined($query_classes{$id})) {
	    $query_classes{$id}->force_attribute("name",$name);
	}
    }
}

################################################################
#### unless specified, calculate population size from the lists of
#### reference and query members

&RSAT::message::TimeWarn("Indexing class members") if ($main::verbose >= 2);
foreach my $r (keys %ref_classes) {
    foreach $m ( $ref_classes{$r}->get_members()) {
	$member_index{$m}++;
	$ref_member_index{$m}++;
    }
}
foreach my $q (keys %query_classes) {
    foreach $m ( $query_classes{$q}->get_members()) {
	$member_index{$m}++;
	$query_member_index{$m}++;
    }
}

#    die keys %member_index;
if ($population_size == 0 ) {
    $population_size = scalar(keys %member_index);
}
&RSAT::message::Info((join("\t", "Population size", $population_size))) if ($main::verbose >= 2);



&CompareClasses();

&Verbose() if ($verbose);
&PrintResult();

################################################################
###### finish verbose
if ($verbose) {
    my $done_time = &AlphaDate;
    print $out "; Job started $start_time\n";
    print $out "; Job done    $done_time\n";
}

################################################################
###### close output stream
close $out if ($outfile{output});


## export graph in gml format
if ($gml_file) {
    my $graph = &CreateGraph("gml");
    $gml_handle = &OpenOutputFile($gml_file);
    $gml = $graph->to_gml();
    print $gml_handle $gml;
}

## export graph in dot format
if ($dot_file) {
    my $graph = &CreateGraph("dot");
    $dot_handle = &OpenOutputFile($dot_file);
    $dot = $graph->to_dot();
    print $dot_handle $dot;
}

exit(0);

################################################################
################### subroutine definition ######################
################################################################

################################################################
#### display full help message
sub PrintHelp {
    my $HELP_CLASS_FILE = &help_message("class file");
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
        compare-classes

        2002 by Joseph Tran and Jacques van Helden (jvanheld\@scmbb.ulb.ac.be)

DESCRIPTION
        Compare two class files (the query file and the reference
        file). Each class of the query file is compared to each
        class of the reference file. The number of common elements is
        reported, as well as the probability to observe at least this
        number of common elements by chance alone.

CATEGORY
        util,stat

USAGE
        compare-classes -r ref_classes -q query_classes
                [additional options]

        compare-classes -i classes
                [additional options]

OPTIONS
    -h      (must be first argument) display full help message

    -help   (must be first argument) display options

    -v      verbose

    -r ref_classes
        A tab-delimited text file containing the dscription of
        reference classes (see format description below).

    -q query_classes
        A tab-delimited text file containing the dscription of
        query classes (see format description below).

    -i input_file
        This file will be used as both reference and query. 
        This is equivalent to 
            -q input_file -r input_file

    -sc score column
	Specify a column of the input file containing a score associated to
	each member. The score is used for some metrics like the dot product.

    -o outputfile
        if not specified, the standard output is used.
        This allows to place the command within a pipe.

    -rnames class_name_file
        File containing names for the reference classes.
        Associate a name to each class, when the classes are
        specified by an ID (ex Gene Ontology term IDs).  
        The class name file contains two columns

            1) class ID
            2) class name


    -qnames class_name_file
        File containing names for the query classes.
        Same format as for -rnames.

    -cat catalog
        Compare the query file to pre-defined catalogs
        (e.g. GO, MIPS functional classes, ...). These
        catalogs associate each gene of a genome to one or
        several classes.  The organism must be specified
        (option -org).
        
        Supported catalogs:
        $supported_catalogs

        This option is currently supported for Saccharomyces
        cerevisiae.

    -org organism (for pre-defined catalogs)        

    -return return_fields
        List of fields to return. Supported field :
        $supported_return_fields

    -uth field #
        upper threshold value for a given field
        Supported_fields: $supported_threshold_fields

    -lth field #
        lower threshold value for a given field
        (same fields as -uth)

    -pop #
        Population size. If not specified, the population size
        is estimated as the number of distinct elemenst in the
        whole set of referenc classes.

    -sort key
        sort on the basis of the specified key.
        Supported keys: $supported_sort_fields

    -rep    replacement
        Sampling was performed with replacement, i.e. a given
        element can appear several times in the same class.

        In this case, the binomial distribution is used
        instead of the hypergeometric.

    -sym    symmetric comparison
        (only useful when -rep is activated, because th
        hypergeometric is by definition symmetric)

    -distinct
        Prevent to compare each class with itself (when the
        reference and query files contain the same classes).

    -triangle
        (ony valid if query file and reference file are the same)
        Do not perform the reciprocal comparisons: if
        reference A has already been compared to query B, then
        reference B does not need to be compared to query A. .
        With matrix output, this returns only the lower
        triangle fo the matrix.

    -matrix [key]
        Return a pairwise matrix, where each row corresponds
        to a reference class, each column to a query class,
        and each cell contains a comparison between the two
        classes. The next argument indicates which statistics
        has to be returne in the matrix (default = sig).
        Supported : $supported_matrix_fields

    	The argument -matrix can be used iteratively to export several
    	matrices in the same output file.
	Example: 
		-matrix QR -matrix sig -matrix 'I(Q,R)' 

    -null 
    	null string (default $null) displayed for undefined values.

    -dot dot_file
        Export a graph with the associations in a dot
        file. Dot files can be visualized and modified with
        the GraphViz package (http://www.graphviz.com/), which
        contains several methods of automatic layout.

    -gml gml_file
        Export a graph with the associations in a gml
        file, which can be visualized and modified with
        various visualization packages, including
         GraphViz (http://www.graphviz.com/)
        yed (http://www.yworks.com/en/products_yed_about.htm)

    -multi_cor
        Factor used for the multi-testing correction. 
        Supported values: 
           nt  number of significance tests (default)
           nq  number of query classes
           nr  number of reference classes
           nc  number of comparisons (nc = nq * nr)
        The differences between these four options are
        explained below (section E-value).

PROBABILITIES

    P-VALUE

        The P-value is the probability for one comparison to return a
        false positive. In other words, it is the probability to
        observe at least c common elements between a given query class
        and a given reference class. It can be calculated with
        different formulae, depending on the underlying random model.

        Let us assume that we have :
                q       size of the query class
                r       size of the reference class
                c       number of common elements
                n       population size

    HYPERGEOMETRIC
                       q     i  q-i     q
        P_value = P(X >= c) = SUM ( C  C     / C  )
                      i=c    r  n-r     n

    BINOMIAL

        When the option -rep (replacement) is active,
        probabilities are calculated on the basis of the
        binomial distribution instead of the hypergeometric.


        The binomial formula is applied with
                p_r = r/n probability of success at each trial
                nb of trials = q
                nb of successes = c

                       q
        P_value = P(X >= c) = SUM (binom(i,q,p_r))
                      i=c

        Beware: the binomial gives an assymmetric result,
        i.e. the fact to swap query and reference classes
        changes the probability. This can be circumvented by
        using the option -sym, described below.

    SYMMETRICAL COMPARISON WITH THE BINOMIAL

        When the comparison is assumed to be symmetrical, the
        program calculates the joint probability fo at least c
        elements to belong to both the query set and the
        reference set.

        In this case, the binomial is applied with :
                p_qr = q/n * r/n
                  = proba of success at each trial
                nb of trials = n
                nb of successes = c

                       q
        P_value = P(X >= c) = SUM (binom(i,n,p_qr))
                      i=c

    E-VALUE

        Assuming that there are x query classes and y
        reference classes, each analysis consists in x*y
        comparisons. Thus, thhe P-value can be misleading,
        because even low P-values are expected to emerge by
        chance alone when the number of query and/or reference
        classes is very high. The E-value reflects better the
        degree of exceptionality.

        The option -multi_cor allows to choose among 4
        possible multi-testing correction factors. The choice
        is left to the user, depending on the question he/she
        wants to answer.

        -multi_cor nr

            How many false positives do we expect per query
            class ?

                E-value = P-value * nr

            Where nr is the number of reference classes
            (e.g. the number of classes in the GO
            classification).

        -multi_cor nq

            How many false positives do we expect per
            reference class ?

                E-value = P-value * nq

            Where nq is the number of query classes
            (e.g. the number of co-expression cluster).


        -multi_cor nc

            How many false positives do we expect for the
            whole set of comparisons ?

                nc = nq * nr
                E-value = P-value * nc

            Where nc is the number of comparisons between a
            query class and a reference class.


        -multi_cor nt

            How many false positives do we expect for the
            whole set of significance tests actually
            performed ?

                  E-value = P-value * nt

            where nt is the number of significance tests
            actually performed (the number of times the
            hypergeometric or binomial formula was used)

        If you do not use any "pre-filtering" threshold, the
        options nc and nt give the same result (nt = nq * nr),
        since a significance test is performed for each pair
        of query class - reference class.

        If you use pre-filtering thresholds (for example -lth occ 1,
        to select only the pairs with at least one common member), the
        actual number of tests can in some cases be much smaller than
        the number of comparisons (nt <= nc = nq*nr).

    SIG

        The significance index is the minus log of the
        E-value. It is calculated in base 10.

        sig = -log10(E_val)

        This index gives an intuitive perception of the
        exceptionality of the common elements : a negative sig
        indicates that the common matches are likely to come by
        chanc alone, a ositive value that they are
        significant. Higher sig values indicate a higher
        significance.

OUTPUT FORMAT

        The program returns a tabdelimited file with one row per
        combination of reference-query class, and one column per
        return field.

        Default return fields:
        1) ref      reference class
        2) query    query class
        3) ref#     number of members in the ref class
        4) query#   number of members in the query class
        5) common   number of elements in common between the query 
    	   	    and reference class

        Additional return values are optionally returned, and can be
        specified with the -return option.

FILE FORMATS
    $HELP_CLASS_FILE
End_of_help
    close HELP;
    exit(0);
}

################################################################
#### display short help message
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
compare-classes options
----------------
-h              (must be first argument) display full help message
-help           (must be first argument) display options
-r              reference classes
-q              query classes
-i              single input file (used as query and reference)
-sc		score column
-rnames         reference class names
-qnames         query class names
-o              output file
-v              verbose
-return         return fields (supported $supported_return_fields)
-lth            lower threshold on a given field
-uth            upper threshold on a given field
-pop            population size
-multi_cor	multi-testing correction (supoprted: nq,nr,nc,nt)
-sort           sort key (supported keys: occ, sig)
-rep            sampling with replacement (binomial instead of hyergeometric)
-sym            symmetric comparison (only with -rep, see detailed help)
-distinct       prevent to compare each class with itself
-triangle       do not perform reciprocal comparison
-matrix [key]   return a similarity/dissimilarity matrix with the specified statistics
-cat            catalog (supported: $supported_catalogs)
-org            organism
-null    	null string (default $null) displayed for undefined values.
-dot            dot file
-gml            gml file
End_short_help
  close HELP;
  exit(0);
}

################################################################
#### read arguments
sub ReadArguments {
    foreach my $a (0..$#ARGV) {
	
        ### verbose
        if ($ARGV[$a] eq "-v") {
            if (&IsNatural($ARGV[$a+1])) {
                $verbose = $ARGV[$a+1];
            } else {
                $verbose = 1;
            }

            ### detailed help
        } elsif ($ARGV[$a] eq "-h") {
            &PrintHelp();

            ### list of options
        } elsif ($ARGV[$a] eq "-help") {
            &PrintOptions();

            ### query file
        } elsif ($ARGV[$a] eq "-q") {
            $infile{query_classes} = $ARGV[$a+1];

            ### reference class names
        } elsif ($ARGV[$a] eq "-rnames") {
            $infile{rnames} = $ARGV[$a+1];
	    
            ### query class names
        } elsif ($ARGV[$a] eq "-qnames") {
            $infile{qnames} = $ARGV[$a+1];
	    
            ### reference file
        } elsif ($ARGV[$a] eq "-r") {
            $infile{ref_classes} = $ARGV[$a+1];
	    
            ### catalog
        } elsif ($ARGV[$a] eq "-cat") {
            $catalog = $ARGV[$a+1];
	    unless ($supported_catalogs{$catalog}) {
		&RSAT::error::FatalError("$catalog is not a valid catalog. Supported: $supported_catalogs");
	    }

	    #### null value
	} elsif ($ARGV[$a] eq "-null") {	    
	    $null =$ARGV[$a+1];

	    #### organism
	} elsif ($ARGV[$a] eq "-org") {	    
	    $organism_name =$ARGV[$a+1];
	    &CheckOrganismName($organism_name);

            ### input file (both reference and query)
        } elsif ($ARGV[$a] eq "-i") {
            $infile{ref_classes} = $ARGV[$a+1];
            $infile{query_classes} = $ARGV[$a+1];

            ### Score column
        } elsif ($ARGV[$a] eq "-sc") {
	    $score_col = $ARGV[$a+1];
	    unless ((&IsNatural($score_col)) && ($score_col >= 1)) {
		&RSAT::error::FatalError( join("\t", $score_col, "Invalid score column: must be an integer >= 1"));
	    }
	    
            ### replacement
        } elsif ($ARGV[$a] eq "-rep") {
            $replacement = 1;

            ### symmetric (for binomial distrib only)
        } elsif ($ARGV[$a] eq "-sym") {
            $symmetric = 1;

            ### output file
        } elsif ($ARGV[$a] eq "-o") {
            $outfile{output} = $ARGV[$a+1];

            ### sort key
        } elsif ($ARGV[$a] eq "-sort") {
            $sort_key = $ARGV[$a+1];
            unless ($supported_sort_fields{$sort_key}) {
                &RSAT::error::FatalError (join("\t", $sort_key, "Invalid sort key. Supported:", $supported_sort_fields));
            }

            ### export a distance matrix
        } elsif ($ARGV[$a] eq "-matrix") {
	    $matrix_key = $ARGV[$a+1];
            push @matrix_keys, $matrix_key;
            unless ($supported_matrix_fields{$matrix_key}) {
                &RSAT::error::FatalError (join("\t", $matrix_key, "Invalid matrix key. Supported:", $supported_matrix_fields));
            }

	    $calc_fields{$calc_groups{$matrix_key}} = 1;

            ### dot file
        } elsif ($ARGV[$a] eq "-dot") {
            $dot_file = $ARGV[$a+1];

            ### gml file
        } elsif ($ARGV[$a] eq "-gml") {
            $gml_file = $ARGV[$a+1];

            ### prevent to compare each class with itself
        } elsif ($ARGV[$a] eq "-distinct") {
            $distinct = 1;

            ### do not perform reciprocal comparisons
        } elsif ($ARGV[$a] eq "-triangle") {
            $triangle = 1;

            ### population size
        } elsif ($ARGV[$a] eq "-pop") {
            $population_size = $ARGV[$a+1];
            unless (&IsNatural($population_size)) {
                &RSAT::error::FatalError("Population size must be a natural number");
            }
            unless ($population_size > 0) {
                &RSAT::error::FatalError("Population size must be strictly positive.");
            }

            #### threshold values
        } elsif ($ARGV[$a] eq "-lth") {
            my $field = $ARGV[$a+1];
	    &RSAT::error::FatalError(join("\t", $field, "Invalid threshold field. Supported:", $supported_threshold_fields))
		unless ($supported_threshold_fields{$field});
            my $value = $ARGV[$a+2];
            $lth{$field} = $value;
        } elsif ($ARGV[$a] eq "-uth") {
            my $field = $ARGV[$a+1];
	    &RSAT::error::FatalError(join("\t", $field, "Invalid threshold field. Supported:", $supported_threshold_fields))
		unless ($supported_threshold_fields{$field});
            my $value = $ARGV[$a+2];
            $uth{$field} = $value;

            #### return fields
        } elsif ($ARGV[$a] eq "-return") {
            chomp($ARGV[$a+1]);
            my @fields_to_return = split ",", $ARGV[$a+1];
            foreach $field (@fields_to_return) {
                if ($supported_return_fields{$field}) {
                    $return_fields{$field} = 1;
                } else {
                    &RSAT::error::FatalError(join("\t", $field, "Invalid return field. Supported:", $supported_return_fields));
		}
	    }

	    #### multi-testing correction
	} elsif ($ARGV[$a] eq "-multi_cor") {
	    $multi_cor = $ARGV[$a+1];
	    unless ($supported_multi_cor{$multi_cor}) {
		&RSAT::error::FatalError(join("\t", $multi_cor, "Invalid multi-testing correction. Supported:", $supported_multi_cor));
	    }
        }
    }
}

################################################################
#### verbose message
sub Verbose {
    print $out "; compare-classes ";
    &PrintArguments($out);
    if (defined(%infile)) {
        print $out "; Input files\n";
        while (($key,$value) = each %infile) {
            print $out ";\t$key\t$value\n";
        }
    }

    ## Number of query classes and elements per class
    printf $out "; %-29s\t%d\n", "Query classes (nq)", $nb_query_classes;
    if ($verbose >= 2) {
	foreach my $f (keys %query_classes) {
	    printf $out ";\t%d\t%s\n", $query_classes{$f}->get_size(), $query_classes{$f}->get_attribute("name");
	}
    }

    printf $out "; %-29s\t%d\n", "Reference classes (nr)", $nb_ref_classes;
    if ($verbose >= 2) {
	foreach my $f (keys %ref_classes) {
	    printf $out ";\t%d\t%s\n", $ref_classes{$f}->get_size(), $ref_classes{$f}->get_attribute("name");
	}
    }

    printf $out "; %-29s\t%d\n", "Comparisons (nq*nr)", $nb_ref_classes*$nb_query_classes;
    if ($return_fields{proba}) {
	printf $out "; %-29s\t%d\n", "Significance tests (nt)", $nb_tests;
    }
    printf $out "; %-24s (%s)\t%d\n", "Multi-testing correction", $multi_cor, $correction;

    printf $out "; %-29s\t%d\n", "Elements  in ref classes", scalar (keys(%ref_member_index));
    printf $out "; %-29s\t%d\n", "Elements in query classes", scalar (keys(%query_member_index));
    printf $out "; %-29s\t%d\n", "Elements in query+ref classes", scalar (keys(%member_index));
    printf $out "; %-29s\t%d\n", "Population size", $population_size;
    printf $out "; %-29s\t%f\n", "Logarithm base for entropy", $base if ($return_fields{entropy});
    print $out "; Sampling with replacement (binommial proba)\n" if ($replacement);
    printf $out "; %-29s\t%s\n", "Sort key", $sort_key if ($sort_key);
    print $out "; Symmetric comparison\n" if ($symmetric);


    print $out "; Thresholds\tlower\tupper\n";
    my %th_keys = (%lth, %uth);
    foreach $f (sort keys %th_keys) {
        print $out ";\t$f";
        if (defined($lth{$f})) {
            printf $out "\t%-5g", $lth{$f};
        } else {
            print $out "\tNA";
        }
        if (defined($uth{$f})) {
            printf $out "\t%-5g", $uth{$f};
        } else {
            print $out "\tNA";
        }
        print $out "\n";
    }

    if (scalar(@matrix_keys) >= 1) {
	print $out "; matrix\t", join ";", @matrix_keys, "\n";
    }

    if (defined(%outfile)) {
        print $out "; Output files\n";
        while (($key,$value) = each %outfile) {
            print $out ";\t$key\t$value\n";
        }
    }
}

################################################################
#### read class file



################################################################
#### compare reference and query classes
sub CompareClasses {
    my $reference_classes = scalar(keys(%ref_classes));
    my $rn = 0;
    
    &RSAT::message::TimeWarn("Comparing classes") if ($main::verbose >= 2);

    if (($multi_cor eq "nc") || ($multi_cor eq "nt")){
	if ($infile{ref_classes} eq $infile{query_classes}) {
	    if ($distinct) {
		$correction = $nb_ref_classes * ($nb_query_classes-1)/2;
	    } else {
		$correction = $nb_ref_classes * ($nb_query_classes+1)/2;
	    }
	} else {
	    $correction = $nb_ref_classes * $nb_query_classes;
	}
    } elsif ($multi_cor eq "nq") {
	$correction = $nb_query_classes;
    } elsif ($multi_cor eq "nr") {
	$correction = $nb_ref_classes;
#    } elsif ($multi_cor eq "nt") {
#		    $correction = $nb_tests;
	$correction = $nb_ref_classes*$nb_query_classes;
    }

    foreach my $r (keys %ref_classes) {
	$rn++;
	
	my %ref_member = ();
	my %not_query = ();


	&RSAT::message::TimeWarn(join ("\t", "Treating reference class" ,$rn, "of", $reference_classes , $r)) if ($main::verbose >= 3);

	################################################################
	#### number of common members 

	#### collect members of the reference class
	my @ref_members = $ref_classes{$r}->get_members();
	my $R = scalar(@ref_members);

	#### check if the number of ref members is above the threshold    
	next if ((defined($lth{R})) && ($R < $lth{R}));
	next if ((defined($lth{'QR'})) && ($R < $lth{'QR'}));
	
	#### index members of the reference class
	foreach $m (@ref_members) {
	    $ref_member{$m} = 1;
	}


	#### query classes
	foreach my $q (keys %query_classes) {
	    
	    &RSAT::message::TimeWarn("Treating query class $q") if ($main::verbose >= 4);
	    
	    next if (($distinct) && ($r eq $q));
	    next if (($infile{ref_classes} eq $infile{query_classes} ) && ($r lt $q)) && $triangle;
	    
	    my $compa_key = $r."__VERSUS__".$q;
	    
	    #### initialize comparison structures
	    @{$common{$compa_key}} = ();
	    @{$R_only{$compa_key}} = ();
	    @{$Q_only{$compa_key}} = ();

	    #### collect members of the query class
	    my @query_members = $query_classes{$q}->get_members();
	    my $Q = scalar(@query_members);

	    #### check if the number of ref members is above the threshold    
	    next if ((defined($lth{'Q'})) && ($Q < $lth{Q}));
	    next if ((defined($lth{'QR'})) && ($Q < $lth{'QR'}));
	    
	    #### compare query and reference classes
	    foreach my $m (@query_members) {
		if ($ref_member{$m}) {
		    push @{$common{$compa_key}}, $m; ### elements common to reference and query class
		    $matching_elements->{$compa_key}->{$m}++;
		} else {
		    push @{$Q_only{$compa_key}}, $m; ### elements found in the query fmily only
		}
	    }
	    
	    #### identify elements found in the reference class only
	    if ($calc_fields{members}) {
		foreach $m (sort($ref_classes{$r}->get_members())) {
		    unless ($matching_elements->{$compa_key}->{$m}) {
			push @{$R_only{$compa_key}}, $m;
		    }
		}
	    }

	    ## QR : intersection between group R and group Q
	    my $QR = scalar(keys %{$matching_elements->{$compa_key}});
	    $compa{$compa_key}->{'R'} = $R;
	    $compa{$compa_key}->{'Q'} = $Q;
	    $compa{$compa_key}->{'QR'} = $QR;

	    my $QvR = $Q + $R - $QR;
	    $compa{$compa_key}->{'QvR'} = $QvR;
	    $compa{$compa_key}->{'R!Q'} = $R - $QR;
	    $compa{$compa_key}->{'Q!R'} = $Q - $QR;
	    $compa{$compa_key}->{'!Q!R'} = $population_size - $QvR;

	    ## Calculate dot product (use only the matching elements -> thus
	    ## must be done here)
	    if ($calc_fields{dotprod}) {
		local $dp = 0;
		local @matching_elements = keys %{$matching_elements->{$compa_key}};
		local %ref_scores = $ref_classes{$r}->get_attribute("scores");
		local %query_scores =$query_classes{$q}->get_attribute("scores");
		foreach my $element (@matching_elements) {
		    my $r_score = $ref_scores{$element};
		    my $q_score = $query_scores{$element};
		    $dp += $r_score*$q_score; 
		}
		$compa{$compa_key}->{dotprod} = $dp;
#		&RSAT::message::Debug("dot product", 
#				      $r, $q, "matching", scalar(@matching_elements),
#				      "dp", $dp) if ($main::verbose >= 0);
	    }

	    ## Suppress the lists of members to free memory if members are
	    ## not required
	    unless ($calc_fields{members}) {
		undef @{$common{$compa_key}};
		undef @{$R_only{$compa_key}};
		undef @{$Q_only{$compa_key}};
		undef $matching_elements->{$compa_key};
	    }

	    #### check thresholds for number of common members
	    if ((defined($lth{'QR'})) &&
		($QR< $lth{'QR'})) {
		delete $compa{$compa_key};
		undef @{$common{$compa_key}};
		undef @{$R_only{$compa_key}};
		undef @{$Q_only{$compa_key}};
		next;
	    } 
	    if ((defined($uth{occ})) &&
		($QR > $uth{occ})) {
		delete $compa{$compa_key};
		undef @{$common{$compa_key}};
		undef @{$R_only{$compa_key}};
		undef @{$Q_only{$compa_key}};
		next;
	    }
	    
	    ## Calculate Jaccard's similarity
	    if ($calc_fields{jac_sim}) {
		if ($QvR > 0) {
		    $compa{$compa_key}->{jac_sim} = $QR/$QvR;
		} else {
		    $compa{$compa_key}->{jac_sim} = "NA";
		}
		if ((defined($lth{jac_sim})) &&
		    ($compa{$compa_key}->{jac_sim}< $lth{jac_sim})) {
		    delete $compa{$compa_key};
		    undef @{$common{$compa_key}};
		    undef @{$R_only{$compa_key}};
		    undef @{$Q_only{$compa_key}};
		    next;
		} 
		if ((defined($uth{jac_sim})) &&
		    ($compa{$compa_key}->{jac_sim} > $uth{jac_sim})) {
		    delete $compa{$compa_key};
		    undef @{$common{$compa_key}};
		    undef @{$R_only{$compa_key}};
		    undef @{$Q_only{$compa_key}};
		    next;
		}
	    }

	    ## ##############################################################	
	    ## Calculate frequencies
	    if ($calc_fields{freq}) {
		warn "; calculating frequencies for ", $compa_key, "\n" if ($verbose >= 5);
		my $n_q = $query_classes{$q}->get_size(); ### number of elements in query class
		my $n_r = $ref_classes{$r}->get_size(); ### number of elements in the reference class
#		my $c = $QR; ### number of common elements

		
		$compa{$compa_key}->{'P(R)'} = $n_r/$population_size;
		$compa{$compa_key}->{'P(Q)'} = $n_q/$population_size;

		$compa{$compa_key}->{'QR/R'} = $QR/$n_r;
		$compa{$compa_key}->{'QR/Q'} = $QR/$n_q;

		#### check thresholds for query freq
		if ((defined($lth{'QR/Q'})) &&
		    ($compa{$compa_key}->{'QR/Q'}< $lth{'QR/Q'})) {
		    delete $compa{$compa_key};
		    undef @{$common{$compa_key}};
		    undef @{$R_only{$compa_key}};
		    undef @{$Q_only{$compa_key}};
		    next;
		} elsif ((defined($uth{'QR/Q'})) &&
			 ($compa{$compa_key}->{'QR/Q'} > $uth{'QR/Q'})) {
		    delete $compa{$compa_key};
		    undef @{$common{$compa_key}};
		    undef @{$R_only{$compa_key}};
		    undef @{$Q_only{$compa_key}};
		    next;
		}

		#### check thresholds for reference freq
		if ((defined($lth{'QR/R'})) &&
		    ($compa{$compa_key}->{'QR/R'}< $lth{'QR/R'})) {
		    delete $compa{$compa_key};
		    undef @{$common{$compa_key}};
		    undef @{$R_only{$compa_key}};
		    undef @{$Q_only{$compa_key}};
		    next;
		} elsif ((defined($uth{'QR/R'})) &&
			 ($compa{$compa_key}->{'QR/R'} > $uth{'QR/R'})) {
		    delete $compa{$compa_key};
		    undef @{$common{$compa_key}};
		    undef @{$R_only{$compa_key}};
		    undef @{$Q_only{$compa_key}};
		    next;
		}

	    }

	    ################################################################
	    ## Entropy
	    if ($calc_fields{entropy}) {
		## Entropy of class Q
		if (($compa{$compa_key}->{'P(Q)'} <= 0) || ($compa{$compa_key}->{'P(Q)'} >= 1)) {
		    $compa{$compa_key}->{'H(Q)'} = 0;
		} else {
		    $compa{$compa_key}->{'H(Q)'} = - $compa{$compa_key}->{'P(Q)'}*log($compa{$compa_key}->{'P(Q)'})/$log_base
			- (1-$compa{$compa_key}->{'P(Q)'})*log(1-$compa{$compa_key}->{'P(Q)'})/$log_base;
		}

		## Entropy of class R
		if (($compa{$compa_key}->{'P(R)'} <= 0) || ($compa{$compa_key}->{'P(R)'} >= 1)) {
		    $compa{$compa_key}->{'H(R)'} = 0;
		} else {
		    $compa{$compa_key}->{'H(R)'} = - $compa{$compa_key}->{'P(R)'}*log($compa{$compa_key}->{'P(R)'})/$log_base
			- (1-$compa{$compa_key}->{'P(R)'})*log(1-$compa{$compa_key}->{'P(R)'})/$log_base;

		}
		
		## Join entropy
		$compa{$compa_key}->{'P(QR)'} = $compa{$compa_key}->{'QR'}/$population_size;
		if (($compa{$compa_key}->{'P(QR)'} <= 0) || ($compa{$compa_key}->{'P(QR)'} >= 1)) {
		    $contrib{'P(QR)'} = 0;
		} else {
		    $contrib{'P(QR)'} = - $compa{$compa_key}->{'P(QR)'}*log($compa{$compa_key}->{'P(QR)'});
		}

		$compa{$compa_key}->{'P(Q!R)'} = $compa{$compa_key}->{'Q!R'}/$population_size;
		if (($compa{$compa_key}->{'P(Q!R)'} <= 0) || ($compa{$compa_key}->{'P(Q!R)'} >= 1)) {
		    $contrib{'P(Q!R)'} = 0;
		} else {
		    $contrib{'P(Q!R)'} = - $compa{$compa_key}->{'P(Q!R)'}*log($compa{$compa_key}->{'P(Q!R)'});
		}

		$compa{$compa_key}->{'P(R!Q)'} = $compa{$compa_key}->{'R!Q'}/$population_size;
		if (($compa{$compa_key}->{'P(R!Q)'} <= 0) || ($compa{$compa_key}->{'P(R!Q)'} >= 1)) {
		    $contrib{'P(R!Q)'} = 0;
		} else {
		    $contrib{'P(R!Q)'} = - $compa{$compa_key}->{'P(R!Q)'}*log($compa{$compa_key}->{'P(R!Q)'});
		}

		$compa{$compa_key}->{'P(!Q!R)'} = $compa{$compa_key}->{'!Q!R'}/$population_size;
		if (($compa{$compa_key}->{'P(!Q!R)'} <= 0) || ($compa{$compa_key}->{'P(!Q!R)'} >= 1)) {
		    $contrib{'P(!Q!R)'} = 0;
		} else {
		    $contrib{'P(!Q!R)'} = - $compa{$compa_key}->{'P(!Q!R)'}*log($compa{$compa_key}->{'P(!Q!R)'});
		}

		$compa{$compa_key}->{'H(Q,R)'} = 
		    ($contrib{'P(QR)'} + $contrib{'P(Q!R)'} + $contrib{'P(R!Q)'} + $contrib{'P(!Q!R)'})/$log_base;

		## Conditional entropy
		$compa{$compa_key}->{'H(Q|R)'} = $compa{$compa_key}->{'H(Q,R)'} - $compa{$compa_key}->{'H(R)'};
		$compa{$compa_key}->{'H(R|Q)'} = $compa{$compa_key}->{'H(Q,R)'} - $compa{$compa_key}->{'H(Q)'};

		## Mutual information
		$compa{$compa_key}->{'I(Q,R)'} = $compa{$compa_key}->{'H(Q)'} + $compa{$compa_key}->{'H(R)'} - $compa{$compa_key}->{'H(Q,R)'};

		## Information content
		my $exp_freq = $compa{$compa_key}->{'P(Q)'}*$compa{$compa_key}->{'P(R)'};
		if ($compa{$compa_key}->{'QR'} <= 0) {
		    $compa{$compa_key}->{'IC'} = 0;
		} else {
		    $compa{$compa_key}->{'IC'} = $compa{$compa_key}->{'P(QR)'} * 
			log(  $compa{$compa_key}->{'P(QR)'} / $exp_freq )/$log_base;
		}
	    }

	    ################################################################
	    #### calculate probabilities
	    if ($calc_fields{proba}) {
		$log_base = 10;
		$ref_log = log($log_base);

		#### check population size
		my $n = $population_size;
		if ($n <= 0) {
		    &RSAT::error::FatalError("Cannot calculate probabilities if reference population is empty");
		}

		#### calculate probabilities of matches
		warn "; calculating proba for ", $compa_key, "\n" if ($verbose >= 5);
		my $n_q = $query_classes{$q}->get_size(); ### number of elements in query class
		my $n_r = $ref_classes{$r}->get_size(); ### number of elements in the reference class
#		my $c = $compa{$compa_key}->{'QR'}; ### number of common elements
		
		#### check number of elements in the reference class
		if ($n_r > $n) {
		    &RSAT::error::FatalError("Number of elements in the reference class ($n_r) cannot be higher than population size ($n)");
		}
		
		#### check number of elements in the query class
		if ($n_q > $n) {
		    &RSAT::error::FatalError("Number of elements in the query class ($n_q) cannot be higher than population size ($n)");
		}
		
		#### check number of common elements
		if ($QR > $n_q) {
		    &RSAT::error::FatalError("Number of common elements ($QR) cannot be higher than query size ($n_q)");
		}
		if ($QR > $n_r) {
		    &RSAT::error::FatalError("Number of common elements ($QR) cannot be higher than reference size ($n_r)");
		}
		
		my $p; ## Proba for a member to be found in common in the two classes
		$nb_tests ++; ## Increment the counter for the number of tests
		if ($replacement) {
		    #### use binomial distribution of there are replacements
		    
		    if ($symmetric) {
			#### test the joint probability to belong to both
			#### query and reference classes, for each element of
			#### the population
			$p = $n_r/$n * $n_q/$n;
			$compa{$compa_key}->{P_val} = &sum_of_binomials($p,$n,$QR,$n);
		    } else {
			#### test the probability to belong to the
			#### reference class, for each element of the
			#### query class
			$p = $n_r/$n;
			$compa{$compa_key}->{P_val} = &sum_of_binomials($p,$n_q,$QR,$n_q);
		    }
		    
		} else{
		    #### use hypergeometric distribution
		    $p = $n_r/$n * $n_q/$n;
		    $compa{$compa_key}->{P_val} = &sum_of_hypergeometrics($n_r, $n, $n_q, $QR, &min($n_r, $n_q));
		    
		}
		$compa{$compa_key}->{'exp_QR'} = $p*$n;
		
		$compa{$compa_key}->{mtest} = $correction;
		$compa{$compa_key}->{E_val} = $compa{$compa_key}->{P_val} * $compa{$compa_key}->{mtest};
		if ($compa{$compa_key}->{E_val} > 0) {
		    $compa{$compa_key}->{sig} = -log($compa{$compa_key}->{E_val})/$ref_log;
		} else {
		    $compa{$compa_key}->{sig} = $inf;
		}
		
		#### check thresholds on probabilities
		foreach my $key (qw(P_val E_val sig)) {
		    if ((defined($lth{$key})) &&
			($compa{$compa_key}->{$key}< $lth{$key})) {
			delete $compa{$compa_key};
			undef @{$common{$compa_key}};
			undef @{$R_only{$compa_key}};
			undef @{$Q_only{$compa_key}};
		    } elsif ((defined($uth{$key})) &&
			     ($compa{$compa_key}->{$key} > $uth{$key})) {
			delete $compa{$compa_key};
			undef @{$common{$compa_key}};
			undef @{$R_only{$compa_key}};
			undef @{$Q_only{$compa_key}};
		    }
		}
	    }
	}
    }
}


## ##############################################################
## Print the result
sub PrintResult {
    
    ################################################################
    ## Print one row per association between a reference and a query class
    if (scalar(keys(%return_fields)) >= 1) {

	#### header
	my @header_fields = ();
	if ($return_fields{rank}) {
	    push @header_fields, ("rank");
	};
	
	push @header_fields, ("ref","query");

	if ($return_fields{occ}) {
	    push @header_fields, "R";
	    push @header_fields, "Q";
	    push @header_fields, "QR";
	    push @header_fields, "QvR";
	    push @header_fields, "R!Q";
	    push @header_fields, "Q!R";
	    push @header_fields, "!Q!R";
	}
	if ($return_fields{freq}) {
	    push @header_fields, 'QR/R' ;
	    push @header_fields, 'QR/Q' ;
	    push @header_fields, 'P(R)' ;
	    push @header_fields, 'P(Q)' ;
	    push @header_fields, "P(QR)";
	    push @header_fields, "P(Q!R)";
	    push @header_fields, "P(R!Q)";
	    push @header_fields, "P(!Q!R)";
	}

	if ($return_fields{jac_sim}) {
	    push @header_fields, "jac_sim" ;
	}

	if ($return_fields{dotprod}) {
	    push @header_fields, "dotprod" ;
	}

	if ($return_fields{proba}) {
	    push @header_fields, "exp_QR" ;
	    push @header_fields, "P_val" ;
#	    push @header_fields, "mtest";
	    push @header_fields, "E_val";
	    push @header_fields, "sig";
	}

	if ($return_fields{entropy}) {
	    push @header_fields, "H(R)";
	    push @header_fields, "H(Q)";
	    push @header_fields, "H(Q,R)";
	    push @header_fields, "H(Q|R)";
	    push @header_fields, "H(R|Q)";
	    push @header_fields, "I(Q,R)";
	    push @header_fields, "IC";
	}

	if ($return_fields{members}) {
#       push @header_fields, "ref_members";
#       push @header_fields, "query_members";
	    push @header_fields, "R_only";
	    push @header_fields, "Q_only";
	    push @header_fields, "common_members";
	}


	## Define header descriptions
	my %field_descrition = ();
	$field_description{'rank'}  = "Rank of the comparison";
	$field_description{'query'}  = "Name of the second class (called class R hereafter)";
	$field_description{'ref'}  = "Name of the first class (called class Q hereafter)";
	$field_description{'Q'}  = "Number of elements in class Q";
	$field_description{'R'} = "Number of elements in class R";
	$field_description{'QR'}  = "Number of elements found in the intersecion between classes R and Q";
	$field_description{'QvR'}  = "Number of elements found in the union of classes R and Q. This is R or Q.";
	$field_description{'R!Q'}  = "Number of elements found in class R but not class Q";
	$field_description{'Q!R'}  = "Number of elements found in the class Q but not in class R";
	$field_description{'!Q!R'}  = "Number of elements of the population (P) found neither in class Q nor in the class R";
	$field_description{'QR/R'} = "Frequency of R elements in the intersection. ";
	$field_description{'QR/Q'}  = "Frequency of Q elements in the intersection. ";
	$field_description{'P(R)'} = "Frequency of R elements relative to population size. P(R)=R/P";
	$field_description{'P(Q)'}  = "Frequency of Q elements relative to population size. P(Q)=Q/P";
	$field_description{'P(QR)'}  = "Frequency of QR elements relative to population size. P(QR)=QR/P";
	$field_description{'P(Q!R)'}  = "Frequency of Q!R elements relative to population size. P(Q!R)=Q!R/P";
	$field_description{'P(R!Q)'}  = "Frequency of R!Q elements relative to population size. P(R!Q)=R!Q/P";
	$field_description{'P(!Q!R)'}  = "Frequency of !Q!R elements relative to population size. P(!Q!R)=!Q!R/P";
	$field_description{'jac_sim'}  = "Jaccard' similarity";
	$field_description{'dotprod'}  = "Dot product (using the score column)";
	$field_description{'exp_QR'}  = "Expected number of elements in the intersection";
	$field_description{'P_val'}  = "P-value of the intersection";
#	$field_description{'mtest'}  = "Correction for the multi-testing.";
	$field_description{'E_val'}  = "E-value of the intersection";
	$field_description{'sig'}  = "Significance of the intersection";
	$field_description{'R_only'}  = "Elements found in the class R only";
	$field_description{'Q_only'}  = "Elements found in the class Q only";
	$field_description{'common_members'}  = "Elements found in both reference and query classes";
	$field_description{'H(Q)'} = "Entropy of class Q. H(Q) = - P(Q)*log[P(Q)] - P(!Q)*log[P(!Q)]";
	$field_description{'H(R)'} = "Entropy of class R. H(R) = - P(R)*log[P(R)] - P(!R)*log[P(!R)]";
	$field_description{'H(Q,R)'} = "Join entropy for classes Q and R. H(Q,R) = - P(QR)*log[P(QR)] - P(Q!R)*log[P(Q!R)] - P(R!Q)*log[P(R!Q)] - P(!Q!R)*log[P(!Q!R)]";
	$field_description{'I(Q,R)'} = "Mutual information of classs Q and R. I(Q,R) = H(Q) + H(R) - H(Q,R)";
	$field_description{'H(Q|R)'} = "Conditional entropy of Q given R. H(Q|R) = H(Q,R) - H(R)";
	$field_description{'H(R|Q)'} = "Conditional entropy of R given Q. H(R|Q) = H(Q,R) - H(Q)";
	$field_description{'IC'} = "Information content (as defined by Schneider, 1986). IC = P(QR) log[P(QR)/P(Q)P(R)]";

	if ($main::verbose >= 1) {
	    print $out "; Column contents\n";
	    foreach my $f (0..$#header_fields) {
		my $field = $header_fields[$f];
		printf $out ";\t%d\t%-14s\t%s\n", $f+1, $field, $field_description{$field};
	    }
	}

	## Print the header row
	print $out "#", join("\t", @header_fields), "\n";

	#### Sort the result
	if ($sort_key eq "name") {
	    ## alphabetical order
	    @sorted_keys = sort (keys %compa); 

	} elsif (($sort_key eq 'E_val') ||
		 ($sort_key eq 'P_val')){
	    ## numerical ascendent
	    @sorted_keys = sort {$compa{$a}->{$sort_key} <=> $compa{$b}->{$sort_key}} (keys %compa); 

	} elsif ($sort_key) {
	    ## numerical descendent
	    @sorted_keys = sort {$compa{$b}->{$sort_key} <=> $compa{$a}->{$sort_key}} (keys %compa); 
	}

	#### class combinations
	my $rank = 0;
	foreach my $compa_key (@sorted_keys) {
	    my ($r, $q) = split "__VERSUS__", $compa_key;
	    $rank++;
	    
	    ## Check thresholds on rank
	    if ((defined($uth{rank})) && ($rank > $uth{rank})) {
		last;
	    }
	    if ((defined($lth{rank})) && ($rank < $lth{rank})) {
		next;
	    }

	    ## Print the rank of the association
	    if ($return_fields{rank}) {
		print $out $rank."\t";
	    }

	    #### reference family name
	    my $r_text = $r;
	    my $rname =  $ref_classes{$r}->get_attribute("name");
	    if ($rname ne $r) {
		## Add class name to class ID
		$r_text .= ":".$rname; 
	    }
	    warn join( "\t", ";ref class", $r, $r_text), "\n" if ($main::verbose >= 10);

	    #### query family name
	    my $q_text = $q;
	    my $qname =  $query_classes{$q}->get_attribute("name");
	    if ($qname ne $q) {
		## Replace class ID by class name
		$q_text .= ";".$qname; 
	    }
	    warn join( "\t", ";query class", $q, $q_text), "\n" if ($main::verbose >= 10);
	    
	    print $out join "\t", ($r_text,
				   $q_text);


	    #### occurrence counts
	    if ($return_fields{occ}) {
		printf $out "\t%d",  $compa{$compa_key}->{'R'};
		printf $out "\t%d",  $compa{$compa_key}->{'Q'};
		printf $out "\t%d",  $compa{$compa_key}->{'QR'};
		printf $out "\t%d",  $compa{$compa_key}->{'QvR'};
		printf $out "\t%d",  $compa{$compa_key}->{'R!Q'};
		printf $out "\t%d",  $compa{$compa_key}->{'Q!R'};
		printf $out "\t%d",  $compa{$compa_key}->{'!Q!R'};
	    }

	    #### Frequencies
	    if ($return_fields{freq}) {
		printf $out "\t%.5f", $compa{$compa_key}->{'QR/R'};
		printf $out "\t%.5f", $compa{$compa_key}->{'QR/Q'};
		printf $out "\t%.5f", $compa{$compa_key}->{'P(R)'};
		printf $out "\t%.5f", $compa{$compa_key}->{'P(Q)'};
		printf $out ( "\t%.5f", $compa{$compa_key}->{'P(QR)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'P(Q!R)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'P(R!Q)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'P(!Q!R)'});
	    }
	    
	    #### Jaccard's similarity
	    if ($return_fields{jac_sim}) {
		printf $out "\t%-.5f", $compa{$compa_key}->{jac_sim};
	    }
	    
	    #### Dot product
	    if ($return_fields{dotprod}) {
		printf $out "\t%7g", $compa{$compa_key}->{dotprod};
	    }

	    #### probabilities
	    if ($return_fields{proba}) {
		printf $out "\t%7.2f", $compa{$compa_key}->{'exp_QR'};

		if ($compa{$compa_key}->{P_val} >= 0.0001) {
		    printf $out "\t%.5f", $compa{$compa_key}->{P_val};
		} else {
		    printf $out "\t%.2g", $compa{$compa_key}->{P_val};
		}

#		printf $out "\t%d", $compa{$compa_key}->{mtest};
		if ($compa{$compa_key}->{E_val} >= 1) {
		    printf $out "\t%7.3f", $compa{$compa_key}->{E_val};
		} elsif ($compa{$compa_key}->{E_val} >= 0.0001) {
		    printf $out "\t%.5f", $compa{$compa_key}->{E_val};
		} else {
		    printf $out "\t%.2g", $compa{$compa_key}->{E_val};
		}
		printf $out ( "\t%.2f", $compa{$compa_key}->{sig});
	    }


	    ## Entropy 
	    if ($return_fields{entropy}) {
		printf $out ( "\t%.5f", $compa{$compa_key}->{'H(Q)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'H(R)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'H(Q,R)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'H(Q|R)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'H(R|Q)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'I(Q,R)'});
		printf $out ( "\t%.5f", $compa{$compa_key}->{'IC'});
	    }

	    #### Members
	    if ($return_fields{members}) {
		print $out "\t", join( " ", @{$R_only{$compa_key}}) ;
		print $out "\t", join( " ", @{$Q_only{$compa_key}}) ;
		print $out "\t", join( " ", @{$common{$compa_key}}) ;
	    }

	    print $out "\n";
	}
    }

    ## ##############################################################
    ## Print the result in the form of a matrix
    if (scalar(@matrix_keys >= 1)) {
	foreach my $matrix_key (@matrix_keys) {
	    &PrintOneMatrix($matrix_key);
	}
    }
	

}


################################################################
#### Create a graph with the result
sub CreateGraph {
    my ($type) = @_;

    my %color = ();

    ## Specify node and arc colors
    if ($type eq "dot") {
	$color{'ref_node'} = "darkgreen";
	if ($infile{ref_classes} eq $infile{query_classes}) {
	    $color{'query_node'} = $color{'ref_node'};
	} else {
	    $color{'query_node'} = "blue";
	}
	$color{'arc'} = "black";
    } else {
	$color{'ref_node'} = "#00BB00";
	if ($infile{ref_classes} eq $infile{query_classes}) {
	    $color{'query_node'} = $color{'ref_node'};
	} else {
	    $color{'query_node'} = "#0000BB";
	}
	$color{'arc'} = "#000000";
    }
    
#    warn join ("\t", $type, values(%color)), "\n";

    my %shape = ();
    $shape{'ref_node'} = "box";
    $shape{'query_node'} = "ellipse";

    my $graph = new RSAT::Graph();
    $graph->set_attribute("label", "compare-classes result");

    #### class combinations
    my %node_obj = (); ## Index of node objects
    foreach my $compa_key (keys %compa) {
	my ($r, $q) = split "__VERSUS__", $compa_key;
	my $ref_id;
	my $query_id;

	## Target node for the association
	if ($infile{ref_classes} eq $infile{query_classes}) {
	    #### ref and query set are identical
	    $ref_id = $r;
	    $query_id = $q;
	} else {
	    #### distinct ID prefixes for references and queries
	    $ref_id = "r_".$r;
	    $query_id = "q_".$q;
	}


	## Source node for the association
	my $source_node;
	if (defined($node_obj{$query_id})) {
	    $source_node = $node_obj{$query_id};
	} else {
	    my @members = $query_classes{$q}->get_members();
	    my $node_label = $query_id." (".scalar(@members).")";
	    $source_node = $graph->create_node(id=>$query_id, 
					       color=>$color{query_node},
					       fontsize=>14,
					       fontcolor=>$color{query_node},
					       shape=>$shape{'query_node'},
					       label=>$node_label);
	    $node_obj{$query_id} = $source_node;
	    &RSAT::message::Info(join("\t", "Created source node", 
				      $q,
				      $query_id,
				      "id=".$source_node->get_attribute("id"), 
				      "label=".$source_node->get_attribute("label"),
				      "color=".$source_node->get_attribute("color"),
				     )) if ($main::verbose >= 3);
	}

	## Target node for the association
	my $target_node;
	if (defined($node_obj{$ref_id})) {
	    $target_node = $node_obj{$ref_id};
	} else {
	    my @members = $ref_classes{$r}->get_members();
	    my $node_label = $ref_id." (".scalar(@members).")";
	    $target_node = $graph->create_node(id=>$ref_id,
					       color=>$color{ref_node},
					       fontsize=>14,
					       fontcolor=>$color{ref_node},
					       shape=>$shape{'ref_node'},
					       label=>$node_label);
	    $node_obj{$ref_id} = $target_node;
	    &RSAT::message::Info(join("\t", "Created target node", 
				      $r,
				      "id=".$target_node->get_attribute("id"), 
				      "label=".$target_node->get_attribute("label"),
				      "color=".$source_node->get_attribute("color"),
				     )) if ($main::verbose >= 3);
	}

	my $arc_label = ();
	$arc_label .= $compa{$compa_key}->{'QR'};
	if ($return_fields{proba}) {
	    $arc_label .= " (";
	    $arc_label .= sprintf("%.1f", $compa{$compa_key}->{sig});
	    $arc_label .= ")";
	}
	$graph->create_arc($source_node, $target_node, label=>$arc_label);
    }
    
    return $graph;
}

################################################################
## Print one comparison matrix
sub PrintOneMatrix {
    my ($matrix_key) = @_;

    my @query_classes = sort keys %query_classes;

    ## Print the matrix type
    print $out "; Matrix", "\t", $matrix_key, "\n";
    
    ## Print the matrix header
    my $header = "#fam";
    if ($infile{qnames}) {
	## replace class IDs by class names
	foreach my $class (@query_classes) {
	    my $qname = $query_class{$class}->get_attribute("name");
	    if (defined($qname)) {
		$header .= "\t".$qname; 
	    } else {
		&Warning("There is no name associated to query class $r\n", 1),
		$header .= "\t".$class; 
	    }
	}
    } else {
	$header .= "\t";
	$header .= join "\t", @query_classes;
    }
    
    $header .= "\n";
    print $out $header;
    
    #### print the matrix
    my $field_format = $field_formats{$matrix_key};
    foreach my $r (sort keys %ref_classes ) {
	if ($infile{rnames}) {
	    my $rname =  $ref_classes{$r}->get_attribute("name");
	    if ($rname) {
		## Replace class ID by class name
		print $out $rname; 
	    } else {
		&Warning("There is no name associated to reference class $r\n", 1),
		print $out $r;
	    }
	} else {
	    print $out $r;
	}
	foreach my $q (sort keys %query_classes ) {
	    my $compa_key = $r."__VERSUS__".$q;
#		die "HELLO", $matrix_key;
	    if (defined($compa{$compa_key}->{$matrix_key})) {
		print $out "\t", sprintf($field_format, $compa{$compa_key}->{$matrix_key});
	    } else {
		print $out "\t", $null;
	    }
	}
	print $out "\n";
    }
}
