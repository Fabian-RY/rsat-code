################################################################
## cluster_motifs.R
##
## This script takes as input a matrix comparison file (that can be
## generated by compare-matrices), performs hierarchical
## clustering.
##
## It returns the resulting tree in json format, which can be loaded
## by the d3 library for display purposes.

## TO DO
## - Define an argument infile.consensus, providing a 3-columns file with the logo ID + its consensus in direct and reverse complementary strands. This consensus file should be exported by comapre-matrices.
## -> this consensus could e used to display trees in R, without requiring the


### Install rjson package
# install.packages("RJSONIO")
library("RJSONIO")
library("ctc")
library("reshape")

## Redefine the main directory (this should be adapted to local configuration)
dir.main <- getwd()

dir.rsat <- Sys.getenv("RSAT");
if (dir.rsat == "") {
  stop("The environment variable RSAT is not defined.")
}

## Load some libraries
source(file.path(dir.rsat, 'R-scripts/config.R'))
#source(file.path(dir.util, 'util.R'))
#source(file.path(dir.util, 'util_plots.R'))
#source(file.path(dir.util, 'util_chip_analysis.R'))


## Options
plot.tree <- FALSE
export <- 'json'


#################
### Functions ###
#################

#################################################################################
## Etxract the tree from an hclust object and convert it into json object.
createLeafNode <- function(hclust, i) {
  list(label = hclust$labels[[i]],
       order = hclust$order[[i]])
}
hclustToTree <- function(hclust) {
  if (length(hclust$merge) == 0)
    return(NULL)
  merges <- list()
  for (index in 1:nrow(hclust$merge)) {
    left <- hclust$merge[index, 1]
    right <- hclust$merge[index, 2]
    if (left < 0)
      left <- createLeafNode(hclust, -left)
    else
      left <- merges[[left]]
    if (right < 0)
      right <- createLeafNode(hclust, -right)
    else
      right <- merges[[right]]
    if (left$order > right$order) {
      tmp <- left
      left <- right
      right <- tmp
    }
    merges[[index]] <- list(
                            children = list(
                              left,
                              right
                              ),
                            order = left$order
                            )
  }
  return(merges[nrow(hclust$merge)])
}

################################################################
## Read arguments from the command line.
##
## Arguments passed on the command line will over-write the default
## arguments specified above.
args = commandArgs(trailingOnly=TRUE);
print("Parsing command-line arguments")
if (length(args >= 1)) {
  print(args)
  for(i in 1:length(args)){
    eval(parse(text=args[[i]]))
  }
}

################################################################
## Check parameter values

## Check that input file has been specified
if (!exists("infile")) {
  stop("Missing mandatory argument: infile=[matrix_comparison_table] ")
}
verbose(paste("Input file", infile), 1)

## Check that description file
if (!exists("description.file")) {
  stop("Missing mandatory argument: description.file=[matrix_description_table] ")
}
verbose(paste("Description file", description.file), 1)

## Check that output file has been specified
if (!exists("outfile")) {
  stop("Missing mandatory argument: outfile=[json_tree_file] ")
}
verbose(paste("Output file", outfile), 1)



## Check that output file has been specified
if (!exists("distance.table")) {
  distance.table <- paste(sep="", outfile, "_dist_table.tab")
}
verbose(paste("Distance table", distance.table), 1)

## Default score is the normalized correlation
if (!exists("score")) {
  score <- "Ncor";
}

#infile <- "/home/jaimecm/Documents/TAGC/Clustering_test/Prueba_Jacques/results/Testing_10_02_2014_pairwise_compa.tab"
# description.file <- "/home/jaimecm/Documents/TAGC/Clustering_test/Prueba_Jacques/results/Testing_10_02_2014_pairwise_compa_matrix_descriptions.tab"

##################################
## Read matrix comparison table
compare.matrices.table <- read.csv(infile, sep = "\t", comment.char = ";")
names(compare.matrices.table)[1] <- sub("^X.", "", names(compare.matrices.table)[1])


################################################################
## Read description table 
description.table <- read.csv(description.file, sep = "\t", comment.char = ";")
matrix.labels <-  as.vector(description.table$label)
names(matrix.labels) <- as.vector(description.table$id)

##############################################
## Extract the score from the matrix comparison table

## Check that the compare-matrices table contains the required score column
if (length(grep(pattern=score, names(compare.matrices.table))) < 1) {
  stop(paste(sep="", "Input file (", infile, ") does not contain the score column (", score, ")."))
}

## Extract score values
score.values <- compare.matrices.table[,score]

## Convert scores to distance metrices
##
## Each score requires to be treated according to its nature
## (similarity or distance) plus some specificities (correlation goes
## from -1 to 1, ...).

## Similarity sores bounded to 1
if ((score == "Ncor")
    || (score=="cor")
    || (score=="logocor")
    || (score=="Nlocogor")
    || (score=="Icor")
    || (score=="NIcor")
    ) {
  ## cor 			Pearson correlation (computed on residue occurrences in aligned columns)
  ## Ncor 			Relative width-normalized Pearson correlation
  ## logocor 			correlation computed on sequence logos
  ## Nlogocor 			Relative width-normalized logocor
  ## Icor 			Pearson correlation computed on Information content
  ## NIcor 			Relative width-normalized Icor
  score.dist <- 1 - score.values

} else if ((score == "logoDP")
           || (score == "cov")) {
  ## logoDP 			dot product of sequence logos
  ## cov 			covariance between residues in aligned columns
  
  stop("logoDP and cov scores are not supported yet")
  
} else if ((score == "dEucl")
           || (score == "NdEucl")
           || (score == "NdEucl")
           || (score == "NsEucl")
           || (score == "SSD")
           || (score == "SW")
           || (score == "NSW")
           ) {
  ## dEucl 			Euclidian distance between residue occurrences in aligned columns
  ## NdEucl 			Relative width-normalized dEucl
  ## NsEucl 			similarity derived from Relative width-normalized Euclidian distance
  ## SSD 			Sum of square deviations
  ## SW 			Sandelin-Wasserman
  ## NSW 			Relative width-normalized Sandelin-Wasserman

  score.dist <- score.values
  
} else if (score == "match_rank") {
  ## match_rank rank of current match among all sorted matches
  stop("match_rank score is not supported yet")

} else {
  stop(paste(score, "is not a valid score", sep="\t"))
}

## Add a column with score column to the compare matrices table, will
## be used to generate a cross-table
compare.matrices.table$score.dist <- score.dist

################################################################
## Build a distance matrix from the distance score list
dist.table <- t(xtabs(score.dist ~ name1+name2, compare.matrices.table) )
## Ensure that symmetrical distances are defined
for (i in 1:nrow(dist.table)) {
  for (j in i:ncol(dist.table)) {
    if (i==j) {next}
    dist.max <- max(dist.table[i,j], dist.table[j,i])
    dist.table[i,j] <- dist.max
    dist.table[j,i] <- dist.max
  }
}
print(dist.table)
write.table(dist.table, file = distance.table, quote = FALSE, row.names = TRUE, col.names=NA, sep = "\t")

## Convert distance table into a distance matrix, required by hclust()
dist.matrix <- as.dist(dist.table)

################
### Inefficient (but probably more robust) way to build a distance matrix, involving two loops
## matrix.names <- sort(unique(as.vector(as.matrix((compare.matrices.table[,c(1,2)])))))
## matrix.nb <- length(matrix.names)
## dist.matrix <- data.frame(matrix(NA, nrow=matrix.nb, ncol=matrix.nb))
## names(dist.matrix) <- matrix.names
## rownames(dist.matrix) <- matrix.names
## for (i in 1:matrix.nb) {
##   for (j in i:matrix.nb) {
##     ## Identify the relevant rows in matrix comparison table
##     matrix.id1 <- matrix.names[i]
##     matrix.id2 <- matrix.names[j]
##     matches <- ((compare.matrices.table[,1] == matrix.id1 & compare.matrices.table[,2] == matrix.id2) |
##                 (compare.matrices.table[,1] == matrix.id2 & compare.matrices.table[,2] == matrix.id1))
##     if (sum(matches) >= 1) {
##       current.score <- compare.matrices.table[which(matches),score]
##     } else {
##       current.score <- "NA"
##     }    
##     dist.matrix[i,j] <- current.score
##     dist.matrix[j,i] <- current.score
##   }
## }


##############################################
### Runs and plot the hierarchical cluster
tree <- hclust(dist.matrix)
tree$labels <- as.vector(description.table$label)
if (plot.tree) {plot(tree) }
if (export == "newick") {
  newick.file <- sub('.json', '', outfile)
  newick.file <- paste(sep='.', newick.file, "newick")
  write(hc2Newick(tree, flat = TRUE), file=newick.file)
}

#######################################
### Creates and parse the json file
halfway <- hclustToTree(tree)
jsonTree <- toJSON(halfway)
## Fix some little technical issues for JSON compatibility with the tree display javascript
jsonTree <- gsub("\\],", "\\]", jsonTree, perl = TRUE)
jsonTree <- paste("{\n\"name\": \"\",\n\"children\":", jsonTree, "}", sep = "")
jsonTree <- gsub("\n\"order\":\\s+\\d+", "", jsonTree, perl = TRUE)
#jsonTree <- gsub(",\\s*\n\\s*}", "\n}", jsonTree, perl = TRUE)


#############################
### Prints the .json file 
writeLines(jsonTree, outfile)

verbose(paste("JSON tree file", outfile), 1)

## ################################
## ## Convert distance matrix (one row per motif x one column per motif)
## ## into a distance table, with one row per matrix pair.
## m <- as.matrix(dist.matrix)
## row.names(m) <- as.vector(description.table$label)
## colnames(m) <- as.vector(description.table$label)
## m2 <- melt(m)[melt(upper.tri(m))$value,]
## names(m2) <- c(";label1", "label2", "distance")
## write.table(m2, file = distance.table, quote = FALSE, row.names = FALSE, sep = "\t")
