#!/usr/bin/perl -w

## TO DO: calculate GC content of the motif in parameters

############################################################
#
# $Id: convert-matrix,v 1.14 2006/08/01 04:38:13 jvanheld Exp $
#
# Time-stamp: <2002-06-06 13:14:17 jvanheld>
#
############################################################
#use strict;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
    require "RSA.lib";
}
use RSAT::matrix;

#### initialise parameters ####
my $start_time = &AlphaDate();
$decimals = 4;
$pseudo_weight = 1;
$max_profile = 10;
$sep="\t";

local %infile = ();
local %outfile = ();
#local $infile{input} = "";
#local $outfile{output} = "";
local $input_format = "";
local $output_format = "patser";
local $verbose = 0;
local $out = STDOUT;

## Return type(s)
@return_types = ();
%supported_return_type = (
			    "profile"=>1,
			    "counts"=>1,
			    "frequencies"=>1,
			    "weights"=>1,
			    "information"=>1,
			    "parameters"=>1,
			    "consensus"=>1,
			    "margins"=>1
			    );
$supported_return_types = join ",", sort keys %supported_return_type;

## input formats
%supported_input_format = ('consensus'=>1,
			   'tab'=>1,
			   'meme'=>1,
			   'gibbs'=> 1,
			   'clustal'=>1);
$supported_input_formats = join ",", sort keys %supported_input_format;

## output formats
%supported_output_format = ('patser'=>1,
			    "MotifSampler"=>1);
$supported_output_formats = join ",", sort keys %supported_output_format;

&ReadArguments();

################################################################
#### check argument values ####


## Input format
unless ($input_format) {
    &RSAT::error::FatalError("You should specify the input matrix format.");
}

## return type(s)
local %return_types = ();
&RSAT::error::FatalError("You should define at least one return type") unless (@return_types);
foreach my $format (@return_types) {
    if ($supported_return_type{$format}) {
	$return{$format}++;
    } else {
	&RSAT::error::FatalError("Invalid return type $format. Supported: ".$supported_return_types);
    }
}


## Prior residue frequencies
if ($prior_file) {
    %prior = ();
    &ReadExpectedFrequencies($prior_file, 1, 1);    
    foreach my $key (sort keys %patterns) {
	my $residue = lc($key);
	$prior{$residue} = $patterns{$key}->{exp_freq};
#	&RSAT::message::Debug("residue", $residue, "prior", $prior{$residue}) if ($main::verbose >= 10);
    }
}

################################################################
#### Perform the conversion


### open output file ###
$out = &OpenOutputFile($outfile{output});

#### verbose ####
my @residues = ();
##my @matrix = ();
my $current_matrix = new RSAT::matrix();
$current_matrix->readFromFile($infile{input}, $input_format);
if ($prior_file) { $current_matrix->setPrior(%prior) };
$current_matrix->set_attribute("pseudo", $pseudo_weight);
$current_matrix->push_attribute("parameters", "pseudo");
$current_matrix->force_attribute("decimals", $decimals);
$current_matrix->force_attribute("max_profile", $max_profile);
$current_matrix->force_attribute("sep", $sep);
# $current_matrix->force_attribute("col_width", $col_width);
$current_matrix->force_attribute("margins", $return{margins});

##### print output ######
&Verbose if ($verbose);

## Print the profile matrix
if ($return{profile}) {
    print $out $current_matrix->toString(sep=>"\t",
					 type=>"profile",
					 format=>$output_format,
					 );
}


## Print the counts matrix
if ($return{counts}) {
    print $out $current_matrix->toString(sep=>"\t",
					 type=>"counts",
					 format=>$output_format,
					 );
}

## Calculate frequency matrix
if ($return{frequencies}) {
    $current_matrix->calcFrequencies();
    print $out $current_matrix->toString(col_width=>($decimals+4), 
					 decimals=>$decimals, 
					 type=>"frequencies",
					 format=>$output_format);
}

## Calculate weight matrix
if ($return{weights}) {
    $current_matrix->calcWeights();
    print $out $current_matrix->toString(col_width=>($decimals+4), 
					 decimals=>$decimals, 
					 type=>"weights",
					 format=>$output_format);
}

## Calculate information content matrix
if ($return{information}) {
    $current_matrix->calcInformation();
    print $out $current_matrix->toString(col_width=>($decimals+4), 
					 decimals=>$decimals, 
					 type=>"information",
					 format=>$output_format);
}


## Calculate consensus
if ($return{consensus}) {
    $current_matrix->calcConsensus();
    print $out "; consensus\t", $current_matrix->get_attribute("consensus.IUPAC"), "\n";
}

## Return parameters
if ($return{parameters}) {
    $current_matrix->calcConsensus();
    print $out $current_matrix->toString(type=>"parameters");
}

##### closing verbose
if ($verbose) {
  my $done_time = &AlphaDate;
  print $out "; Job started $start_time\n";
  print $out "; Job done    $done_time\n";
}


##### close output file
close $out if ($outfile{output});


exit(0);

################################################################
#################### subroutine definition #####################
################################################################

################################################################
## Display full help message 
sub PrintHelp {
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	convert-matrix

        1999 by Jacques van Helden (jvanheld\@scmbb.ulb.ac.be)
	
USAGE
        convert-matrix [-i inputfile] [-o outputfile] [-v]

DESCRIPTION

	Read a position-specific scoring matrix (PSSM) from different
	formats, and exports it in a format that can be used by the
	matrix matching program patser (Hertz et al, 1999).

	The program also converts the original matrix to provide
	different position-specific scores (weight, frequencies,
	information contents), general statistics (E-value, total
	information content), and synthetic descriptions (consensus).

	PSSM can be used to represent the binding specificity of a
	transcription factor or the conserved residues of a protein
	domain.

	Each row of the matrix corresponds to one residue (nucleotide
	or amino-acid depending on the sequence type).  Each column
	corresponds to one position in the alignment.  The value
	within each cell represents the frequency of each residue at
	each position.

CATEGORY
	util
	conversion
	sequences

OPTIONS
	-h	display full help message
	-help	display options
	-v	verbose

	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.

	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.

	-prior prior frequency file
		File indicating prior residue frequencies
		If no prior frequency file is specified, prior
		frequencies are read from the input file. In case this
		file does not contain any indication of prior
		frequencies, equal priors are assumed.

	-in_format	
		input matrix format
		Supported: $supported_input_formats

	-return	return type
		Supported: $supported_return_types

		convert-matrix allows to perform various conversions, starting
		from an input occurrence matrix, in order to obtain various
		statistics such as frequencies, weights, information contents,
		.... The supported return types are described in detail below.

	-out_format	
		output matrix format. 
		Supported: $supported_output_formats

		The option -out_format allows to export the matrix in
		different formats in order to use it as input for various
		pattern matching programs (e.g. patser, MotifScanner, ...).

		The option -return allows to specify the matrix content, the
		option -out_format its format. 

		Beware: each of these programs expectes to find a specific
		type of information in the matrix. For instance, patser uses a
		matrix of counts (or optionnally weights), whereas
		MotifScanner uses a frequency matrix. 
		
		In order to use a matrix as input for another program, the
		verbosity should be set to 0, in order to avoid comment lines
		(which would be misinterpreted by other programs).
		
		Recommended combinations of parameters
		
		Input for patser
		      -return counts -out_format patser -v 0
		
		Input for MotifScanner
		      -return frequencies -out_format MotifScanner -v 0

	-pseudo	
		pseudo-weight used for the calculation of the weight
		matrix (default: $pseudo_weight)

	-decimals
		number of decimals to print for real matrices
		(frequencies, weights, information)

	-max_profile
		Maximal width of the profile histogram (units = number
		of characters).

PRIOR FREQUENCY FILE

      The prior frequency file is a tab-delimited text file with one
      row per residue, and two columns. The first column indicates the
      residue, the second column its prior frequency.

      Prior frequency files can be generated with the program
      oligo-analysis.
      
      oligo-analysis -i reference-seq.fasta -l 1 -return freq -1str -v 1

INPUT FORMATS
    consensus
	Output file from consensus, the pattern-discovery program
	developed by Jerry Hertz (Hertz et al., Comput Appl Biosci,
	1990:6, 81-92).

    tab
	tab-delimited file. One row per residue, one column per
	position. The first letter of each row indicates the residue.

    gibbs
	Output file from gibbs, the pattern-discovery program
	developed by Andrew Neuwald (Lawrence et al. Science, 1993:
	262, 208-214; Neuwald, et al. Protein Sci, 1995: 4, 1618-1632)

    meme
	Output file from MEME, the pattern-discovery program developed by
	tim Bailey.
    
    MotifSampler
	Output file from MotifSampler, the pattern-discovery program
	developed by Gert Thijs (Thijs et al. Bioinformatics, 2001:17,
	1113-1122).

    clustal
	The popular multiple alignemnt program clustalw. 

OUTPUT FORMATS
    counts
        Each cell of the matrix indicates the number of occurrences of the
        residue at a given position of the alignment.

    profile
	The matrix is printed vertically (each matrix column becomes a
	row in the output text). Additional parameters are indicated
	besides each position, and a histogram is drawed.

    crude frequencies
        Relative frequencies are calculated as the counts of residues
        divided by the total count of the column.

        Fij=Cij/SUMi(Cij)

        where

        Cij is the absolute frequency (counts) of residue i at position j of
            the alignment

        Fij is the relative frequency of residue i at position j of the
            alignment

    frequencies corrected with pseudo-weights
        Relative frequencies can be corrected by a pseudo-weight (b) to
        reduce the bias due to the small number of observations.

        F\'ij=Cij+b*Pi/[SUMi(Cij)+b]

        where

        Pi  is the prior frequency for residue i

        b   is the pseudo-weight, which is "shared" between residues
            according to their prior frequencies.

    weights
        Weights are calculated according to the formula from Hertz (1999),
        as the natural logarithm of the ratio between the relative frequency
        (corrected for pseudo-weights) and the prior residue probability.

        Wij=ln(F\'ij/Pi)

    information
        The crude information content is calculated according to the formula
        from Hertz (1999).

        Iij = Fij*ln(Fij/Pi)

        In addition, we calculate a "corrected" information content which
        takes pseudo-weights into account.

        I\'ij = F\'ij*ln(F\'ij/Pi)

	One advantage of the corrected information content is that it
	assigns finite values when Fij=0.

    margins
	Calculate marginal values (column and row sum, min, max) for each 
        matrix.

    parameters
        Returns a series of parameters associated to the matrix. The
        list of parameters to be exported depends on the input formats
        (each pattern discovery program returns specific parameters,
        which are more or less related to each others but not
        identical).

        Some additional parameters are optionally calculated

        consensus
            The degenerate consensus is calculated by collecting, at each
            position, the list of residues with a positive weight.
            Contrarily to most applications, this consensus is thus weighted
            by prior residue frequencies: a residue with a high frequency
            might not be represented in the consensus if this frequency does
            not significantly exceed the expected frequency. Uppercases are
            used to highlight weights >= 1.

            The consensus is exported as regular expression, and with the
            IUPAC code for ambiguous nucleotides
            (http://www.chem.qmw.ac.uk/iupac/misc/naseq.html).

                    A                       (Adenine) 
                    C                       (Cytosine)
                    G                       (Guanine)
                    T                       (Thymine)
                    R       = A or G        (puRines)
                    Y       = C or T        (pYrimidines)
                    W       = A or T        (Weak hydrogen bonding)
                    S       = G or C        (Strong hydrogen bonding)
                    M       = A or C        (aMino group at common position)
                    K       = G or T        (Keto group at common position)
                    H       = A, C or T     (not G)
                    B       = G, C or T     (not A)
                    V       = G, A, C       (not T)
                    D       = G, A or T     (not C)
                    N       = G, A, C or T  (aNy)

            The strict consensus indicates, at each position, the residue
            with the highest positive weight.

        information
            The total information is calculated by summing the
            information content of all the cells of the matrix. This
            parameters is already returned by the program consensus
            (Hertz), but not by other programs.

End_of_help
  close HELP;
  exit(0);
}

################################################################
## Display short help message
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
convert-matrix options
----------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-i		input file
-o		output file
-v		verbose
-in_format	input matrix format. Supported: $supported_input_formats
-out_format	output matrix format. Supported: $supported_output_formats
-return		return type(s). Supported: $supported_return_types
-prior 		prior frequency file
-pseudo		pseudo-weight (default: $pseudo_weight)
-decimals	number of decimals digits to print for real matrices
-max_profile	Maximal width of the profile histogram 
End_short_help
  close HELP;
  exit(0);
}


################################################################
## Read arguments
sub ReadArguments {
  foreach my $a (0..$#ARGV) {
    ### verbose ###
    if ($ARGV[$a] eq "-v") {
      if (&IsNatural($ARGV[$a+1])) {
	$verbose = $ARGV[$a+1];
      } else {
	$verbose = 1;
      }
      
      ### detailed help
    } elsif ($ARGV[$a] eq "-h") {
      &PrintHelp();
      
      ### list of options
    } elsif ($ARGV[$a] eq "-help") {
      &PrintOptions();
      
      ### input file 
    } elsif ($ARGV[$a] eq "-i") {
      $infile{input} = $ARGV[$a+1];
      
      ### prior frequency file
    } elsif ($ARGV[$a] eq "-prior") {
	$prior_file = $ARGV[$a+1];

      ### output file 
    } elsif ($ARGV[$a] eq "-o") {
      $outfile{output} = $ARGV[$a+1];
      
      ### return type(s)
    } elsif ($ARGV[$a] eq "-return") {
      my $return_types = $ARGV[$a+1];
      push @return_types, split(",", $return_types);


      ### input format 
    } elsif ($ARGV[$a] eq "-in_format") {
      $input_format = $ARGV[$a+1];
      unless ($supported_input_format{$input_format}) {
	  &RSAT::error::FatalError("$input_format\tInvalid format for input matrix\tSupported: $supported_input_formats");
      }

      ### Obsolete option for the input format 
    } elsif ($ARGV[$a] eq "-format") {
	&RSAT::message::Warning("Option -format is obsolete. Use -in_format instead.");
	$input_format = $ARGV[$a+1];
	unless ($supported_input_format{$input_format}) {
	    &RSAT::error::FatalError("$input_format\tInvalid format for input matrix\tSupported: $supported_input_formats");
	}

      ### output format 
    } elsif ($ARGV[$a] eq "-out_format") {
      $output_format = $ARGV[$a+1];
      unless ($supported_output_format{$output_format}) {
	  &RSAT::error::FatalError("$output_format\tInvalid format for output matrix\tSupported: $supported_output_formats");
      }

      ### pseudo-weight
    } elsif ($ARGV[$a] eq "-pseudo") {
      $pseudo_weight = $ARGV[$a+1];
      unless (&IsReal($pseudo_weight)) {
	  &RSAT::error::FatalError("Invalid pseudo-weight $pseudo_weight. Must be a real value");
      }

      ### decimals
    } elsif ($ARGV[$a] eq "-decimals") {
      $decimals = $ARGV[$a+1];
      unless (&IsNatural($decimals)) {
	  &RSAT::error::FatalError("Invalid decimals $decimals. Must be a natural value");
      }

      ### max_profile
    } elsif ($ARGV[$a] eq "-max_profile") {
      $max_profile = $ARGV[$a+1];
      unless (&IsNatural($max_profile)) {
	  &RSAT::error::FatalError("Invalid max_profile $max_profile. Must be a natural value");
      }

    }
  }
}

################################################################
## Print verbosity
sub Verbose {
  print $out "; convert-matrix ";
  &PrintArguments($out);
  if (defined(%infile)) {
    print $out "; Input files\n";
    while (($key,$value) = each %infile) {
      print $out ";\t$key\t$value\n";
    }
  }
  if (defined(%outfile)) {
    print $out "; Output files\n";
    while (($key,$value) = each %outfile) {
      print $out ";\t$key\t$value\n";
    }
  }

  printf $out "%-22s\t%d\n", "; pseudo-weight", $pseudo_weight;
}
