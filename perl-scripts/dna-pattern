#!/usr/bin/perl

### CVS: added the option -mask

############################################################
#
# $Id: dna-pattern,v 1.46 2006/06/10 22:20:58 jvanheld Exp $
#
# Time-stamp: <2003-08-13 12:16:03 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require RSAT::pattern;
require RSAT::match;
&InitMatchScores();

$start_date = &AlphaDate();

#### init variables ####
@matches = (); ## Empty match list before analyzing the next sequence
$merge_matches = 0;
$pattern_score = 1;
$noid = 0;
$limits = 0;
$strands_to_search = "DR";
$in_format = "fasta";
$match_format = "table";
#$search_method = "IUPAC";
$search_method = "regexp";

if ($HelpRequested) {
    &Help;
    exit;
}


&ReadArguments();

################################################################
#
# check parameter values 
#

#### return values
unless (defined(%return)) {
    $return{match_positions} = 1;
}

#### top scores only valid with sliding window
if (($return{top} ) && !($search_method eq "sliding window")) {
    &RSAT::error::FatalError("The option -top is only vlid with the option -window\n");
}
if (($sort ) && !($return{top})) {
    &RSAT::error::FatalError("The option -sort is only vlid with the option -top\n");
}

#### check allowed substitutions ####
unless (($allowed_subst eq "") || (&IsNatural($allowed_subst))) {
    &RSAT::error::FatalError("Invalid number of allowed substitutions.\n");
}

### check input format 
&CheckInputSeqFormat($in_format);

@patterns = &ReadPatterns(pattern_file=>$pattern_file, 
			  score_column=>$score_column, 
			  noid=>$noid,
			  pattern_score=>$pattern_score,
			  pattern_id=>$pattern_id,
			  pattern_seq=>$pattern_seq,
			  );
@patterns = sort {$b->get_attribute("score") <=> $a->get_attribute("score")} @patterns;


#### check patterns
if ($main::verbose >= 2) {
    warn "Patterns\n";
    foreach my $pattern (@patterns) {
	warn join ("\t", 
		   $pattern->get_attribute("sequence"),
		   $pattern->get_attribute("id"),
		   $pattern->get_attribute("score"),
		   ), "\n";
    }
}

### no pattern specified
if ($#patterns < 0) {
    &Warning("There is not a single pattern.") ;
    exit(0);
}

#### prepare pattern hash for sliding window 
%pattern_scores = ();
%pattern_lengths = ();
if ($search_method eq "sliding window") {
    #### calculate pattern length
    my $first_pattern_seq =  $patterns[0]->get_attribute("sequence");
    $pattern_length = length($first_pattern_seq);

    foreach my $pattern (@patterns) {
	my $pattern_seq = lc($pattern->get_attribute("sequence"));
	
	#### index pattern length
	$pattern_lengths{length($pattern_seq)}++;
	
	#### check pattern length
#	if (length($pattern_seq) != $pattern_length) {
#	    &RSAT::error::FatalError("With the sliding window option, all patterns must have the same length");
#	}
	
	#### check non-degeneracy
	if ($pattern_seq =~ /[^acgt]/i) { &RSAT::error::FatalError("With the sliding window option, only non-degenerate DNA alphabet is supported [ACGT]\n") };

	#### index pattern score
	my $pattern_score = $pattern->get_attribute("score");
	$pattern_scores{$pattern_seq} = $pattern_score;
    }

    #### two strand search
    if ($strands_to_search eq "DR") {
	foreach my $pattern_seq (keys %pattern_scores) {
	    $pattern_scores{lc(&ReverseComplement($pattern_seq))} = $pattern_scores{$pattern_seq};
	}
	$strand = "DR";
    } else {
	$strand = "D";
    }

    #### create an object for the composite pattern
    $pattern = new RSAT::pattern(id => "composite",
				 sequence => "*composite*",
				 score => $pattern_score,
				 min_length=>&min(keys(%pattern_lengths)),
				 max_length=>&max(keys(%pattern_lengths)),
				);

}

### open output file ###
$out = &OpenOutputFile($outputfile);

&Verbose if ($verbose >=1);

#### search ###
### open sequence file ###
($in, $input_dir) = &OpenInputFile($inputfile);

### read input sequences
while ((($current_seq, $sequence_id, @comments) = &ReadNextSequence($in, $in_format, $input_dir, "", $mask)) &&
       (($current_seq) || ($sequence_id))) {
    push @sequence_ids, $sequence_id;

    #### remove tabs and blank spaces ####    
    $current_seq = &FoldSequence($current_seq, 0);
    
    $sequence_length = length($current_seq);


    #### verbose
    $s++;
    &RSAT::message::Info(join ("\t", "; Scanning sequence", $s, $sequence_id, $sequence_length)) if ($verbose >= 2);
    
#    &RSAT::message::Debug($sequence_id, $current_seq) if ($main::verbose >= 10);
    
    if (($origin <  0) || ($origin eq "-0")) {
	$orig_pos = $sequence_length + $origin + 1; 
    } else {
	$orig_pos = $origin;
    }
    
    ## Print sequence limits
    &PrintSequenceLimits($sequence_id, $sequence_length, $orig_pos) if ($limits);

    if ($search_method eq "sliding window") {
	&SlidingWindowSearch();
	
    } else {
	foreach $pattern (@patterns) {
	    $expression = $pattern->get_attribute("sequence");
	    $expression =~ tr/a-z/A-Z/;
	    $pattern_length = length($expression);
	    $D_regular_expression = &IUPAC_to_regular($expression);
	    $R_regular_expression = &ReverseComplement($D_regular_expression);
	    $RC_pattern = &ReverseComplement($expression);
	    
	    $match_count = 0;
	    #### palindromic patterns are searched only  on one strand 
	    if (($expression eq &ReverseComplement($expression)) && 
		($strands_to_search eq "DR")) {
		$regular_expression = $D_regular_expression;
		$strand = "DR";
		if ($search_method eq "regexp") {
		    &RegExpSearch($current_seq, $regular_expression);
		} else {
		    &IUPACsearch();
		}
	    } else { 
		#### search on direct strand
		if ($strands_to_search =~ /D/) {
		    $regular_expression = $D_regular_expression;
		    $strand = "D";
		    if ($search_method eq "regexp") {
			&RegExpSearch($current_seq, $regular_expression);
		    } else {
			&IUPACsearch();
		    }
		}
		#### search on reverse complement strand
		if ($strands_to_search =~ /R/) {
		    $regular_expression = $R_regular_expression;
		    $strand = "R";
		    if ($search_method eq "regexp") {
			&RegExpSearch($current_seq, $regular_expression);
		    } else {
			&IUPACsearch();
		    }
		}
	    }
	    
	    #### increment the total counter for the pattern
	    $sum_per_pattern{$pattern} += $match_count;
	    $sum_per_sequence{$sequence_id} += $match_count;
	    $total_sum += $match_count;
	    
	    #### store match count if requested
	    if ($calc{match_counts}) {
		$match_count{$sequence_id}{$pattern} = $match_count;
	    }
	}
    }

    if ($merge_matches) {
	my @merged_matches = &MergeMatches(@matches);
	&PrintMatchLocations(@merged_matches);
	@matches = ()
    }
}

&MatchProfiles() if ($return{match_profiles});

&MatchCounts if ($return{match_counts});

&TopScores if ($return{top});

&CountTable if ($return{table});

&MatchingStatistics() if ($return{stats});

#### elapsed time
if ($verbose) {
    $done_date = &AlphaDate;
    print $out "; Job started\t$start_date\n";
    print $out "; Job done   \t$done_date\n";
}

if ($outputfile) {
    close ($out);
}


################################################################
#################### subroutine definition #####################
################################################################


################################################################
# search with a regular expression
#
sub RegExpSearch {
    my %pat_hash = &Substitute($regular_expression, $allowed_subst, 0);
    my @keys = sort {
	($pat_hash{$a} > $pat_hash{$b}) ||
	    (($pat_hash{$a} == $pat_hash{$b}) and
	     (lc($a) cmp lc($b)))
	    } keys %pat_hash;
    foreach my $regular_pattern (@keys) {
	$seq_to_crop = $current_seq;
	while ($seq_to_crop =~ /($regular_pattern)(.*)/i) {
#	    &RSAT::message::Debug("Matching pattern", $regular_pattern, $seq_to_crop) if ($main::verbose >= 10);
	    $match_count++;
#	    if ($strand eq "DR") {
#		$match_count++;
#	    }
	    $matching_seq = $1;
	    $matching_seq_length = length($matching_seq);
	    $remaining_seq = $2;
	    $remaining_seq_len =  length($remaining_seq);
	    $offset = $matching_seq_length + $remaining_seq_len -1;

#	    &RSAT::message::Debug("Offset calculation", 
#				  "match len:".$matching_seq_length, 
#				  "remaining len:".$remaining_seq_len, 
#				  "offset:".$offset, 
#				  "matching:".$matching_seq, 
#				  "remaining:".$remaining_seq) if ($main::verbose >= 0);
	    $up_flank = "";
	    $down_flank = "";
	    if ($return{match_positions}) {
		if ($strand eq "R") {
#		    $matching_seq = &ReverseComplement($matching_seq);
		    $up_flanking = $right_flanking;
		    $down_flanking = $left_flanking;
		} else {
		    $up_flanking = $left_flanking;
		    $down_flanking = $right_flanking;
		}
		if (($left_flanking) || ($right_flanking)){
		    $up_flank = substr($current_seq,-$offset-$up_flanking-1,$up_flanking);
		    $down_flank = substr($current_seq,-$offset+$matching_seq_length-1,$down_flanking);
		    
#		    if ($strand eq "R") {
#			$up_flank = &ReverseComplement($up_flank);
#			$down_flank = &ReverseComplement($down_flank);
#			$matching_seq = lc($down_flank).uc($matching_seq).lc($up_flank);
#		    } else {
#			$matching_seq = lc($up_flank).uc($matching_seq).lc($down_flank);
#		    }
		    
		}
		$start_pos = $sequence_length - $offset - $orig_pos;
		$end_pos = $start_pos + $matching_seq_length - 1;
		$mismatches = $pat_hash{$regular_pattern};
		
		my $match = new RSAT::match();
		$match->set_attribute("type", "regexp");
		$match->set_attribute("pattern_id", $pattern->get_attribute("id"));
		$match->set_attribute("pattern_seq", $pattern->get_attribute("sequence"));
		$match->set_attribute("expression", $regular_pattern);
		$match->set_attribute("sequence_id", $sequence_id);
		$match->set_attribute("start_pos", $start_pos);
		$match->set_attribute("end_pos", $end_pos);
		$match->set_attribute("strand", $strand);
		$match->set_attribute("matching_seq", $matching_seq);
		$match->set_attribute("up_flank", $up_flank);
		$match->set_attribute("down_flank", $down_flank);
		$match->set_attribute("mismatches", $mismatches);
		&TreatMatch($match);
	    }
	    if ($no_overlap) {
		$seq_to_crop = $remaining_seq;
	    } elsif ($remaining_seq) {
#		&RSAT::message::Debug("cropping sequence", length($seq_to_crop), $matching_seq_length, $offset, $regular_pattern, $seq_to_crop);
		$seq_to_crop = substr($seq_to_crop,-$offset);
#		&RSAT::message::Debug("cropped sequence", length($seq_to_crop), $offset, $regular_pattern, $seq_to_crop);
	    } else {
		$seq_to_crop = "";
	    }
	}
    }
} # RegExpSearch

################################################################
# search a IUPAC pattern
#
sub IUPACsearch {
    $offset = 0;
    $match_pos = 0;
    
    if ($strand eq "R") {
	$IUPAC_pattern = &ExpandSeq($RC_pattern);
    } else {
	$IUPAC_pattern = &ExpandSeq($pattern->get_attribute("sequence"));
    }
    $pattern_len = length($IUPAC_pattern);
    
    do {
	($match_pos,$matching_seq,$mismatches) = &NextMatch($current_seq, $IUPAC_pattern, $allowed_subst, $offset);
	unless ($match_pos == -1) {
	    $match_count++;
	    if ($strand eq "DR") {
		$match_count++;
	    }
	    
	    unless ($return{match_counts}) {
		if ($strand eq "R") {
		    $matching_seq = &ReverseComplement($matching_seq);
		} 
		$start_pos = $match_pos -$orig_pos;
		$end_pos = $start_pos + $pattern_len -1;
		
		my $match = new RSAT::match();
		$match->set_attribute("pattern_id", $pattern->get_attribute("id"));	
		$match->set_attribute("pattern_seq", $pattern->get_attribute("sequence"));
		$match->set_attribute("expression", $IUPAC_pattern);
		$match->set_attribute("type", "IPUAC");
		$match->set_attribute("sequence_id", $sequence_id);
		$match->set_attribute("start_pos", $start_pos);
		$match->set_attribute("end_pos", $end_pos);
		$match->set_attribute("strand", $strand);
		$match->set_attribute("mismatches", $mismatches);
		$match->set_attribute("matching_seq", $matching_seq);
		&TreatMatch($match);
	    }
	    if ($no_overlap) {
		$offset = $match_pos + $pattern_len;
	    } else {
		$offset = $match_pos;
	    }
	} 
    } until ($match_pos == -1);
} # IUPACsearch


################################################################
## Treat a new match: either print it or store it if merge option has
## been activated
sub TreatMatch {
    my ($match) = @_;


    ################################################################
    ## Calculate match score
    if (($search_method eq "sliding window") ||
	($score_column > 0)) {
	$score = $pattern->get_attribute("score");
    } else {
	$match_length = length($matching_seq);
	$score = ($match_length - $mismatches)/$match_length;
    }
    $match->force_attribute("score", $score);

    return if ((defined($threshold)) && ($score < $threshold));


    ################################################################
    ## Store or print depending on the merge option
    if ($merge_matches) {
	warn join ("\t", 
		   "Storing new match", 
		   $match->get_attribute("sequence_id"), 
		   $match->get_attribute("pattern_id"), 
		   $match->get_attribute("strand"), 
		   $match->get_attribute("start_pos"), 
		   $match->get_attribute("end_pos"), 
		   $match->get_attribute("matching_seq"), 
		   $score, 
		   ), "\n" if ($main::verbose >= 5);
	push @matches, $match;
    } else {
	&PrintMatchLocation($match);
    }
    
}

################################################################
## Merge overlapping matches
sub MergeMatches {
    my (@matches) = @_;
    my @merged_matches = ();

    &RSAT::messahe::Info(join "\t", "Merging matches", @matches) if ($main::verbose >= 3);

    ## Check that there are at least two patterns
    unless (scalar(@matches) >= 2) {
	return @matches;
    }
    
    ## index starting positions
    my %start = ();
    foreach my $match (@matches) {
	$start{$match} = $match->get_attribute("start_pos");
    }

    ## Sort matches according to the start position
    @matches = sort {$start{$a} <=> $start{$b}} @matches;
    my $last_match = $matches[0];
    for my $m (1..$#matches) {
	$current_match = $matches[$m];
	if ($current_match->get_attribute("start_pos") <= $last_match->get_attribute("end_pos")) {
#  	    warn join( "\t", "Merging", 
#  		       "last",
#  		       $last_match->get_attribute("matching_seq"),
#  		       $last_match->get_attribute("start_pos"),
#  		       $last_match->get_attribute("end_pos"),
#  		       "current",
#  		       $current_match->get_attribute("matching_seq"),
#  		       $current_match->get_attribute("start_pos"),
#  		       $current_match->get_attribute("end_pos"),
#  		       ), "\n" if ($main::verbose >= 10);

	    ## Set the ID to "merged"
	    $last_match->force_attribute("pattern_id", "merged");
	    $last_match->force_attribute("pattern_seq", "merged");
	    
	    ## merged score is the maximum score
	    $last_match->force_attribute("score", &max($last_match->get_attribute("score"),
						     $current_match->get_attribute("score")));
	    
	    ## Merged strand is the sum of last and current strands
	    unless ($last_match->get_attribute("strand") eq 
		    $current_match->get_attribute("strand")) {
		$last_match->force_attribute("strand", "DR");
	    }
	    
	    ## calculate negative offset to take the end of the sequence
	    my $offset = $last_match->get_attribute("end_pos") 
		- $current_match->get_attribute("end_pos");

	    ## If right match extends wider than left match, extend left match
	    if ($offset < 0) {
		
		my $extension = substr($current_match->get_attribute("matching_seq"), $offset);
		
		## extend the sequence
		my $merged_sequence = $last_match->get_attribute("matching_seq");
		$merged_sequence .= $extension;
		&RSAT::message::Debug(
		    "offset", 
		    $offset, 
		    "last",
		    $last_match->get_attribute("matching_seq"), 
		    $last_match->get_attribute("start_pos"), 
		    $last_match->get_attribute("end_pos"), 
		    "current",
		    $current_match->get_attribute("matching_seq"), 
		    $current_match->get_attribute("start_pos"), 
		    $current_match->get_attribute("end_pos"), 
		    $offset, 
		    $extension, 
		    $merged_sequence), if ($main::verbose >= 10);
		$last_match->force_attribute("matching_seq", $merged_sequence);
		
		## position
		$last_match->force_attribute("end_pos",$current_match->get_attribute("end_pos"));
		
		## downstream flank
		$last_match->force_attribute("down_flank",$current_match->get_attribute("down_flank"));
		
	    }
#  	    warn join( "\t", "Merged match", 
#  		       $last_match,
#  		       $last_match->get_attribute("matching_seq"),
#  		       $last_match->get_attribute("start_pos"),
#  		       $last_match->get_attribute("end_pos")),"\n" if ($main::verbose >= 10);
	} else {
	    push @merged_matches, $last_match;
	    $last_match = $current_match;
	}
    }
    push @merged_matches, $last_match;
    
    return @merged_matches;
}


################################################################
## Print a list of matches
sub PrintMatchLocations {
    my @matches = @_;
    foreach my $match (@matches) {
	&PrintMatchLocation($match);
    }
}

################################################################
# Print a single match location
sub PrintMatchLocation {
    my ($match) = @_;
    my $matching_seq = uc($match->get_attribute("matching_seq"));

    my $strand = $match->get_attribute("strand");
    
    if ($match->get_attribute("type") eq "regexp") {
	my $up_flank = $match->get_attribute("up_flank");
	my $down_flank = $match->get_attribute("down_flank");
	if ($strand eq "R") {
	    $matching_seq = &SmartRC($matching_seq);
	    $right_flank = &ReverseComplement($down_flank);
	    $left_flank = &ReverseComplement($up_flank);
	} else {
	    $right_flank = $up_flank;
	    $left_flank = $down_flank;
	}
	
	## Append flanking
	$matching_seq = join ("", lc($right_flank),
			       uc($matching_seq),
			       lc($left_flank),
			       );
    }

    if ($match_format eq "fasta") {
	#### fasta identifier line
	print $out ">";
	print $out join ("_", 
			 $match->get_attribute("sequence_id"),
			 $match->get_attribute("strand"),
			 $match->get_attribute("start_pos"),
			 $match->get_attribute("end_pos"),
			 $match->get_attribute("pattern_id"),
			 );
	printf $out (" score: %.2f", $score);
	print $out " pattern: ", $pattern->get_attribute("sequence");
	print $out "\n";
	print $out $matching_seq, "\n";
    } else {
	print $out join ("\t", 
			 $match->get_attribute("pattern_id"),
			 $match->get_attribute("strand"),
			 $match->get_attribute("pattern_seq"),
			 $match->get_attribute("sequence_id"),
			 $match->get_attribute("start_pos"),
			 $match->get_attribute("end_pos"),
			 $matching_seq,
			 sprintf ("%.2f", $match->get_attribute("score")),
			 ), "\n";
    }
}


################################################################
## Option list
sub ShortHelp	{
    open HELP, "|more";
    print HELP <<EndShortHelp;
dna-pattern options
-------------------
-h		complete help message
-help		short help message
-p		pattern
-pl		pattern list file
-i		sequence file. 
-mask upper|lower	mask upper- or lowercases, respectively
-subst		allowed substitutions
-sc		score column
-o		output file.
-format		input format (raw, filelist or IG)
-id		pattern identifier (one word). 
-noid		use pattern sequence as id
-noov		prevent detection of overlapping pattern
-2str		search matches on both strands (default)
-1str		search matches on the Direct strand only
-R		search matches on the Reverse complementary strand only
-pos		return match positions (default)
-match_format	format for returning matches (supported: fasta, table)
-c		return the count of matches for each pattern in each sequence
-table		return a table with the count of pattern matches per sequence
-colsum		return total occ per sequence in the count table
-rowsum		return total occ per pattern in the count table
-total		return total occ per sequence and per pattern in the count table
-stats		return matching statistics
-window		sliding window size
-top		only return the top score
-sort		sort sequences according to their top score
-th		threshold
-merge		merge mutually overlapping matches
-ct		return total count in all sequences
-N #		return matching sequences with # flanking nucleotides
-NL #		return matching sequences with # left flanking nucleotides
-NR #		return matching sequences with # right flanking nucleotides
-v		verbose
-origin		origin (position 0)
-limit 		return start and end positions for each input sequence
EndShortHelp
    close HELP;
    exit(0);
}


################################################################
#
# Read command line arguments
#
sub ReadArguments {
    foreach $a (0..$#ARGV) {
	if ($ARGV[$a] eq "-h") {
	    &Help;
	} elsif  ($ARGV[$a] eq "-help") {
	    &ShortHelp;
	    
	} elsif ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }

	} elsif ($ARGV[$a] =~ /^-ori/) {
	    $origin = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] =~ /^-limit/) {
	    $limits = 1;
	    
	} elsif (($ARGV[$a] eq "-subst") && (&IsNatural($ARGV[$a+1]))){
	    $allowed_subst = $ARGV[$a+1];
	    if ($allowed_subst > 0) {
		$search_method = "IUPAC";
		warn "; Seach method: IUPAC\n" if ($verbose >=1);
	    }
	    
	} elsif ($ARGV[$a] eq "-IUPAC") {
	    $search_method = "IUPAC";
	    warn "; Seach method: IUPAC\n" if ($verbose >=1);
	    
	    ################################################################
	    #### pattern specification
	} elsif ($ARGV[$a] eq "-id") {
	    # directly read pattern identifier from the command line
	    if ($ARGV[$a+1] =~ /(\S+)/) {
		$pattern_id = $1;
	    }
	    
	} elsif ($ARGV[$a] eq "-p") {
	    # directly read pattern sequence from the command line
	    $pattern_seq = $ARGV[$a+1];
	    warn ("; Pattern sequence\t", $pattern_seq, "\n") if ($verbose >=4);
	    
	} elsif ($ARGV[$a] eq "-pl") {
	    # read name of file containing the list of patterns and open it
	    if ($ARGV[$a+1] =~ /(\S+)/) {
		$pattern_file = $1;
		&RSAT::error::FatalError("Cannot read pattern file '$pattern_file'.") 
		    unless (-r $pattern_file);
	    } 

	    #### score column in the pattern file
	} elsif (($ARGV[$a] eq "-sc") && (&IsNatural($ARGV[$a+1])) && ($ARGV[$a+1] > 1)) {
	    $score_column = $ARGV[$a+1];
	    
	    #### the pattern file contains no identifier
	} elsif ($ARGV[$a] eq "-noid") {
	    $noid = 1;
	    
	    ################################################################
	    #### sequence file
	} elsif ($ARGV[$a] eq "-i") {
	    # read input file name (sequence file)
	    $inputfile = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-format") {
	    # read input format (sequence format)
	    $in_format = lc($ARGV[$a+1]);
	    
	    
	    ################################################################
	    #### output file
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];

	    ################################################################
            #### matching options

	    #### strands
	} elsif (($ARGV[$a] eq "-1str") ||
		 ($ARGV[$a] eq "-D") ||
		 ($ARGV[$a] eq "-W") || 
		 ($ARGV[$a] eq "-1str")) {
	    $strands_to_search = "D";
	} elsif (($ARGV[$a] eq "-R") ||($ARGV[$a] eq "-C")) {
	    $strands_to_search = "R";
	} elsif (($ARGV[$a] eq "-2str") || 
		 ($ARGV[$a] eq "-DR") || 
		 ($ARGV[$a] eq "-RD") ||
		 ($ARGV[$a] eq "-CW") ||
		 ($ARGV[$a] eq "-CW") ||
		 ($ARGV[$a] =~ /-2str/)
		 ) {
	    $strands_to_search = "DR";
	    
	    #### threshold
	} elsif ($ARGV[$a] eq "-th") {
	    $threshold = $ARGV[$a+1];
	    unless (&IsReal($threshold)) {
		&RSAT::error::FatalError("Threshold must have a real value");
	    }

	    #### merge matches
	} elsif ($ARGV[$a] eq "-merge") {
	    $merge_matches = 1;
	    
	    #### no overlap
	} elsif ($ARGV[$a] eq "-noov") {
	    $no_overlap = 1;
	    
	    ################################################################
            #### output 
	    
	    #### matching positions
	} elsif ($ARGV[$a] eq "-pos") {
	    $return{match_positions} = 1;

	    #### match format
	} elsif ($ARGV[$a] eq "-match_format") {
	    $match_format = $ARGV[$a+1];;
	    
	    #### count matches
	} elsif ($ARGV[$a] eq "-c") {
	    $calc{match_counts} = 1;
	    $return{match_counts} = 1;
	    
	    #### sum matches over all sequences
	} elsif ($ARGV[$a] eq "-ct") {
	    $return{match_counts} = 1;
	    $return{sum_only} = 1;
	    
	    #### return results in a sequence x pattern_count table
	} elsif ($ARGV[$a] eq "-table") {
	    $calc{match_counts} = 1;
#	    $return{sum_only} = 0;
	    $return{table} = 1;

	    #### add a column containing the sum of colums to the table output
	} elsif ($ARGV[$a] eq "-colsum") {
	    $return{col_sum} = 1;
	    #### add a row containing the sum of rows to the table output
	} elsif ($ARGV[$a] eq "-rowsum") {
	    $return{row_sum} = 1;
	    #### add a column and a row for totals to the table output
	} elsif ($ARGV[$a] eq "-total") {
	    $return{col_sum} = 1;
	    $return{row_sum} = 1;

	    #### return a summary of matching statistics 
	} elsif ($ARGV[$a] eq "-stats") {
	    $calc{match_counts} = 1;
	    $calc{col_sum} = 1;
	    $calc{row_sum} = 1;
	    $return{stats} = 1;

	    #### matching profiles
	} elsif ($ARGV[$a] =~ /-prof/) {
	    $return{match_profiles} = 1;

	    #### sliding window
	} elsif ($ARGV[$a] =~ /^-win/) {
#	    die;
	    $search_method = "sliding window";
	    $sliding_window_size = $ARGV[$a+1];
	    unless (&IsNatural($sliding_window_size)) {
		&RSAT::error::FatalError( "Sliding window size must be a natural number");
	    }
	    unless ($sliding_window_size > 0) {
		&RSAT::error::FatalError( "Sliding window size must be > 0");
	    }

	    #### top score
	} elsif ($ARGV[$a] eq "-top") {
	    $return{top} = 1;
	    #### sort
	} elsif ($ARGV[$a] eq "-sort") {
	    $sort = 1;

	    ## mask
	} elsif ($ARGV[$a] eq "-mask") {
	    $mask = $ARGV[$a+1];
	    &CheckMask($mask);

	    #### flanking (return flanking residues)
	} elsif (($ARGV[$a] eq "-N") && (&IsNatural($ARGV[$a+1]))) {
	    $left_flanking = $ARGV[$a+1];
	    $right_flanking = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-NL") && (&IsNatural($ARGV[$a+1]))) {
	    $left_flanking = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-NR") && (&IsNatural($ARGV[$a+1]))) {
	    $right_flanking = $ARGV[$a+1];
	    
	}
    }
}



################################################################
# scan the sequence with a sliding window
sub SlidingWindowSearch {
    my @pattern_lengths = keys(%pattern_lengths);
    my $min_pattern_length = &min(@pattern_lengths);
    my $max_pattern_length = &max(@pattern_lengths);


    $last_pos = $sequence_length - $min_pattern_length;

    return if ($last_pos < $sliding_window_size);

    $current_seq = lc($current_seq);
    my @scores = ();
    my $current_score = 0;
    my $previous_score = 0;
    my $score_sum = 0;
    my $top_score;

    #### initialize score vector
    for my $pos (0..($sliding_window_size-2)) {
	my @current_position_scores = ();
	for my $pattern_length (@pattern_lengths) {
	    my $subseq = substr($current_seq, $pos, $pattern_length);
	    push @current_position_scores, $current_score, $pattern_scores{$subseq};
	}
	my $current_score = &checked_max(@current_position_scores);
	push @scores, $current_score;
	$score_sum += $current_score;
    }
    $top_score = $score_sum;

    #### scan the sequence with the sliding window
    for my $pos (($sliding_window_size-1)..$last_pos) {
	my @current_position_scores = ();
	for my $pattern_length (@pattern_lengths) {
	    my $subseq = substr($current_seq, $pos, $pattern_length);
	    push @current_position_scores, $current_score, $pattern_scores{$subseq};
	}
	my $current_score = &checked_max(@current_position_scores);
	push @scores, $current_score;
	$score_sum += $current_score;
	
#	warn join( "\t", $sliding_window_size, $last_pos, $subseq, $current_score, $score_sum, $threshold), "\n" if ($current_score);
	if ($score_sum >= $threshold) {
	    $pattern->force_attribute("score", $score_sum);
	    $end_pos = $pos - $orig_pos + $pattern_length ;
	    $start_pos = $pos - $orig_pos - $sliding_window_size +2;
	    $matching_seq = substr($current_seq, $start_pos, $sliding_window_size + $pattern_length - 1);
	    &PrintMatchLocation() if ($return{match_positions});
	    $profile_score{$sequence_id}{$start_pos} = $score_sum if ($return{match_profiles});
#	    die $profile_score{$sequence_id}{$start_pos};
	}
	
	$previous_score = shift @scores;
	$score_sum -= $previous_score;
	$top_score = &max($top_score, $score_sum);
    }
    if ($top_score >= $threshold) {
	$top_score{$sequence_id} = $top_score;
    }
}


################################################################
#
# Report sliding window profiles
#
sub MatchProfiles {
    
    ################################################################
    #### calculate min and max positions
    warn "; Calculating min and max position\n" if ($verbose >= 2);
    for my $id  (@sequence_ids) {
	my %matches = %{$profile_score{$id}};
	$min_pos = &min($min_pos, keys %matches);
	$max_pos = &max($man_pos, keys %matches);
    }

    #### print header
    print $out join( "\t", 
		     "; position",
		     ($min_pos..$max_pos)
		     ), "\n";

    warn "; Printing matching profiles\n" if ($verbose >= 2);
    #### print profiles
    for my $id  (@sequence_ids) {
	my %matches = %{$profile_score{$id}};
	my @match_positions = sort {$a <=> $b} keys %matches;
	print $out join( "\t", 
			 $id,
			 @matches{@match_positions}, 
			 ), "\n";
    }
}


################################################################
# Verbosity: report parameters
# 
sub Verbose {
    print $out "; dna-pattern ";
    &PrintArguments($out);
    print $out "; Citation: van Helden et al. (2000). Yeast 16(2), 177-187.\n";
    printf $out "; %-21s\t%s\n", "Input file", $inputfile if ($inputfile);
    printf $out "; %-21s\t%s\n", "Input format", $in_format; 
    printf $out "; %-21s\t%s\n", "Output file", $outputfile if ($outputfile);
    printf $out "; %-21s\t%s\n", "Pattern file", $pattern_file if ($pattern_file);
    printf $out "; %-21s\t%s\n", "Search method", $search_method;
    if ($search_method eq "sliding window") {
	printf $out "; %-21s\t%s\n", "Sliding window", $sliding_window_size;
	printf $out "; %-21s\t%s\n", "Pattern length", $pattern_length;
    }
    
    printf $out "; %-21s\t%g\n", "Threshold", $threshold;
    printf $out "; %-21s\t%d\n", "Allowed substitutions", $allowed_subst;
    if (defined(%return)) {
	foreach $key (keys %return) {
	    printf $out "; %-21s\t%s\n", "return", $key 
		if ($return{$key});
	}
    }
    print $out "; Patterns\n";
    print $out "; \tseq\tid\tscore\n";
    foreach my $pattern (@patterns) {
	print $out ("; ", 
		    "\t", $pattern->get_attribute("sequence"),
		    "\t", $pattern->get_attribute("id"),
		    "\t", $pattern->get_attribute("score"),
		    "\n");
    }
    print $out "; \n";

    if ($return{match_positions}) {
	print $out "; Matching positions\n";
	
	unless ($match_format eq "fasta") {
	    print $out join ("\t", 
			     "; PatID",
			     "Strand",
			     "Pattern",
			     "SeqID",
			     "Start",
			     "End",
			     "matching_seq",
			     "Score"), "\n";
	}
    }
}





################################################################
# Matching statistics
#
sub MatchingStatistics {
    my $nb_sequences = $#sequence_ids + 1;
    my $nb_patterns = $#patterns + 1;
    my $matching_patterns = 0;
    my $matching_patterns_pct = 0;
    my $max_matching_score_pct = 0;
    my $max_matching_score;
    my $max_score;
    foreach my $pattern (@patterns) {
	$max_score = &max($max_score, $pattern->get_attribute("score"));
	if ($sum_per_pattern{$pattern} > 0) {
	    $matching_patterns++ ;
	    $max_matching_score = &max($max_matching_score, $pattern->get_attribute("score"));
	}
    }
    if ($nb_patterns > 0) {
	$matching_patterns_pct =  100*$matching_patterns/$nb_patterns;
    }

    if ($max_score > 0) {
	$max_matching_score_pct =  100*$max_matching_score/$max_score;
    }

    my $matched_sequences = 0;
    my $matched_sequences_pct = 0;
    foreach my $sequence_id (@sequence_ids) {
	$matched_sequences++ if ($sum_per_sequence{$sequence_id} > 0);
    }
    if ($nb_sequences > 0) {
	$matched_sequences_pct = 100*$matched_sequences/$nb_sequences;
    }

    print $out "; Matching statistics\n";

    printf $out ( "%-21s\t%s\t%s\t%s\n", 
		  "; statistics",
		  "max",
		  "matched",
		  "percent"
		  ), "\n";
    printf $out ( "%-21s\t%d\t%d\t%.1f\n", 
		  "matching patterns",
		  $nb_patterns,
		  $matching_patterns,
		  $matching_patterns_pct
		  );
    printf $out ( "%-21s\t%.2f\t%.2f\t%.1f\n", 
		  "matching scores",
		  $max_score,
		  $max_matching_score,
		  $max_matching_score_pct
		  );
    printf $out ( "%-21s\t%d\t%d\t%.1f\n", 
		  "matching sequence",
		  $nb_sequences,
		  $matched_sequences,
		  $matched_sequences_pct
		  );
}

################################################################
# print the matching table (patterns/sequences)
sub CountTable {
#    print $out "; Match count table\n";
    print $out ";seq";
    foreach my $pattern (@patterns) {
	print $out "\t", $pattern->get_attribute("id");
    }
    print $out "\ttotal" if ($return{col_sum}); #### print total of occurrences per sequence
    print $out "\n";
    foreach $sequence_id (@sequence_ids) {
	print $out $sequence_id;
	foreach my $pattern (@patterns) {
	    print $out "\t", $match_count{$sequence_id}{$pattern};
	}
	print $out "\t", $sum_per_sequence{$sequence_id} if ($return{col_sum});
	print $out "\n";
    }
    #### print total of occurrences per pattern
    if ($return{row_sum}) {
	print $out "total";
	foreach my $pattern (@patterns) {
	    print $out "\t", $sum_per_pattern{$pattern};
	}
	print $out "\t", $total_sum;
	print $out "\n";
    }
}

################################################################
# match counts
sub MatchCounts {
    if ($return{sum_only}) {
	print $out "; Counts per pattern\n";
	print $out "; PatID\tPattern\tMatches\n";
	foreach my $pattern (@patterns) {
	    print $out $pattern->get_attribute("id");
	    print $out "\t", $pattern->get_attribute("sequence");
	    print $out "\t", $sum_per_pattern{$pattern};
	    print $out "\ttotal";
	    print $out "\n";
	}

    } else {
	print $out "; Counts per sequence and per pattern\n";
	print $out "; SeqID\tPatID\tPattern\tMatches\n";
	foreach $sequence_id (@sequence_ids) {
	    foreach $pattern (@patterns) {
		if ($match_count{$sequence_id}{$pattern} >= $threshold) {
		    print $out join ("\t", "$sequence_id",
				     $pattern->get_attribute("id"),
				     $pattern->get_attribute("sequence"),
				     $match_count{$sequence_id}{$pattern}
				     ), "\n";
		}
	    }
	}
    }
}

################################################################
# top scores
sub TopScores {
    print $out "; Top score per sequence (sliding window)\n";
    print $out "; SeqID\ttop\n";
    if ($sort) {
	@sequence_ids = sort {$top_score{$b} <=> $top_score{$a}} @sequence_ids;
    }
    foreach $sequence_id (@sequence_ids) {
	printf $out  "$sequence_id\t%f\n", $top_score{$sequence_id};
    }
}

############ HELP message ####################
sub Help	{
    open HELP, "|more";
    print HELP <<EndOfHelp;
NAME
	dna-pattern
	perl script v1.1 by Jacques van Helden, 30 July 1997.

DESCRIPTION
	Searches all occurrences of a pattern within DNA sequences.
        The pattern can be entered as a simple nucleotide sequence, 
        but can also include degenerate nucleotide codes, or regular 
        expressions. 

CATEGORY
	sequences
	pattern matching

USAGE
	(get help)
	dna-pattern -h

	(directly enter the sequence to search)
	dna-pattern  -i sequencefile -format seq_format -p pattern [-id identifier] 
			[-1str|-2str|-R] [-c|-ct] [-noov]
			[-N flanking] [-v]

	(read a list of patterns from a file)
	dna-pattern -i sequencefile -format seq_format -pl pattern_file 
   			[-1str|-2str|-R] [-c|-ct]  [-noov] 
   			[-N flanking] [-v]

ARGUMENTS
	-h	help (displays the current message)

	-help	short help message

	-i	input sequence file. This file contains the sequences where the pattern(s)
		will be searched for. 
		Various format are accepted
		If omitted, standard input (eg keyboard) will be used. 
		This allows to use the program within a pipe.

	-mask upper|lower
		Mask lower or uppercases, respecively, i.e. replace
		selected case by N characters.

	-format	input sequence format. The accepted formats are
		fasta	       FastA format
		IG	       IntelliGenetics format
		raw	       a single sequence in a file
		multi	       each new line is a new sequence
		filelist       a list of files containing each 
			       a single raw sequence
	-o	output file.
		If omitted, standard output (eg screen) will be used. 
		This allows to use the program within a pipe.

	-p	pattern entered directly after -p. 
		Alternatively use -pl.

	-pl	name of the file containing the patterns to search .
		(see format below)

	-subst #
               allow # substitutions. 

	-sc #	
		score column

		the #th column of the pattern file contains a number
		indicating the score for a match of this pattern. This
		option allows to weight the matches according to a
		user-defined scheme.

	-noid	
		do not search pattern identifier in the second column
		of pattern file. instead the id takes the same content
		as the pattern sequence.

	-noov
		Do not count overlapping matches for self-overlapping
		patterns.

	-2str	search matches on both strands (direct and reverse complement)

	-1str	search matches only on the direct strand.

	-R 	search matches only on the reverse complement strand.

	-id	pattern identifier (one word). 
		Use this option combined with -p.

	-pos	return match positions (default)

	-match_format	
		format for returning matches (supported: fasta, table)

	-c	return the count of matches rather than the list of
		positions and matching words. 
		If a list of sequence files is given (-sl), the count of 
                matches within each file is returned, as well as the 
                cumulative count.

	-table	return the count of pattern matches per sequence
		in the form of a table.
		(one line per sequence, one column per pattern)

	-colsum	(together with -table)
		prints an extra column with the total occurrences per sequence

	-rowsum	(together with -table)
		prints an extra row with total occurrences per pattern

	-total	(together with -table)
		prints an extra column with the total occurrences per sequence
		and an extra row with total occurrences per pattern.
		(amounts to combine -colsum and -rowsum)

	-stats	return matching statistics

        -th #   Threshold. 
                Return match count only for sequences with >= # matches.
                Only valid in combination with -c.

	-merge  merge mutually overlapping matches. When succesive
		matches overlap, they are converted into a single
		match. The merged match takes the ID "merged". The
		score is the highest score of the matching patterns.

	-ct	same as c, except that it returns the sum of matches in all 
		the files of the sequence file list, instead of the count 
		within each separate file. 

	-N #	return matching sequences with # flanking nucleotides

	-NL #	return matching sequences with # left flanking nucleotides

	-NR #	return matching sequences with # right flanking nucleotides

	-v	verbose.

        -origin #
                define # as the origin for the calculation of positions.
                -origin -0 defines the end of each sequence as the 
                origin. The matching positions are then negative values, 
                providing the distance between the match and the end of the 
                sequence.

	-limit
		return start and end positions for each input sequence

	-window #	
		Sliding window size. The score at each position is
		calculated by summing the scores of all patterns
		encountered within a sliding window of size #. This
		option automatically returns matching positions. 
		A threshold can be specified to specify the minimal
		matching score to be returned.

	-top	(with sliding window only)
		only return the top score obtained with the sliding
		window for each sequence.

	-sort	(with -top only)
		sort sequences according to their top score

PATTERN FORMATS

    PATTERN SEQUENCE

	The standard degenerate nucleotide code of the IUPAC-IUB
	commission is supported (http://www.iupac.org/, see
	http://www.chem.qmw.ac.uk/iupac/misc/naseq.html for complete
	information).

	The pattern sequence should thus only contain the following characters:
		A			Adenine
		C			Cytosine
		G			Guanine
		T			Thymine
		R	= A or G        puRines
		Y	= C or T        pYrimidines
		W	= A or T        Weak hydrogen bonding
		S	= G or C        Strong hydrogen bonding
		M	= A or C        aMino group at common position
		K	= G or T        Keto group at common position
		H	= A, C or T     not G
		B	= G, C or T     not A
		V	= G, A, C       not T
		D	= G, A or T     not C
		N	= G, A, C or T  aNy
	Upper and lower case are considered equivalent.

	Patterns can either be entered directly by the user, or listed
	in a file.

        The pattern can also contain regular expression elements:
        - GAT\[TA\]AG means \"GATAAG or GATTAG\" (equivalent to GATWAG).
        - CGGN{11}CCG means CGG followed by 10 N followed by CCG.
        - GATAAGN{0,30}GATAAG means two GATAAG spaced by 0 to 30 
          nucleotides.

    DIRECT PATTERN INPUT

	Type the -p option directly followed by a pattern sequence. 
	An optional identifier can be further entered after the -id option.

    PATTERN FILE

	A pattern file is a tab-delimited text file. Each row contains
	the description of one pattern. Column content:
	  1) Pattern sequence. This is the only mandatory column.
	  2) Pattern ID (optional).
	Additional columns can be used to specify other pattern
	attributes (description, score, ...), but they are by default
	ignored by the program. The option -sc allows to specify a
	score column.

SEQUENCE FILE FORMAT
        Different formats are supported:
        - raw
	- wc (=wconsensus)
        - filelist
        - IG (intelligenetics)

	raw	The input file must contain raw sequences without any 
                comment or other text. Tabs (\\t), blank spaces and newline 
                characters (\\n) are accepted (they will be automatically 
                removed before analysis). The sequence must be terminated by 
                a newline character.
	
	filelist	
		file list. Each line of the input file contains the 
		name of a file containing a single sequence in raw format.

	IG	IntelliGenetics format. 	
 		The first non-comment line must be the sequence identifier 
		(a single word without spaces). 
		The sequence follows the identifier line identifier. It can 
                include spaces, tabs or newlines, that will be removed for 
                sequence analysis.
                The end of one sequence is indicated by termination character:
		1 for linear, 2 for circular sequences. 
		A single file may contain several sequences. 

		EXAMPLE of IG suite:

		; sequence of the region upstream from NIL1
	        ; Locus GAT1
 	        ; ORF YFL021W  coord:   6 95964 97496
 	        ; upstream region size: 100
 	        ; upstream region coord:        6 95864 95963
 	        GAT1
 	        ACAGAGCAACAATAATAACAGCACTATGAGTCGCACACTT
  	        GCGGTGCCCGGCCCAGCCACATATATATAGGTGTGTGCCA
  	        CTCCCGGCCCCGGTATTAGC
  	        1
 	        ; sequence of the region upstream from PUT4
                ; Locus PUT4
                ; ORF YOR348C  coord:   15 988773 986890
                ; upstream region size: 100
                ; upstream region coord:        15 988873 988774
                PUT4
                GGGTTTGTGTTCCTCTTCCTTTCCTTTTTTTTTCTCTCTT
                CCCTTCCAGTTTCTTTTATTCTTTGCTGTTTCGAAGAATC
                ACACCATCAATGAATAAATC
                1	

OUTPUT
	The output file contains columns separated by tabs (\\t).

	Column contents:

	1- pattern identifier
	2- matching strand : direct (D) or reverse complement (R)
	3- pattern sequence
	4- name of the sequence matching the pattern
	5- start position of the match
	6- end position of the match
	7- match sequence
	8- matching score

	If the -c option is entered, output file returns the following
	columns :

	1- query pattern identifier word
	2- query pattern sequence
	3- sequence file name
	4- number of matches for the current pattern in the current file

EXAMPLES
	dna-pattern -i GATA -p GATWA -s $RSAGENOME/chr1.raw -c
	
	will count all occurences of the strings 'GATAA' and 'GATTA' present 
	in the file $RSAGENOME/chr1.raw.
WEB VERSION
	http://www.scmbb.ulb.ac.be/bioinformatics/rsa-tools/
EndOfHelp
    close HELP;
    exit(0);
}


################################################################
## Print the start and end positions of the sequence
sub PrintSequenceLimits {
    my ($sequence_id, $sequence_length, $orig_pos) = @_;

    my $seq_start = new RSAT::pattern(
	sequence_id => $sequence_id,
	pattern_id=>"SEQ_START",
	strand => "DR",
	start_pos => 1-$orig_pos,
	end_pos => 1-$orig_pos,
	pattern_seq => "-",
	matching_seq => "-",
	score=>0,
    );
    &PrintMatchLocation($seq_start);
    
    my $seq_end = new RSAT::pattern(
	sequence_id => $sequence_id,
	pattern_id=>"SEQ_END",
	strand => "DR",
	start_pos => $sequence_length - $orig_pos,
	end_pos => $sequence_length - $orig_pos,
	pattern_seq => "-",
	matching_seq => "-",
	score=>0,
    );
    &PrintMatchLocation($seq_end);
}


