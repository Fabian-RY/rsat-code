#!/usr/bin/perl -w
############################################################
#
# $Id: pathways-from-genome,v 1.11 2012/08/08 13:30:10 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

pathways-from-genome

=head1 VERSION

$program_version

=head1 DESCRIPTION

Taks manager developed in the context of the MICROME project,
implemening a workflow to infer metabolic pathways from Bacterial
genomes.

=head1 AUTHORS

Jacques.van-Helden@univ-amu.fr

=head1 CATEGORY

=over

=item metabolism

=item genome analysis

=back

=head1 USAGE

pathways-from-genome -org Organism_name [-v #] [-o output_directory]  [...]

=head1 OUTPUT FORMAT

The user-specified output directory is subdivided into organism- and
task-specific subdirectories. Results are presented in the form of
tab-delimited text files, associated with HTML formatted reports.

=head1 SEE ALSO

=item I<infer-operon>

used to infer operons and syntons.

=item I<compare-classes>

used for pathway projections (comparing sets of genes/EC numbers with
annotated pathways) and for pathway-to-pathway comparisons.

=head1 WISH LIST

=over

=item B<wish 1>

=item B<wish 2>

=back

=cut


BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}
require "RSA.lib";
require "RSA.disco.lib";
require "footprint.lib.pl";
require RSAT::organism;


################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.11 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";


  our $verbose = 0;
  our $in = STDIN;
  our $out = STDOUT;

  our @organism_names = ();
  our %organism_info = ();
  our $organism_name = "";

  our $refresh_time = 0;


  ## Image formats
  our @image_formats = ("png", "pdf");
  our $icon_height = "200"; ## Height for the previsualization icons in the HTML reports

  ## Supported tasks
  our @supported_tasks = qw(all
			    metanet
			    ger
			    operons
			    syntons
			    synthesis
			  );
  our $supported_tasks = join ",", @supported_tasks;
  our %supported_task = ();
  foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
  }

  ## Organism must be supported in RSAT
  my $organism = new RSAT::organism();

  ## Input files
  our %infile = ();

  ## Default parameters
  our %param = ();
  $param{operon_dist} = 55; push @param_list, "operon_dist";  ## optimal value for E.coli and B.subtilis, after an evaluation by Rekin's Janky (PhD thesis)
  $param{operon_min_genes} = 1; push @param_list, "operon_min_genes"; ## We also want singletons because they may contain a separate enzyme-coding gene
  $param{skip_org} = 0; ## Skip the first entries of the organism table
  $param{last_org} = 0; ## Stop reading organism table after a user-specified number of organisms

  ## Default column order for organism cross-table
  our @org_table_columns = qw(tax_id
			      microscope_genome_id
			      metacyc_frame_version
			      organism_name
			      uniprot_proteome
			      rsat_organism_id
			      obiw_genome_id
			      family_name
			      family_taxid
			      order_name
			      order_taxid);
  our %org_table_column = ();
  &IndexOrgTableColumns();


  ## Job management options
  our $job_prefix; $job_prefix = "pathways-from-genomes";
  our $die_on_error; $die_on_error = 1;
  our $batch; $batch = 0;
  our $batch_cmd; $batch_cmd = "";
  our $dry; $dry = 0;
  our $max_jobs; $max_jobs = 100000; ## Max number of allowed jobs to send to batch queue

  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values

  &RSAT::message::TimeWarn("Checking parameters") if ($main::verbose >= 1);

  ## If no task is specified, run all of them
  unless (scalar(keys(%task))) {
    %task = %supported_task;
  }

  ## If option -task all was called, activate all tasks
  if ($task{all}) {
    %task = %supported_task;
  }

  ################################################################
  ## Read organism names + cross references from organism table if
  ## specified.

  &ReadOrganismCrossTable() if ($infile{organism_table});

  ## Check organism names
  our $org_nb = scalar(@organism_names);
  if ($org_nb <= 0) {
    &RSAT::error::FatalError("You must specify at least one organism (option -org)");
  } else {
    ## Check that all organisms are supported before starting any analysis
    &RSAT::message::TimeWarn("Checking $org_nb organism names") if ($main::verbose >= 1);
    my $org_counter = 0;
    foreach my $organism_name (@organism_names) {
      $org_counter++;
      &RSAT::message::TimeWarn("", $org_counter, $organism_name) if ($main::verbose >= 2);

      ## Check that organism is supported in RSAT
      $organism->check_name($organism_name, 1);
    }
  }


  ## Output directory
  if ($output_dir) {
    &RSAT::util::CheckOutDir($output_dir, "", 755);
  } else {
    &RSAT::error::FatalError("You must define the output directory (option -o)");
  }

  ## Open a text file for the main (multi-organisms) logs
  $main_log_file = $output_dir."/log.txt";
  our $main_log = &OpenOutputFile($main_log_file);
  print $main_log "; pathways-from-genome ";
  &PrintArguments($main_log);

  ## Open the HTML file for the main (multi-organisms) synthesis
  $main_synthesis_file = $output_dir."/synthesis.html";
  if ($task{synthesis}) {
    our $main_syn = &OpenOutputFile($main_synthesis_file);
    print $main_syn &PrintHtmlResultHeader(program=>"pathways-from-genome", "title"=>"Access by organism", "result_toc"=>0, refresh_time=>$refresh_time);
    print $main_syn "<table class='sortable'>\n";

    ## Print header line of the main synthesis table
    my @main_syn_fields = qw (nb
			      organism_name
			      dir
			      log
			      ger
			      operons
			      syntons
			     );
    print $main_syn "<tr>\n";
    foreach my $field (@main_syn_fields) {
      print $main_syn "<th>", $field, "</th>\n";
    }
    print $main_syn "</tr>\n";
  }


  ################################################################
  ## Iterate over selected organisms

  my $org_counter = 0;
  foreach $organism_name (@organism_names) {
    $org_counter++;

    ## Check skip organism option
    if ($org_counter <= $param{skip_org}) {
      &RSAT::message::Info("Skipping organism", $org_counter."/".$org_nb, $organism_name, "(option -skip_org ".$param{skip_org}.")") if ($main::verbose >= 1);
      next;
    }

    ## Check last organism option
    if (($param{last_org} > 0) && ($org_counter > $param{last_org})) {
      &RSAT::message::Info("Stop reading organism table, due to option -last_org ".$param{last_org}) if ($main::verbose >= 1);
      last;
    }


    ## Clean the %outfile and %dir hash tables
    our %outfile = ();
    our %dir = ();

    ## Define organism-specific subdirectory
    $dir{output} = $output_dir."/".$organism_name;
    &RSAT::util::CheckOutDir($dir{output}, "", 755);

    ## Prefix
    $param{prefix} = $organism_name;

    ################################################################
    ## Open log file
    $outfile{log} = &OutFileName("", ".txt", "log");
    $out = &OpenOutputFile($outfile{log});


    ################################################################
    ## Open the organism-specific HTML report
    $outfile{synthesis} = &OutFileName("html", ".html", $organism_name."_synthesis");
    if ($task{synthesis}) {
      $syn = &OpenOutputFile($main::outfile{synthesis});
      print $syn &PrintHtmlResultHeader(program=>"pathways-from-genome", "title"=>$organism_name, "result_toc"=>0, refresh_time=>$refresh_time);

      print $main_syn "<tr>";
      print $main_syn "<td>", $org_counter, "</td>";
      print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $outfile{synthesis}, $organism_name), "</td>";
      print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $dir{output}, " [dir]"), "</td>";
      print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $outfile{log}, " [log]"), "</td>";
    }

    ## Check that organism is supported in RSAT
    unless ($organism->check_name($organism_name, 1)) {

      ## Close line of HTML report table
      print $main_syn "</tr>" if ($task{synthesis});

      ## Issue a warning
      my $warning = join ("\t", "Skipping non-supported organism", $org_counter."/".$org_nb, $organism_name);
      push @warnings, $warning;
      &RSAT::message::TimeWarn($warning) if ($main::verbose >= 2);

      next;
    }

    ## Report organism to be analyzed
    &RSAT::message::TimeWarn("Organism", $org_counter."/".$org_nb, $organism_name) if ($main::verbose >= 1);


    ################################################################
    ## Collect Gene-EC-reaction table from the MicroCyc database at Genoscope
    ## (CEA, France).
    &GetGER(get_reactions=>0);
#    &GetGER(get_reactions=>1);

    ## Append table of links to the HTML report
    if ($task{synthesis}) {
      print $syn "<h2>Metabolic annotations from Genoscope/MicroCyc</h2>\n";
      my $microscope_url = "https://www.genoscope.cns.fr/agc/microscope/";
      print $syn "<p>Source: MicroCyc database (<a target='_blank' href='".$microscope_url."'>".$microscope_url."</a>)\n";
      my $microcyc_ws_url = "http://www.genoscope.cns.fr/microme/microcyc-wsc/";
      print $syn "<br>Downloaded using Web services: <a target='_blank' href='".$microcyc_ws_url."'>".$microcyc_ws_url."</a></p>\n";
      print $syn &LinkTable("Files: metabolic annotations", @files_to_index);
    }
    @files_to_index = ();

    ################################################################
    ## Infer operons and syntons
    &InferOperonsOrSyntons("operons");
    &InferOperonsOrSyntons("syntons");

    ## Submit the batch command to the cluster manager.
    if ($batch) { &doit($batch_cmd, $dry, $die_on_error, $verbose, 1, $job_prefix); $batch_cmd = ""; }

    ################################################################
    ## Print verbosity
    &Verbose() if ($main::verbose >= 1);

    ################################################################
    ## Report execution time and close output stream
    my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
    print $out $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified
    close $out;


    ## End of the HTML file
    &CloseSynthesis($syn) if ($task{synthesis});

    ## Report organism-specific output dir and synthesis file
    &RSAT::message::TimeWarn("\tOrganism directory", $dir{output}) if ($main::verbose >= 2);
    &RSAT::message::TimeWarn("\tOrganism synthesis", $outfile{synthesis}) if ($main::verbose >= 2);
  }

  if ($task{synthesis}) {
    print $main_syn "</table>\n";
    &CloseSynthesis($main_syn);
  }

  if (scalar(@warnings) > 0) {
    print $main_log (join "\n; ",  "; Warning messages",
		     @warnings), "\n";
  }
  close $main_log;


  ## Report main output dir and synthesis file
  &RSAT::message::TimeWarn("Output directory", $output_dir) if ($main::verbose >= 1);
  &RSAT::message::TimeWarn("Log file", $main_log_file) if ($main::verbose >= 1);
  &RSAT::message::TimeWarn("Synthesis", $main_synthesis_file) if ($main::verbose >= 1);
  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display one image on a HTML page with a link (href) to the original
## (or other) file.
sub HtmlDisplayOneImage {
  my ($img_file, %args) = @_;
  my $href = $args{href} || $img_file;
  my $href_param = $args{href_param} || "";
  my $base  = $args{base} || ".";
  my $img_param = $args{img_param} || "";
  my $img_path = &RSAT::util::RelativePath($base, $img_file);
  my $href_path = &RSAT::util::RelativePath($base, $href);
  my $html = "<a href='".$href_path."' ".$href_param.">";
  $html .= "<img src='".$img_path."' ".$img_param.">";
  $html .= "</a>";
#   &RSAT::message::Debug("\nimg_file=".$img_file,
# 		       "\nhref=".$href,
# 		       ) if ($main::verbose >= 10);
  return $html;
}

################################################################
## Generate a table with links to a set of output files
##
## Usage:
##  &LinkTable($title, @output_file_keys);
sub LinkTable {
  my ($title, @output_file_keys) = @_;
  $html = "";
  $html .= "<h3>".$title."</h3>\n";
  $html .= "<table class='whitebg'>\n";
#  $html .= "<table>\n";
  for my $key (@output_file_keys) {
    $html .= "<tr>";
    $html .= "<td>".$key."</td>\n";
    $html .= "<td>";
    $html .= &LinkOneFile($outfile{synthesis}, $outfile{$key}, &ShortFileName($outfile{$key}));
    $html .= "</tr>\n";
  }
  $html .= "</table>\n";
  return ($html);
}

################################################################
## Index columns of the organism cross-table
sub IndexOrgTableColumns {
  for my $col (1..scalar(@org_table_columns)) {
    $field = lc($org_table_columns[$col-1]);
    $org_table_column{$field} = $col;
  }
}

################################################################
## Read organism cross-table
sub ReadOrganismCrossTable {
  my ($orgs) = &OpenInputFile($infile{organism_table});

  my $l = 0;
  my $org_counter = 0;
  while (<$orgs>) {
    $l++;
    next if /^;/;		## Skip comment lines
    next unless /\S/;		## Skip empty lines
    chomp();

    ## Parse header line
    if (/^#/) {
      s/^#//;
      @org_table_columns = split "\t/";
      &IndexOrgTableColumns(); ## Update the column index of organism cross-table
      next;
    }

    ## Parse one line
    my @fields = split /\t/;
    my $organism_name = $fields[$org_table_column{rsat_organism_id}-1];

    if ($organism_name) {
      $org_counter++;
      &RSAT::message::Info("Adding organism", $org_counter, $organism_name,  "line ".$l) if ($main::verbose >= 3);
      push @organism_names, $organism_name;

      ## Store all organism information (cross-references) in a hash table indexed by organism names
      foreach my $field (keys %org_table_column) {
	my $column = $org_table_column{$field}-1;
	my $value = $fields[$column];
	$organism_info{$organism_name}->{$field} = $value;
      }

    } else {
      &RSAT::message::Warning($infile{organism_table}, "Organism", $org_counter, $fields[0], "line ".$l, "missing field", "rsat_organism_id", "expected in column ".$org_table_column{rsat_organism_id}, );
    }

  }
  close $orgs;
}

################################################################
## Clos the synthetic table
sub CloseSynthesis {
  my ($handle) = @_;
  print $handle "<hr>\n";
  print $handle "</body>\n";
  print $handle "</html>\n";
  close $handle;
}


################################################################
## Display full help message 
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }


=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();


=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();


=pod

=item B<-org Organism_name>

Organism name. Must be an organism supported in this RSAT server. The
list of supported organisms can be obtained with
I<supported-organisms>.

This option is incompatible with the option -org_table.

Multiple organisms can be specifie by calling repeatedly the option
-org.

Example:

 pathways-from-genome -v 1 \
    -org Bacillus_subtilis_168_uid57675 \
    -org Mycoplasma_pneumoniae_M129_uid57709 \
    -o results/pathways_from_genome


=cut
    } elsif ($arg eq "-org") {
      &RSAT::error::FatalError("Options -org and -org_table are mutually incompatible") if ($infile{organism_table});
      my $organism_name = shift(@arguments);
      push @organism_names, $organism_name;

=pod

=item B<-org Organism_table>


Tab-delimited text file indicating the organism names + their
cross-references to a series of external databases.

This option is incompatible with the option -org.

The first columns of the organism table must contain the following
fields.

=over

=item RSAT organism identifier

All RSAT organism IDs must be an organism supported in this RSAT
server.

=item MicroCyc genome identifier

=item NCBI TAXID

=back

Additional columns are currently ignored.


=cut
    } elsif ($arg eq "-org_table") {
      &RSAT::error::FatalError("Options -org and -org_table are mutually incompatible") if (scalar(@organism_names) > 0);
      $infile{organism_table} = shift(@arguments);


=pod

=item B<-last_org last_organism_number>

Stop after having analyzed the specified number of organisms. This
option is useful for debugging or for analyzing subsets of the
organism table.

=cut
    } elsif ($arg eq "-last_org") {
      $param{last_org} = shift(@arguments);
      &RSAT::error::FatalError($param{last_org}, "Invalid value for option -last_org. Should be a Natural number.")
	unless (&RSAT::util::IsNatural($param{last_org}));

=pod

=item B<-skip_org skip_organism_number>

Skip the specified number of organisms when reading organism
table. This option is useful for debugging, or for resuming an
interrupted analysis.

=cut
    } elsif ($arg eq "-skip_org") {
      $param{skip_org} = shift(@arguments);
      &RSAT::error::FatalError($param{skip_org}, "Invalid value for option -skip_org. Should be a Natural number.")
	unless (&RSAT::util::IsNatural($param{skip_org}));

=pod

=item	B<-o output_base>

Base for the output directories. Subdirectories will be created for
each organism, and with organism-specific directories, for each result
type.

Mandatory argument.

=cut
    } elsif ($arg eq "-o") {
      $output_dir = shift(@arguments); ## We reserve the hash table %outfile to organism-specific directories



=pod

=item B<-task>

Specify a subset of tasks to be executed.

By default, the program runs all necessary tasks. However, in some
cases, it can be useful to select one or several tasks to be executed
separately.

Beware: task selection requires expertise, because some tasks depends
on the prior execution of other tasks in the workflow. Selecting tasks
before their prerequisite tasks have been completed will provoke fatal
errors.

B<Default tasks>

=over

=item I<all> (default)

Run all supported tasks.

=item I<metanet>

Get metabolic network from Genoscope/MicroCyc database, via de
MicroCyc interface.

=item I<ger>

Get gene-EC-reaction table from the Genoscope/MicroCyc database, via
the MicroCyc Web services.

=item I<operons>

Infer operons from intergenic distances (tool I<infer-operon>), using
a simple distance-based method (I<infer-operons>). This method assigns
each intergenic region with a status, either intra-operon or
inter-operons. The accuracy is estimated to ~80% (Rekin's Janky, PhD
thesis), with a balanced rate between false positives (intra-operons
considered as inter-operons) and false negatives (the opposite).

=item I<syntons>

Compute syntons from gene orientations. Syntons are defined as maximal
(non-extendable) sets of contiguous genes transcribed in the same
direction. A synton can contain one or several successive operons.

Note: in practice, we detect by running I<infer-operon> with a
virtually infinite threshold on intergenic distance. Since all genes
of an operon are (by definition) transcribed in the same direction,
syntons contain all the full operons (they can be considered as a
maximization of the sensitivity for operon prediction, but with an
important cost in specificity).

=back

=cut
    } elsif ($arg eq "-task") {
      my @requested_tasks = split ",", shift (@arguments);
      foreach my $task (@requested_tasks) {
	next unless $task;
	if ($supported_task{$task}) {
	  $task{$task} = 1;
	} else {
	  &RSAT::error::FatalError("Task '$task' is not supported. \n\tSupported: $supported_tasks");
	}
      }


=pod

=item B<-batch>

Run tasks in batch on a PC cluster (requires proper configuration of
the qsub parameters in RSAT_config.props).

In order to ensure a good treatment of the dependencies between the
tasks of the workflow, the granularity of batch processing is quite
coarse: all the tasks related to a given organism are rassembled and
sent to a single cluster node. The option I<-batch> is this only
useful when treating multiple organisms.

=cut
  } elsif ($arg eq "-batch") {
    $main::batch = 1;


    ## Dry run
=pod

=item B<-dry>

Dry run: print the commands but do not execute them.

=cut
  } elsif ($arg eq "-dry") {
    $main::dry = 1;;

    ## Don't die on error
=pod

=item B<-nodie>

Do not die in case a sub-program returns an error.

The option -nodie allows you to circumvent problems with specific
sub-tasks, but this is not recommended because the results may be
incomplete.

=cut

} elsif ($arg eq "-nodie") {
  $main::die_on_error = 0;


    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
  print $out "; peak-quality ";
  &PrintArguments($out);
  printf $out "; %-22s\t%s\n", "Program version", $program_version;

  ## List tasks
  printf $out "; %-22s\t%s\n", "Requested tasks", join(",", sort keys %task);

  ## List parameter values
  print $out "; Parameter values\n";
  foreach my $param_name (@param_list) {
    print $out sprintf ";\t%-22s\t%s\n", $param_name, $param{$param_name};
  }

  ## List directories
  if (%dir) {
    print $out "; Directories\n";
    foreach my $key (sort keys (%dir)) {
      my $value = $dir{$key};
#    while (my ($key,$value) = each %dir) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  ## List input files
  if (%infile) {
    print $out "; Input files\n";
    foreach my $key (sort keys (%infile)) {
      my $value = $infile{$key};
#    while (my ($key,$value) = each %infile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  ## List output files
  if (%outfile) {
    print $out "; Output files\n";
    foreach my $key (sort keys (%outfile)) {
      my $value = $outfile{$key};
#    while (my ($key,$value) = each %outfile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

}


################################################################
## Infer operons from gene coordinates
sub InferOperonsOrSyntons {
  my ($operons_or_syntons) = @_;
  unless ($operons_or_syntons) {
    $operons_or_syntons = "operon";
  }
  my $dist = $param{operon_dist};

  @files_to_index = ();

  ## For syntons, set distance to a very very large value
  if ($operons_or_syntons eq "syntons") {
    $dist = 10000000;
  }

  ## Define suffix for operon and synton files
  my $operon_suffix = "ming".$param{operon_min_genes};
  unless ($operons_or_syntons eq "syntons") {
    $operon_suffix .= "_dist".$dist;
  }

  ## Inferred operons
  $dir{$operons_or_syntons} = $dir{output}."/".$operons_or_syntons;
  $outfile{"gene_".$operons_or_syntons} = &OutFileName($operons_or_syntons, ".tab", "gene_".$operons_or_syntons."_".$operon_suffix); push @files_to_index, "gene_".$operons_or_syntons;
  $outfile{"gene_".$operons_or_syntons."_html"} = $outfile{"gene_".$operons_or_syntons}; $outfile{"gene_".$operons_or_syntons."_html"} =~ s/\.tab$/\.html/; push @files_to_index, "gene_".$operons_or_syntons."_html";

  ## Infer operon for each gene
  if ($task{$operons_or_syntons}) {
    &RSAT::message::TimeWarn("\tInferring ".$operons_or_syntons, "dist=".$dist, "min_gene_nb=".$param{operon_min_genes}) if ($main::verbose >= 1);
    &RSAT::util::CheckOutDir($dir{$operons_or_syntons}, "", 755);
    my $cmd = $SCRIPTS."/infer-operon -v 1 ";
    $cmd .= " -sep '-' -return q_info,operon,leader,gene_nb";
    $cmd .= " -org ".$organism_name;
    $cmd .= " -all ";
    $cmd .= " -min_gene_nb ".$param{operon_min_genes};
    $cmd .= " -dist ".$dist;
    $cmd .= " | ".$SCRIPTS."/add-gene-info";
    $cmd .= " -org ".$organism_name;
    $cmd .= " -col 2 -info descr";
    $cmd .= " -o ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= "; ".$SCRIPTS."/text-to-html ";
    $cmd .= " -i ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= " -o ".$outfile{"gene_".$operons_or_syntons."_html"};
    $cmd .= " -chunk 10000";
    &one_command($cmd, 1) ;
    &RSAT::message::Info("Gene-".$operons_or_syntons." (tab)", $outfile{"gene_".$operons_or_syntons}) if ($main::verbose >= 3);
    &RSAT::message::Info("Gene-".$operons_or_syntons." (html)", $outfile{"gene_".$operons_or_syntons."_html"}) if ($main::verbose >= 3);
  }

   ## Generate a table with a single line per operon
  $outfile{$operons_or_syntons} = &OutFileName($operons_or_syntons, ".tab", $operons_or_syntons."_".$operon_suffix); push @files_to_index, $operons_or_syntons;
  $outfile{$operons_or_syntons."_html"} = $outfile{$operons_or_syntons}; $outfile{$operons_or_syntons."_html"} =~ s/\.tab$/\.html/; push @files_to_index, $operons_or_syntons."_html";
  if ($task{$operons_or_syntons}) {
    my $cmd = "";
    $cmd .= "echo '; ".$operons_or_syntons." ' > ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '; Organism               \t".$organism_name."' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '; Max intergenic distance\t".$dist."' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '#".$operons_or_syntons."\tleader\tgene_nb' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; grep -v '^;' ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= " | grep -v '^#'";
    $cmd .= " | cut -f 7,8,9";
    $cmd .= " | sort -u ";
    $cmd .= ">> ".$outfile{$operons_or_syntons};
    $cmd .= "; ".$SCRIPTS."/text-to-html ";
    $cmd .= " -i ".$outfile{$operons_or_syntons};
    $cmd .= " -o ".$outfile{$operons_or_syntons."_html"};
    $cmd .= " -chunk 10000";
    &one_command($cmd, 1) ;
    &RSAT::message::Info($operons_or_syntons." (tab)", $outfile{$operons_or_syntons}) if ($main::verbose >= 3);
    &RSAT::message::Info($operons_or_syntons." (html)", $outfile{$operons_or_syntons."_html"}) if ($main::verbose >= 3);
  }

  ## Compute statistics on operon sizes
  $outfile{$operons_or_syntons."_stats"} = &OutFileName($operons_or_syntons, ".tab", $operons_or_syntons."_".$operon_suffix."_stats"); push @files_to_index, $operons_or_syntons."_stats";
  for my $img_format (@image_formats) {
    $outfile{$operons_or_syntons."_stats_".$img_format} = &OutFileName($operons_or_syntons, ".".$img_format, $operons_or_syntons."_".$operon_suffix."_stats"); push @files_to_index, $operons_or_syntons."_stats_".$img_format;
  }
  if ($task{$operons_or_syntons}) {
    &RSAT::message::TimeWarn("\tComputing size distribution", $operons_or_syntons) if ($main::verbose >= 1);
    $cmd = $SCRIPTS."/classfreq -v 1 -ci 1 -col 3";
    $cmd .= " -i ".$outfile{$operons_or_syntons};
    $cmd .= " -o ".$outfile{$operons_or_syntons."_stats"};

     for my $img_format (@image_formats) {
       $cmd .= "; ".$SCRIPTS."/XYgraph";
       $cmd .= " -i ".$outfile{$operons_or_syntons."_stats"};
       $cmd .= " -xcol 1 -ycol 4,5,6";
       $cmd .= " -format ".$img_format;
       $cmd .= " -xgstep1 5" unless ($img_format eq "pdf");
       $cmd .= " -xmin 0 -ymin 0";
       $cmd .= " -lines -legend  -xsize 800 -ysize 400";
       $cmd .= " -xleg1 'Number of genes per ".$operons_or_syntons."' -yleg1 'Number of predicted ".$operons_or_syntons."'";
       $cmd .= " -title1 \"Size distribution of predicted ".$operons_or_syntons." in ".$organism_name."\"";
       $cmd .= " -o ".$outfile{$operons_or_syntons."_stats_".$img_format};
     }
    &one_command($cmd, 1) ;
    &RSAT::message::Info($operons_or_syntons." stats (tab)", $outfile{$operons_or_syntons."_stats"}) if ($main::verbose >= 3);
    for my $img_format (@image_formats) {
      &RSAT::message::Info($operons_or_syntons." size distrib (".$img_format.")", $outfile{$operons_or_syntons."_stats_".$img_format}) if ($main::verbose >= 3);
    }
  }


  ################################################################
  ## Summarize the operon results
  if ($task{synthesis}) {
    print $syn "<hr><h2>", ucfirst($operons_or_syntons), "</h2>";

    print $syn "<br>Min nb of genes per ".$operons_or_syntons.": ".$param{operon_min_genes}."\n";
    if ($operons_or_syntons eq "operons") {
      print $syn "<br>Max intergenic distance : ".$param{operon_dist}."\n";
    } else {
    }

    print $syn "<h3>Size distribution</h3>";
    print $syn "<table class='whitebg'>";
    print $syn "<tr>";
    print $syn "<td>";

    ## Initialize statistics
    my $nb_genes = "NA";
    my $nb_operons = "NA";
    my $operon_mean_size = "NA";
    my $operon_max_size = "NA";

    ## Read statistics about operon/synton sizes
    if (-e $outfile{$operons_or_syntons."_stats"}) {
      my ($stats) = &OpenInputFile($outfile{$operons_or_syntons."_stats"});
      my $in_stats = 0;
      my %stats = ();
      while (<$stats>) {
	$in_stats = 1 if (/; Statistics/);
	next unless ($in_stats);
	$in_stats = 0 if (/; Seconds/);
	s/^; //;
	my ($key, $value) = split /\t/;
	$stats{$key} = $value;
      }

      $nb_genes = $stats{sum};
      $nb_operons = $stats{count};
      $operon_mean_size = $stats{mean};
      $operon_max_size = $stats{max};

      ## Add information in the organism-specific synthesis
      print $syn "<br>Nb genes: ", $nb_genes;
      print $syn "<br>Nb ".$operons_or_syntons.": ", $nb_operons;
      print $syn "<br>Mean size: ", sprintf("%.1f", $operon_mean_size);
      print $syn "<br>Max size: ", $operon_max_size;

      ## Add info in the main synthesis
      print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $dir{$operons_or_syntons}, $nb_operons),  "</td>\n";

    } else {
      print $syn "<p><font color='red'>Missing stats file: ", $outfile{$operons_or_syntons."_stats"}, "</font></p>\n";
    }

    ## Display size distribution
    print $syn "<td>";
    if (-e $outfile{$operons_or_syntons."_stats_png"}) {
      print $syn "<p>", &HtmlDisplayOneImage($outfile{$operons_or_syntons."_stats_png"},
					     base=>$outfile{synthesis},
					     href=>$outfile{$operons_or_syntons."_stats_pdf"},
					     img_param=>"height='".$icon_height."' border=1",
					    ), "</p>\n";
    } else {
      print $syn "<p><font color='red'>Missing size distribution file: ", $outfile{$operons_or_syntons."_stats_png"}, "</font></p>\n";
    }
    print $syn "</td>";
    print $syn "<tr>";
    print $syn "</table>\n";

    ## Append table of links to the HTML report
    print $syn &LinkTable("Files: ".$operons_or_syntons, @files_to_index);
    @files_to_index = ();
  }
}

################################################################
## Collect Gene-EC-Reaction (GER) table from the MicroCyc database
## at Genoscope (CEA, France).
sub GetGER() {
  my (%args) = @_;
  my $suffix;

  ## Output directory for GER
  $dir{GER} = $dir{output}."/GER";

  ## Determine suffix
  if ($args{get_reactions}) {
    $suffix = "gene-reaction";
  } else {
    $suffix = "gene-ec";
  }

  ## Define output files
  $outfile{$suffix} = &OutFileName("GER", ".tab", $suffix); push @files_to_index, $suffix;
  if ($suffix eq "gene-ec") {
    $outfile{$suffix."_by_id"} = &OutFileName("GER", ".tab", $suffix."_by_id"); push @files_to_index, $suffix."_by_id";
    $outfile{$suffix."_by_id_html"} = $outfile{$suffix."_by_id"}; $outfile{$suffix."_by_id_html"} =~ s/\.tab$/\.html/; push @files_to_index, $suffix."_by_id_html";
  }

  ## Collect Gene-EC-Reactions from MICROSCOPE database Note that the
  ## current version of the script collects a highly redundant table,
  ## because all synonyms and cross-references are represented by line
  ## duplications. This is convenient for the path building tool, but
  ## inconvenient for computing statistics.
  if ($task{ger}) {

    ## Check that organism table contains a cross-reference to the MICROSCOPE database for the organism
    unless ($organism_info{$organism_name}->{metacyc_frame_version}) {
      my $warning = join ("\t", "Cannot collect GER for organism", $organism_name, "because missing cross-reference to Genoscope/MicroCyc.", $organism_name);
      push @warnings, $warning;
      &RSAT::message::Warning($warning) if ($main::verbose >= 1);
      return();
    }

    ## Run the MICROME/MICROSCOPE Web client
    my $ms_org_id = $organism_info{$organism_name}->{metacyc_frame_version};
    my $ger_cmd = &RSAT::server::GetProgramPath("gene-ec-genoscope.py");
    my $cmd = "python2.7 ".$ger_cmd;
    $cmd .= " --ms_org_id ".$ms_org_id;
    $cmd .= " --reactions" if ($args{get_reactions});
    $cmd .= " -o ".$outfile{$suffix};
    &one_command($cmd, 1);

    if ($suffix eq "gene-ec") {
      ## Select non-redundant subset of the GER table, using the column ID
      ## to identify genes
      $cmd = "grep '^#' ".$outfile{$suffix};
      $cmd .= " | perl -pe 's/^\#//'";
      $cmd .= " | awk -F'\\t' '{print \"#\"\$4\"\\t\"\$2\"\\t\"\$1}'";
      $cmd .= " > ".$outfile{$suffix."_by_id"};
      $cmd .= "; grep -v '^; ' ".$outfile{$suffix};
      $cmd .= "| grep -v '^#' | awk -F'\\t' '\$3 == \"id\"'";
      $cmd .= " | awk -F '\\t' '{print \$4\"\\t\"\$2\"\\t\"\$1}'";
      $cmd .= " >> ".$outfile{$suffix."_by_id"};

      ## Convert gene-ec table to HTML format
      $cmd .= " ; ".$SCRIPTS."/text-to-html ";
      $cmd .= " -i ".$outfile{$suffix."_by_id"};
      $cmd .= " -o ".$outfile{$suffix."_by_id_html"};
      &one_command($cmd, 1);
    }
  }


  ## Add info in the main synthesis
  if ($task{synthesis}) {
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $dir{GER}, $suffix),  "</td>\n";
  }
}


__END__
