#!/usr/bin/perl -w
############################################################
#
# $Id: pathways-from-genome,v 1.5 2012/08/07 14:35:26 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

pathways-from-genome

=head1 VERSION

$program_version

=head1 DESCRIPTION

Taks manager developed in the context of the MICROME project,
implemening a workflow to infer metabolic pathways from Bacterial
genomes.


=head1 AUTHORS

Jacques.van-Helden@univ-amu.fr

=head1 CATEGORY

=over

=item metabolism

=item genome analysis

=back

=head1 USAGE

pathways-from-genome -org Organism_name [-v #] [-o output_directory]  [...]

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=head1 SEE ALSO

=head1 WISH LIST

=over

=item B<wish 1>

=item B<wish 2>

=back

=cut


BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}
require "RSA.lib";
require "RSA.disco.lib";
require "footprint.lib.pl";
require RSAT::organism;


################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.5 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";


  our $verbose = 0;
  our $in = STDIN;
  our $out = STDOUT;

  our $organism_name = "";
  our $refresh_time = 0;

  ## Image formats
  our @image_formats = ("png", "pdf");

  ## Supported tasks
  our @supported_tasks = qw(all
			    operons
			    syntons
			    synthesis
			  );
  our $supported_tasks = join ",", @supported_tasks;
  our %supported_task = ();
  foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
  }

  ## Organism must be supported in RSAT
  my $organism = new RSAT::organism();

  ## Input files
  our %infile = ();

  ## Default parameters
  our %param = ();
  $param{operon_dist} = 55; push @param_list, "operon_dist";  ## optimal value for E.coli and B.subtilis, after an evaluation by Rekin's Janky (PhD thesis)
  $param{operon_min_genes} = 1; push @param_list, "operon_min_genes"; ## We also want singletons because they may contain a separate enzyme-coding gene

  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values

  &RSAT::message::TimeWarn("Checking parameters") if ($main::verbose >= 1);

  ## If no task is specified, run all of them
  unless (scalar(keys(%task))) {
    %task = %supported_task;
  }

  ## If option -task all was called, activate all tasks
  if ($task{all}) {
    %task = %supported_task;
  }

  ## Organism name is mandatory
  our $org_nb = scalar(@organism_names);
  if ($org_nb <= 0) {
    &RSAT::error::FatalError("You must specify at least one organism (option -org)");
  } else {
    ## Check that all organisms are supported before starting any analysis
    &RSAT::message::TimeWarn("Checking $org_nb organism names") if ($main::verbose >= 1);
    my $org_counter = 0;
    foreach $organism_name (@organism_names) {
      $org_counter++;
      &RSAT::message::TimeWarn("", $org_counter, $organism_name) if ($main::verbose >= 1);
      ## Check that organism is supported in RSAT
      $organism->check_name($organism_name);
    }
  }


  ## Output directory
  if ($output_dir) {
    &RSAT::util::CheckOutDir($output_dir, "", 755);
  } else {
    &RSAT::error::FatalError("You must define the output directory (option -outdir)");
  }

  ## Open the HTML file for the main (multi-organisms) synthesis
  $main_synthesis_file = $output_dir."/synthesis.html";
  our $main_syn = &OpenOutputFile($main_synthesis_file);
  print $main_syn &PrintHtmlResultHeader(program=>"pathways-from-genome", "title"=>"Access by organism", "result_toc"=>0, refresh_time=>$refresh_time);
  print $main_syn "<table class='sortable'>\n";

  ## Print header line of the main synthesis table
  @main_syn_fields = qw (Organism_name
			 dir
			 log
			 operons
			 syntons
			);
  print $main_syn "<tr>\n";
  foreach my $field (@main_syn_fields) {
    print $main_syn "<th>", $field, "</th>\n";
  }
  print $main_syn "</tr>\n";


  ################################################################
  ## Iterate over selected organisms

  my $org_counter = 0;
  foreach $organism_name (@organism_names) {
    $org_counter++;
    &RSAT::message::TimeWarn("Organism", $org_counter."/".$org_nb, $organism_name) if ($main::verbose >= 1);

    ## Clean the %outfile and %dir hash tables
    our %outfile = ();
    our %dir = ();

    ## Define organism-specific subdirectory
    $dir{output} = $output_dir."/".$organism_name;
    &RSAT::util::CheckOutDir($dir{output}, "", 755);


    ## Prefix
    $param{prefix} = $organism_name;

    ################################################################
    ## Open log file
    $outfile{log} = &OutFileName("", ".txt", "log");
    $out = &OpenOutputFile($outfile{log});


    ################################################################
    ## Open the organism-specific HTML report
    $outfile{synthesis} = &OutFileName("html", ".html", $organism_name."_synthesis");
    $syn = &OpenOutputFile($main::outfile{synthesis});
    print $syn &PrintHtmlResultHeader(program=>"pathways-from-genome", "title"=>$organism_name, "result_toc"=>0, refresh_time=>$refresh_time);

    print $main_syn "<tr>";
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $outfile{synthesis}, $organism_name), "</td>";
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $dir{output}, " [dir]"), "</td>";
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $outfile{log}, " [log]"), "</td>";

    ################################################################
    ## Infer operons and syntons
    &InferOperonsOrSyntons("operons");
    &InferOperonsOrSyntons("syntons");

    ################################################################
    ## Print verbosity
    &Verbose() if ($main::verbose >= 1);

    ################################################################
    ## Report execution time and close output stream
    my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
    print $out $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified
    close $out;


    ## End of the HTML file
    &CloseSynthesis($syn);

    ## Report organism-specific output dir and synthesis file
    &RSAT::message::TimeWarn("\tOrgansim directory", $dir{output}) if ($main::verbose >= 1);
    &RSAT::message::TimeWarn("\tOrganism synthesis", $outfile{synthesis}) if ($main::verbose >= 1);
  }

  print $main_syn "</table>\n";
  &CloseSynthesis($main_syn);

  ## Report main output dir and synthesis file
  &RSAT::message::TimeWarn("Output directory", $output_dir) if ($main::verbose >= 1);
  &RSAT::message::TimeWarn("Synthesis", $main_synthesis_file) if ($main::verbose >= 1);
  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################

################################################################
## Clos the synthetic table
sub CloseSynthesis {
  my ($handle) = @_;
  print $handle "<hr>\n";
  print $handle "</body>\n";
  print $handle "</html>\n";
  close $handle;
}


################################################################
## Display full help message 
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }


=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();


=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();


=pod

=item B<-org Organism_name>

Organism name. Must be an organism supported in this RSAT server. The
list of supported organisms can be obtained with
I<supported-organisms>.

Multiple organisms can be specifie by calling repeatedly the option
-org.

Example:

 pathways-from-genome -v 1 \
    -org Bacillus_subtilis_168_uid57675 \
    -org Mycoplasma_pneumoniae_M129_uid57709 \
    -o results/pathways_from_genome


=cut
    } elsif ($arg eq "-org") {
      my $organism_name = shift(@arguments);
      push @organism_names, $organism_name;


=pod

=item	B<-o output_directory>

Output directory.

Mandatory argument.

=cut
    } elsif ($arg eq "-o") {
      $output_dir = shift(@arguments); ## We reserve the hash table %outfile to organism-specific directories



=pod

=item B<-task>

Specify a subset of tasks to be executed.

By default, the program runs all necessary tasks. However, in some
cases, it can be useful to select one or several tasks to be executed
separately.

Beware: task selection requires expertise, because some tasks depends
on the prior execution of other tasks in the workflow. Selecting tasks
before their prerequisite tasks have been completed will provoke fatal
errors.

B<Default tasks>

=over

=item I<all> (default)

Run all supported tasks.

=item I<operons>

Infer operons from intergenic distances (tool I<infer-operon>).

=back

=cut
    } elsif ($arg eq "-task") {
      my @requested_tasks = split ",", shift (@arguments);
      foreach my $task (@requested_tasks) {
	next unless $task;
	if ($supported_task{$task}) {
	  $task{$task} = 1;
	} else {
	  &RSAT::error::FatalError("Task '$task' is not supported. \n\tSupported: $supported_tasks");
	}
      }

    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
  print $out "; peak-quality ";
  &PrintArguments($out);
  printf $out "; %-22s\t%s\n", "Program version", $program_version;

  ## List tasks
  printf $out "; %-22s\t%s\n", "Requested tasks", join(",", sort keys %task);

  ## List parameter values
  print $out "; Parameter values\n";
  foreach my $param_name (@param_list) {
    print $out sprintf ";\t%-22s\t%s\n", $param_name, $param{$param_name};
  }

  ## List directories
  if (%dir) {
    print $out "; Directories\n";
    foreach my $key (sort keys (%dir)) {
      my $value = $dir{$key};
#    while (my ($key,$value) = each %dir) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  ## List input files
  if (%infile) {
    print $out "; Input files\n";
    foreach my $key (sort keys (%infile)) {
      my $value = $infile{$key};
#    while (my ($key,$value) = each %infile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  ## List output files
  if (%outfile) {
    print $out "; Output files\n";
    foreach my $key (sort keys (%outfile)) {
      my $value = $outfile{$key};
#    while (my ($key,$value) = each %outfile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

}


################################################################
## Infer operons from gene coordinates
sub InferOperonsOrSyntons {
  my ($operons_or_syntons) = @_;
  unless ($operons_or_syntons) {
    $operons_or_syntons = "operon";
  }
  my $dist = $param{operon_dist};

  my @for_synthesis = ();

  ## For syntons, set distance to a very very large value
  if ($operons_or_syntons eq "syntons") {
    $dist = 10000000;
  }

  ## Define suffix for operon and synton files
  my $operon_suffix = "ming".$param{operon_min_genes};
  unless ($operons_or_syntons eq "syntons") {
    $operon_suffix .= "_dist".$dist;
  }

  ## Inferred operons
  $dir{$operons_or_syntons} = $dir{output}."/".$operons_or_syntons;
  $outfile{"gene_".$operons_or_syntons} = &OutFileName($operons_or_syntons, ".tab", "gene_".$operons_or_syntons."_".$operon_suffix); push @for_synthesis, "gene_".$operons_or_syntons;
  $outfile{"gene_".$operons_or_syntons."_html"} = $outfile{"gene_".$operons_or_syntons}; $outfile{"gene_".$operons_or_syntons."_html"} =~ s/\.tab$/\.html/; push @for_synthesis, "gene_".$operons_or_syntons."_html";

  ## Infer operon for each gene
  if ($task{$operons_or_syntons}) {
    &RSAT::message::TimeWarn("\tInferring ".$operons_or_syntons, "dist=".$dist, "min_gene_nb=".$param{operon_min_genes}) if ($main::verbose >= 1);
    &RSAT::util::CheckOutDir($dir{$operons_or_syntons}, "", 755);
    my $cmd = $SCRIPTS."/infer-operon -v 1 ";
    $cmd .= " -sep '-' -return q_info,operon,leader,gene_nb";
    $cmd .= " -org ".$organism_name;
    $cmd .= " -all ";
    $cmd .= " -min_gene_nb ".$param{operon_min_genes};
    $cmd .= " -dist ".$dist;
    $cmd .= " | ".$SCRIPTS."/add-gene-info";
    $cmd .= " -org ".$organism_name;
    $cmd .= " -col 2 -info descr";
    $cmd .= " -o ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= "; ".$SCRIPTS."/text-to-html ";
    $cmd .= " -i ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= " -o ".$outfile{"gene_".$operons_or_syntons."_html"};
    $cmd .= " -chunk 10000";
    &one_command($cmd, 1) ;
    &RSAT::message::Info("Gene-".$operons_or_syntons." (tab)", $outfile{"gene_".$operons_or_syntons}) if ($main::verbose >= 3);
    &RSAT::message::Info("Gene-".$operons_or_syntons." (html)", $outfile{"gene_".$operons_or_syntons."_html"}) if ($main::verbose >= 3);
  }

   ## Generate a table with a single line per operon
  $outfile{$operons_or_syntons} = &OutFileName($operons_or_syntons, ".tab", $operons_or_syntons."_".$operon_suffix); push @for_synthesis, $operons_or_syntons;
  $outfile{$operons_or_syntons."_html"} = $outfile{$operons_or_syntons}; $outfile{$operons_or_syntons."_html"} =~ s/\.tab$/\.html/; push @for_synthesis, $operons_or_syntons."_html";
  if ($task{$operons_or_syntons}) {
    my $cmd = "";
    $cmd .= "echo '; ".$operons_or_syntons." ' > ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '; Organism               \t".$organism_name."' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '; Max intergenic distance\t".$dist."' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '#".$operons_or_syntons."\tleader\tgene_nb' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; grep -v '^;' ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= " | grep -v '^#'";
    $cmd .= " | cut -f 7,8,9";
    $cmd .= " | sort -u ";
    $cmd .= ">> ".$outfile{$operons_or_syntons};
    $cmd .= "; ".$SCRIPTS."/text-to-html ";
    $cmd .= " -i ".$outfile{$operons_or_syntons};
    $cmd .= " -o ".$outfile{$operons_or_syntons."_html"};
    $cmd .= " -chunk 10000";
    &one_command($cmd, 1) ;
    &RSAT::message::Info($operons_or_syntons." (tab)", $outfile{$operons_or_syntons}) if ($main::verbose >= 3);
    &RSAT::message::Info($operons_or_syntons." (html)", $outfile{$operons_or_syntons."_html"}) if ($main::verbose >= 3);
  }

  ## Compute statistics on operon sizes
  $outfile{$operons_or_syntons."_stats"} = &OutFileName($operons_or_syntons, ".tab", $operons_or_syntons."_".$operon_suffix."_stats"); push @for_synthesis, $operons_or_syntons."_stats";
  for my $img_format (@image_formats) {
    $outfile{$operons_or_syntons."_stats_".$img_format} = &OutFileName($operons_or_syntons, ".".$img_format, $operons_or_syntons."_".$operon_suffix."_stats"); push @for_synthesis, $operons_or_syntons."_stats_".$img_format;
  }
  if ($task{$operons_or_syntons}) {
    &RSAT::message::TimeWarn("\tComputing size distribution", $operons_or_syntons) if ($main::verbose >= 1);
    $cmd = $SCRIPTS."/classfreq -v 1 -ci 1";
    $cmd .= " -i ".$outfile{$operons_or_syntons};
    $cmd .= " -o ".$outfile{$operons_or_syntons."_stats"};

     for my $img_format (@image_formats) {
       $cmd .= "; ".$SCRIPTS."/XYgraph";
       $cmd .= " -i ".$outfile{$operons_or_syntons."_stats"};
       $cmd .= " -xcol 1 -ycol 4,5,6";
       $cmd .= " -format ".$img_format;
       $cmd .= " -xgstep1 5" unless ($img_format eq "pdf");
       $cmd .= " -xmin 0 -ymin 0";
       $cmd .= " -lines -legend  -xsize 600 -ysize 400";
       $cmd .= " -xleg1 'Number of genes per ".$operons_or_syntons."' -yleg1 'Number of predicted ".$operons_or_syntons."'";
       $cmd .= " -title1 \"Size distribution of predicted ".$operons_or_syntons." in ".$organism_name."\"";
       $cmd .= " -o ".$outfile{$operons_or_syntons."_stats_".$img_format};
     }
    &one_command($cmd, 1) ;
    &RSAT::message::Info($operons_or_syntons." stats (tab)", $outfile{$operons_or_syntons."_stats"}) if ($main::verbose >= 3);
    for my $img_format (@image_formats) {
      &RSAT::message::Info($operons_or_syntons." size distrib (".$img_format.")", $outfile{$operons_or_syntons."_stats_".$img_format}) if ($main::verbose >= 3);
    }
  }

  ################################################################
  ## Summarize the operon results
  print $syn "<hr><h2>", ucfirst($operons_or_syntons), "</h2>";

  print $syn "<br>Min nb of genes per ".$operons_or_syntons.": ".$param{operon_min_genes}."\n";
  if ($operons_or_syntons eq "operons") {
    print $syn "<br>Max intergenic distance : ".$param{operon_dist}."\n";
  } else {
  }

  print $syn "<h3>Statistics</h3>";

  ## Read statistics
  if (-e $outfile{$operons_or_syntons."_stats"}) {
    my ($stats) = &OpenInputFile($outfile{$operons_or_syntons."_stats"});
    my $in_stats = 0;
    my %stats = ();
    while (<$stats>) {
      $in_stats = 1 if (/; Statistics/);
      next unless ($in_stats);
      $in_stats = 0 if (/; Seconds/);
      s/^; //;
      my ($key, $value) = split /\t/;
      $stats{$key} = $value;
    }

    ## Add information in the organism-specific synthesis
    print $syn "Nb genes: ", $stats{sum};
    print $syn "<br>Nb ".$operons_or_syntons.": ", $stats{count};
    print $syn "<br>Mean size: ", $stats{mean};
    print $syn "<br>Max size: ", $stats{max};

    ## Add info in the main synthesis
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $dir{$operons_or_syntons}, $stats{count}),  "</td>";

  } else {
    print $syn "<p><font color='red'>Missing stats file: ", $outfile{$operons_or_syntons."_stats"}, "</font></p>\n";
  }

  ## Display size distribution
  if (-e $outfile{$operons_or_syntons."_stats_png"}) {
    print $syn "<p>", &HtmlDisplayOneImage($outfile{$operons_or_syntons."_stats_png"},
					   base=>$outfile{synthesis},
					   href=>$outfile{$operons_or_syntons."_stats_pdf"},
					   href_param=>"height='2' border=1",
					  ), "</p>\n";
  } else {
    print $syn "<p><font color='red'>Missing size distribution file: ", $outfile{$operons_or_syntons."_stats_png"}, "</font></p>\n";
  }

  ## Append table of links to the HTML report
  print $syn &LinkTable("Files: ".$operons_or_syntons, @for_synthesis);;
}

################################################################
## Display one image on a HTML page with a link (href) to the original
## (or other) file.
sub HtmlDisplayOneImage {
  my ($img_file, %args) = @_;
  my $href = $args{href} || $img_file;
  my $base  = $args{base} || ".";
  my $img_path = &RSAT::util::RelativePath($base, $img_file);
  my $href_path = &RSAT::util::RelativePath($base, $href);
  my $html = "<a href='".$href_path."' ".$args{href_param}.">";
  $html .= "<img src='".$img_path."'>";
  $html .= "</a>";
#   &RSAT::message::Debug("\nimg_file=".$img_file,
# 		       "\nhref=".$href,
# 		       ) if ($main::verbose >= 10);
  return $html;
}


################################################################
## Generate a table with links to a set of output files
##
## Usage:
##  &LinkTable($title, @output_file_keys);
sub LinkTable {
  my ($title, @output_file_keys) = @_;
  $html = "";
  $html .= "<h3>".$title."</h3>\n";
  $html .= "<table class='whitebg'>\n";
#  $html .= "<table>\n";
  for my $key (@output_file_keys) {
    $html .= "<tr>";
    $html .= "<td>".$key."</td>\n";
    $html .= "<td>";
    $html .= &LinkOneFile($outfile{synthesis}, $outfile{$key}, &ShortFileName($outfile{$key}));
    $html .= "</tr>\n";
  }
  $html .= "</table>\n";
  return ($html);
}


__END__
