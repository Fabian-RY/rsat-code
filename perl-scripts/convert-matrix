#!/usr/bin/perl -w

## TO DO: calculate GC content of the motif in parameters

############################################################
#
# $Id: convert-matrix,v 1.37 2007/08/05 08:03:03 jvanheld Exp $
#
# Time-stamp: <2002-06-06 13:14:17 jvanheld>
#
############################################################
#use strict;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
    require "RSA.lib";
}
use RSAT::matrix;
use RSAT::MatrixReader;

#### initialise parameters ####
my $start_time = &AlphaDate();
$decimals = 2;
$pseudo_weight = 1;
$equi_pseudo = 0;
$max_profile = 24;
$sep="\t";
$null = "NA";

local %infile = ();
local %outfile = ();
local $input_format = "";
local $output_format = "patser";
local $verbose = 0;
local $out = STDOUT;

local $sort_key = "";
local $sort_order = "";

## Return type(s)
@return_fields = ();
%supported_return_type = (
			  "profile"=>1,
			  "counts"=>1,
			  "frequencies"=>1,
			  "weights"=>1,
			  "info"=>1,
			  "information"=>1,
			  "parameters"=>1,
			  "consensus"=>1,
			  "margins"=>1,
			  "sites"=>1,
			  "wdistrib"=>1,
			 );
$supported_return_fields = join ",", sort keys %supported_return_type;

## input formats
%supported_input_format = %RSAT::MatrixReader::supported_input_format;
$supported_input_formats = join ",", sort keys %supported_input_format;


## output formats
%supported_output_format = %RSAT::matrix::supported_output_format;
$supported_output_formats = join ",", sort keys %supported_output_format;

## site formats
%supported_site_format = ('fasta'=>1,
			  "wc"=>1,
			  "multi"=>1,
			 );
$supported_site_formats = join ",", sort keys %supported_site_format;
$site_format="fasta";

&ReadArguments();

################################################################
#### check argument values ####

## Input format
unless ($input_format) {
    &RSAT::error::FatalError("You should specify the input matrix format.");
}

## return type(s)
local %return_fields = ();
unless (scalar(@return_fields)) {
  if ((lc($output_format ) eq "transfac") ||
      (lc($output_format ) eq "consensus")) {
    push @return_fields, "counts";
  } else {
    &RSAT::error::FatalError("You should define at least one return type");
  }
}
foreach my $format (@return_fields) {
    if ($supported_return_type{$format}) {
	$return_fields{$format}++;
    } else {
	&RSAT::error::FatalError("Invalid return type $format. Supported: ".$supported_return_fields);
    }
}

## Information
if ($return_fields{information}) {
  $return_fields{info} = 1;
  &RSAT::message::Warning("Option -return information is obsolete. Please use -return info.");
}

## Prior residue frequencies
if ($infile{prior}) {
    %prior = ();
    &ReadExpectedFrequencies($infile{prior}, 1, 1);    
    foreach my $key (sort keys %patterns) {
	my $residue = lc($key);
	$prior{$residue} = $patterns{$key}->{exp_freq};
#	&RSAT::message::Debug("residue", $residue, "prior", $prior{$residue}) if ($main::verbose >= 10);
    }
}

################################################################
#### Perform the conversion


### open output file ###
$out = &OpenOutputFile($outfile{output});

##### print output ######
&Verbose if ($verbose);

## Read the input matrices
my @matrices = &RSAT::MatrixReader::readFromFile($infile{input}, $input_format);

## Calculate parameters before sorting because sorting can be done on
## a computed parameter rather than defined in the input file.
if ($return_fields{parameters}) {
    foreach my $matrix (@matrices) {
	$matrix->calcWeights();
	$matrix->calcInformation();
	$matrix->calcConsensus();
    }
}

## Sort the matrices if requested
if ($sort_key) {
  @matrices = &RSAT::MatrixReader::SortMatrices($sort_key, $sort_order, @matrices);
}

#### export the matrices
my $m = 0;
foreach my $matrix (@matrices) {
    $m++;
    if ((defined($top_matrices)) && ($m > $top_matrices)) {
	last;
    }

    &RSAT::message::Info("Exporting matrix", $m."/".scalar(@matrices))
	if ($main::verbose >= 3);

    if ($m > 1) {
      print $out $RSAT::matrix::matrix_separator{$output_format}, "\n";
    }
    if ($main::verbose >= 1) {
	print $out  ";\n; MATRIX ", $m."/".scalar(@matrices), "\n;\n";
    }
    &ExportMatrix($matrix);
}


## closing verbose
if ($verbose) {
    my $done_time = &AlphaDate();
    print $out "; Job started $start_time\n";
    print $out "; Job done    $done_time\n";
}

##### close output file
close $out if ($outfile{output});


exit(0);

################################################################
#################### subroutine definition #####################
################################################################

################################################################
## Display full help message 
sub PrintHelp {
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	convert-matrix

        1999 by Jacques van Helden (jvanheld\@scmbb.ulb.ac.be)
	
USAGE
        convert-matrix [-i inputfile] [-o outputfile] [-v]

DESCRIPTION

	Read a position-specific scoring matrix (PSSM) from different
	formats, and exports it in a format that can be used by the
	matrix matching program patser (Hertz et al, 1999).

	The program also performs a statistical analysis of the
	original matrix to provide different position-specific scores
	(weight, frequencies, information contents), general
	statistics (E-value, total information content), and synthetic
	descriptions (consensus).

	PSSM can be used to represent the binding specificity of a
	transcription factor or the conserved residues of a protein
	domain.

	Each row of the matrix corresponds to one residue (nucleotide
	or amino-acid depending on the sequence type).  Each column
	corresponds to one position in the alignment.  The value
	within each cell represents the frequency of each residue at
	each position.

CATEGORY
	util
	conversion
	PSSM

OPTIONS
	-h	display full help message
	-help	display options
	-v	verbose

	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.

	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.

	-prior prior frequency file
		File indicating prior residue frequencies
		If no prior frequency file is specified, prior
		frequencies are read from the input file. In case this
		file does not contain any indication of prior
		frequencies, equal priors are assumed.

	-from
		input matrix format
		Supported: $supported_input_formats

	-to
		output matrix format. 
		Supported: $supported_output_formats

		The option -out_format allows to export the matrix in
		different formats in order to use it as input for various
		pattern matching programs (e.g. patser, MotifScanner, ...).

		The option -return allows to specify the matrix content, the
		option -out_format its format. 

		Beware: each of these programs expectes to find a specific
		type of information in the matrix. For instance, patser uses a
		matrix of counts (or optionnally weights), whereas
		MotifScanner uses a frequency matrix. 

		In order to use a matrix as input for another program, the
		verbosity should be set to 0, in order to avoid comment lines
		(which would be misinterpreted by other programs).

		Recommended combinations of parameters

		Input for patser
		      -return counts -out_format patser -v 0

		Input for MotifScanner
		      -return frequencies -out_format MotifScanner -v 0

	-return	return type
		Supported: $supported_return_fields

		convert-matrix allows to perform various conversions, starting
		from an input occurrence matrix, in order to obtain various
		statistics such as frequencies, weights, information contents,
		.... The supported return types are described in detail below.

	-sort desc|asc|alpha key

		Sort matrices according to the specified attribute
		(sort_key). The sorting can be done on numerical
		values, either in descending (desc) or ascending (asc)
		order. It can also be done in alphabetical order
		(alpha).

		The key mst be one of the numeric parameters of the
		matrices (e.g. information.content, E-value, ...).

		This option is convenient, for example, to sort
		matrices from MotifSampler according to their
		information content:
			-sort desc MS.ic

	-top 
	        Maximal number of matrices to return. 
		Some of the input formats can contain several matrices
		in a single file (e.g. consensus, meme,
		MotifSampler). By default, all the matrices are parsed
		and exported. The option -top allows to restrict the
		number of matrices to be exported.

	-pseudo	
		pseudo-weight used for the calculation of the weight
		matrix (default: $pseudo_weight)

	-equi_pseudo
		If this option is called, the pseudo-weight is
		distributed in an equiprobable way between residues.
		By default, the pseudo-weight is distributed
		proportionally to residue priors.

	-decimals
		Number of decimals to print for real matrices
		(frequencies, weights, information) or to compute
		score distributions.

		Warning: for the computation of score distributions,
		the computing time increases exponentially with the
		number of decimals. We recommend to restrict the
		precision to 2 decimals for the weight, this is
		generally more than sufficient.

	-max_profile
		Maximal width of the profile histogram (units = number
		of characters).

PRIOR FREQUENCY FILE

      The prior frequency file is a tab-delimited text file with one
      row per residue, and two columns. The first column indicates the
      residue, the second column its prior frequency.

      Prior frequency files can be generated with the program
      oligo-analysis.

      oligo-analysis -i reference-seq.fasta -l 1 -return freq -1str -v 1

INPUT/OUTPUT FORMATS

    Some formats are supported only for input, others for
    output. There are more formats accepted for input, because the
    general use of this program is to convert a PSSM obtained from a
    database (e.g. TRANSFAC) or a pattern-discovery program
    (e.g. consensus, gibbs, meme, MotifSampler, ...) and obtain a
    matrix either for scanning (with matrix-scan) or for computing
    statistical parameters (see the return fields below).

    tab (input/output)
	tab-delimited file. One row per residue, one column per
	position. The first column of each row indicates the residue,
	the following columns give the frequency of that residue
	at the corresponding position of the matrix.

        The tab format accepts a user-specific set of return fields
        (option -return), provigind different statistics on the matrix
        (counts, frequencies, weights, information, other parameters:
        see description below).

    patser (output)
        This format can be used as input to scan sequences with
        patser, the pattern-matching program developed by Jerry Hertz.

        This is actually the same format as tab (described above), but
        the only return filed is the count matrix.

    assembly (input)
	Output file from the program pattern-assembly. One assembly
	file can contain zero, one or several assemblies. Each
	assembly is converted to a position-specific scoring matrix by
	taking, for each residue at each position, the score of the
	most significant pattern (oligonucleotide) containing that
	residue in this position of the assembly.

    consensus (input/output)
	Output file from consensus, the pattern-discovery program
	developed by Jerry Hertz (Hertz et al., Comput Appl Biosci,
	1990:6, 81-92). This file contains one or several matrices, +
	additional information on the parameters used for pattern
	discovery (e.g. prior residue frequencies).

    gibbs (input)
	Output file from gibbs, the pattern-discovery program
	developed by Andrew Neuwald (Lawrence et al. Science, 1993:
	262, 208-214; Neuwald, et al. Protein Sci, 1995: 4, 1618-1632)

    meme (input)
	Output file from MEME, the pattern-discovery program developed by
	tim Bailey.This file contains one or several matrices, +
	additional information on the parameters used for pattern
	discovery (e.g. prior residue frequencies).

    MotifSampler (input/output)
	Output file from MotifSampler, the pattern-discovery program
	developed by Gert Thijs (Thijs et al. Bioinformatics, 2001:17,
	1113-1122).

    TRANSFAC (input/output)
        Format used in the TRANSFAC database;
        (http://www.gene-regulation.com/pub/databases.html)

    cb (input)
	Cluster-Buster output file (usual extention .cb). The header
	line starts with a > (like in fasta format). The matrix is
	then printed "vertically" on the following lines: each column
	corresponds to one residue, and each row to a position in the
	alignment.

    feature (input)
        Output file from convert-features. 

        This format allows to obtain a PSSM from a list of (supposedly
        pre-aligned) sites. These sites can themselves have been
        collected by scanning sequences with a matrix (matrix-scan) or
        by searching string-based patterns in a sequence
        (dna-pattern). 

        Converting features to matrices can for example be useful for
        iterative refinment of a matrix (colecting sites from a
        matrix, and building a matrix from those sites).

        Another application is to detect oligomers or dyads in a
        sequence set, and build a matrix from these.

    clustal (input)
	The popular multiple alignemnt program clustalw. 

RETURN FIELDS FOR THE TAB-DELIMITED OUTPUT FORMAT

   The tab output format supports user-specified return fields.

    counts
        Each cell of the matrix indicates the number of occurrences of the
        residue at a given position of the alignment.

    profile
	The matrix is printed vertically (each matrix column becomes a
	row in the output text). Additional parameters are indicated
	besides each position, and a histogram is drawed.

    crude frequencies
        Relative frequencies are calculated as the counts of residues
        divided by the total count of the column.

        Fij=Cij/SUMi(Cij)

        where

        Cij is the absolute frequency (counts) of residue i at position j of
            the alignment

        Fij is the relative frequency of residue i at position j of the
            alignment

    frequencies corrected with pseudo-weights
        Relative frequencies can be corrected by a pseudo-weight (b) to
        reduce the bias due to the small number of observations.

        F\'ij=Cij+b*Pi/[SUMi(Cij)+b]

        where

        Pi  is the prior frequency for residue i

        b   is the pseudo-weight, which is "shared" between residues
            according to their prior frequencies.

    weights
        Weights are calculated according to the formula from Hertz (1999),
        as the natural logarithm of the ratio between the relative frequency
        (corrected for pseudo-weights) and the prior residue probability.

        Wij=ln(F\'ij/Pi)

    information
        The crude information content is calculated according to the formula
        from Hertz (1999).

        Iij = Fij*ln(Fij/Pi)

        In addition, we calculate a "corrected" information content which
        takes pseudo-weights into account.

        I\'ij = F\'ij*ln(F\'ij/Pi)

	One advantage of the corrected information content is that it
	assigns finite values when Fij=0.

    margins
	Calculate marginal values (column and row sum, min, max) for each 
        matrix.

    parameters
        Returns a series of parameters associated to the matrix. The
        list of parameters to be exported depends on the input formats
        (each pattern discovery program returns specific parameters,
        which are more or less related to each others but not
        identical).

        Some additional parameters are optionally calculated

        consensus
            The degenerate consensus is calculated by collecting, at each
            position, the list of residues with a positive weight.
            Contrarily to most applications, this consensus is thus weighted
            by prior residue frequencies: a residue with a high frequency
            might not be represented in the consensus if this frequency does
            not significantly exceed the expected frequency. Uppercases are
            used to highlight weights >= 1.

            The consensus is exported as regular expression, and with the
            IUPAC code for ambiguous nucleotides
            (http://www.chem.qmw.ac.uk/iupac/misc/naseq.html).

                    A                       (Adenine) 
                    C                       (Cytosine)
                    G                       (Guanine)
                    T                       (Thymine)
                    R       = A or G        (puRines)
                    Y       = C or T        (pYrimidines)
                    W       = A or T        (Weak hydrogen bonding)
                    S       = G or C        (Strong hydrogen bonding)
                    M       = A or C        (aMino group at common position)
                    K       = G or T        (Keto group at common position)
                    H       = A, C or T     (not G)
                    B       = G, C or T     (not A)
                    V       = G, A, C       (not T)
                    D       = G, A or T     (not C)
                    N       = G, A, C or T  (aNy)

            The strict consensus indicates, at each position, the residue
            with the highest positive weight.

        information
            The total information is calculated by summing the
            information content of all the cells of the matrix. This
            parameters is already returned by the program consensus
            (Hertz), but not by other programs.

	wdistrib
	    Theoretical distribution of weight probabilities (computed
	    as in Bailey, Bioinformatics, 1999).

End_of_help
  close HELP;
  exit(0);
}

################################################################
## Display short help message
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
convert-matrix options
----------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-i		input file
-o		output file
-v		verbose
-from		input matrix format. Supported: $supported_input_formats
-to		output matrix format. Supported: $supported_output_formats
-return		return type(s). Supported: $supported_return_fields
-sort desc|asc|alpha key     Sort matrices according to the specified key.
-top		maximal number of matrices to return. 
-prior 		prior frequency file
-pseudo		pseudo-weight (default: $pseudo_weight)
-equi_pseudo	equiprobable distribution of pseudo-weights between residues
-decimals	number of decimals digits to print for real matrices
-max_profile	Maximal width of the profile histogram 
End_short_help
  close HELP;
  exit(0);
}


################################################################
## Read arguments
sub ReadArguments {
  foreach my $a (0..$#ARGV) {
    ### verbose ###
    if ($ARGV[$a] eq "-v") {
      if (&IsNatural($ARGV[$a+1])) {
	$verbose = $ARGV[$a+1];
      } else {
	$verbose = 1;
      }
      
      ### detailed help
    } elsif ($ARGV[$a] eq "-h") {
      &PrintHelp();
      
      ### list of options
    } elsif ($ARGV[$a] eq "-help") {
      &PrintOptions();
      
      ### input file 
    } elsif ($ARGV[$a] eq "-i") {
      $infile{input} = $ARGV[$a+1];
      
      ### Maximal number of matrices to return
    } elsif ($ARGV[$a] eq "-top") {
	$top_matrices = $ARGV[$a+1];
	&FatalError(join("\t", $top_matrices, "Invlaid value for the option -top. Should be a strictly positive Natural number.")) 
	    unless ((&IsNatural($top_matrices)) && ($top_matrices >= 1));

	## Sort matrices
    } elsif ($ARGV[$a] eq "-sort") {
	$sort_order = lc($ARGV[$a+1]);
	unless (($sort_order eq "desc")
		|| ($sort_order eq "asc")
		|| ($sort_order eq "alpha")
	    ) {
	    &RSAT::error::FatalError($sort_order, "is not a valid sorting order. Supported: desc,asc,alpha.");
	}
	$sort_key = $ARGV[$a+2];

      ### prior frequency file
    } elsif ($ARGV[$a] eq "-prior") {
	$infile{prior} = $ARGV[$a+1];

      ### output file 
    } elsif ($ARGV[$a] eq "-o") {
      $outfile{output} = $ARGV[$a+1];

      ### return type(s)
    } elsif ($ARGV[$a] eq "-return") {
      my $return_fields = $ARGV[$a+1];
      push @return_fields, split(",", $return_fields);


      ### input format 
    } elsif ($ARGV[$a] eq "-from") {
      $input_format = lc($ARGV[$a+1]);
      unless ($supported_input_format{$input_format}) {
	  &RSAT::error::FatalError("$input_format\tInvalid format for input matrix\tSupported: $supported_input_formats");
      }
    } elsif ($ARGV[$a] eq "-in_format") {
	&RSAT::message::Warning("The option -in_format is obsolete, please use -from instead.");
	$input_format = lc($ARGV[$a+1]);
      unless ($supported_input_format{$input_format}) {
	  &RSAT::error::FatalError("$input_format\tInvalid format for input matrix\tSupported: $supported_input_formats");
      }

      ### Obsolete option for the input format 
    } elsif ($ARGV[$a] eq "-format") {
	&RSAT::message::Warning("Option -format is obsolete. Use -in_format instead.");
	$input_format = $ARGV[$a+1];
	unless ($supported_input_format{$input_format}) {
	    &RSAT::error::FatalError("$input_format\tInvalid format for input matrix\tSupported: $supported_input_formats");
	}

      ### output format 
    } elsif ($ARGV[$a] eq "-to") {
      $output_format = $ARGV[$a+1];
      unless ($supported_output_format{$output_format}) {
	  &RSAT::error::FatalError("$output_format\tInvalid format for output matrix\tSupported: $supported_output_formats");
      }
    } elsif ($ARGV[$a] eq "-out_format") {
	&RSAT::message::Warning("The option -out_format is obsolete, please use -to instead.");
      $output_format = $ARGV[$a+1];
      unless ($supported_output_format{$output_format}) {
	  &RSAT::error::FatalError("$output_format\tInvalid format for output matrix\tSupported: $supported_output_formats");
      }

      ### site format 
    } elsif ($ARGV[$a] eq "-site_format") {
      $site_format = $ARGV[$a+1];
      unless ($supported_site_format{$site_format}) {
	  &RSAT::error::FatalError("$site_format\tInvalid format for sites\tSupported: $supported_site_formats");
      }

      ### pseudo-weight
    } elsif ($ARGV[$a] eq "-pseudo") {
      $pseudo_weight = $ARGV[$a+1];
      unless (&IsReal($pseudo_weight)) {
	  &RSAT::error::FatalError("Invalid pseudo-weight $pseudo_weight. Must be a real value");
      }

      ## Equiprobable distribution of the pseudo-weight
	} elsif ($ARGV[$a] eq "-equi_pseudo") {
	    $equi_pseudo = 1;

      ### decimals
    } elsif ($ARGV[$a] eq "-decimals") {
      $decimals = $ARGV[$a+1];
      unless (&IsNatural($decimals)) {
	  &RSAT::error::FatalError("Invalid decimals $decimals. Must be a natural value");
      }

      ### max_profile
    } elsif ($ARGV[$a] eq "-max_profile") {
      $max_profile = $ARGV[$a+1];
      unless (&IsNatural($max_profile)) {
	  &RSAT::error::FatalError("Invalid max_profile $max_profile. Must be a natural value");
      }

    }
  }
}

################################################################
## Print verbosity
sub Verbose {
  print $out "; convert-matrix ";
  &PrintArguments($out);
  if (defined(%infile)) {
    print $out "; Input files\n";
    while (($key,$value) = each %infile) {
      print $out ";\t$key\t$value\n";
    }
  }
  if (defined(%outfile)) {
    print $out "; Output files\n";
    while (($key,$value) = each %outfile) {
      print $out ";\t$key\t$value\n";
    }
  }

  printf $out "%-22s\t%d\n", "; pseudo-weight", $pseudo_weight;
}


################################################################
## Export one matrix
sub ExportMatrix {
  my ($current_matrix) = @_;
#  $current_matrix->readFromFile($infile{input}, $input_format);
  if ($infile{prior}) {
    $current_matrix->setPrior(%prior);
  }
  $current_matrix->set_attribute("pseudo", $pseudo_weight);
  $current_matrix->set_attribute("equi_pseudo", $equi_pseudo);
  $current_matrix->push_attribute("parameters", "pseudo");
  $current_matrix->force_attribute("decimals", $decimals);
  $current_matrix->force_attribute("max_profile", $max_profile);
  $current_matrix->force_attribute("sep", $sep);
  # $current_matrix->force_attribute("col_width", $col_width);
  $current_matrix->force_attribute("margins", $return_fields{margins});

  ## Print the profile matrix
  if ($return_fields{profile}) {
    print $out $current_matrix->toString(sep=>"\t",
					 type=>"profile",
					 format=>$output_format,
					);
  }


  ## Print the counts matrix
  if ($return_fields{counts}) {
    print $out $current_matrix->toString(sep=>"\t",
					 type=>"counts",
					 format=>$output_format,
					);
  }

  ## Calculate frequency matrix
  if ($return_fields{frequencies}) {
    $current_matrix->calcFrequencies();
    print $out $current_matrix->toString(col_width=>($decimals+4), 
					 decimals=>$decimals, 
					 type=>"frequencies",
					 format=>$output_format);
  }

  ## Calculate weight matrix
  if ($return_fields{weights}) {
    $current_matrix->calcWeights();
    print $out $current_matrix->toString(col_width=>($decimals+4), 
					 decimals=>$decimals, 
					 type=>"weights",
					 format=>$output_format);
  }

  ## Calculate information content matrix
  if ($return_fields{info}) {
    $current_matrix->calcInformation();
    print $out $current_matrix->toString(col_width=>($decimals+4), 
					 decimals=>$decimals, 
					 type=>"information",
					 format=>$output_format);
  }


  ## Return sites
  if ($return_fields{sites}) {
    print $out "; Sites\t",$current_matrix->get_attribute("sites"),"\n" if ($main::verbose >= 1);
    my $s = 0;
    my @site_ids = $current_matrix->get_attribute("site_ids");
    foreach my $site_seq ($current_matrix->get_attribute("sequences")) {
      $s++;
      my $site_id =  $site_ids[$s-1] || $s;
      &PrintNextSequence($out, $site_format, 0, $site_seq, $site_id);
#      print $out $s, "\t\\", $site_seq, "\\\n";
    }
  }

  ## Calculate consensus
  if ($return_fields{consensus}) {
    $current_matrix->calcConsensus();
    print $out "; consensus\t", $current_matrix->get_attribute("consensus.IUPAC"), "\n";
  }

  ## Return parameters
  if ($return_fields{parameters}) {
    $current_matrix->calcConsensus();
    print $out $current_matrix->toString(type=>"parameters");
  }

  ## Return weight distribution
  if ($return_fields{wdistrib}) {
    $current_matrix->calcTheorScoreDistrib("weights", decimals=>$decimals);
    my %weight_proba = $current_matrix->getTheorScoreDistrib("weights");
    my %weight_proba_cum = $current_matrix->getTheorScoreDistrib("weights", "cum");
    my %weight_proba_inv_cum = $current_matrix->getTheorScoreDistrib("weights", "inv_cum");

    ## Print the description of column contents
    my @columns = ("weight", "proba", "cum", "Pval", "ln_Pval", "log_P", "sig");
    if ($main::verbose >= 1) {
      print $out ";\n; Theoretical distribution of weight probabilities\n";
      my %descr = ();
      $descr{"weight"} = "log-likelihood score: w=P(S|M)/P(S|B)";
      $descr{"proba"} = "probability density function: P(W=w)";
      $descr{"cum"} = "cumulative density function: P(W <= w)";
      $descr{"Pval"} = "P-value = inverse cumulative density function: Pval = P(W >= w)";
      $descr{"ln_Pval"} = "natural logarithm of the P-value";
      $descr{"log_P"} = "base 10 logarithm of the P-value";
      $descr{"sig"} = "significance: sig = -log10(Pval)";
      $c =0;
      foreach my $col (@columns) {
	$c++;
	print $out sprintf(";\t%d\t%-12s\t%s", $c, $col, $descr{$col}), "\n";
      }
    }

    ## Print header
    print $out "#", join ("\t", @columns), "\n";

    ## Print the score distribution
    my $log10 = log(10);
    foreach my $weight (sort {$a <=> $b} keys (%weight_proba)) {
      $weight = sprintf("%.${decimals}f", $weight);
      my $weight_proba = $null;
      my $weight_proba_cum = $null;
      my $weight_proba_inv_cum = $null;
      my $ln_pval = $null;
      my $log_P = $null;
      my $sig = $null;
      if (defined($weight_proba{$weight})) {
	$weight_proba = sprintf("%.1e", $weight_proba{$weight});
      }
      if (defined($weight_proba_cum{$weight})) {
	$weight_proba_cum = sprintf("%.1e", $weight_proba_cum{$weight});
      }
      if (defined($weight_proba_inv_cum{$weight})) {
	$weight_proba_inv_cum = sprintf("%.1e", $weight_proba_inv_cum{$weight});
	if ($weight_proba_inv_cum{$weight} > 0) {
	  $ln_pval =  sprintf("%.3f",log($weight_proba_inv_cum{$weight}));
	  $sig =  sprintf("%.3f",-log($weight_proba_inv_cum{$weight})/$log10);
	  $sig =~ s/^-(0.0+)$/$1/;
	  $log_P = -$sig;
	} else {
	  $ln_pval = "-Inf";
	  $log_P = "-Inf";
	  $sig = "Inf";
	}
      }
      print $out join("\t", $weight, 
		      $weight_proba,
		      $weight_proba_cum,
		      $weight_proba_inv_cum,
		      $ln_pval,
		      $log_P,
		      $sig,
		     ), "\n";
    }
  }

}

