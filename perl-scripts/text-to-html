#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.cgi.lib";
###require "cgi-lib.pl";


#### initialise parameters ####
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;

$chunk = 50;

#### read arguments ####
&ReadArguments();


#### check argument values ####



### open input file ###
($in, $input_dir) = &OpenInputFile($infile{input});

### open output file ###
$out = &OpenOutputFile($outfile{output});

###### execute the command #########
#print &HtmlTop ($infile{input});    
#die "$outfile{output}\t$out";


print $out "<HTML>";
print $out "<TITLE>$infile{input}</TITLE>";
print $out "<BODY BGCOLOR='#FFFFFF'>";

#### verbose ####
if ($verbose) {
    print $out ";text-to-html result\n";
    if ($infile{input} ne "") {
	print $out ";Input file	$infile{input}\n";
    }
    if ($outfile{output} ne "") {
	print $out ";Output file	$outfile{output}\n";
    }
}


print &PrintHtmlTable($in, "", "", $chunk, $out, $border);

print $out "</BODY>";
print $out "</HTML>";


###### print output ######




###### verbose ######
if ($verbose) {
    $done_time = `date '+%d/%m/%y %H:%M:%S %Z'`;
    print $out ";Job started $start_time";
    print $out ";Job done    $done_time";
}


###### close input file ######
close $in unless ($infile{input} eq "");

###### close output file ######
close $out unless ($outfile{output} eq "");


exit(0);


################################################################
##################### subroutine definition ####################
################################################################

################################################################
#### Display full help message 
sub PrintHelp {
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	text-to-html

        1998 by Jacques van Helden (jacques\@scmbb.ulb.ac.be)
	
USAGE
        text-to-html [-i inputfile] [-o outputfile] [-v] [-font variable]

DESCRIPTION
	Converts a tab-delimited file into a HTML table.

CATEGORY
	util

OPTIONS
        -h      (must be first argument) display full help message
        -help   (must be first argument) display options
	-v	verbose
	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-font variable
		use variable instead of fixed fonts
	-chunk
		chunk size (when there are many rows, the program
		splits the table into several HTML tables, to reduce
		the waiting time on the browser.

	
INPUT FORMAT
	A tab-delimited text file
	
OUTPUT FORMAT
	An HTML file with a HTML table.
		
EXAMPLES
       text-to-html -v -i mydata -o myresult
	
End_of_help
  close HELP;
  exit (0);
}

################################################################
#### Display short help message
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
text-to-html options
----------------
-h      (must be first argument) display full help message
-help   (must be first argument) display options
-i      input file
-o      output file
-v      verbose
-font	variable
-chunk	chunk size
End_short_help
  close HELP;
  exit (0);
}


################################################################
## Read arguments
sub ReadArguments {
    foreach $a (0..$#ARGV) {
	foreach my $a (0..$#ARGV) {
	    ### verbose ###
	    if ($ARGV[$a] eq "-v") {
		if (&IsNatural($ARGV[$a+1])) {
		    $verbose = $ARGV[$a+1];
		} else {
		    $verbose = 1;
		}
		
		### detailed help
	    } elsif ($ARGV[$a] eq "-h") {
		&PrintHelp();
		
		### list of options
	    } elsif ($ARGV[$a] eq "-help") {
		&PrintOptions();
		
		### input file ###
	    } elsif ($ARGV[$a] eq "-i") {
		$infile{input} = $ARGV[$a+1];
		
		### output file ###
	    } elsif ($ARGV[$a] eq "-o") {
		$outfile{output} = $ARGV[$a+1];
		
		### output file ###
	    } elsif ($ARGV[$a] eq "-chunk") {
		$chunk= $ARGV[$a+1];
		unless (&IsNatural($chunk)) {
		    &RSAT::error::FatalError("Chunk must be a natural number");
		}
		
		### output file ###
	    } elsif ($ARGV[$a] eq "-border") {
		$border= $ARGV[$a+1];

		### input file ###
	    } elsif (($ARGV[$a] eq "-font") && ($ARGV[$a+1] =~ /^var/i)) {
		$font{variable} = 1;
		
	    }
	}
    }
}
