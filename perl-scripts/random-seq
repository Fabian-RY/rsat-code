#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib.pl";



if ($ARGV[0] eq "-h") {
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	random-seq
	
USAGE
	random-seq -l seqlength [-v] [-o outputfile]
	
	Generate a random sequence of length seqlength.
	
OPTIONS
    OUTPUT OPTIONS
	-l	sequence length
	-r	repetitions. Allows to generate a set r of sequences,
		each of length l.
	-v	verbose.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the comand within a pipe.
	-format	output format. 
		Two options are available:
		IG	IG suite from IntelliGenetics
		raw	(default) 
        -lw ##  Line width. A newline character will be inserted in the 
                sequence every ## bases. Default is 70. 
                -lw 0 will prevent newline insertion.
                
    PROBABILITIES
	-a	alphabet
		must be followed by nucleotide frequencies expressed precisely 
		this way:
		-a a:t # c:g #
		ex: 
		-a a:t 0.3 c:g 0.2
		
		The option 
		-a yeast
		will automatically use the nucleotide frequencies from yeast 
		genome.  
	-expfreq
		indicate the file that contains expected oligonucleotide 
		frequencies. When this option is used, the sequences are 
		generated according to a Markov chain. For instance if the 
		frequency file contains tetranucleotides, each base will be 
		selected randomly with a probability depending on the 3 
		preceding bases:
		
		           p(Wj-3,j)
		p(Bj=B) = -----------
		          p(Wj-3,j-1)
		          
		where	Bj	is the base at position j
			B	is a nucleotide, ie A, C, G or T
			Wj-3,j-1
				is a word found in the sequence between 
				positions j-3 and j-1
			Wj-3,j	is the same word with the character B 
				concatenated at its end
WEB VERSION
	http://www.cifn.unam.mx/Computational_Biology/yeast/random-seq.html

End_of_help
    close HELP;
  exit;
}

if ($ARGV[0] eq "-help") {
  open HELP, "| more";
  print HELP <<End_short_help;
random-seq options
==================
	-l	sequence length
	-r	repetitions. 
	-v	verbose.
	-o outputfile
	-format	output format. 
        -lw ##  Line width. 
	-a	alphabet. ex: -a a:t 0.3 c:g 0.2
	-expfreq
End_short_help
    close HELP;
  exit;
}

#### initialise parameters ####
$format = "raw";
$repetitions = 1;
$line_width = 70;
@letters = ('A','C','G','T');
$freq{'A'} = 0.25;
$freq{'C'} = 0.25;
$freq{'G'} = 0.25;
$freq{'T'} = 0.25;

#### read arguments ####
foreach $a (0..$#ARGV) {

  if ($ARGV[$a] eq "-v") {
    $verbose = 1;
    
  } elsif ($ARGV[$a] eq "-l") {
    $seq_length = $ARGV[$a+1];

  } elsif ($ARGV[$a] eq "-o") {
    $outputfile = $ARGV[$a+1];

  } elsif ($ARGV[$a] eq "-format") {
    $format = lc($ARGV[$a+1]);

  } elsif ($ARGV[$a] eq "-r") {
    $repetitions = $ARGV[$a+1];

  } elsif ($ARGV[$a] eq "-expfreq") {
    $freq_file = $ARGV[$a+1];

  } elsif ($ARGV[$a] eq "-lw") {
    $line_width = $ARGV[$a+1];

  } elsif ($ARGV[$a] eq "-a") {
    if (("$ARGV[$a+1] $ARGV[$a+2]" =~ /a:t (\S+)/i) && ($1 <=1) && ($1 >=0)){
      $freq{'A'} = $freq{'T'} = $1;
    }
    if (("$ARGV[$a+3] $ARGV[$a+4]" =~ /c:g (\S+)/i) && ($1 <=1) && ($1 >=0)){
      $freq{'C'} = $freq{'G'} = $1;
    }
    
    if ($ARGV[$a+1] eq "yeast") {
      $freq{'A'} = $freq{'T'} = 0.308512197555054;
      $freq{'C'} = $freq{'G'} = 0.191487802444946;
    }

  }
}


#### check argument values ####
if ($seq_length eq "") {
  print "	You should specify the sequence length.\n";
  print "	Type random-seq -h for more info.\n";
  exit;
} 

unless ($seq_length > 0) {
  print "	Sequence length should be > 0.\n";
  print "	Type random-seq -h for more info.\n";
  exit;
}

unless ($repetitions >=1) {
  print "	Number of repetitions should be >=1.\n";
  print "	Type random-seq -h for more info.\n";
  exit;
}

CheckOutputSeqFormat($format);

### calculate cumulated frequencies ###

### for individual nucleotides ###
$cum_letter_freq[0] = $freq{$letters[0]};
for $l (1..$#letters) {
  $cum_letter_freq[$l] = $cum_letter_freq[$l-1]+$freq{$letters[$l]};
}
unless ($cum_letter_freq[$#letters] > 0) {
  print "	Error: invalid alphabet specification.\n";
  print "	Type random-seq -h for more info.\n";
  exit;
}
for $l (0..$#letters) {
  $freq{$letters[$l]} /= $cum_letter_freq[$#letters];
  $cum_letter_freq[$l] /= $cum_letter_freq[$#letters];
}

### oligonucleotide frequencies ###
if ($freq_file ne "") {
  unless (open EXPECTED, $freq_file) {
    print "	cannot open frequency file\n";
    exit;
  }
  while (<EXPECTED>) {
    if (/([acgt]+)\t(\S+)/i) {
      $oligo_seq = lc($1);
      $expected_freq{$oligo_seq} = $2;
    }
  }
  $oligo_length = length($oligo_seq); ##!!! all oligonucleotides must be the same size
  close EXPECTED;
  foreach $oligo_seq (keys %expected_freq) {
    $subword = substr($oligo_seq,0,$oligo_length-1);
    $subword_freq{$subword} += $expected_freq{$oligo_seq};
  }
  foreach $subword (keys %subword_freq) {
    $word = lc($subword.$letters[0]);
    $cum_letter_freq{$subword}[0] = $expected_freq{$word}/$subword_freq{$subword};
    for $l (1..$#letters) {
      $word = lc($subword.$letters[$l]);
      $cum_letter_freq{$subword}[$l] = $cum_letter_freq{$subword}[$l-1] + $expected_freq{$word}/$subword_freq{$subword};
    }
  }
}


#### verbose ####
if ($verbose) {
  print "random sequence\n";
  print "sequence length	$seq_length\n";
  print "repetitions		$repetitions\n";
  print "format			$format\n";
  if ($outputfile ne "") {
    print "Output file	$outputfile\n";
  }
  print "nucleotide frequencies: \n";
  if ($freq_file ne "") {
    print "Calibrated oligonucleotide frequencies\n";
    print "	oligonucleotide length:  $oligo_length\n";
    print "	expected frequency file: $freq_file\n";
  } else {
    for $l (0..$#letters) {
      print "\t";
      print "$letters[$l]\t";
      print "$freq{$letters[$l]}\n";    
    }
  }
  print "\n";
}



### open output file ###
if ($outputfile ne "") {
  unless (open(OUTPUT, ">$outputfile")) {
    print "\tcannot open output file\n";
    print "\ttype oligo-analysis -h for help\n";
    exit;
  }
  $out = OUTPUT;
} else {
  $out = STDOUT;
}

###### execute the command #########
srand (time);

for $r (1..$repetitions) {
  ### initialization
  $sequence = "";
  $seq_id = "rand_$r";
  @comments = ();
  push (@comments, "random sequence");
  push (@comments, "length: $seq_length");
  if ($repetitions > 1) {
      push (@comments, "repetition nb $r of $repetitions");
  }

  if ($freq_file ne "") {
    @subword_keys = sort keys %subword_freq;
    $rand = int (rand $#subword_keys);
    $subword = $subword_keys[$rand];
    $sequence .= uc($subword);
    for $i ($oligo_length..$seq_length) {
        @cum_letter_freq = @{$cum_letter_freq{$subword}};
        $rand = rand;
        $l = -1;
        do {
          $l++;
        } until (($l > $#letters) || ($cum_letter_freq[$l] >= $rand));
        $next_letter = $letters[$l];
        $sequence .= $next_letter;
        $subword = lc(substr($subword.$next_letter,1));
      }
  } else {
    for $i (1..$seq_length) {
      $rand = rand;
      $l = -1;
      do {
        $l++;
      } until (($l > $#letters) || ($cum_letter_freq[$l] >= $rand));
      $next_letter = $letters[$l];
      $sequence .= $next_letter;
    }
  }
  PrintNextSequence($out, $format, $line_width, $sequence, $seq_id, @comments);
}  

###### close input file ######
if ($inputfile ne "") {
  close $in;
}

###### close output file ######
if ($outputfile ne "") {
  close $out;
}


exit(0);

