#!/usr/bin/perl -w
############################################################
#
# $Id: graph-node-degree,v 1.3 2007/01/18 10:46:12 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

## use strict;

=pod

=head1 NAME

graph-node-degree

=head1 DESCRIPTION

Calculate the node degree of each node and specifies if this node is a seed or a target node.

=head1 AUTHORS

=over

=item jvanheld@scmbb.ulb.ac.be

=item sylvain@scmbb.ulb.ac.be

=head1 CATEGORY

graph analysis

=head1 USAGE

graph-node-degree [-i graph_file] -node node1 [-node node2 ...] [-o outputfile] [-v #] [...]

graph-node-degree [-i graph_file] -nodef node_file [-o outputfile] [-v #] [...]

graph-node-degree [-i graph_file] -all [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

See convert-graph for a description of the supported input formats.

=head1 OUTPUT FORMAT

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph;

################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();

    @node_names = (); ## Names of the nodes for which the degree is searched
    @found_nodes = (); ## Node objects
    @unknown_nodes = (); ## Names of the unidentified nodes
    $all_nodes = 0; ## Search the degree of all nodes

    @out_fields = qw(id in_deg out_deg degree ktype);

    ################################################################
    ## Initialize the graph
    $graph = new RSAT::Graph();
    $graph->set_attribute("label", "graph");

    ## Columns of the tab-delimited graph file
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;

    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
#    $main::in = STDIN;
    $main::out = STDOUT;

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values

    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ## Read input graph
    $graph->read_from_table($infile{graph}, $source_col, $target_col, $weight_col);


    ################################################################
    ## Build the list of seed nodes

    ## Use all nodes as seeds
    if ($all_nodes) {
      @found_nodes = $graph->get_nodes();
      &RSAT::message::TimeWarn("Describle all",scalar(@found_nodes), "nodes of the graph") if ($main::verbose >= 2);
      ## Put the name of each node in the list
      @node_names = ();
      foreach my $node (@found_nodes) {
	my $name = $node->get_attribute("label");
	push @node_names, $name;
      }
    } else {

      ## Read nodes from a file
      if ($infile{nodes}) {
	my $l = 0;
	&RSAT::message::TimeWarn("Reading nodes from file", $infile{nodes}) if ($main::verbose >= 2);
	my ($nodes_handle) = &OpenInputFile($infile{nodes});
	while (my $line = <$nodes_handle>) {
	  $l++;
	  next if ($line =~ /^\#/); ## Skip header lines
	  next if ($line =~ /^--/); ## Skip comment lines
	  next if ($line =~ /^;/); ## Skip comment lines
	  next unless ($line =~ /\S/); ## Skip empty lines
	  chomp($line);
	  my @fields = split /\s+/, $line;
	  my $name =  $fields[0];
	  if ($name) {
	    push @node_names,$name;
	  } else {
	    &RSAT::message::Warning("Line", $l, "starts with space. Skipped.");
	  }
	}
	close $nodes_handle;
      }

      ## Identify seed nodes in the graph
      if (scalar(@node_names) == 0) {
	&RSAT::message::Warning("The list of input nodes is empty. see the options -all, -node and -nodef fo specify the nodes.");
      }
      &RSAT::message::TimeWarn("Identifying",scalar(@node_names), "nodes in the graph") if ($main::verbose >= 2);
      foreach my $name (@node_names) {
	my $node = $graph->node_by_id($name);
	if ($node) {
	  push @found_nodes, $node;
	  &RSAT::message::Info("Identified node with name", $name, $node->get_attribute("id")) if ($main::verbose >= 3);
	} else {
	  push @unknown_nodes, $name;
	  &RSAT::message::Warning("The graph does not contain any node with name", $name);
	}
      }
    }


    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

     ## Print the header
     my %field_descr = ();
     $field_descr{id} = "node identifier";
     $field_descr{in_deg} = "incoming degree (number of incoming arcs)";
     $field_descr{out_deg} = "outgoing degree (number of outgoing arcs)";
     $field_descr{degree} = "total degree (number of incoming + outgoing arcs)";
     $field_descr{ktype} = "connectivity type. Orphan (degree=0), source (in_deg=0), target (out_deg=0) or intermediate.";
     print $out "; Field descriptions\n";
     foreach my $field (@out_fields) {
       printf $out ";\t%-15s\t%s\n", $field, $field_descr{$field};
     }
#     print $out '#',  join ("\t", @out_fields), "\n";

    ################################################################
    ## Calculate the degree
    foreach my $node (@found_nodes) {
      my $in_deg = scalar($node->get_attribute("in_nodes")) || 0;
      my $out_deg = scalar($node->get_attribute("out_nodes")) || 0;
      $node->force_attribute("in_deg", $in_deg);
      $node->force_attribute("out_deg", $out_deg);
      $node->force_attribute("degree", $in_deg + $out_deg);

      ## Specify th connectivity type
      if (($in_deg == 0) && ($out_deg == 0)) {
	$node->force_attribute("ktype", "orphan");
      } elsif ($in_deg == 0) {
	$node->force_attribute("ktype", "source");
      } elsif ($out_deg == 0) {
	$node->force_attribute("ktype", "target");
      } else {
	$node->force_attribute("ktype", "interm");
      }

#       ################################################################
#       ## Print the results
#       my @out_values = ();
#       foreach my $field (@out_fields) {
# 	push @out_values, $node->get_attribute($field);
#       }
#       print $out join ("\t", @out_values), "\n";
    }


    $graph->push_attribute("nodes_to_export", @found_nodes);
    print $out $graph->to_text("node_table", @out_fields);

    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Graph file
=pod

=item B<-i graphfile>

If no graph file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{graph} = shift(@arguments);

	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes in the tab-delimited
graph file.

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes in the tab-delimited
graph file.

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight nodes in the tab-delimited
graph file.

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }


=pod

=item B<-nodef node_file>

Node file. The node file specifies a list of nodes.

Node file format: the first word of each row specifies one node. The rest of the row is ignored.

=cut
	} elsif ($arg eq "-nodef") {
	    $main::infile{nodes} = shift(@arguments);

=pod

=item B<-all>

Look for the degree of all nodes. 

=cut
	} elsif ($arg eq "-all") {
	    $all_nodes = 1;

=pod

=item B<-node node>

Specify one node. This option can be used iteratively to specify
several nodes.

=cut
	} elsif ($arg eq "-node") {
	    push @node_names, shift(@arguments);

=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; graph-neighbnours ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }

    ## Report graph size
    my ($nodes, $arcs) = $graph->get_size();
    print $out "; Graph size\n";
    print $out ";\tnodes\t",$nodes,"\n";
    print $out ";\tarcs\t",$arcs,"\n";

    ## Report seed nodes
    if ($all_nodes) {
      print $out "; All nodes\t",scalar(@node_names),"\n";
    } else {
      print $out "; Selected nodes\t",scalar(@node_names),"\n";
    }
    if (@unknown_nodes) {
      print $out ";\tidentified\t",scalar(@found_nodes),"\n";
      print $out ";\tunknown nodes\t",scalar(@node_names) - scalar(@found_nodes),"\n";
      foreach my $name (@unknown_nodes) {
	print $out join ("\t", ";\t", "unknown", $name), "\n";
      }
    }
}


__END__

=pod

=head1 SEE ALSO

=cut
