#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib.pl";

#### initialise parameters ####
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;
$null = "<NULL>";

&ReadArguments;

### open input file ###
$last_col;
foreach $f (0..$#input_files) {
    if ((defined($default_sc)) && !(defined ($sc[$f]))) {
	$sc[$f] = $default_sc;
    }
    $inputfile = $input_files[$f];
    
    $in = &OpenInputFile($inputfile);
    $max_fields{$f} = 0;
    while (<$in>) {
	next unless (/\S/);
	next if (/^;/);
	chomp;
	@fields = split "\t";
	if (defined($sc[$f])) {
	    $max_fields{$f}= 1;
	} else {
	    $max_fields{$f} = &max($max_fields{$f},$#fields);
	}
	$key = lc($fields[0]);
	$id{$key} = $fields[0];
	if (defined($sc[$f])) {
	    $col = $last_col + 1;
	    $score{$key}[$col] = $fields[$sc[$f]-1];
	} else {
	    for $c (1..$#fields) {
		$col = $last_col + $c;
		$score{$key}[$col] = $fields[$c];
	    }
	}
    }
    close $in;
    $last_col += $max_fields{$f};
}

### open output file ###
$out = &OpenOutputFile($outputfile);

#### print header line
print $out ";key";
foreach $f (0..$#input_files) {
    foreach $c (1..$max_fields{$f}) {
	print $out "\t", $input_files[$f], "_$c";
    }
}
print $out "\n";

#### print result
foreach $key (sort keys %id) {
    print $out $id{$key};
    for $f (1..$last_col) {
	$score = $score{$key}[$f];
	if ($score eq "") {
	    print $out "\t$null";
	} else {
	    print $out "\t$score";
	}
    }
    print $out "\n";
}

#### verbose ####
if ($verbose) {
    print $out "; compare-scores";
    foreach $a (@ARGV) {
        if (($a =~ /\S+\s+\S+/) || ($a !~ /\S/)){
            print $out " '$a'";
        } else {
            print $out " $a";
        }
    }
    print $out "\n";

    print $out ";Input files :\n";
    for $f (0..$#input_files) {
	print $out ";\t$input_files[$f]\t$sc[$f]\n";
    }
    if ($outputfile ne "") {
	print $out ";Output file	$outputfile\n";
    }
}



###### print output ######




###### verbose ######
if ($verbose) {
    $done_time = `date '+%d/%m/%y %H:%M:%S %Z'`;
    print $out ";Job started $start_time";
    print $out ";Job done    $done_time";
}


###### close output file ######
close $out unless ($outputfile eq "");


exit(0);


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	compare-scores

        1998 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        compare-scores -i inputfile_1 -i inputfile_2 [-i inputfile_n] [-o outputfile] [-v] -sc #

DESCRIPTION
	compares the score associated to keys in different input files

OPTIONS
        -h      (must be first argument) display full help message
        -help   (must be first argument) display options
	-v	verbose
	-i input_file (use recursively to indicate several input files)
		input file. 
		At least 2 different input files must be specified.
		The input files each contain a table with several columns,
		separated by tabulations (\t). 
		The first column of each input file contains the key.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
		
	-sc	score column. 
		The score column must be >=2 (the first column
		contains the object identifier).

	-sc#	score column for the #th file

INPUT FORMAT
	each line of the input file provides the score for a single key. 
	The first word of each line must be the key.
	The score can be located in any column, which will be indicated with the parameter -sc.
	Lines beginning with a semicolumn (;) are ignored.
	
OUTPUT FORMAT
	One line per key. The first column is the key, followed by 1 column for 
	the score associated to that key in each of the input files specified.
	
EXAMPLES
       compare-scores -v -i data_file_1 -i data_file_2 -sc 4  -o myresult
	
End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
compare-scores options
----------------
-h      (must be first argument) display full help message
-help   (must be first argument) display options
-i      input file (use recursively to indicate several input files)
-o      output file
-v      verbose
-sc	score column
-sc#	score column for the #th file
End_short_help
  close HELP;
  exit;
}

sub ReadArguments {
#### read arguments ####
    foreach $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    $verbose = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions;
	    
	    ### input file ###
	} elsif ($ARGV[$a] eq "-i") {
	    push @input_files, $ARGV[$a+1];
	    
	    ### output file ###
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    
	    ### score column
	} elsif ($ARGV[$a] eq "-sc") {
	    $default_sc = $ARGV[$a+1];
	    unless ((&IsNatural($default_sc)) && ($default_sc >= 2)) {
		warn "Error : score column must be an integer and > 2\n";
		&PrintHelp;
	    }
	    
	} elsif ($ARGV[$a] =~ /^-sc(\d+)/)  {
	    $sc[$1-1] = $ARGV[$a+1]; ### substract 1 from the index
	    unless ((&IsNatural($sc[$1-1])) && ($sc[$1-1] >= 2)) {
		warn "Error : score column must be an integer and > 2\n";
		&PrintHelp;
	    }
	    
	}
    }
}
