#!/usr/bin/perl -w
############################################################
#
# $Id: compare-features,v 1.2 2005/07/25 16:13:32 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################
# use strict;
#use diagnostics;
BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
    require "RSA.lib";
}
use RSAT::feature;
use RSAT::stats;


=pod

=head1 NAME

compare-features

=head1 DESCRIPTION

Compare two sets of features. 

This program takes as input several feature files (two or more), and
calculates the intersection and difference between features.

=head1 AUTHORS

=item Jean Val√©ry Turatsinze <jturatsi@ulb.ac.be> 

=item Jacques van Helden <jvanheld@scmbb.ulb.ac.be>

=head1 CATEGORY

util

=head1 USAGE
    
compare-features -i inputfile_1 -i inputfile_2 [-i inputfile_3 ... ...] 
[-o outputfile] [-v]

=head1 INPUT FORMAT

The two input files are in feature format. 

Each feature is represented by a single line, which 
should provide the following information:

Input file columns:

=item 1. map label (eg gene name)

=item 2. feature type

=item 3. feature identifier (ex: GATAbox, Abf1_site)

=item 4. strand (D for Direct, R for Reverse),

=item 5. feature start position

=item 6. feature end position

=item 7. (optional) description 

=item 8. (optional) score

The standard input format assumes that these topics 
are provided in this order, separated by tabs. 
Start and end positions can be positive or negative.


=head1 OUTPUT FORMAT

=cut


################################################################
#### Main package
package main;
{
    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();
    
    
    #local %infile = ();
    local @inputfiles = ();
    local %outfile = ();
    
    local $verbose = 0;
    local $in = STDIN;
    local $out = STDOUT;

    local $input_format = "ft";
    %supported_input_format =(
			      ft=>1,
			      gft=>1,
			      gff=>1,
			      dnapat=>1,
			      );
    $supported_input_formats = join (",", keys %supported_input_format);

    local $output_format = "ft";
    %supported_output_format =(
			       ft=>1,
			       gft=>1,
			       gff=>1,
			       dnapat=>1
			       );
    $supported_output_formats = join (",", keys %supported_output_format);

    local @feature_lists = ();

    &ReadArguments();

    ################################################################
    #### check argument values

    ## Number of input files should be >= 2
    unless (scalar(@inputfiles) >= 2) {
	&RSAT::error::FatalError("You must specify at least two input files\n");
    }

    ################################################################
    ### open output stream
    $out = &OpenOutputFile($outfile{output});

    ################################################################
    ##### read input
    my $feat_nb = 0;
    my %feature_ids = ();
    foreach my $f (0..$#inputfiles) {
	my @features = ();
	my $infile = $inputfiles[$f];
	&RSAT::message::TimeWarn(join("\t", "Reading features from file", $f, $infile)) if ($main::verbose >= 2);
	($in) = &OpenInputFile($infile);
	while (<$in>) {
	    ## Comment lines
	    if ((/^;\s+(.*)/) || (/^--\s+(.*)/)) {
		next;
	    }
	    next unless (/\S/);
	    chomp;
	    my $feature = new RSAT::feature();
	    $feat_nb++;
	    my $new_id = "ft_".$feat_nb;
	    $feature->parse_from_row($_, $input_format);
	    $feature->set_attribute("id", $new_id);
	    $feature->set_attribute("file_nb", $f);
	    $feature->set_attribute("filename", $infile);
	    push @features, $feature;
	    $feature_ids{$new_id} = $feature;
#	print $out $feature->to_text($output_format, $null);
	}
	close $in if ($infile);
	push @feature_lists, \@features;
    }

    ################################################################
    #### print verbose
    &Verbose() if ($verbose);

    ################################################################
    ## Index of all the starting positions per sequence. The indexing keys are
    ## - sequence name
    ## - reference to the feature object
    ## The indexed value is the starting positions
    my %left_index = (); 
    for my $a (0..$#inputfiles) {
	my $ref_a = $feature_lists[$a];
	foreach my $feature (@{$ref_a}) {
	    my $seq_name = $feature->get_attribute('seq_name');
	    my $start = $feature->get_attribute('start');
	    my $end = $feature->get_attribute('end');

	    ## Calcualate left and right coordinates
	    my $left = &RSAT::stats::min($start, $end);
	    $feature->set_attribute("left", $left);
	    my $right = &RSAT::stats::max($start, $end);
	    $feature->set_attribute("right", $right);
	    my $len = $right - $left + 1;
	    $feature->set_attribute("len", $len);


	    ## Index the feature 
	    my $id = $feature->get_attribute("id");
	    $left_index{$seq_name}->{$id} = $left;
# 	    &RSAT::message::Debug("Indexing left position", 
# 				  $a, $inputfiles[$a], $seq_name, $start, $end, $left,
# #				  $feature, \$feature, 
# 				  $feature->get_attribute("id"),
# 				  $feature->get_attribute("left"),
# 				  ) if ($main::verbose >= 0);
	}
    }

    ## Detect intersection between features
    foreach my $seq_name (keys (%left_index)) {
	my %seq_features = %{$left_index{$seq_name}};
	my @sorted_features = sort {$left_index{$seq_name}->{$a} <=> $left_index{$seq_name}->{$b} } keys %seq_features;
	&RSAT::message::Info(join("\t", "Features per sequences", 
				  scalar(keys(%seq_features)), 
				  $seq_name)
			     ) if ($main::verbose >= 3);
	foreach my $f (0..$#sorted_features) {
	    my $current_id = $sorted_features[$f];
	    my $current_feature = $feature_ids{$current_id};
	    &RSAT::message::Debug("Sorted features",
				  $f+1, 
				  scalar(@sorted_features),
				  $current_id, 
				  $seq_name,
				  $current_feature->get_attribute("strand"),
				  $current_feature->get_attribute("left"),
				  $current_feature->get_attribute("right"),
				  $current_feature->get_attribute("len"),
				  $current_feature->get_attribute("file_nb"),
				  $current_feature->get_attribute("filename"),
				  ) if ($main::verbose >= 0);

	    ## Detect next features overlapping with the current one
	    my $next = $f+1;
	    my $intersection = 0;
	    while ($next <= $#sorted_features) {
		my $next_id = $sorted_features[$next];
		my $next_feature = $feature_ids{$next_id};
		my $intersection = $current_feature->get_attribute("right") - $next_feature->get_attribute("left") + 1;
		$intersection = &RSAT::stats::max(0,$intersection);
		if ($intersection <= 0) {
		    last;
		} else {
		    &RSAT::message::Debug("Intersection", 
					  $f+1,
					  $current_id, 
					  $current_feature->get_attribute("left"),
					  $current_feature->get_attribute("right"),
					  $next+1,
					  $next_id, 
					  $next_feature->get_attribute("left"),
					  $next_feature->get_attribute("right"),
					  $intersection) if ($main::verbose >= 0);
		    ## Treat the intersection (stats, report)
		}
		$next++;
	    }

	}
    }

#     ## Pairwise comparisons of feature lists
#     for my $a (0..$#inputfiles) {
# 	my $ref_a = $feature_lists[$a];
# 	for my $b ($a..$#inputfiles) {
# 	    my $ref_b = $feature_lists[$b];	    
# 	}
#     }


    ################################################################
    ###### print output


    ################################################################
    ###### finish verbose
    if ($verbose >= 1) {
	my $done_time = &AlphaDate();
	print $out "; Job started $start_time\n";
	print $out "; Job done    $done_time\n";
    }


    ################################################################
    ###### close output stream
    close $out if ($outfile{output});


    exit(0);
    
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
    foreach my $a (0..$#ARGV) {

	## Verbosity
=pod


=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$main::verbose = $ARGV[$a+1];
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

display options

=cut
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions();
	    

	    ## Input file
=pod

=item B<-i inputfile>

This option can be used iteratively to specify several input files. 

It must be used at least 2 times, since the comparison requires at least two
feature files.

=cut
	} elsif ($ARGV[$a] eq "-i") {
	    push @main::inputfiles, $ARGV[$a+1];
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($ARGV[$a] eq "-o") {
	    $main::outfile{output} = $ARGV[$a+1];
	    

	    ### input format  
=pod

=item B<-iformat input_format>

Input feature format (Supported: $supported_input_formats)

=cut
	} elsif ($ARGV[$a] eq "-iformat") {
	    $main::input_format = $ARGV[$a+1];
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supoprted: $supported_input_formats")
		unless ($supported_input_format{$input_format});

	    ### output format  
=pod

=item B<-oformat output_format>

Output feature format (Supported: $supported_output_formats)

=cut
	} elsif ($ARGV[$a] eq "-oformat") {
	    $main::output_format = $ARGV[$a+1];
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supoprted: $supported_output_formats")
		unless ($supported_output_format{$output_format});

	}
    }

=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $out "; compare-features ";
    &PrintArguments($out);
    print $out "; Input files\n";
    print $out join ("\t", ";", "file#", "feat#", "file name"), "\n";
    foreach my $f (0..$#main::inputfiles) {
	my $infile = $main::inputfiles[$f];
	my $feature_list_ref = $main::feature_lists[$f];
	my @feature_list = @{$feature_list_ref};
	my $nb_features = scalar(@feature_list);
	print $out join("\t", ";", 
			$f+1,
			$nb_features,
			$infile,
			), "\n";
    }

    if (defined(%main::outfile)) {
	print $out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=item feature-map

=item convert-features


=cut
