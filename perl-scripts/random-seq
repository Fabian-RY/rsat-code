#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.classes";



#### initialise parameters ####
$out_format = "fasta";
$repetitions = 1;
$line_width = 70;
$sequence_type = "dna";

&ReadArguments();


################################################################
#
# calculate residue frequencies
#
if ($sequence_type eq "dna") {
    @letters = qw ( A C G T );
} elsif ($sequence_type =~ /prot/) {
    @letters = qw ( a c d e f g h i k l m n p q r s t v w y );
#    @letters = qw ( A C D E F G H I K L M N P Q R S T V W Y );
} else {
    die "Error: unknown sequence type $sequence_type\n";
}

if (defined(%alphabet)) {
    %freq = %alphabet
} else {
    foreach $letter (@letters) {
	$freq{$letter} = 1/($#letters + 1);
    }
}


#### check argument values ####
unless (&IsNatural($seq_length)) {
    warn "	You should specify the sequence length.\n";
    warn "	Type random-seq -h for more info.\n";
    exit;
} 

unless ($repetitions >=1) {
    warn "	Number of repetitions should be >=1.\n";
    warn "	Type random-seq -h for more info.\n";
    exit;
}

&CheckOutputSeqFormat($out_format);


#### non-coding frequencies
if ($ncf) {
    #### check organism
    &CheckOrganism($organism_name);
  
    #### check oligo length
#    die $oligo_length;
    unless ((&IsNatural($oligo_length)) && ($oligo_length > 0)) {
	&FatalError("For using intergenic oligonucleotide frequencies, the oligo length needs to be specified\n");
    }

    $data_dir = $supported_organism{$organism_name}->{'data'};
    
    ### localize dyad non-coding frequency file
    $method = "Frequency file";
    $exp_freq_file = "$data_dir/oligo-frequencies/${oligo_length}nt_non-coding_${organism_name}.freq";
    
#    &FatalError("cannot read expected frequency file $exp_freq_file\n") 
#	unless ((-e  $exp_freq_file) && 
#		(-e  $exp_freq_file.".gz"));
} 


#  if ($genomic_segments) {
#      #### organism
#      &CheckOrganism($organism_name);
#      &ReadOrfPositions($organism_name);
#      foreach $chr (values %chomosome) {
#      }
#  }

### expected frequency file
if ($exp_freq_file) {

    &ReadExpectedFrequencies($exp_freq_file) ;
    
    foreach my $pattern_seq (keys %patterns) {
	$expected_freq{$pattern_seq} = $patterns{$pattern_seq}->{exp_freq};
    }
    
#      die "	cannot open frequency file\n"
#  	unless (open EXPECTED, $exp_freq_file);
    
#      while (<EXPECTED>) {
#  	chomp;
#  	next if (/^;/);
#  	next unless (/\S/);
#  	($oligo_seq, $expected_freq) = split "\t";
#  #print STDERR "HELLO\t$oligo_seq";

#  	die "error: frequency file contains non-number values\t'$expected_freq'\n"
#  	    unless (&IsReal($expected_freq));
	    
#  	$oligo_seq = lc($oligo_seq);
#  #warn "\t$oligo_seq\n";
#  	if (defined($expected_freq{$oligo_seq})) {
#  	    warn ("; WARNING: oligomer\t", $oligo_seq, "\t found twice in the expected frequency file\n",
#  		  "; only taking the first frequency into account\n");
#  	} else {
#  	    $expected_freq{$oligo_seq} = $expected_freq;
#  	    $sum_expected_freq+= $expected_freq{$oligo_seq};
#  	}
#      }
#      $oligo_length = length($oligo_seq); ##!!! all oligomers must be the same size
#      close EXPECTED;

    #### make sure the sum of frequencies is 1
#    foreach $oligo_seq (keys %expected_freq) {
#	$expected_freq{$oligo_seq} = $expected_freq{$oligo_seq}/$sum_expected_freq;
#    }
    #### calculate subword frequencies
    foreach $oligo_seq (keys %expected_freq) {
	$subword = substr($oligo_seq,0,$oligo_length-1);
	$subword_freq{$subword} += $expected_freq{$oligo_seq};
    }
    #### calculate conditional residue probabilities
    foreach $subword (keys %subword_freq) {
	$word = lc($subword.$letters[0]);
	$cum_letter_freq{$subword}[0] = $expected_freq{$word};
	$cum_letter_freq{$subword}[0]/=$subword_freq{$subword} if $expected_freq{$word};
	for $l (1..$#letters) {
	    $word = lc($subword.$letters[$l]);
	    $cum_letter_freq{$subword}[$l] = $cum_letter_freq{$subword}[$l-1];
#	    print (join ("\t", 
#			 $subword, 
#			 $subword_freq{$subword},
#			 $word, 
#			 $expected_freq{$word}
#			 ), "\n");
	    $cum_letter_freq{$subword}[$l] += $expected_freq{$word}/$subword_freq{$subword} if $expected_freq{$word};
	}
    }
    @subword_keys = sort keys %subword_freq;
	    

} else {
### calculate cumulated frequencies ###
### for individual residues ###
    $cum_letter_freq[0] = $freq{$letters[0]};
    for $l (1..$#letters) {
	$cum_letter_freq[$l] = $cum_letter_freq[$l-1]+$freq{$letters[$l]};
    }
    unless ($cum_letter_freq[$#letters] > 0) {
	warn "	Error: invalid alphabet specification.\n";
	warn "	Type random-seq -h for more info.\n";
	exit;
    }
    for $l (0..$#letters) {
	$freq{$letters[$l]} /= $cum_letter_freq[$#letters];
	$cum_letter_freq[$l] /= $cum_letter_freq[$#letters];
    }
}



### open output file ###
$out = &OpenOutputFile($outputfile);



#### verbose ####
if ($verbose) {
    print $out "; random sequence\n";
    print $out "; sequence length	$seq_length\n";
    print $out "; repetitions		$repetitions\n";
    print $out "; format			$out_format\n";
    if ($outputfile ne "") {
	print $out "; Output file	$outputfile\n";
    }
    print $out "; residue frequencies: \n";
    if ($exp_freq_file) {
	print $out "; Calibrated oligomer frequencies\n";
	print $out "; 	oligomer length:         $oligo_length\n";
	print $out "; 	expected frequency file: $exp_freq_file\n";
	print $out "; oligomer frequencies\n";
#	foreach $key (sort keys %expected_freq) {
#	    printf $out ";\t%s\t%f\n", $key, $expected_freq{$key};
#	}
	print $out "; subword frequencies\n";

	foreach $subword (sort keys %subword_freq) {
	    printf $out ";\t%s\t%f\t", $subword, $subword_freq{$subword};
	    for $l (0..$#letters) {
		printf $out (" %s:%g",
			    $letters[$l],
			    $cum_letter_freq{$subword}[$l] - ($l>0)*$cum_letter_freq{$subword}[$l-1]
			     );
	    }
	    print $out "\n";
	}
    } else {
	for $l (0..$#letters) {
	    print $out "; \t";
	    print $out "; $letters[$l]\t";
	    print $out "; $freq{$letters[$l]}\n";    
	}
    }
}


################################################################
#
# generate the random sequence
#
if (defined($seed)) {
    srand($seed);
} else {
    srand (time);
}

for $r (1..$repetitions) {
    ### initialization
    $sequence = "";
    $seq_id = "rand_$r";
    @comments = ();
    push (@comments, "random sequence");
    push (@comments, "length: $seq_length");
    if ($repetitions > 1) {
	push (@comments, "repetition nb $r of $repetitions");
    }
    
    if ($exp_freq_file) {
	$rand = int (rand $#subword_keys);
	#### first work selection should be improved
	$subword = $subword_keys[$rand];
	$sequence .= uc($subword);

	for $i ($oligo_length..$seq_length) {
#	    @cum_letter_freq = @{$cum_letter_freq{$subword}};
	    $rand = rand;
	    $l = 0;
	    while ($l <= $#letters) {
		if ($cum_letter_freq{$subword}[$l] >= $rand) {
		    last;
		}
		else {
		    $l++;
		}
	    }
	    $next_letter = $letters[$l];
#	    print "\t$subword\t$rand\t$l\t$next_letter\t", $cum_letter_freq{$subword}[$l] , "\n";
	    $sequence .= $next_letter;
	    $subword = lc(substr($subword.$next_letter,1));
	}
    } else {
	for $i (1..$seq_length) {
	    $rand = rand;
	    $l = -1;
	    do {
		$l++;
	    } until (($l > $#letters) || ($cum_letter_freq[$l] >= $rand));
	    $next_letter = $letters[$l];
	    $sequence .= $next_letter;
	}
    }
    PrintNextSequence($out, $out_format, $line_width, $sequence, $seq_id, @comments);
}  

###### close output file ######
close $out if ($outputfile);


exit(0);




sub ReadArguments {
    #### read arguments ####
    foreach $a (0..$#ARGV) {
	
	if ($ARGV[$a] eq "-v") {
	    $verbose = 1;
	    
	} elsif ($ARGV[$a] eq "-l") {
	    $seq_length = $ARGV[$a+1];

	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp();
	    
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions();
	    
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];

	} elsif ($ARGV[$a] eq "-format") {
	    $out_format = lc($ARGV[$a+1]);

	} elsif ($ARGV[$a] eq "-type") {
	    $sequence_type = lc($ARGV[$a+1]);

	} elsif ($ARGV[$a] eq "-r") {
	    $repetitions = $ARGV[$a+1];

	} elsif ($ARGV[$a] eq "-expfreq") {
	    $exp_freq_file = $ARGV[$a+1];

	} elsif ($ARGV[$a] eq "-lw") {
	    $line_width = $ARGV[$a+1];

	} elsif ($ARGV[$a] eq "-seed") {
	    $seed = $ARGV[$a+1];

	} elsif ($ARGV[$a] eq "-a") {
	    if (("$ARGV[$a+1] $ARGV[$a+2]" =~ /a:t (\S+)/i) && ($1 <=1) && ($1 >=0)){
		$alphabet{'A'} = $alphabet{'T'} = $1;
	    }
	    if (("$ARGV[$a+3] $ARGV[$a+4]" =~ /c:g (\S+)/i) && ($1 <=1) && ($1 >=0)){
		$alphabet{'C'} = $alphabet{'G'} = $1;
	    }
	    
	    if ($ARGV[$a+1] eq "yeast") {
		$alphabet{'A'} = $alphabet{'T'} = 0.308512197555054;
		$alphabet{'C'} = $alphabet{'G'} = 0.191487802444946;
	    }

	    ### use oligo non-coding frequencies as expected frequencies
	} elsif ($ARGV[$a] =~ /^-ncf/i) {
	    $ncf = 1;

	    ### organism (for selecting the appropriate expected frequencies)
	} elsif ($ARGV[$a] =~ /^-org/i) {
	    $organism_name = $ARGV[$a+1];
	    
	    #### oligonucleotide length
	} elsif ($ARGV[$a] eq "-ol") {
	    $oligo_length = $ARGV[$a+1];
	    
#  	    ### genomic segments
#  	} elsif ($ARGV[$a] =~ /^-gen/i) {
#  	    $genomic_segments = 1;
	    
	}
	    
    }
}

sub PrintHelp {
    open HELP, "| more";
    print HELP <<End_of_help;
NAME
	random-seq
	
USAGE
	random-seq -l seqlength [-v] [-o outputfile]
	
DESCRIPTION
	Generates random sequences according to different
	probabilistic models, including Markov chains.

CATEGORY
	sequences

OPTIONS
    OUTPUT OPTIONS
	-l	sequence length
	-r	repetitions. Allows to generate a set r of sequences,
		each of length l.
	-v	verbose.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the comand within a pipe.
	-format	output format. 
		Two options are available:
		IG	IG suite from IntelliGenetics
		raw	(default) 
        -lw ##  Line width. A newline character will be inserted in the 
                sequence every ## bases. Default is 70. 
                -lw 0 will prevent newline insertion.
	-type	protein|DNA
	-seed #	seed for the random generator
                
    PROBABILITIES
	-a	alphabet
		must be followed by residue frequencies expressed precisely 
		this way:
		-a a:t # c:g #
		ex: 
		-a a:t 0.3 c:g 0.2
		
		The option 
		-a yeast
		will automatically use the residue frequencies from yeast 
		genome.  
	-expfreq
		indicate the file that contains expected oligomer 
		frequencies. When this option is used, the sequences are 
		generated according to a Markov chain. For instance if the 
		frequency file contains tetramers, each base will be 
		selected randomly with a probability depending on the 3 
		preceding bases:
		
		           p(Wj-3,j)
		p(Bj=B) = -----------
		          p(Wj-3,j-1)
		          
		where	Bj	is the base at position j
			B	is a residue, ie A, C, G or T
			Wj-3,j-1
				is a word found in the sequence between 
				positions j-3 and j-1
			Wj-3,j	is the same word with the character B 
				concatenated at its end
	-ncf	use non-coding frequencies as expected frequencies
	-org	organism 
		This is necessary with the option -ncf, to determine
		which frequency file has to be sued for expected
		frequency calibration.
	-ol	oligo-length
		This is necessary with the option -ncf, to determine
		the oligonucleotide length for the Markov chain model.
WEB VERSION
	http://ucmb.ulb.ac.be/bioinformatics/rsa-tools/

End_of_help
    close HELP;
    exit(0);
}


sub PrintOptions {
    open HELP, "| more";
    print HELP <<End_short_help;
random-seq options
==================
-l		sequence length
-r		repetitions (number of sequences)
-v		verbose
-o		outputfile
-format		output format. 
-lw ##		Line width. 
-a		alphabet. ex: -a a:t 0.3 c:g 0.2
-expfreq	file containing expected oligomer frequencies
-type   protein|DNA
-seed #	seed for the random generator
-ncf		use dyad non-coding frequencies as expected frequencies
-org		organism 
-ol		oligo-length
End_short_help
    close HELP;
    exit(0);
}
