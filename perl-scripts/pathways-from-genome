#!/usr/bin/perl -w
############################################################
#
# $Id: pathways-from-genome,v 1.7 2012/08/08 04:09:39 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

pathways-from-genome

=head1 VERSION

$program_version

=head1 DESCRIPTION

Taks manager developed in the context of the MICROME project,
implemening a workflow to infer metabolic pathways from Bacterial
genomes.


=head1 AUTHORS

Jacques.van-Helden@univ-amu.fr

=head1 CATEGORY

=over

=item metabolism

=item genome analysis

=back

=head1 USAGE

pathways-from-genome -org Organism_name [-v #] [-o output_directory]  [...]

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=head1 SEE ALSO

=head1 WISH LIST

=over

=item B<wish 1>

=item B<wish 2>

=back

=cut


BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}
require "RSA.lib";
require "RSA.disco.lib";
require "footprint.lib.pl";
require RSAT::organism;


################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  our $start_time = &RSAT::util::StartScript();
  our $program_version = do { my @r = (q$Revision: 1.7 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";


  our $verbose = 0;
  our $in = STDIN;
  our $out = STDOUT;

  our $organism_name = "";
  our $refresh_time = 0;

  ## Image formats
  our @image_formats = ("png", "pdf");
  our $icon_height = "200"; ## Height for the previsualization icons in the HTML reports

  ## Supported tasks
  our @supported_tasks = qw(all
			    operons
			    syntons
			    synthesis
			  );
  our $supported_tasks = join ",", @supported_tasks;
  our %supported_task = ();
  foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
  }

  ## Organism must be supported in RSAT
  my $organism = new RSAT::organism();

  ## Input files
  our %infile = ();

  ## Default parameters
  our %param = ();
  $param{operon_dist} = 55; push @param_list, "operon_dist";  ## optimal value for E.coli and B.subtilis, after an evaluation by Rekin's Janky (PhD thesis)
  $param{operon_min_genes} = 1; push @param_list, "operon_min_genes"; ## We also want singletons because they may contain a separate enzyme-coding gene
  $param{skip_org} = 0; ## Skip the first entries of the organism table
  $param{last_org} = 0; ## Stop reading organism table after a user-specified number of organisms

  ## Default column order for organism cross-table
  our @org_table_columns = qw(tax_id 
			     microscope_genome_id
			     microscope_metacyc_id
			     organism_name
			     uniprot_proteome
			     rsat_organism_id
			     obiw_genome_id
			     family_name
			     family_taxid
			     order_name
			     order_taxid);
  our %org_table_column = ();
  &IndexOrgTableColumns();

  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values

  &RSAT::message::TimeWarn("Checking parameters") if ($main::verbose >= 1);

  ## If no task is specified, run all of them
  unless (scalar(keys(%task))) {
    %task = %supported_task;
  }

  ## If option -task all was called, activate all tasks
  if ($task{all}) {
    %task = %supported_task;
  }

  ################################################################
  ## Read organism names + cross references from organism table if
  ## specified.

  &ReadOrganismCrossTable() if ($infile{organism_table});

  ## Check organism names
  our $org_nb = scalar(@organism_names);
  if ($org_nb <= 0) {
    &RSAT::error::FatalError("You must specify at least one organism (option -org)");
  } else {
    ## Check that all organisms are supported before starting any analysis
    &RSAT::message::TimeWarn("Checking $org_nb organism names") if ($main::verbose >= 1);
    my $org_counter = 0;
    foreach my $organism_name (@organism_names) {
      $org_counter++;
      &RSAT::message::TimeWarn("", $org_counter, $organism_name) if ($main::verbose >= 2);

      ## Check that organism is supported in RSAT
      $organism->check_name($organism_name, 1);
    }
  }


  ## Output directory
  if ($output_dir) {
    &RSAT::util::CheckOutDir($output_dir, "", 755);
  } else {
    &RSAT::error::FatalError("You must define the output directory (option -outdir)");
  }

  ## Open a text file for the main (multi-organisms) logs
  $main_log_file = $output_dir."/log.txt";
  our $main_log = &OpenOutputFile($main_log_file);
  print $main_log "; pathways-from-genome ";
  &PrintArguments($main_log);

  ## Open the HTML file for the main (multi-organisms) synthesis
  $main_synthesis_file = $output_dir."/synthesis.html";
  our $main_syn = &OpenOutputFile($main_synthesis_file);
  print $main_syn &PrintHtmlResultHeader(program=>"pathways-from-genome", "title"=>"Access by organism", "result_toc"=>0, refresh_time=>$refresh_time);
  print $main_syn "<table class='sortable'>\n";

  ## Print header line of the main synthesis table
  @main_syn_fields = qw (nb
			 organism_name
			 dir
			 log
			 operons
			 syntons
			);
  print $main_syn "<tr>\n";
  foreach my $field (@main_syn_fields) {
    print $main_syn "<th>", $field, "</th>\n";
  }
  print $main_syn "</tr>\n";


  ################################################################
  ## Iterate over selected organisms

  my $org_counter = 0;
  foreach $organism_name (@organism_names) {
    $org_counter++;

    ## Check skip organism option
    if ($org_counter <= $param{skip_org}) {
      &RSAT::message::Info("Skipping organism", $org_counter."/".$org_nb, $organism_name, "(option -skip_org ".$param{skip_org}.")") if ($main::verbose >= 1);
      next;
    }

    ## Check last organism option
    if (($param{last_org} > 0) && ($org_counter > $param{last_org})) {
      &RSAT::message::Info("Stop reading organism table, due to option -last_org ".$param{last_org}) if ($main::verbose >= 1);
      last;
    }


    ## Clean the %outfile and %dir hash tables
    our %outfile = ();
    our %dir = ();

    ## Define organism-specific subdirectory
    $dir{output} = $output_dir."/".$organism_name;
    &RSAT::util::CheckOutDir($dir{output}, "", 755);

    ## Prefix
    $param{prefix} = $organism_name;

    ################################################################
    ## Open log file
    $outfile{log} = &OutFileName("", ".txt", "log");
    $out = &OpenOutputFile($outfile{log});


    ################################################################
    ## Open the organism-specific HTML report
    $outfile{synthesis} = &OutFileName("html", ".html", $organism_name."_synthesis");
    $syn = &OpenOutputFile($main::outfile{synthesis});
    print $syn &PrintHtmlResultHeader(program=>"pathways-from-genome", "title"=>$organism_name, "result_toc"=>0, refresh_time=>$refresh_time);

    print $main_syn "<tr>";
    print $main_syn "<td>", $org_counter, "</td>";
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $outfile{synthesis}, $organism_name), "</td>";
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $dir{output}, " [dir]"), "</td>";
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $outfile{log}, " [log]"), "</td>";

    ## Check that organism is supported in RSAT
    unless ($organism->check_name($organism_name, 1)) {

      ## Close line of HTML report table
      print $main_syn "</tr>";

      ## Issue a warning
      my $warning = join ("\t", "Skipping non-supported organism", $org_counter."/".$org_nb, $organism_name);
      push @warnings, $warning;
      &RSAT::message::TimeWarn($warning) if ($main::verbose >= 2);

      next;
    }

    ## Report organism to be analyzed
    &RSAT::message::TimeWarn("Organism", $org_counter."/".$org_nb, $organism_name) if ($main::verbose >= 1);


    ################################################################
    ## Infer operons and syntons
    &InferOperonsOrSyntons("operons");
    &InferOperonsOrSyntons("syntons");

    ################################################################
    ## Print verbosity
    &Verbose() if ($main::verbose >= 1);

    ################################################################
    ## Report execution time and close output stream
    my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
    print $out $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified
    close $out;


    ## End of the HTML file
    &CloseSynthesis($syn);

    ## Report organism-specific output dir and synthesis file
    &RSAT::message::TimeWarn("\tOrganism directory", $dir{output}) if ($main::verbose >= 2);
    &RSAT::message::TimeWarn("\tOrganism synthesis", $outfile{synthesis}) if ($main::verbose >= 2);
  }

  print $main_syn "</table>\n";
  &CloseSynthesis($main_syn);

  if (scalar(@warnings) > 0) {
    print $main_log (join "\n; ",  "; Warning messages",
		     @warnings), "\n";
  }
  close $main_log;


  ## Report main output dir and synthesis file
  &RSAT::message::TimeWarn("Output directory", $output_dir) if ($main::verbose >= 1);
  &RSAT::message::TimeWarn("Log file", $main_log_file) if ($main::verbose >= 1);
  &RSAT::message::TimeWarn("Synthesis", $main_synthesis_file) if ($main::verbose >= 1);
  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################

################################################################
## Index columns of the organism cross-table
sub IndexOrgTableColumns {
  for my $col (1..scalar(@org_table_columns)) {
    $field = lc($org_table_columns[$col-1]);
    $org_table_column{$field} = $col;
  }
}

################################################################
## Read organism cross-table
sub ReadOrganismCrossTable {
  my ($orgs) = &OpenInputFile($infile{organism_table});

  my $l = 0;
  my $read_organisms = 0;
  while (<$orgs>) {
    $l++;
    next if /^;/;		## Skip comment lines
    next unless /\S/;		## Skip empty lines
    chomp();

    ## Parse header line
    if (/^#/) {
      s/^#//;
      @org_table_columns = split "\t/";
      &IndexOrgTableColumns(); ## Update the column index of organism cross-table
      next;
    }

    ## Parse one line

    my @fields = split /\t/;
    my $organism_name = $fields[$org_table_column{rsat_organism_id}-1];
    if ($organism_name) {
      $read_organisms++;

      &RSAT::message::Info("Adding organism", $read_organisms, $organism_name,  "line ".$l) if ($main::verbose >= 3);
      push @organism_names, $organism_name;

    } else {
      &RSAT::message::Warning($infile{organism_table}, "line ".$l, "missing field", "rsat_organism_id", "expected in column ".$org_table_column{rsat_organism_id}, );
    }

  }
  close $orgs;
}

################################################################
## Clos the synthetic table
sub CloseSynthesis {
  my ($handle) = @_;
  print $handle "<hr>\n";
  print $handle "</body>\n";
  print $handle "</html>\n";
  close $handle;
}


################################################################
## Display full help message 
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }


=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();


=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();


=pod

=item B<-org Organism_name>

Organism name. Must be an organism supported in this RSAT server. The
list of supported organisms can be obtained with
I<supported-organisms>.

This option is incompatible with the option -org_table.

Multiple organisms can be specifie by calling repeatedly the option
-org.

Example:

 pathways-from-genome -v 1 \
    -org Bacillus_subtilis_168_uid57675 \
    -org Mycoplasma_pneumoniae_M129_uid57709 \
    -o results/pathways_from_genome


=cut
    } elsif ($arg eq "-org") {
      &RSAT::error::FatalError("Options -org and -org_table are mutually incompatible") if ($infile{organism_table});
      my $organism_name = shift(@arguments);
      push @organism_names, $organism_name;

=pod

=item B<-org Organism_table>


Tab-delimited text file indicating the organism names + their
cross-references to a series of external databases.

This option is incompatible with the option -org.

The first columns of the organism table must contain the following
fields.

=over

=item RSAT organism identifier

All RSAT organism IDs must be an organism supported in this RSAT
server.

=item Microscope genome identifier

=item NCBI TAXID

=back

Additional columns are currently ignored.


=cut
    } elsif ($arg eq "-org_table") {
      &RSAT::error::FatalError("Options -org and -org_table are mutually incompatible") if (scalar(@organism_names) > 0);
      $infile{organism_table} = shift(@arguments);


=pod

=item B<-last_org last_organism_number>

Stop after having analyzed the specified number of organisms. This
option is useful for debugging or for analyzing subsets of the
organism table.

=cut
    } elsif ($arg eq "-last_org") {
      $param{last_org} = shift(@arguments);
      &RSAT::error::FatalError($param{last_org}, "Invalid value for option -last_org. Should be a Natural number.")
	unless (&RSAT::util::IsNatural($param{last_org}));

=pod

=item B<-skip_org skip_organism_number>

Skip the specified number of organisms when reading organism
table. This option is useful for debugging, or for resuming an
interrupted analysis.

=cut
    } elsif ($arg eq "-skip_org") {
      $param{skip_org} = shift(@arguments);
      &RSAT::error::FatalError($param{skip_org}, "Invalid value for option -skip_org. Should be a Natural number.")
	unless (&RSAT::util::IsNatural($param{skip_org}));

=pod

=item	B<-o output_directory>

Output directory.

Mandatory argument.

=cut
    } elsif ($arg eq "-o") {
      $output_dir = shift(@arguments); ## We reserve the hash table %outfile to organism-specific directories



=pod

=item B<-task>

Specify a subset of tasks to be executed.

By default, the program runs all necessary tasks. However, in some
cases, it can be useful to select one or several tasks to be executed
separately.

Beware: task selection requires expertise, because some tasks depends
on the prior execution of other tasks in the workflow. Selecting tasks
before their prerequisite tasks have been completed will provoke fatal
errors.

B<Default tasks>

=over

=item I<all> (default)

Run all supported tasks.

=item I<operons>

Infer operons from intergenic distances (tool I<infer-operon>).

=back

=cut
    } elsif ($arg eq "-task") {
      my @requested_tasks = split ",", shift (@arguments);
      foreach my $task (@requested_tasks) {
	next unless $task;
	if ($supported_task{$task}) {
	  $task{$task} = 1;
	} else {
	  &RSAT::error::FatalError("Task '$task' is not supported. \n\tSupported: $supported_tasks");
	}
      }

    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
  print $out "; peak-quality ";
  &PrintArguments($out);
  printf $out "; %-22s\t%s\n", "Program version", $program_version;

  ## List tasks
  printf $out "; %-22s\t%s\n", "Requested tasks", join(",", sort keys %task);

  ## List parameter values
  print $out "; Parameter values\n";
  foreach my $param_name (@param_list) {
    print $out sprintf ";\t%-22s\t%s\n", $param_name, $param{$param_name};
  }

  ## List directories
  if (%dir) {
    print $out "; Directories\n";
    foreach my $key (sort keys (%dir)) {
      my $value = $dir{$key};
#    while (my ($key,$value) = each %dir) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  ## List input files
  if (%infile) {
    print $out "; Input files\n";
    foreach my $key (sort keys (%infile)) {
      my $value = $infile{$key};
#    while (my ($key,$value) = each %infile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

  ## List output files
  if (%outfile) {
    print $out "; Output files\n";
    foreach my $key (sort keys (%outfile)) {
      my $value = $outfile{$key};
#    while (my ($key,$value) = each %outfile) {
      printf $out ";\t%-13s\t%s\n", $key, $value;
    }
  }

}


################################################################
## Infer operons from gene coordinates
sub InferOperonsOrSyntons {
  my ($operons_or_syntons) = @_;
  unless ($operons_or_syntons) {
    $operons_or_syntons = "operon";
  }
  my $dist = $param{operon_dist};

  my @for_synthesis = ();

  ## For syntons, set distance to a very very large value
  if ($operons_or_syntons eq "syntons") {
    $dist = 10000000;
  }

  ## Define suffix for operon and synton files
  my $operon_suffix = "ming".$param{operon_min_genes};
  unless ($operons_or_syntons eq "syntons") {
    $operon_suffix .= "_dist".$dist;
  }

  ## Inferred operons
  $dir{$operons_or_syntons} = $dir{output}."/".$operons_or_syntons;
  $outfile{"gene_".$operons_or_syntons} = &OutFileName($operons_or_syntons, ".tab", "gene_".$operons_or_syntons."_".$operon_suffix); push @for_synthesis, "gene_".$operons_or_syntons;
  $outfile{"gene_".$operons_or_syntons."_html"} = $outfile{"gene_".$operons_or_syntons}; $outfile{"gene_".$operons_or_syntons."_html"} =~ s/\.tab$/\.html/; push @for_synthesis, "gene_".$operons_or_syntons."_html";

  ## Infer operon for each gene
  if ($task{$operons_or_syntons}) {
    &RSAT::message::TimeWarn("\tInferring ".$operons_or_syntons, "dist=".$dist, "min_gene_nb=".$param{operon_min_genes}) if ($main::verbose >= 1);
    &RSAT::util::CheckOutDir($dir{$operons_or_syntons}, "", 755);
    my $cmd = $SCRIPTS."/infer-operon -v 1 ";
    $cmd .= " -sep '-' -return q_info,operon,leader,gene_nb";
    $cmd .= " -org ".$organism_name;
    $cmd .= " -all ";
    $cmd .= " -min_gene_nb ".$param{operon_min_genes};
    $cmd .= " -dist ".$dist;
    $cmd .= " | ".$SCRIPTS."/add-gene-info";
    $cmd .= " -org ".$organism_name;
    $cmd .= " -col 2 -info descr";
    $cmd .= " -o ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= "; ".$SCRIPTS."/text-to-html ";
    $cmd .= " -i ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= " -o ".$outfile{"gene_".$operons_or_syntons."_html"};
    $cmd .= " -chunk 10000";
    &one_command($cmd, 1) ;
    &RSAT::message::Info("Gene-".$operons_or_syntons." (tab)", $outfile{"gene_".$operons_or_syntons}) if ($main::verbose >= 3);
    &RSAT::message::Info("Gene-".$operons_or_syntons." (html)", $outfile{"gene_".$operons_or_syntons."_html"}) if ($main::verbose >= 3);
  }

   ## Generate a table with a single line per operon
  $outfile{$operons_or_syntons} = &OutFileName($operons_or_syntons, ".tab", $operons_or_syntons."_".$operon_suffix); push @for_synthesis, $operons_or_syntons;
  $outfile{$operons_or_syntons."_html"} = $outfile{$operons_or_syntons}; $outfile{$operons_or_syntons."_html"} =~ s/\.tab$/\.html/; push @for_synthesis, $operons_or_syntons."_html";
  if ($task{$operons_or_syntons}) {
    my $cmd = "";
    $cmd .= "echo '; ".$operons_or_syntons." ' > ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '; Organism               \t".$organism_name."' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '; Max intergenic distance\t".$dist."' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; echo '#".$operons_or_syntons."\tleader\tgene_nb' >> ".$outfile{$operons_or_syntons};
    $cmd .= "; grep -v '^;' ".$outfile{"gene_".$operons_or_syntons};
    $cmd .= " | grep -v '^#'";
    $cmd .= " | cut -f 7,8,9";
    $cmd .= " | sort -u ";
    $cmd .= ">> ".$outfile{$operons_or_syntons};
    $cmd .= "; ".$SCRIPTS."/text-to-html ";
    $cmd .= " -i ".$outfile{$operons_or_syntons};
    $cmd .= " -o ".$outfile{$operons_or_syntons."_html"};
    $cmd .= " -chunk 10000";
    &one_command($cmd, 1) ;
    &RSAT::message::Info($operons_or_syntons." (tab)", $outfile{$operons_or_syntons}) if ($main::verbose >= 3);
    &RSAT::message::Info($operons_or_syntons." (html)", $outfile{$operons_or_syntons."_html"}) if ($main::verbose >= 3);
  }

  ## Compute statistics on operon sizes
  $outfile{$operons_or_syntons."_stats"} = &OutFileName($operons_or_syntons, ".tab", $operons_or_syntons."_".$operon_suffix."_stats"); push @for_synthesis, $operons_or_syntons."_stats";
  for my $img_format (@image_formats) {
    $outfile{$operons_or_syntons."_stats_".$img_format} = &OutFileName($operons_or_syntons, ".".$img_format, $operons_or_syntons."_".$operon_suffix."_stats"); push @for_synthesis, $operons_or_syntons."_stats_".$img_format;
  }
  if ($task{$operons_or_syntons}) {
    &RSAT::message::TimeWarn("\tComputing size distribution", $operons_or_syntons) if ($main::verbose >= 1);
    $cmd = $SCRIPTS."/classfreq -v 1 -ci 1 -col 3";
    $cmd .= " -i ".$outfile{$operons_or_syntons};
    $cmd .= " -o ".$outfile{$operons_or_syntons."_stats"};

     for my $img_format (@image_formats) {
       $cmd .= "; ".$SCRIPTS."/XYgraph";
       $cmd .= " -i ".$outfile{$operons_or_syntons."_stats"};
       $cmd .= " -xcol 1 -ycol 4,5,6";
       $cmd .= " -format ".$img_format;
       $cmd .= " -xgstep1 5" unless ($img_format eq "pdf");
       $cmd .= " -xmin 0 -ymin 0";
       $cmd .= " -lines -legend  -xsize 800 -ysize 400";
       $cmd .= " -xleg1 'Number of genes per ".$operons_or_syntons."' -yleg1 'Number of predicted ".$operons_or_syntons."'";
       $cmd .= " -title1 \"Size distribution of predicted ".$operons_or_syntons." in ".$organism_name."\"";
       $cmd .= " -o ".$outfile{$operons_or_syntons."_stats_".$img_format};
     }
    &one_command($cmd, 1) ;
    &RSAT::message::Info($operons_or_syntons." stats (tab)", $outfile{$operons_or_syntons."_stats"}) if ($main::verbose >= 3);
    for my $img_format (@image_formats) {
      &RSAT::message::Info($operons_or_syntons." size distrib (".$img_format.")", $outfile{$operons_or_syntons."_stats_".$img_format}) if ($main::verbose >= 3);
    }
  }

  ################################################################
  ## Summarize the operon results
  print $syn "<hr><h2>", ucfirst($operons_or_syntons), "</h2>";

  print $syn "<br>Min nb of genes per ".$operons_or_syntons.": ".$param{operon_min_genes}."\n";
  if ($operons_or_syntons eq "operons") {
    print $syn "<br>Max intergenic distance : ".$param{operon_dist}."\n";
  } else {
  }

  print $syn "<h3>Statistics</h3>";
  print $syn "<table class='whitebg'>";
  print $syn "<tr>";
  print $syn "<td>";

  ## Initialize statistics
  my $nb_genes = "NA";
  my $nb_operons = "NA";
  my $operon_mean_size = "NA";
  my $operon_max_size = "NA";


  ## Read statistics
  if (-e $outfile{$operons_or_syntons."_stats"}) {
    my ($stats) = &OpenInputFile($outfile{$operons_or_syntons."_stats"});
    my $in_stats = 0;
    my %stats = ();
    while (<$stats>) {
      $in_stats = 1 if (/; Statistics/);
      next unless ($in_stats);
      $in_stats = 0 if (/; Seconds/);
      s/^; //;
      my ($key, $value) = split /\t/;
      $stats{$key} = $value;
    }

    $nb_genes = $stats{sum};
    $nb_operons = $stats{count};
    $operon_mean_size = $stats{mean};
    $operon_max_size = $stats{max};

    ## Add information in the organism-specific synthesis
    print $syn "<br>Nb genes: ", $nb_genes;
    print $syn "<br>Nb ".$operons_or_syntons.": ", $nb_operons;
    print $syn "<br>Mean size: ", sprintf("%.1f", $operon_mean_size);
    print $syn "<br>Max size: ", $operon_max_size;

    ## Add info in the main synthesis
    print $main_syn "<td>", &LinkOneFile($main_synthesis_file, $dir{$operons_or_syntons}, $nb_operons),  "</td>\n";

  } else {
    print $syn "<p><font color='red'>Missing stats file: ", $outfile{$operons_or_syntons."_stats"}, "</font></p>\n";
  }

  ## Display size distribution
  print $syn "<td>";
  if (-e $outfile{$operons_or_syntons."_stats_png"}) {
    print $syn "<p>", &HtmlDisplayOneImage($outfile{$operons_or_syntons."_stats_png"},
					   base=>$outfile{synthesis},
					   href=>$outfile{$operons_or_syntons."_stats_pdf"},
					   img_param=>"height='".$icon_height."' border=1",
					  ), "</p>\n";
  } else {
    print $syn "<p><font color='red'>Missing size distribution file: ", $outfile{$operons_or_syntons."_stats_png"}, "</font></p>\n";
  }
  print $syn "</td>";
  print $syn "<tr>";
  print $syn "</table>\n";

  ## Append table of links to the HTML report
  print $syn &LinkTable("Files: ".$operons_or_syntons, @for_synthesis);;
}

################################################################
## Display one image on a HTML page with a link (href) to the original
## (or other) file.
sub HtmlDisplayOneImage {
  my ($img_file, %args) = @_;
  my $href = $args{href} || $img_file;
  my $href_param = $args{href_param} || "";
  my $base  = $args{base} || ".";
  my $img_param = $args{img_param} || "";
  my $img_path = &RSAT::util::RelativePath($base, $img_file);
  my $href_path = &RSAT::util::RelativePath($base, $href);
  my $html = "<a href='".$href_path."' ".$href_param.">";
  $html .= "<img src='".$img_path."' ".$img_param.">";
  $html .= "</a>";
#   &RSAT::message::Debug("\nimg_file=".$img_file,
# 		       "\nhref=".$href,
# 		       ) if ($main::verbose >= 10);
  return $html;
}


################################################################
## Generate a table with links to a set of output files
##
## Usage:
##  &LinkTable($title, @output_file_keys);
sub LinkTable {
  my ($title, @output_file_keys) = @_;
  $html = "";
  $html .= "<h3>".$title."</h3>\n";
  $html .= "<table class='whitebg'>\n";
#  $html .= "<table>\n";
  for my $key (@output_file_keys) {
    $html .= "<tr>";
    $html .= "<td>".$key."</td>\n";
    $html .= "<td>";
    $html .= &LinkOneFile($outfile{synthesis}, $outfile{$key}, &ShortFileName($outfile{$key}));
    $html .= "</tr>\n";
  }
  $html .= "</table>\n";
  return ($html);
}


__END__
