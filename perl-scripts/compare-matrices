#!/usr/bin/perl -w
############################################################
#
# $Id: compare-matrices,v 1.3 2008/02/24 11:15:40 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

compare-matrices

=head1 VERSION

$program_version

=head1 DESCRIPTION

Compare two or more position-specific scoring matrices (PSSM), and
return various similarity statistics.

=head1 AUTHORS

Jacques.van.Helden@ulb.ac.be

=head1 CATEGORY

=over

=item sequences

=item pattern matching

=item PSSM

=back

=head1 USAGE

compare-matrices -fil1 inputfile1 -fiel2 inputfile2 [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

The user has to specify exactly input files (options I<-file1> and
I<-file2>), each containing one or several PSSMs. Each matrix of file
one is compared with each matrix of file2.

Any PSSM format supported in RSAT (type I<convert-matrix -h> for a
description).

=head1 OUTPUT FORMAT

By default, the output format is a tab-delimited file with one row per
matrix comparison, and one column per statistics.

=head2 ALGORITHM

The program successibely computs one or several (dis)similiraty
metrics between each matrix of the first input file and each matrix of
the secnd input file.

Since the matrices are not supposed to be in phase, for each pair of
matrix, the program tests all possible I<offset> (shift) values
between the two matrices.

=head1 (DIS)SIMLARITY METRICS

=head2 Euclidian distance (dEucl)

 dEucl = 1/w * SUM{r} SUM{j=1->w1} (F1_{r,j} - F2_{r,j})^2

where symbols are defined as follows

=over

=item I<w>

length of the alignment (depends on the offset between the two
matrices).

=item I<r>

residue belonging to the alphabet (A,C,G,T for DNA motifs).

=item I<j>

index of a column of the aligned PSSM.

=item I<F1>

frequency of residue r in the jth column of the aligned subset of the
first matrix (taking the offset into account).

=item I<F2>

frequency of residue r in the jth column of the aligned subset of the
second matrix (taking the offset into account).

=back

=head1 REFERENCES

=over

=item Pape, U.J., Rahman, S., and Vingron, M. (2008). Natural
similarity measures between position frequency matrices with an
application to clustering. Bioinformatics 24 (3) pp. 350-7.

=back

=cut


BEGIN {
  if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
  }
}
require "RSA.lib";
use RSAT::matrix;
use RSAT::MatrixReader;
use RSAT::stats;



################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  my $start_time = &AlphaDate();
  $program_version = do { my @r = (q$Revision: 1.3 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  %main::infile = ();
  %main::outfile = ();

  $main::verbose = 0;
#  $main::in = STDIN;
  $main::out = STDOUT;


  ## Return fields
  my %supported_return_fields = (
      "consensus"=>1,
      "ncol"=>1,
      "dEucl"=>1
      );
  my %return_field = %supported_return_fields;

  ## Matrices
  local @matrices1 = ();
  local @matrices2 = ();

  ## input formats
  %supported_input_format = %RSAT::MatrixReader::supported_input_format;
  $supported_input_formats = join ",", sort keys %supported_input_format;
  local $input_format1 = "";
  local $input_format2 = "";

  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values
  unless (($infile{file1}) && ($infile{file2})) {
    &RSAT::error::FatalError("You must define two input files (options -file1 and -file2)");
  }

  unless (($input_format1) && ($input_format2)) {
    &RSAT::error::FatalError("You must define two input format(s) (option -format, or options -format1 and -format2)");
  }


  ################################################################
  ## Open output stream
  $main::out = &OpenOutputFile($main::outfile{output});

  ################################################################
  ## Read input
  @matrices1 = &RSAT::MatrixReader::readFromFile($infile{file1}, $input_format1);
  &RSAT::message::TimeWarn(scalar(@matrices1), "Matrices loaded from file 1", $infile{file1})
      if ($main::verbose >= 2);
      @matrices2 = &RSAT::MatrixReader::readFromFile($infile{file2}, $input_format2);
  &RSAT::message::TimeWarn(scalar(@matrices2), "Matrices loaded from file 2", $infile{file2})
      if ($main::verbose >= 2);

  ## Calculate the consensus for each matrix
  if ($return_field{consensus}) {
      foreach my $matrix (@matrices1, @matrices2) {
	  $matrix->calcConsensus();
      }
  }

  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose);

  ################################################################
  ## Print the header
  my @header = ();
  push (@header, "m1", "m2");
  push (@header, "offset", "ali_len");
  push (@header, "start1", "end1", "start2", "end2");
  push (@header, "ncol1", "ncol2") if ($return_field{ncol});
  push (@header, "dEucl") if ($return_field{dEucl});
  push (@header, "consensus1", "consensus2") if ($return_field{consensus});


  my $c = 0;
  foreach my $field (@header) {
      $c++;
      print $out join ("\t", ";", $c, $field), "\n";
  }
  print $out "#", join("\t", @header), "\n";

  ################################################################
  ## compare the matrices and print the result
  my $m1 = 0;
  foreach my $matrix1 (@matrices1) {
      $m1++;
      &RSAT::message::TimeWarn("File 1", "Analyzing matrix", $m1."/".scalar(@matrices1)) 
	if ($main::verbose >= 3);

      my $ncol1 = $matrix1->get_attribute("ncol");
      my $nrow1 = $matrix1->get_attribute("nrow");
      my @counts1 = $matrix1->getMatrix();
      my @crude_freq1 = $matrix1->getCrudeFrequencies();


      my $m2 = 0;
      foreach my $matrix2 (@matrices2) {
	$m2++;
	&RSAT::message::TimeWarn("Compparing matrices", 
				 "file1", $m1."/".scalar(@matrices1),
				 "file2", $m2."/".scalar(@matrices2),
				)
	  if ($main::verbose >= 4);
	  my $ncol2 = $matrix2->get_attribute("ncol");
	  my $nrow2 = $matrix2->get_attribute("nrow");

	  ## Check that both matrices have the same number of rows
	  unless ($nrow2 == $nrow1) {
	      &RSAT::error::FatalError("Input matrices must have the same number of residues rows)", $nrow1, $nrow2);
	  }
	  my @counts2 = $matrix2->getMatrix();
	  my @crude_freq2 = $matrix2->getCrudeFrequencies();

	  ## Compute offsets for sliding one matrix along the othe one
	  my $offset_min = 1 - $ncol2;
	  my $offset_max = &RSAT::stats::min($ncol1, $ncol2) -1;

	  ## Slide matrix2 along matrix1
	  foreach my $offset ($offset_min..$offset_max) {

	      ## Compute aligned matrix positions
	      my $ali_len = 0;
	      $ali_len = &RSAT::stats::min(($ncol2 - abs($offset)), $ncol1);
	      my $end1 = &RSAT::stats::min($ncol1, $ncol1+$offset);
	      my $start1 = &RSAT::stats::min($ncol1, $end1-$ali_len+1);
	      my $start2 = &RSAT::stats::max(1- $offset, 1);
	      my $end2 = &RSAT::stats::min($start2+$ali_len-1, $ncol2);

	      ## Highlight alignment in consensus
	      $consensus1 = join ("",
#				  substr($matrix1->get_attribute("consensus.IUPAC"), 0, $start1-1),
				  substr($matrix1->get_attribute("consensus.IUPAC"), $start1-1, $ali_len),
				  "."x($start1-1),
				  "."x($ncol1-$end1)
#				  substr($matrix1->get_attribute("consensus.IUPAC"), $end1),
		  );
	      $consensus2 = join ("",
#				  substr($matrix2->get_attribute("consensus.IUPAC"), 0, $start2-1),
				  substr($matrix2->get_attribute("consensus.IUPAC"), $start2-1, $ali_len),
				  "."x($start2-1),
				  "."x($ncol2-$end2)
#				  substr($matrix2->get_attribute("consensus.IUPAC"), $end2),
		  );


	      ## Compute the Euclidian distance between the matrices
	      ## (cf Tomtom)
	      my $dEucl = 0;
	      foreach my $pos (1..$ali_len) {
		  my $col1 = $start1+$pos-1;
		  my $col2 = $start2+$pos-1;
		  for my $r (0..($nrow1-1)) {
		      my $f1 = $crude_freq1[$col1-1][$r];
		      my $f2 = $crude_freq2[$col2-1][$r];
		      my $diff = $f1 - $f2;
		      $dEucl += $diff**2;
		  }
	      }
	      $dEucl = sqrt($dEucl);
	      $dEucl /= $ali_len if ($ali_len > 0); ## Relativize the distance with respect to the column number
	      $dEucl = sprintf("%.3f", $dEucl);

	      ## Print the output
	      my @out_fields = ($m1, $m2);
	      push (@out_fields, $offset, $ali_len);
	      push (@out_fields, $start1, $end1, $start2, $end2);
	      push (@out_fields, $ncol1, $ncol2) if ($return_field{ncol});
	      push (@out_fields, $dEucl) if ($return_field{dEucl});
	      push (@out_fields, 
		    $consensus1,
		    $consensus2) if ($return_field{consensus});
	      print $out join("\t", @out_fields) , "\n";
	  }
      }
  }


  ################################################################
  ## Print output


  ################################################################
  ## Finish verbose
  if ($main::verbose >= 1) {
    my $done_time = &AlphaDate();
    print $main::out "; Job started $start_time\n";
    print $main::out "; Job done    $done_time\n";
  }


  ################################################################
  ## Close output stream
  close $main::out if ($main::outfile{output});


  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
  system "pod2text -c $0";
  exit()
}

################################################################
## Display short help message
sub PrintOptions {
  &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

    ## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
      if ($arg eq "-v") {
	if (&IsNatural($arguments[0])) {
	  $main::verbose = shift(@arguments);
	} else {
	  $main::verbose = 1;
	}

	## Help message
=pod

=item B<-h>

Display full help message

=cut
      } elsif ($arg eq "-h") {
	&PrintHelp();

	## List of options
=pod

=item B<-help>

Same as -h

=cut
      } elsif ($arg eq "-help") {
	&PrintOptions();

	## Input files
=pod

=item B<-file1 matrix_file1>

The first input file containing one or several matrices.

=cut
      } elsif ($arg eq "-file1") {
	$main::infile{file1} = shift(@arguments);

=pod

=item B<-file2 matrix_file2>

The second input file containing one or several matrices.

=cut
      } elsif ($arg eq "-file2") {
	$main::infile{file2} = shift(@arguments);

	### Input format 
=pod

=item B<-format matrix_format>

Specify the matrix format for both input files (alternatively, see
options -format1 and -format2).

=cut
      } elsif ($arg eq "-format") {
	$input_format1 = shift(@arguments);
	$input_format2 = $input_format1;
	unless ($supported_input_format{$input_format1}) {
	  &RSAT::error::FatalError("$input_format1\tInvalid format for input matrices\tSupported: ".$supported_input_formats);
	}

	### Input format for file1 only
=pod

=item B<-format1 matrix_format1>

Specify the matrix format for the first input file only (requires
-format2).

=cut
      } elsif ($arg eq "-format1") {
	$input_format1 = shift(@arguments);
	unless ($supported_input_format{$input_format1}) {
	  &RSAT::error::FatalError("$input_format1\tInvalid format for input matrices\tSupported: ".$supported_input_formats);
	}

	### Input format for file2 only
=pod

=item B<-format2 matrix_format2>

Specify the matrix format for the second input file only (requires
-format1).

=cut
      } elsif ($arg eq "-format2") {
	$input_format2 = shift(@arguments);
	unless ($supported_input_format{$input_format2}) {
	  &RSAT::error::FatalError("$input_format2\tInvalid format for input matrices\tSupported: ".$supported_input_formats);
	}

	## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
      } elsif ($arg eq "-o") {
	$main::outfile{output} = shift(@arguments);

      } else {
	&FatalError(join("\t", "Invalid option", $arg));

      }
  }


=pod

=back

=cut

}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; compare-matrices ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-6s\t%s\n", $key, $value;
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    
    print $main::out "; Matrices\n";
    printf $main::out ";\t%-6s\t%d\t%s\n", "file1", scalar(@matrices1), $infile{file1};
    printf $main::out ";\t%-6s\t%d\t%s\n", "file2", scalar(@matrices2), $infile{file2};
    

}


__END__

=pod

=head1 SEE ALSO

=over

=item B<convert-matrix>

=item B<matrix-scan>

=back

=head1 WISH LIST

=over

=item check and correct the Euclidian distance

=item implement other metrices

=item add comparison of m1 with reverse complement of m2

=back

=cut
