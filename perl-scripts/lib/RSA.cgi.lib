#!/usr/bin/perl
use CGI;
#use CGI::Carp;

#  #### redirect error log to a file
#  BEGIN {
#      $ERR_LOG = "/dev/null";
#  #    $ERR_LOG = "$TMP/RSA_ERROR_LOG.txt";
#      use CGI::Carp qw(carpout);
#      open (LOG, ">> $ERR_LOG")
#  	|| die "Unable to redirect log\n";
#      carpout(*LOG);
#  }


### For debugging
sub ListParameters {
  my($cgi_query) = $_[0];
  @param = $query->param;
  print "<H3>Parameter values</H3>";
  print "<UL><TABLE>\n";
  foreach $key (@param) {
    print "<TR>";
    print "<TD VALIGN=TOP><B>$key</B></TD>";
    $value = $query->param($key);
    $value =~ s/\n/<BR>/g;
    print "<TD VALIGN=TOP>$value</TD>";
    print "</TR>\n";
  }
  print "</TABLE></UL>\n";
}

# ################################################################
# #### list parameters from a CGI query
# sub ListParameters {
#   my $cgi_query = $_[0];
#   @param = $query->param;
#   print "<H3>Parameter values</H3>";
#   print "<UL><TABLE>\n";
#   foreach $key (@param) {
#     print "<TR>";
#     print "<TD VALIGN=TOP><B>$key</B></TD>";
#     $value = $query->param($key);
#     $value =~ s/\n/<BR>/g;
#     print "<TD VALIGN=TOP>$value</TD>";
#     print "</TR>\n";
#   }
#   print "</TABLE></UL>\n";

# }


## ##############################################################
## Start a new HTML page and write the header of a RSAT query form or result
## page usage &RSA_header($program_name)
sub RSA_header {
  my ($title) = @_;
  $title =~ s/\"//g;
  $title =~ s/\'//g;
  print $query->header;
  ### print the header of the result page
  print $query->start_html(-title=>"RSA-tools : $title",
                         -author=>'jvanheld@ucmb.ulb.ac.be',
                         -BGCOLOR=>'#FFFFFF');
  print "<H3 ALIGN='center'><A HREF='$WWW_RSA/RSA_home.cgi'>RSA-tools</A> - $title</H3>";
}


## ##############################################################
## send results by e-mail or display on the browser
sub SelectOutput {
    my ($default_output) = @_;
    $default_output = "display" unless ($default_output);

    my @values = ();
    if ($default_output eq 'server') {
	push @values, 'server'
    }
    push @values, ('display','email');

    print "<B>Output</B>&nbsp;";
    print $query->radio_group(-name=>'output',
#			      -values=>['display','server','e-mail'],
			      -values=>[@values],
			      -default=>$default{'output'});
    print $query->textfield(-name=>'user_email',
			    -size=>30);
    print "<BR>\n";
    print "<BR>\n";
}



### print a selection between diferent modes of sequence entry 
### in a HTML form
### - sequences copy-pasted in a textarea
### - sequences uploaded from a file on the client side
### - sequences piped from a previous script, and stored on the server
###   (typically  in a temporary dir)
sub DisplaySequenceChoice {
    print &SequenceChoice();
}

sub SequenceChoice {
    my $sequenceChoiceString = "";
    $sequenceChoiceString .=  "<B>Sequence</B>";
    #$sequenceChoiceString .=  "<UL>\n";
    
    if ($sequence_file = $query->param(sequence_file)) {
	### sequence file is already on the server machine 
	### (piped from a previous script)
	$sequence_url = $sequence_file;
	$sequence_url =~ s|$RSA/public_html|$WWW_RSA|;
	$sequenceChoiceString .=  "<a href=$sequence_url>";
	$sequenceChoiceString .=  " transferred from previous query<BR>\n";
	$sequenceChoiceString .=  "</a>";
	$sequence_format = $query->param(sequence_format);
	$sequenceChoiceString .=  "<INPUT type='hidden' NAME='sequence_format' VALUE='$sequence_format'>\n";
	$sequenceChoiceString .=  "<INPUT type='hidden' NAME='sequence_file' VALUE='$sequence_file'>\n";
    } else {
	#### sequence format (pop-up menu)
	$sequenceChoiceString .=  "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n";
	$sequenceChoiceString .=  "<B><A HREF='help.formats.html'>Format</A></B>&nbsp;";
	$sequenceChoiceString .=  $query->popup_menu(-name=>'sequence_format',
						    -Values=>['fasta', 
							      'ig',
							      'wconsensus',
							      'raw',
							      'ncbi',
							      'multi'],
						    -default=>$sequence_format);
	$sequenceChoiceString .=  "<BR>\n";
	### text area to copy-paste the sequence
	$sequenceChoiceString .=  "Paste your sequence in the box below<BR>\n";
	$sequenceChoiceString .=  $query->textarea(-name=>'sequence',
						  -default=>$default{sequence},
						  -rows=>4,
						  -columns=>55);
	$sequenceChoiceString .=  "<BR>\n";
	
	### option to upload the sequence file from the client machine 
	$sequenceChoiceString .=  "Or select a file to upload<BR>\n";
	$sequenceChoiceString .=  $query->filefield(-name=>'uploaded_file',
						    -default=>'',
						    -size=>45,
						    -maxlength=>200);
    }
    $sequenceChoiceString .=  "<BR>\n";
    #$sequenceChoiceString .=  "</UL>\n";
    return $sequenceChoiceString;
}


################################################################
#### Treat input sequence for the web server
#### The seqence can be specified in 3 ways :
#### - as a file to upload from the client to the server $query->param('uploaded_file')
#### - as a text in the textarea $query->param('sequence')
#### - as a sequence file already on the server $query->param('sequence_file')
#### usage : 
####    ($sequence_file,$sequence_format) = &GetSequenceFile();
####    ($sequence_file,$sequence_format) = &GetSequenceFile($required_format, $add_rc);
sub GetSequenceFile {
    my ($required_format, $no_format, $add_rc) = @_;
#    my ($required_format, $add_rc) = @_;
    
    ### sequence file format
    my $sequence_format = lc($query->param("sequence_format"));
    if ($accepted_input_seq{$sequence_format}) {
#	$parameters .= " -format $sequence_format" unless ($no_format);
	#$parameters .= " -format $sequence_format";
    } else {
	&cgiError("Invalid sequence format : '$sequence_format'.");
    }
    
    
    unless ($sequence_file = $query->param('sequence_file')) { ### sequence file already on the server side
	### create a new temporary sequence file
	$sequence_file = "$TMP/$tmp_file_name.seq"; 
    
	### upload sequence file from the client side
	$upload_file = $query->param('uploaded_file');
	if ($upload_file) {
	    if ($upload_file =~ /\.gz$/) {
		$sequence_file .= ".gz";
	    }
	    $type = $query->uploadInfo($upload_file)->{'Content-Type'};
	    open SEQ, ">$sequence_file" ||
		&cgiError("Cannot store sequence file in temp dir.");
	    while (<$upload_file>) {
		print SEQ;
	    }
	    close SEQ;
	    
	    ### read sequence from the textarea "sequence"
	} elsif ($query->param('sequence') =~ /\S/) {
	    if (open SEQ, ">$sequence_file") {
		print SEQ $query->param('sequence');
		close SEQ;
	    }
	} else {
	    &cgiError("The sequence box should not be empty.");
	}
    
	#### sequence file will be deleted
	&DelayedRemoval($sequence_file);
    }

    #### convert-seq
    if (($add_rc) ||
	((defined($required_format)) && (lc($sequence_format) ne lc($required_format)))
	) {
	unless ($accepted_output_seq{$required_format}) {  ### use convert-seq
	    &cgiError("Invalid sequence format : ${required_format}.");
	}
	my $converted_seq_file = $sequence_file.".".$required_format;
	my $convert_seq_command = "$SCRIPTS/convert-seq ";
	$convert_seq_command .= " -i $sequence_file -o $converted_seq_file ";
	$convert_seq_command .= " -from  $sequence_format -to $required_format ";
	
	if ($add_rc) {
	    $convert_seq_command .= "-addrc ";
	}
	system $convert_seq_command;
	
	#print "<PRE>$convert_seq_command</PRE>\n";
	&DelayedRemoval($converted_seq_file);
	$sequence_file = $converted_seq_file;
	$sequence_format = $required_format;
    }
    
    return($sequence_file, $sequence_format);
}


### input pattern ####
#sub GetPatternFile {
#  ### usage : $pattern_file = &GetPatternFile;
#  unless ($pattern_file = $query->param(pattern_file)) { ### pattern file already on the server side
#    $pattern_file = "$TMP/$tmp_file_name.pat"; ### create a new temporary pattern file
#    
#    ### read pattern from the textarea "patterns"
#    if ($query->param('patterns') =~ /\S/) {
#      if (open SEQ, ">$pattern_file") {
#	print SEQ $query->param('patterns');
#	close SEQ;
#      }
#    } else {
#      &cgiError("The pattern box should not be empty.");
#    }
#  }
#  &DelayedRemoval("$pattern_file"); ### remove the file after one hour
#  return($pattern_file);
#}


#### warn the users to wait for complete result before clicking on piping buttons
sub PipingWarning {
    my $message = "One or several button(s) will appear at the bottom of this page, ";
    $message .= "allowing you to send the result as input for a subsequent query."; 
    &cgiMessage($message, "Information");
}


### display a pop-up menu with a selection of organism
### on the basis of the configuration found in RSA.config
sub OrganismPopUp {
    print &OrganismPopUpString(@_);
}
sub OrganismPopUpString {
    my (@selected_organisms) = @_;
    if (scalar(@selected_organisms) <= 0) {
	@selected_organisms = &ListSupportedOrganisms("keys");
    }
    my $organismPopup = "";
    $organismPopup .=  "<B>Organism</B>&nbsp;";
    $organismPopup .=  "<SELECT NAME='organism'>\n";
    foreach my $org (@selected_organisms) {
	$name = $supported_organism{$org}->{'name'};
	if ((lc($org) eq lc($default{organism})) ||
	    (lc($name) eq lc($default{organism}))) {
	    $organismPopup .=  "<OPTION SELECTED VALUE='$org'>$name\n";
	} else {
	    $organismPopup .=  "<OPTION VALUE='$org'>$name\n";
	}
    }
    $organismPopup .=  "</SELECT>";
    $organismPopup .=  "<BR>\n";
    return $organismPopup;
}


### display a pop-up menu with the supported taxonomy
### on the basis of the configuration found in RSA.config
sub TaxonomyPopUp {
    print &TaxonomyPopUpString();
}
sub TaxonomyPopUpString {
    require RSAT::Tree;
    #require RSAT::TreeNode;
    my $tree = new RSAT::Tree();
    $tree->LoadSupportedTaxonomy("Bacteria", \%supported_organism, 1);
#    $tree->LoadSupportedTaxonomy(1);
    my @supported_taxons = $tree->node_names();
    my %indented_taxon = $tree->as_indented_hash();
    my $taxonomyPopup = "";
    $taxonomyPopup .=  "<B>Taxon</B>&nbsp;";
    $taxonomyPopup .=  "<SELECT NAME='taxon'>\n";
    foreach my $taxon (@supported_taxons) {
	$name = $indented_taxon{$taxon};
	if ((lc($taxon) eq lc($main::default{taxon})) ||
	    (lc($name) eq lc($main::default{taxon}))) {
	    $taxonomyPopup .=  "<OPTION SELECTED VALUE='$taxon'>$name\n";
	} else {
	    $taxonomyPopup .=  "<OPTION VALUE='$taxon'>$name\n";
	}
    }
    $taxonomyPopup .=  "</SELECT>";
    $taxonomyPopup .=  "<BR>\n";
    return $taxonomyPopup;
}




################################################################
#### Print a text table in html format
##
## usage
##   PrintHtmlTable(FILE_HANDLE,$mirror_file)
## reads the content of FILEHANDLE and displays 
## it in the form of a HTML table.
## if $mirror_file is specified, a copy of the input text (without HTML formatting)  
## is saved on the hard drive
##
## global variables
## ================
## The fixed font type can be switched off 
## by specifiying a global variable 
##       $font{variable} = 1;
sub PrintHtmlTable {
    my ($FILE, $mirror_file, $mirror_verbose, $chunk, $out, $border) = @_;
    $out = STDOUT unless ($out);
    $chunk = 100 unless (&IsNatural($chunk));
    my $line_count = 0;
    my $last_line = "";
    my $header_line = "";
    unless ($border) {
	$border=1;
    }
    
    $TABLE="<TABLE CELLSPACING=3 BORDER=$border>";
    unless ($font{variable}) {
	$font_spec_start = "<TT>";
	$font_spec_end = "</TT>";
    }
    
    if ($mirror_file) {
	if (open MIRROR, ">$mirror_file") {
	    $mirror = 1;
	    &DelayedRemoval($mirror_file);
	} else {
	    &Warning("Could not open the mirror file $mirror_file<P>\n");
	}
    }
    
    print $out "<PRE>";
    while (<$FILE>) {
	s|$RSA/(public_html/)*||g; #### avoid exposing the full path through the web interface
	if ($mirror) {
	    print MIRROR $_
		unless ((/^;/) && !($mirror_verbose)); 
	}

	if (/^\s*$/) {		#nothing on the line
	} elsif (/^;WARNING/) {		# warning
	    push @warnings, $_;
	} elsif ((/^;/) || (/^\#/)) {		# comment line
	    if ($table_opened) {
		print $out "<\/TABLE><PRE>\n";
		$table_opened = 0;
	    } 
	    print $out $last_line;
	    $last_line = $_;

	} elsif (!($table_opened)) { # first line of the table
	    $table_opened = 1;
	    $line_count = 0;
	    print $out "</PRE>\n\n$TABLE\n";
	    
	    # print the header line
	    chomp($last_line);
	    $last_line =~ s/;//;
	    $last_line =~ s/\t/ <\/TT><\/B><\/TD>\n<TD><B>$font_spec_start/g;
	    $header_line = "<TR VALIGN=top>\n<TD><B>".$font_spec_start.$last_line.$font_spec_end."</B></TD>\n</TR>\n\n";
	    print $out $header_line;
	    $last_line = "";
	    
	    ### print the first result line
	    chomp;
	    s/\t/ <\/TT><\/TD>\n<TD>$font_spec_start/g;
	    print $out "<TR VALIGN=top>\n<TD>".$font_spec_start;
	    print $out $_;
	    print $out $font_spec_end."</TD>\n</TR>\n\n";
	    
	} else {			# other line of the table
	    $line_count++;
	    if ($line_count%$chunk == 0) {
		### avoid HTML tables with too many rows
		print $out "</TABLE>\n\n$TABLE";
		print $out $header_line;
	    }
	    chomp;
	    s/\t/ <\/TT><\/TD>\n<TD>$font_spec_start/g;
	    print $out "<TR VALIGN=top>\n<TD>".$font_spec_start.$_.$font_spec_end."</TD>\n</TR>\n\n";
	}
    }
    if ($table_opened) {
	print $out "</TABLE>\n\n";
	print $out @warnings;
	print $out "<PRE>\n";
	$table_opened = 0;
    }
    print $out $last_line;
    print $out "</PRE>\n";
    if ($mirror_file ne "") {
	close MIRROR;
    }
}

sub Print_CGI_Input {
### returns all the fields of the %input hash
    print "<PRE>";
    foreach $key (sort keys %input) {
	print "$key\t$input{$key}\n";
    }
    print "</PRE>";

    print "Parameters: $parameters<P><P>\n";
}


################################################################
##### Save the command string in a temporry file for debugging
sub SaveCommand {
    my ($command, $tmp_file_name) = @_;

    #### temporary file for storing the result
    unless ($tmp_file_name) {
	$tmp_file_name = sprintf "command.%s", &AlphaDate.".txt";
    }
    open CMD, ">${tmp_file_name}_command.txt";
    print CMD $command, "\n";
    close CMD;

}


################################################################
#### save the result in a temporary file on the server
#### this file will be deleted after some delay
sub ServerOutput {
    #### redirect the task to email output
    &EmailTheResult(@_);

}

#### send e-mail with the result of a command
sub EmailTheResult {
    my ($command, $email_address, $tmp_file_name) = @_;
    my $delay = "72 hours";
    $mail_command = "mail -s \'RSA-tools - $script_name - $date\'";

    #### check the email address
    &CheckEmailAddress($email_address);

    #### temporary file for storing the result
    unless ($tmp_file_name) {
	$tmp_file_name = sprintf "result.%s", &AlphaDate.".txt";
    }
    my $result_URL = "$WWW_RSA/tmp/$tmp_file_name";
    
    #### debugging: report the command
    print "<PRE>$command > $TMP/$tmp_file_name</PRE>" if ($ECHO >= 1);

    #### Indicate the URL of the future result file
    my $message = "The server is now processing your request.\n"; 
    $message .= "Once it will be finished, the result will become available at the following URL\n";
    $message .= "\t${result_URL}\n";
    $message .= "When the result will be ready, you will be warned at your email address ($email_address).\n";
    $message .= "The result file will remain on the server for $delay.\n";
    $html_message = $message;
    $html_message =~ s|(http://\S+)|<a href=$1>$1</a>|gm;

    &Info($html_message);

    #### concatenate the command with the email notification
    my $email_message = "Your result is available at the following URL:\n\t${result_URL}";
    $email_message .= "\nThe result file will remain there for $delay.";
    $email_command =  "$command | perl -pe 's|$RSA/(public_html/)*||g' > $TMP/$tmp_file_name; ";
    $email_command .= "echo \"$email_message\" | $mail_command $email_address &"; 
    print "<PRE>$email_command</PRE>" if ($ECHO >= 1);
    system $email_command;


    #### prepare removal of the temporary file
    &DelayedRemoval("$TMP/$tmp_file_name", $delay);
}

#  sub OldEmailTheResult {
#      my ($command, $email_address) = @_;
#      $mail_command = "mail -s \'RSA-tools - $script_name - $date\'";
#      $email_address = &trim($email_address);
#      &CheckEmailAddress($email_address);
#      &Info ("Result will be sent to your e-mail address: $email_address");
#      system "$command | $mail_command $email_address &"; 
#  }

#### check email address format
sub CheckEmailAddress {
    my ($email_address) = @_;
    if ($email_address eq "") {
	&RSAT::error::FatalError ("You did not enter your e-mail address");
    } elsif ($email_address !~ /(\S+\@\S+)/) {
	&RSAT::error::FatalError ("The e-mail address you entered is not valid: $email_address");
    }
}


sub SelectFormat {
    my($in_format) = lc($_[0]);

    #### update the sequence format in a web form
    $form =~  s/ selected>Wconsensus/>Wconsensus/i; 
    $form =~  s/ selected>Fasta/>Fasta/i; 
    $form =~  s/ selected>NCBI/>NCBI/i; 
    $form =~  s/ selected>IG/>IG/i; 
    $form =~  s/ selected>raw/>raw/i; 
    $form =~  s/ selected>multi/>multi/i; 
    if ($in_format =~ /fasta/i) {
	$form =~  s/\>Fasta/ SELECTED\>Fasta/i; 
    } elsif ($in_format =~ /multi/i) {
	$form =~  s/\>multi/ SELECTED\>multi/i; 
    } elsif ($in_format =~ /raw/i) {
	$form =~  s/\>raw/ SELECTED\>raw/i; 
    } elsif ($in_format =~ /^wc/i) {
	$form =~  s/\>Wconsensus/ SELECTED\>Wconsensus/i; 
    } elsif ($in_format =~ /ig/i) {
	$form =~  s/\>IG/ SELECTED\>IG/i; 
    }    
}



1; # return true

