#!/usr/bin/perl -w
############################################################
#
# $Id: graph-intra-cluster-edges,v 1.5 2007/03/13 12:28:50 rsat Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

## use strict;

=pod

=head1 NAME

graph-intra-cluster-edges

=head1 DESCRIPTION

Count the number (or the sum of the weight) of intra cluster (or class edges) of a graph according to some classification file.

=head1 AUTHORS

=over

=item sylvain@scmbb.ulb.ac.be

=head1 CATEGORY

graph analysis

=head1 USAGE

graph-intra-cluster-edges [-i graph_file] -clusters cluster_file [-o outputfile] [-v #] [-weights] [...] 

=head1 INPUT FORMAT

=head2 Graph format

See I<convert-graph> for a description of the supported input graph
formats. Default format for the input graph: tab.

=head2 Cluster format

A two column tab delimited file. First column corresponding to the nodes and second column to the classes.

=head1 OUTPUT FORMAT

The output file is a matrix with node labels as rows and clusters (classes) as columns. 

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph2;
require RSAT::Classification;

################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();

    ################################################################
    ## Initialize the input graph
    $graph = new RSAT::Graph2();
    $graph->set_attribute("label", "input graph");

    ## Columns of the tab-delimited graph file
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;

    ## Count the sum of the intra cluster edges or count their number
    local $weights = 0;
 
    %main::infile = ();
    %main::outfile = ();
    $main::verbose = 0;
    $main::out = STDOUT;

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ## Read input graph
    $graph->read_from_table($infile{graph}, $source_col, $target_col, $weight_col);
    
    ## Read and add the class specification to each node
    $graph->load_classes($infile{clusters});

    ################################################################
    ## Count the number of intra-cluster edge by looking for each arc
    ## if the target node is located in the same cluster than 
    ## the source node
    ## The results are stored in an two dimensional array. Lines represent
    ## the nodes and edges represent the clusters.
    
    ## Indices of the two-dimensional array;
    my %nodes_name_id = $graph->get_attribute("nodes_name_id");
    my %nodes_id_name = $graph->get_attribute("nodes_id_name");
    my @cluster_list = $graph->get_attribute("cluster_list");
    my %clusters_name_id = ();
    my %clusters_edge_nb = ();
    for (my $i = 0; $i < scalar(@cluster_list); $i++) {
     $cluster_name_id{$cluster_list[$i]} = $i;
    }
    my @arcs = $graph->get_attribute("arcs");
    my @result = ();
    for (my $i = 0; $i < @arcs; $i++) {
      my $source_node = $arcs[$i][0];
      my $target_node = $arcs[$i][1];
      my @source_clusters = $graph->get_nodes_clusters($source_node);
      my @target_clusters = $graph->get_nodes_clusters($target_node);
      
      my $add_value = 1;
      if ($weights) {
        $add_value = $arcs[$i][2];
        $add_value /= 2;
      }
      
      foreach my $scluster (@source_clusters) {
        foreach my $tcluster (@target_clusters) {
          if ($scluster eq $tcluster) {
            my $source_node_index = $nodes_name_id{$source_node};
            my $target_node_index = $nodes_name_id{$target_node};
            my $cluster_index = $cluster_name_id{$tcluster};
            $result[$source_node_index][$cluster_index] += $add_value;
            $result[$target_node_index][$cluster_index] += $add_value;
            $clusters_edge_nb{$tcluster} += 1;
          }
        }
      }
    }
    
    ################################################################
    ## Print the results
   
    ## Print cluster names
    foreach my $cluster (@cluster_list) {
      print $out "\t$cluster";
    }
    print $out "\tsum";
    
    ## Print node name and the number of intra-edge cluster
    for (my $i = 0; $i < scalar(@result); $i++) {
      print $out "\n";
      print $out "$nodes_id_name{$i}";
      my $sum = 0;
      for (my $j = 0; $j < scalar(@cluster_list); $j++) {
        my $cluster = $cluster_list[$j];
        my $clusterIndex = $cluster_name_id{$cluster};
        my $val = 0;
        if (defined($result[$i][$j])) {
          $val = $result[$i][$j];
        }
        $sum += $val;
        print $out "\t$val";
      }
      print $out "\t$sum";
    }
    print $out "\n";
    print $out "#Arcs";
    foreach my $cluster (@cluster_list) {
      #my $val = ($clusters_edge_nb{$cluster}) / 2;
      my $val = ($clusters_edge_nb{$cluster});
      print $out "\t$val";
    }
    print $out "\n";
    
    
    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print STDOUT "; Job started $start_time\n";
	print STDOUT "; Job done    $done_time\n";
    }

    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});

    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Graph file
=pod

=item B<-i graphfile>

If no graph file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	  $main::infile{graph} = shift(@arguments);

	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes in the tab-delimited
graph file.

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes in the tab-delimited
graph file.

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight nodes in the tab-delimited
graph file.

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }



=pod

=item B<-clusters cluster_file>

Cluster file. The cluster file is a two columns tab-delimited indicating for each node the cluster to which it belongs.

=cut
	} elsif ($arg eq "-clusters") {
	    $main::infile{clusters} = shift(@arguments);


	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);

	    ## Weights
=pod

=item	B<-weights>

Sums the weight of the intra cluster edges instead of counting them. Adds half the weight of each arc.

=cut
	} elsif ($arg eq "-weights") {
	    $weights = 1;



	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}
################################################################
#### verbose message
sub Verbose {
    print STDOUT "; graph-neighbnours ";
    &PrintArguments(STDOUT);
    if (defined(%main::infile)) {
	print STDOUT "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print STDOUT ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print STDOUT "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print STDOUT ";\t$key\t$value\n";
	}
    }

    ## Report graph size
    my ($nodes, $arcs) = $graph->get_size();
    print STDOUT "; Graph size\n";
    print STDOUT ";\tnodes\t",$nodes,"\n";
    print STDOUT ";\tarcs\t",$arcs,"\n";

}


__END__

=pod

=head1 SEE ALSO

=over

=item I<graph-neighbours>

=item I<convert-graph>


=item I<compare-classes>

=item I<convert-classes>

=back

=cut
