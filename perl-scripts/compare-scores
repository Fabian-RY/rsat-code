#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";

#### initialise parameters ####
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;
$null = $default_null = "<NULL>"; 
$default_ic = 1;

&ReadArguments();

### read input file ###
$last_col;
foreach $f (0..$#input_files) {
    #### select the input file
    $inputfile = $input_files[$f];

    #### identifier column for the current file
    unless (defined ($ic[$f])) {
	$ic[$f] = $default_ic;
    }
    my $ii = $ic[$f] - 1; ### identifier column index
    
    #### score column for the current file
    if ((defined($default_sc)) && !(defined ($sc[$f]))) {
	$sc[$f] = $default_sc;
    }
    
    ($in, $input_dir) = &OpenInputFile($inputfile);
    $max_fields{$f} = 0;
    while (<$in>) {
	next unless (/\S/);
	next if (/^;/);
	chomp;
	@fields = split "\t";
	if (defined($sc[$f])) {
	    $max_fields{$f}= 1;
	} else {
	    $max_fields{$f} = &max($max_fields{$f},$#fields);
	}

	### comparison is case-insensitive, but the ID case is maintained in the output
	$id =  &trim($fields[$ii]);
	$key = lc($id);
	$id{$key} = $id;

	if (defined($sc[$f])) {
	    $col = $last_col + 1;
	    $score{$key}[$col] = $fields[$sc[$f]-1];
	} else {
	    for $c (1..$#fields) {
		$col = $last_col + $c;
		$score{$key}[$col] = $fields[$c];
	    }
	}

    }
    close $in;
    $last_col += $max_fields{$f};
}

### open output file ###
$out = &OpenOutputFile($outputfile);


#### verbose ####
if ($verbose) {
    print $out "; compare-scores";
    &PrintArguments($out);

    print $out ";Input files :\n";
    for $f (0..$#input_files) {
	print $out ";\t$input_files[$f]\t$sc[$f]\n";
    }
    if ($outputfile ne "") {
	print $out ";Output file	$outputfile\n";
    }
}


#### print header line
print $out ";key";
foreach $f (0..$#input_files) {
    foreach $c (1..$max_fields{$f}) {
	my $column_name = $input_files[$f];

	## Basename
	if ($basename) {
	    $column_name = &ShortFileName($column_name);
	}

	## Suppress substrings
	for my $sub (@suppress) {
	    $column_name =~ s/$sub//g;
	}


	## Column number
	if ($max_fields[$f] > 1 ) {
	    $column_name .=  "_$c"
	}

	print $out "\t", $column_name;
    }
}
print $out "\n";

#### print result
my @sorted_keys = ();
if ($numeric_IDs) {
    if ($decreasing) {
	@sorted_keys = sort {$b <=> $a } keys %id;
    } else {
	@sorted_keys = sort {$a <=> $b } keys %id;
    }
} else {
    @sorted_keys = sort keys %id;
}

foreach $key (@sorted_keys) {
    print $out $id{$key};
    for $f (1..$last_col) {
	$score = $score{$key}[$f];
	if ($score eq "") {
	    print $out "\t$null";
	} else {
	    print $out "\t$score";
	}
    }
    print $out "\n";
}


###### verbose ######
if ($verbose) {
    $done_time = `date '+%d/%m/%y %H:%M:%S %Z'`;
    print $out ";Job started $start_time";
    print $out ";Job done    $done_time";
}


###### close output file ######
close $out unless ($outputfile eq "");


exit(0);


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	compare-scores

        1998 by Jacques van Helden (jvanheld\@scmbb.ulb.ac.be)
	
USAGE
        compare-scores -i inputfile_1 -i inputfile_2 [-i inputfile_n] [-o outputfile] [-v] [-ic \#] -sc \#

DESCRIPTION
	compares the score associated to keys in different input files
	(basically, this amounts to join different tables on the basis
	of a unique identifier).

CATEGORY
	util

OPTIONS
        -h      (must be first argument) display full help message
        -help   (must be first argument) display options
	-v	verbose
	-i input_file (use recursively to indicate several input files)
		input file. 
		At least 2 different input files must be specified.
		The input files each contain a table with several columns,
		separated by tabulations (\t). 
		The first column of each input file contains the key.
	-files	list of files
		All following arguments are considered as input file
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-sc	score column. 
	-sc#	score column for the #th file
	-ic	Identifier column (default 1) 
	-ic#	identifier column for the #th file
	-null   null string (default $default_null) displayed when one
		file contains no value for a given key)
	-numeric
		sort IDs numerically rather than alphabetically
	-decreasing
		sort IDs numerically in a decreasing order
	-basename
		remove path (directory) from file names in the header
	-suppress
		Suppress a given substring from file names in the header
		This option can be used iteratively to suppress different
		substrings.

		Example:
			-suppress '.tab' -suppress 'oligos_'

INPUT FORMAT
	each line of the input file provides the score for a single key. 
	The first word of each line must be the key.
	The score can be located in any column, which will be indicated with the parameter -sc.
	Lines beginning with a semicolumn (;) are ignored.
	
OUTPUT FORMAT
	One line per key. The first column is the key, followed by 1 column for 
	the score associated to that key in each of the input files specified.
	
EXAMPLES
       compare-scores -v -i data_file_1 -i data_file_2 -sc 4  -o myresult
	
End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
compare-scores options
----------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-i		input file (use recursively to indicate several input files)
-files		input files (all following arguments are used as input file)
-o		output file
-v		verbose
-sc		score column
-sc#		score column for the #th file
-ic		identifier column
-ic#		identifier column for the #th file
-null		null string (default $default_null)
-numeric	sort IDs numerically rather than alphabetically
-decreasing	sort IDs numerically in a decreasing order
-basename	remove path (directory) from file names in the header
-suppress	suppress a given substring from file names in the header
End_short_help
  close HELP;
  exit;
}

sub ReadArguments {
#### read arguments ####
    foreach $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    $verbose = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions;
	    
	    ### input file ###
	} elsif ($ARGV[$a] eq "-i") {
	    push @input_files, $ARGV[$a+1];
	    
	    ### multiple input files
	} elsif ($ARGV[$a] eq "-files") {
	    push @input_files, @ARGV[$a+1..$#ARGV];
	    last;
	    
	    ### output file ###
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    
	    ### null string ###
	} elsif ($ARGV[$a] eq "-null") {
	    $null = $ARGV[$a+1];
	    
	    ### null string ###
	} elsif ($ARGV[$a] eq "-numeric") {
	    $numeric_IDs = 1;
	    
	    ### null string ###
	} elsif ($ARGV[$a] eq "-decreasing") {
	    $numeric_IDs = 1;
	    $decreasing = 1;
	    
	    ### score column
	} elsif ($ARGV[$a] eq "-sc") {
	    $default_sc = $ARGV[$a+1];
	    unless ((&IsNatural($default_sc)) && ($default_sc >= 1)) {
		warn "Error : score column must be an integer >= 1\n";
		&PrintHelp();
	    }
	    
	} elsif ($ARGV[$a] =~ /^-sc(\d+)/)  {
	    $sc[$1-1] = $ARGV[$a+1]; ### substract 1 from the index
	    unless ((&IsNatural($sc[$1-1])) && ($sc[$1-1] >= 1)) {
		warn "Error : score column must be an integer and >= 1\n";
		&PrintHelp();
	    }
	    
	    ### identifier column
	} elsif ($ARGV[$a] eq "-ic") {
	    $default_ic = $ARGV[$a+1];
	    unless ((&IsNatural($default_ic)) && ($default_ic >= 1)) {
		&Fatalerror("Identifier column must be an integer >= 1");
	    }	    
	} elsif ($ARGV[$a] =~ /^-ic(\d+)/)  {
	    $ic[$1-1] = $ARGV[$a+1]; ### substract 1 from the index
	    unless ((&IsNatural($ic[$1-1])) && ($ic[$1-1] >= 1)) {
		&Fatalerror("Identifier column must be an integer >= 1");
	    }

	} elsif ($ARGV[$a] eq '-basename') {
	    $basename = 1;

	} elsif ($ARGV[$a] eq '-suppress') {
	    push @suppress, $ARGV[$a+1];

	}
    }
}
