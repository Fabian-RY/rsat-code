#!/usr/bin/perl
############################################################
#
# $Id: dna-pattern,v 1.8 2001/09/09 21:40:55 jvanheld Exp $
#
# Time-stamp: <2001-09-09 23:40:14 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.classes";

# for more info type:
#            dna-pattern -help
#
# help content at the end of this file

$start_date = &AlphaDate;

#### init variables ####
$pattern_score = 1;
$noid = 0;
$strands_to_search = "DR";
$in_format = "fasta";
#$search_method = "IUPAC";
$search_method = "regexp";

if ($HelpRequested) {
  &Help;
  exit;
}


&ReadArguments;

##############################
### check parameter values ###
##############################

#### check allowed substitutions ####
unless (($allowed_subst eq "") || (&IsNatural($allowed_subst))) {
  print "	Error: invalid number of allowed substitutions.\n";
  print "	Type dna-pattern -help for more info.\n";
  exit;
}

### check input format 
&CheckInputSeqFormat($in_format);


@patterns = &ReadPatterns(pattern_file=>$pattern_file, 
			  score_column=>$score_column, 
			  noid=>$noid,
			  pattern_score=>$pattern_score,
			  pattern_id=>$pattern_id,
			  pattern_seq=>$pattern_seq);

### no pattern specified
&FatalError("You did not specify any pattern.") if ($#patterns < 0);


### open output file ###
$out = &OpenOutputFile($outputfile);
#if ($outputfile) {
#  unless (open(OUTPUT, ">$outputfile")) {
#    print "\tcannot open output file\n";
#    print "\ttype seq_oligofreq -h for help\n";
#    exit;
#  }
#  $out = OUTPUT;
#} else {
#  $out = STDOUT;
#}


#### verbose ####
if ($verbose) {
  print $out "; dna-pattern";
  foreach $a (@ARGV) {
    print $out " $a";
  }
  print $out "\n";
  printf $out "; %-21s\t%s\n", "Input file", $inputfile if ($inputfile);
  printf $out "; %-21s\t%s\n", "Input format", $in_format; 
  printf $out "; %-21s\t%s\n", "Output file", $outputfile if ($outputfile);
  printf $out "; %-21s\t%s\n", "Pattern file", $pattern_file if ($pattern_file);
  printf $out "; %-21s\t%s\n", "Search method", $search_method;
  printf $out "; %-21s\t%d\n", "Allowed substitutions", $allowed_subst;
  print $out "; Patterns to match\n";
  print $out "; \tseq\tid\tscore\n";
  foreach $pattern (@patterns) {
    print $out ("; ", 
		"\t", $pattern->get_attribute("sequence"),
		"\t", $pattern->get_attribute("id"),
		"\t", $pattern->get_attribute("score"),
		"\n");
  }
  print $out "; \n";
  
  if ($sum_only) {
    print $out "; PatID\tPattern\tMatches\n";
  } elsif ($count_matches) {
    print $out "; SeqID\tPatID\tPattern\tMatches\n";
  } else {
    print $out "; PatID";
    print $out "\tStrand";
    print $out "\tPattern";
    print $out "\tSeqID";
    print $out "\tStart";
    print $out "\tEnd";
    print $out "\tMatching_word";
    print $out "\tScore";
    print $out "\n";
  }
}


#### search ###
### open sequence file ###
$in = &OpenInputFile($inputfile);

### read input sequences
while ((($current_seq, $sequence_id, @comments) = &ReadNextSequence($in, $in_format)) &&
	 (($current_seq) || ($sequence_id))) {
  
  push @sequence_ids, $sequence_id;

  ### remove tabs and blank spaces ###    
  $current_seq = &FoldSequence($current_seq, 0);
  
  $sequence_length = length($current_seq);
  
  if (($origin <  0) || ($origin eq "-0")) {
    $orig_pos = $sequence_length + $origin + 1; 
  } else {
    $orig_pos = $origin;
  }
  
  foreach $pattern (@patterns) {
    $expression = $pattern->get_attribute("sequence");
    $expression =~ tr/a-z/A-Z/;
    $pattern_length = length($expression);
    $D_regular_expression = &IUPAC_to_regular($expression);
    $R_regular_expression = &ReverseComplement($D_regular_expression);
    $RC_pattern = &ReverseComplement($expression);
    
    $match_count = 0;
    ### palindromic patterns are searched only  on one strand 
    if (($expression eq ReverseComplement($expression)) && 
	($strands_to_search eq "DR")) {
      $regular_expression = $D_regular_expression;
      $strand = "DR";
      if ($search_method eq "regexp") {
	&RegExpSearch;
      } else {
	&IUPACsearch;
      }
    } else { 
      ### search on direct strand
      if ($strands_to_search =~ /D/) {
	$regular_expression = $D_regular_expression;
	$strand = "D";
	if ($search_method eq "regexp") {
	  &RegExpSearch;
	} else {
	  &IUPACsearch;
	}
      }
      ### search on reverse complement strand
      if ($strands_to_search =~ /R/) {
	$regular_expression = $R_regular_expression;
	$strand = "R";
	if ($search_method eq "regexp") {
	  &RegExpSearch;
	} else {
	  &IUPACsearch;
	}
      }
    }
    
    ### increment the total counter for the pattern
    $sum_per_pattern{$pattern} += $match_count;
    $sum_per_sequence{$sequence_id} += $match_count;
    $total_sum += $match_count;
    
    ### store match count if requested
    if ($table) {
      $match_count{$sequence_id}{$pattern} = $match_count;
    } elsif (($count_matches) && 
	     (!$sum_only) &&
	     ($match_count >= $threshold)) {
      print $out "$sequence_id";
      print $out "\t", $pattern->get_attribute("id");
      print $out "\t", $pattern->get_attribute("sequence");
      print $out "\t$match_count\n";
    }
  }
}

if (($sum_only) &&
    (!$table)) {
  foreach $pattern (@patterns) {
    print $out $pattern->get_attribute("id");
    print $out "\t", $pattern->get_attribute("sequence");
    print $out "\t", $sum_per_pattern{$pattern};
    print $out "\ttotal";
    print $out "\n";
  }
}



### print result in the form of a table
if ($table) {
  print $out ";seq";
  foreach $pattern (@patterns) {
    print $out "\t", $pattern->get_attribute("id");
  }
  print $out "\ttotal" if ($total); ### print total of occurrences per sequence
  print $out "\n";
  foreach $sequence_id (@sequence_ids) {
    print $out $sequence_id;
    foreach $pattern (@patterns) {
      print $out "\t", $match_count{$sequence_id}{$pattern};
    }
    print $out "\t", $sum_per_sequence{$sequence_id} if ($total);
    print $out "\n";
  }
  
  ### print total of occurrences per pattern
  if ($total) {
    print $out "total";
    foreach $pattern (@patterns) {
      print $out "\t", $sum_per_pattern{$pattern};
    }
    print $out "\t", $total_sum;
    print $out "\n";
  }
  
}

if ($verbose) {
  $done_date = &AlphaDate;
  print $out ";\n; Job started\t$start_date\n";
  print $out "; Job done   \t$done_date\n";
}

if ($outputfile) {
  close ($out);
}


############################# subroutine definition ############################



###### search with regular expression ######
sub RegExpSearch {
  local(%pat_hash) = Substitute($regular_expression, $allowed_subst, 0);
  @keys = sort {
    ($pat_hash{$a} > $pat_hash{$b}) ||
	(($pat_hash{$a} == $pat_hash{$b}) and
	 (lc($a) cmp lc($b)))
	  } keys %pat_hash;
  foreach $reg_pat (@keys) {
    $seq_to_crop = $current_seq;
    while ($seq_to_crop =~ /($reg_pat)(.*)/i) {
      $match_count++;
      if ($strand eq "DR") {
	$match_count++;
      }
      $matching_word = $1;
      $matching_word_length = length($matching_word);
      $remaining_seq = $2;
      $offset = $matching_word_length + length($remaining_seq)-1;
      unless ($count_matches) {
	if ($strand eq "R") {
	  $matching_word = &ReverseComplement($matching_word);
	  $up_neighborhood = $right_neighborhood;
	  $down_neighborhood = $left_neighborhood;
	} else {
	  $up_neighborhood = $left_neighborhood;
	  $down_neighborhood = $right_neighborhood;
	}
	if (($left_neighborhood) || ($right_neighborhood)){
	  $up_neighb = substr($current_seq,-$offset-$up_neighborhood-1,$up_neighborhood);
	  $down_neighb = substr($current_seq,-$offset+$matching_word_length-1,$down_neighborhood);
	  if ($strand eq "R") {
	    $up_neighb = &ReverseComplement($up_neighb);
	    $down_neighb = &ReverseComplement($down_neighb);
	    $matching_word = lc($down_neighb).uc($matching_word).lc($up_neighb);
	  } else {
	    $matching_word = lc($up_neighb).uc($matching_word).lc($down_neighb);
	  }
	}
	$start_pos = $sequence_length - $offset - $orig_pos;
	$end_pos = $start_pos + $matching_word_length - 1;
	$mismatches = $pat_hash{$reg_pat};
	&PrintMatch;
      }
      if ($no_overlap) {
	$seq_to_crop = $remaining_seq;
      } else {
	$seq_to_crop = substr($seq_to_crop,-$offset);
      }
    }
  }
} # RegExpSearch

###### search a IUPAC pattern ######
sub IUPACsearch {
#  print STDERR ("$sequence_id"
#		"\t", $pattern->get_attribute("sequence"),
#		"\t", $regular_expression,
#		"\n");
  $offset = 0;
  $match_pos = 0;
  
  if ($strand eq "R") {
    $IUPAC_pattern = &ExpandSeq($RC_pattern);
  } else {
    $IUPAC_pattern = &ExpandSeq($pattern->get_attribute("sequence"));
  }
  $pattern_len = length($IUPAC_pattern);
  
  do {
    ($match_pos,$matching_word,$mismatches) = &NextMatch($current_seq, $IUPAC_pattern, $allowed_subst, $offset);
    unless ($match_pos == -1) {
      $match_count++;
      if ($strand eq "DR") {
	$match_count++;
      }
      
      unless ($count_matches) {
	if ($strand eq "R") {
	  $matching_word = &ReverseComplement($matching_word);
	} 
	$start_pos = $match_pos -$orig_pos;
	$end_pos = $start_pos + $pattern_len -1;
	&PrintMatch;
      }
      if ($no_overlap) {
	$offset = $match_pos + $pattern_len;
      } else {
	$offset = $match_pos;
      }
    } ###unless
  } until ($match_pos == -1);
} # IUPACsearch


sub PrintMatch {
  if ($score_column > 0) {
    $score = $pattern->get_attribute("score");
  } else {
    $match_length = length($matching_word);
    $score = ($match_length - $mismatches)/$match_length;
  }
  print $out $pattern->get_attribute("id");
  print $out "\t$strand";
  print $out "\t", $pattern->get_attribute("sequence");
  print $out "\t$sequence_id";
  print $out "\t$start_pos";
  print $out "\t$end_pos";
  print $out "\t$matching_word";
  printf $out "\t%.2f", $score;
  print $out "\n";
}

############ HELP message ####################
sub Help	{
open HELP, "|more";
print HELP "
NAME
	dna-pattern
	perl script v1.1 by Jacques van Helden, 30 July 1997.

	Searches all occurrences of a pattern within DNA sequences.
        The pattern can be entered as a simple nucleotide sequence, 
        but can also include degenerate nucleotide codes, or regular 
        expressions. 

USAGE
	(get help)
	dna-pattern -h

	(directly enter the sequence to search)
	dna-pattern  -i sequencefile -format seq_format -p pattern [-id identifier] 
			[-D|-R|-DR] [-c|-ct] [-noov]
			[-N neighborhood] [-v]

	(read a list of patterns from a file)
	dna-pattern -i sequencefile -format seq_format -pl pattern_file 
   			[-D|-R|-DR] [-c|-ct]  [-noov] 
   			[-N neighborhood] [-v]

ARGUMENTS
	-h	help (displays the current message)
	-help	short help message
	-i	input sequence file. This file contains the sequences where the pattern(s)
		will be searched for. 
		Various format are accepted
		If omitted, standard input (eg keyboard) will be used. 
		This allows to use the program within a pipe.
	-format	input sequence format. The accepted formats are
		fasta	       FastA format
		IG	       IntelliGenetics format
		raw	       a single sequence in a file
		multi	       each new line is a new sequence
		filelist       a list of files containing each 
			       a single raw sequence
	-o	output file.
		If omitted, standard output (eg screen) will be used. 
		This allows to use the program within a pipe.
	-p	pattern entered directly after -p. 
		Alternatively use -pl.
	-pl	name of the file containing the patterns to search .
		each line of this file should contain an identifier and the 
		corresponding pattern, separated by a single tab.
		Alternatively use -p.
	-subst #
        allow # substitutions. 
	-sc #	
		score column
		the #th column of the pattern file contains a number indicating 
		the score for a match of this pattern. This option allows to 
		weight the matches according to a user-defined scheme.
	-noid	
		do not search pattern identifier in the second column of 
		pattern file. instead the id takes the same content as the
		pattern sequence.
	-noov	
		prevents detection of overlapping pattern
	-DR	search matches on both strands (direct and reverse complement)
	-D	search matches only on the direct strand.
	-R 	search matches only on the reverse complement strand.
	-id	pattern identifier (one word). 
		Use this option combined with -p.
	-c	return the count of matches rather than the list of
		positions and matching words. 
		If a list of sequence files is given (-sl), the count of 
                matches within each file is returned, as well as the 
                cumulative count.
	-table	return the count of pattern matches per sequence
		in the form of a table.
		(one line per sequence, one column per pattern)
	-total	(together with -table)
		print and extra column with the total occurrences per sequence
		and an extra row with total occurrences per pattern
        -th #   Threshold. 
                Return match count only for sequences with >= # matches.
                Only valid in combination with -c.
	-ct	same as c, except that it returns the sum of matches in all 
		the files of the sequence file list, instead of the count 
		within each separate file. 
	-N #	return matching sequences with # flanking nucleotides
	-NL #	return matching sequences with # left flanking nucleotides
	-NR #	return matching sequences with # right flanking nucleotides
	-v	verbose.
        -origin #
                define # as the origin for the calculation of positions.
                -origin -0 defines the end of each sequence as the 
                origin. The matching positions are then negative values, 
                providing the distance between the match and the end of the 
                sequence.

PATTERN FORMATS
	PATTERN SEQUENCE FORMAT
	The standard degenerate nucleotide code of the IUPAC-IUB commission 
	is supported (see http://www.chem.qmw.ac.uk/iupac/misc/naseq.html for 
	complete information).
	The pattern sequence should thus only contain the following characters:
		A			(Adenine)
		C			(Cytosine)
		G			(Guanine)
		T			(Thymine)
		R	= A or G        (puRines)
		Y	= C or T        (pYrimidines)
		W	= A or T        (Weak hydrogen bonding)
		S	= G or C        (Strong hydrogen bonding)
		M	= A or C        (aMino group at common position)
		K	= G or T        (Keto group at common position)
		H	= A, C or T     (not G)
		B	= G, C or T     (not A)
		V	= G, A, C       (not T)
		D	= G, A or T     (not C)
		N	= G, A, C or T  (aNy)
	Upper and lower case are considered equivalent.
	
	Patterns can be either entered directly by the user, or listed in a 
	file.

        The pattern can also contain regular expression elements:
        - GAT\[TA\]AG means \"GATAAG or GATTAG\" (equivalent to GATWAG).
        - CGGN{11}CCG means CGG followed by 10 N followed by CCG.
        - GATAAGN{0,30}GATAAG means two GATAAG spaced by 0 to 30 
          nucleotides.

	DIRECT PATTERN INPUT
	Type the -p option directly followed by a pattern sequence. 
	An optional identifier can be further entered after the -id option.

	PATTERN FILE 
	Each line contains a single pattern, for which two informations can 
	be provided: 
	- the pattern sequence (mandatory)
	- a pattern identifier (optional)
	Identifier and sequence must be separated by a single tab 
	character (\\t). 

SEQUENCE FILE FORMAT
        3 formats are supported:
        - raw
        - filelist
        - IG (intelligenetics)

	raw	The input file must contain raw sequences without any 
                comment or other text. Tabs (\\t), blank spaces and newline 
                characters (\\n) are accepted (they will be automatically 
                removed before analysis). The sequence must be terminated by 
                a newline character.
	
	filelist	
		file list. Each line of the input file contains the 
		name of a file containing a single sequence in raw format.

	IG	IntelliGenetics format. 	
 		The first non-comment line must be the sequence identifier 
		(a single word without spaces). 
		The sequence follows the identifier line identifier. It can 
                include spaces, tabs or newlines, that will be removed for 
                sequence analysis.
                The end of one sequence is indicated by termination character:
		1 for linear, 2 for circular sequences. 
		A single file may contain several sequences. 

		EXAMPLE of IG suite:

		; sequence of the region upstream from NIL1
	        ; Locus GAT1
 	        ; ORF YFL021W  coord:   6 95964 97496
 	        ; upstream region size: 100
 	        ; upstream region coord:        6 95864 95963
 	        GAT1
 	        ACAGAGCAACAATAATAACAGCACTATGAGTCGCACACTT
  	        GCGGTGCCCGGCCCAGCCACATATATATAGGTGTGTGCCA
  	        CTCCCGGCCCCGGTATTAGC
  	        1
 	        ; sequence of the region upstream from PUT4
                ; Locus PUT4
                ; ORF YOR348C  coord:   15 988773 986890
                ; upstream region size: 100
                ; upstream region coord:        15 988873 988774
                PUT4
                GGGTTTGTGTTCCTCTTCCTTTCCTTTTTTTTTCTCTCTT
                CCCTTCCAGTTTCTTTTATTCTTTGCTGTTTCGAAGAATC
                ACACCATCAATGAATAAATC
                1	

OUTPUT
	The output file contains columns separated by tabs (\\t), 
	providing respectively:
	- query pattern identifier word
	- match found on direct (D) or reverse complement (R) strand
	- pattern sequence
	- sequence file name
	- start position of the match
	- end position of the match
	- matching sequence
	- the matching score

	If the -c option is entered, output file provides :
	- query pattern identifier word
	- query pattern sequence
	- sequence file name
	- number of matches for the current pattern in the current file

EXAMPLES
	dna-pattern -i GATA -p GATWA -s $RSAGENOME/chr1.raw -c
	
	will count all occurences of the strings 'GATAA' and 'GATTA' present 
	in the file $RSAGENOME/chr1.raw.
WEB VERSION
	http://www.ucmb.ulb.ac.be/bioinformatics/rsa-tools/
";
  close HELP;
  exit(0);
}


sub ShortHelp	{
open HELP, "|more";
print HELP "
dna-pattern options
-------------------
-h	complete help message
-help   short help message
-p	pattern
-pl	pattern list file
-s	sequence file. 
-subst  allowed substitutions
-sc	score column
-o	output file.
-format	input format (raw, filelist or IG)
-id	pattern identifier (one word). 
-noid	use pattern sequence as id
-noov	prevent detection of overlapping pattern
-DR	search matches on both strands (default)
-D	search matches on the Direct strand only
-R 	search matches on the Reverse complementary strand only
-c	return the count of matches for each pattern in each sequence
-table	return a table with the count of pattern matches per sequence
-total	return total occ per sequence and per pattern in the count table
-th     threshold
-ct	return total count in all sequences
-N #	return matching sequences with # flanking nucleotides
-NL #	return matching sequences with # left flanking nucleotides
-NR #	return matching sequences with # right flanking nucleotides
-v	verbose
-origin origin (position 0)
";
  close HELP;
  exit(0);
}


#### read arguments ####
sub ReadArguments {
    foreach $a (0..$#ARGV) {
	if ($ARGV[$a] eq "-h") {
	    &Help;
	} elsif  ($ARGV[$a] eq "-help") {
	    &ShortHelp;
	    
	} elsif ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }

	} elsif ($ARGV[$a] =~ /^-ori/) {
	    $origin = $ARGV[$a+1];
	    
	} elsif (($ARGV[$a] eq "-subst") && (&IsNatural($ARGV[$a+1]))){
	    $allowed_subst = $ARGV[$a+1];
	    if ($allowed_subst > 0) {
		$search_method = "IUPAC";
	    }
	    
	    ################################################################
	    #### pattern specification
	} elsif ($ARGV[$a] eq "-id") {
	    # directly read pattern identifier from the command line
	    if ($ARGV[$a+1] =~ /(\S+)/) {
		$pattern_id = $1;
	    }
	    
	} elsif ($ARGV[$a] eq "-p") {
	    # directly read pattern sequence from the command line
	    $pattern_seq = $ARGV[$a+1];
	    warn ("; Pattern sequence\t", $pattern_seq, "\n") if ($verbose >=4);
	    
	} elsif ($ARGV[$a] eq "-pl") {
	    # read name of file containing the list of patterns and open it
	    if ($ARGV[$a+1] =~ /(\S+)/) {
		$pattern_file = $1;
		&FatalError("Cannot read pattern file '$pattern_file'.") 
		    unless (-r $pattern_file);
	    } 

	    #### score column in the pattern file
	} elsif (($ARGV[$a] eq "-sc") && (&IsNatural($ARGV[$a+1])) && ($ARGV[$a+1] > 1)) {
	    $score_column = $ARGV[$a+1];
	    
	    #### the pattern file contains no identifier
	} elsif ($ARGV[$a] eq "-noid") {
	    $noid = 1;
	    
	    ################################################################
	    #### sequence file
	} elsif ($ARGV[$a] eq "-i") {
	    # read input file name (sequence file)
	    $inputfile = $ARGV[$a+1];
	    
	} elsif ($ARGV[$a] eq "-format") {
	    # read input format (sequence format)
	    $in_format = lc($ARGV[$a+1]);
	    
	    
	    ################################################################
	    #### output file
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];

	    ################################################################
            #### matching options

	    #### strands
	} elsif (($ARGV[$a] eq "-D") ||($ARGV[$a] eq "-W") || ($ARGV[$a] eq "-1str")) {
	    $strands_to_search = "D";
	} elsif (($ARGV[$a] eq "-R") ||($ARGV[$a] eq "-C")) {
	    $strands_to_search = "R";
	} elsif (($ARGV[$a] eq "-DR") || 
		 ($ARGV[$a] eq "-RD") ||
		 ($ARGV[$a] eq "-CW") ||
		 ($ARGV[$a] eq "-CW") ||
		 ($ARGV[$a] eq "2str")
		 ) {
	    $strands_to_search = "DR";
	    
	    #### threshold
	} elsif ($ARGV[$a] eq "-th") {
	    $threshold = $ARGV[$a+1];

	    #### no overlap
	} elsif ($ARGV[$a] eq "-noov") {
	    $no_overlap = 1;
	    
	    ################################################################
            #### output type
	    
	    #### count matches
	} elsif ($ARGV[$a] eq "-c") {
	    $count_matches = 1;
	    
	    #### sum matches over all sequences
	} elsif ($ARGV[$a] eq "-ct") {
	    $count_matches = 1;
	    $sum_only = 1;
	    
	    ### return results in a sequence x pattern_count table
	} elsif ($ARGV[$a] eq "-table") {
	    $count_matches = 1;
	    $sum_only = 0;
	    $table = 1;
	    #### add a column and a row for totals to the table output
	} elsif ($ARGV[$a] eq "-total") {
	    $total = 1;

	    #### neighborhood (return flanking residues)
	} elsif (($ARGV[$a] eq "-N") && (&IsNatural($ARGV[$a+1]))) {
	    $left_neighborhood = $ARGV[$a+1];
	    $right_neighborhood = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-NL") && (&IsNatural($ARGV[$a+1]))) {
	    $left_neighborhood = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-NR") && (&IsNatural($ARGV[$a+1]))) {
	    $right_neighborhood = $ARGV[$a+1];
	    
    }
  }
}

sub ReadPatterns {
##
# Reads patterns from a file (or from the standard input) 
# and returns a list of RSA::Pattern objects. 
##
    my (%args) = @_;
    my @patterns = ();
    my $pattern_file = $args{pattern_file};
    my $score_column = $args{score_column};
    my $noid = $args{noid};
    my $pattern_id = $args{pattern_id};
    my $pattern_score = $args{pattern_score};
    my $pattern_seq = $args{pattern_seq};

    if ($pattern_file) {
	### read patterns from a file
	my $pattern_stream = &OpenInputFile($pattern_file);
#	open PATTERNS, $pattern_file || &FatalError"Cannot open pattern file";
	while (<$pattern_stream>) {
	    if (/^;/) {

		#### for piping with oligo-analysis and dyad-analysis
		#### take occ_sig as the score column
		if (!(defined($score_column)) &&
		    (/^;\s+(\d+)\s+occ_sig\s+/)) {
		    $score_column = $1;
		}
		next;
	    }
	    next unless (/\S/);
	    chomp;
	    my @fields = split, /\t/;
	    next unless ($fields[0] =~ /\S/);
	    $pattern_seq = $fields[0];
	    if (($noid) || ($fields[1] !~ /\S/)) {
		$pattern_id = $pattern_seq;
	    } else {
		$pattern_id = $fields[1];
	    }
	    if ($score_column >= 1) {
		$pattern_score = $fields[$score_column - 1];
	    } else {
		$pattern_score = 1; ### default score
	    }
	    
	    push @patterns, new RSA::pattern(id => $pattern_id,
					     sequence => $pattern_seq,
					     score => $pattern_score);
	}
	close $pattern_stream;
    
    ### pattern specified on the command line
    } elsif ($pattern_seq) {
	if ($pattern_id) {
	    $pattern_id = $pattern_id;
	} else {
	    $pattern_id = $pattern_seq;
	}
	push @patterns, new RSA::pattern(id=>$pattern_id,
					 sequence=>$pattern_seq,
					 score=>$pattern_score);
	
    }

    return @patterns;
}
