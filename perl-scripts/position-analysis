#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";

###### initialize parameters ##########
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;
$class_interval = 20;
$in_format = "fasta";
$sum_strands = 0;
$group_rc = 0;
$XYgraph_command = "$SCRIPTS/XYgraph";

&ReadArguments();

##############################
### check parameter values ###
##############################


### check oligonucleotide length
unless ($oligo_length > 0) {
  print "\tYou should specify an oligonucleotide length > 0.\n";
  print "\tType position-analysis -h for more info..\n";
  exit;
}


#### min and max classes to take into account for chi-square calculation
if ((&IsNatural($min_pos)) && (&IsNatural($max_pos))) {
  if ($max_pos < $min_pos) {
    die "Error: min position should be smaller than max position\n";
  }
}


### open sequence file ###
&CheckInputSeqFormat($in_format);
($in, $input_dir) = &OpenInputFile($inputfile);



#### initializations
$sequence_number = 0;
$nb_possible_pos = 0;
$sum_seq_length = 0;



#die "POUET\t$pattern_file\n" if ($pattern_file);
&LocalReadPatterns() if ($pattern_file);
&ReadSequence;
&CalcClasses;


### statistics on oligo occurrences
foreach $oligo_seq (sort keys %occurrences) {
  $sum_occurrences += $occurrences{$oligo_seq};	
  $sum_overlaps += $overlaps{$oligo_seq};	
}

&SumStrands if ($sum_strands);


#### if a pattern file has been specified, forget info about other patterns
if ($pattern_file) {
  foreach $oligo_seq (sort keys %occurrences) {
    unless ($selected_pattern{$oligo_seq}) {
      delete $occurrences{$oligo_seq};
    }
  }
}

#### check threshold on occurrences
if (&IsNatural($low_thr{'occ'})) {
    foreach $oligo_seq (sort keys %occurrences) {
	if ($occurrences{$oligo_seq} < $low_thr{'occ'}) {
	    delete $occurrences{$oligo_seq};
	}
    }
}

&CalcExpected();

&CalcChi();

### open output file ###
$out = &OpenOutputFile($outputfile);

### verbose ###
if ($verbose) {
  print $out ";position-analysis";
  foreach $a (@ARGV) {
    print $out " $a";
  }
  print $out "\n";
  print $out ";Input parameters\n";
  print $out ";\tInput file	$inputfile\n" if ($inputfile ne "");
  print $out ";\tInput format	$in_format\n";
  print $out ";\tOutput file	$outputfile\n" if ($outputfile ne "");
  print $out ";\tOligonucleotide length	$oligo_length\n";
  print $out ";\tchi threshold (lower)\t$low_thr{'chi'}\n" if (&IsReal($low_thr{'chi'}));
  print $out ";\toccurrence threshold (lower)\t$low_thr{'occ'}\n" if (&IsNatural($low_thr{'occ'}));
  if ($sum_strands) {
    print $out ";\tCounted on both strands\n";
    if ($group_rc) {
      print $out ";\tgrouped by pairs of reverse complements\n";
    }
  } else {
    print $out ";\tCounted on a single strand\n";
  }
  print $out ";\tthreshold on occurrence #	$occurrence_threshold\n" if ($occurrence_threshold > 0);
  
  print $out ";Sequence statistics:\n";
  print $out ";\tNb of sequences		$sequence_number\n";
  print $out ";\tSum of sequence lengthes\t$sum_seq_length\n";
  print $out ";\tmax sequence length	$max_seq_length\n";
  print $out ";\tavg sequence length	", $sum_seq_length/$sequence_number ,"\n" if ($sequence_number > 0);
  print $out ";\tnb possible positions\t\t",$nb_possible_pos ,"\n";
  unless ($sequence_number > 1000) {
    print $out ";Sequences:\n";
    foreach $s (1..$sequence_number) {
      print $out ";\t$id_list[$s]\t$seq_length[$s]\n";
    }
  }

  if ($#selected_patterns >=0) {
      print $out join ("\n;\t", "; Selected patterns", @selected_patterns), "\n";
  }
  
  print $out ";Class parameters:\n";
  print $out ";\tmin position\t$min_pos\n" if (&IsNatural($min_pos));
  print $out ";\tmax position\t$max_pos\n" if (&IsNatural($max_pos));
  print $out ";\tclass interval	$class_interval\n";
  print $out ";\tmin class\t$min_calc_class\n" if (&IsNatural($min_pos));
  print $out ";\tmax class\t$max_calc_class\n" if (&IsNatural($max_pos));
  print $out ";\ttotal positions\t$sum_pos_per_class\n";
  print $out ";\tnumber of classes	$calc_class_nb\n";
  print $out ";\tdegrees of freedom for chi2	", $calc_class_nb-1, "\n";
  print $out ";\tSequences per class:\n";
  print $out ";\t\tclass\t\[min\tmax\]\tseq\tpos\n";
  for $class ($min_calc_class..$max_calc_class) {
    print $out ";\t\t$class\t\[$class_min[$class]\t$class_max[$class]\]\t$seq_per_class[$class]\t$pos_per_class[$class]\n";
  }
  
  print $out ";Oligonucleotide statistics:\n";	
  print $out ";\ttotal oligo occurrences         $sum_occurrences\n";
  if ($no_overlap) {
    print $out ";\ttotal overlaps         $sum_overlaps\n";
  }
  print $out ";\tnb possible oligonucleotides\t$nb_possible_oligo\n";
  print $out ";\n";
}


### result ####
### sort oligonucleotides in function of significance or alphabetically
if ($sort_result) {
  $date = `date '+%H:%M:%S'`;
  chomp $date;
  print ";$date\tsorting results ...\n" if ($hyperverbose);
  if ($score_column > 0) {
    @sorted_keys = sort { 
      $sccore{$b} <=>  $score{$a}
    } keys %occurrences;
  } elsif ($return{'chi'}) {
    @sorted_keys = sort { 
      $chi_square{$b} <=>  $chi_square{$a}
    } keys %occurrences;
  } else {
    @sorted_keys = sort { 
      $in_bound_occurrences{$b} <=>  $in_bound_occurrences{$a}
    } keys %occurrences;
  }
} else {
  @sorted_keys = sort keys %occurrences;
}

### print header ###
$date = `date '+%H:%M:%S'`;
chomp $date;
print ";$date\tprinting results ...\n" if ($hyperverbose);
print $out ";seq";
print $out "\tid";
print $out "\tocc";
print $out "\tover" if ($no_overlaps);
print $out "\tchi2";
if ($return{'distrib'}) {
  for $class ($min_calc_class..$max_calc_class) {
    print $out "\t\[$class_min[$class]-$class_max[$class]\]";
    #		print $out " (exp)" if ($return{'exp'});
  }
}
print $out "\n";


### print result ###
foreach $oligo_seq (@sorted_keys) {
  print $out "$oligo_seq";
  print $out "\t$oligo_seq";
  if ($group_rc) {
    print $out "|", lc(ReverseComplement($oligo_seq));
  }
  
  ### occurrences ###
  print $out "\t$in_bound_occurrences{$oligo_seq}";
  print $out "\t$overlaps{$oligo_seq}" if ($no_overlaps);
  
  ### chi-square value ###
  print $out "\t$chi_square{$oligo_seq}";
  
  ### position distribution
  if ($return{'distrib'}) {
    for $class ($min_calc_class..$max_calc_class) {
      print $out "\t$class_freq{$oligo_seq}[$class]";
      #			printf $out " (%.1f)", $exp_occ{$oligo_seq}[$class] if ($return{'exp'});
    }
  }
  
  print $out "\n";
  
  if (($return{'exp'}) && ($return{'distrib'})) {
    print $out "$oligo_seq";
    print $out "\t$oligo_seq";
    if ($group_rc) {
      print $out "|", lc(ReverseComplement($oligo_seq));
    }
    print $out "\t$in_bound_occurrences{$oligo_seq}";
    print $out "\t$overlaps{$oligo_seq}" if ($no_overlaps);
    
    print $out "\texpected";
    
    for $class ($min_calc_class..$max_calc_class) {
      printf $out "\t%.1f", $exp_occ{$oligo_seq}[$class]; 
    }       
    print $out "\n";
  }
}


### generate XYgraphs
if ($return{'graph'}) {
    if ($outputfile) {
	$dir =`dirname $outputfile`; 
	if ($dir) {
	    chdir ($dir);
	    #### PROBLEM
#	    die "HELLO\t$dir",`pwd`,"\n";
	}
    }
    $date = `date '+%H:%M:%S'`;
    chomp $date;
    print ";$date\tgenerating the graphs ... \n" if ($hyperverbose);
    $index_file = "graph_index_${oligo_length}nt_ci${class_interval}.html";
    open INDEX, ">$index_file";
    print INDEX "<HTML><BODY><PRE>\n";
    close INDEX;
    foreach $oligo_seq (@sorted_keys) {
	$graph_file_name = "${oligo_seq}_ci${class_interval}_pos_distrib.gif";
	$xmax = ($max_class+1) * $class_interval;
	$title2 = "$in_bound_occurrences{$oligo_seq} occurrences";
	if ($score_column > 0) {
	    $score = sprintf "score = %.2f", $score{$oligo_seq};
	} elsif ($return{'chi'}) {
	    $score = sprintf "%.2f", $chi_square{$oligo_seq};
	    $title2 .= ", score = $score";
	} 
	$command = "$XYgraph_command -o $graph_file_name -lines -xcol 1 -ycol 2,3 -legend -title1 '$oligo_seq distribution profile' -title2 '$title2' -xleg1 'position' -yleg1 'class frequency' -ymin 0 -xmin $class_min[0] -xmax $class_max[$max_class] -xgstep2 $class_interval -xsize 600";
	print "; $command\n" if ($verbose);
	open XY, "| $command";
	print XY ";class\tocc_$oligo_seq\texp_$oligo_seq\n"; ### header line
	foreach $class (0..$max_class) {
	    print XY "$class_center[$class]\t";
	    print XY "$class_freq{$oligo_seq}[$class]\t";
	    print XY "$exp_occ{$oligo_seq}[$class]\n";
	}
	close XYgraph;
	open INDEX, ">>$index_file";
	print INDEX "<A HREF=\"$graph_file_name\">$oligo_seq</A>";
	print INDEX "\t$in_bound_occurrences{$oligo_seq}";
	print INDEX "\t$score";
	print INDEX "\n";
	close INDEX;
    }
    open INDEX, ">>$index_file";
    print INDEX "</PRE></BODY></HTML>\n";
    close INDEX;
}



if ($verbose) {
  $done_time  = `date '+%d/%m/%y %H:%M:%S %Z'`;
  print $out ";Job started $start_time";
  print $out ";Job done    $done_time";
  
}

close $out;

exit(0);


sub SumStrands {
  ### sum profiles of reverse complement patterns for strand insensitive analysis ###
  $date = `date '+%H:%M:%S'`;
  chomp $date;
  print ";$date\tsumming occurrences of reverse complementary patterns ...\n" if ($hyperverbose);
  
  ### occurrences
  foreach $oligo_seq (keys %occurrences) {
    $rc_oligo_seq = lc(&ReverseComplement($oligo_seq));
    $occurrences_2strands{$oligo_seq} = $occurrences{$oligo_seq} + $occurrences{$rc_oligo_seq};
    $occurrences_2strands{$rc_oligo_seq} = $occurrences_2strands{$oligo_seq};
  }
  foreach $oligo_seq (keys %occurrences_2strands) {
    $occurrences{$oligo_seq} = $occurrences_2strands{$oligo_seq};
  }
  undef %occurrences_2strands;
  
  ### positions ###
  for $class (0..$max_class) {
    foreach $oligo_seq (sort keys %occurrences) {
      $rc_oligo_seq = lc(&ReverseComplement($oligo_seq));
      if ($rc_oligo_seq eq $oligo_seq) {
	$m_pos_bothstrands{$oligo_seq}[$class] = $class_freq{$oligo_seq}[$class];
      } else {
	$m_pos_bothstrands{$oligo_seq}[$class] = $class_freq{$oligo_seq}[$class] + $class_freq{$rc_oligo_seq}[$spos_class];;
      }	  
    }
    foreach $oligo_seq (sort keys %occurrences) {
      $class_freq{$oligo_seq}[$class] = $m_pos_bothstrands{$oligo_seq}[$class];
      undef $m_pos_bothstrands{$oligo_seq}[$class];
    }   
  }
  
  #### if requested, group results by pairs of reverse complements ####
  if ($group_rc) {
    $date = `date '+%H:%M:%S'`;
    chomp $date;
    print ";$date\tgrouping patterns by pairs of reverse complements ...\n" if ($hyperverbose);
    foreach $oligo_seq (keys %occurrences) {
      $rc_oligo_seq = lc(&ReverseComplement($oligo_seq));
      if ($rc_oligo_seq gt $oligo_seq) { ### only suppress one oligo from the dyad 
	delete $occurrences{$rc_oligo_seq};
	delete $mseq{$rc_oligo_seq};
	delete $class_freq{$rc_oligo_seq};
      }
    }
  }
}


#### read patterns from a file
sub LocalReadPatterns {
#    die "HELLO";
    $date = `date '+%H:%M:%S'`;
    chomp $date;
    print ";$date\treading pattern file ...\n" if ($hyperverbose);
    open PATTERNS, "$pattern_file" || die "Error: cannot open pattern file $pattern_file\n";
    while (<PATTERNS>) {
	next if (/^;/);
	next unless (\S);
	chomp;
	@fields = split, "\t";
	$pattern = lc($fields[0]);
	print ";\t$pattern\n" if ($hyperverbose);
	$selected_pattern{$pattern} = 1;
	$score{$pattern} = $fields[$score_column-1] if ($score_column > 0);
    }
    close PATTERNS;
    @selected_patterns = keys %selected_pattern;
}


#### Read input and calculate oligo distribution ####
sub ReadSequence {
    if ($hyperverbose) {
	$date = `date '+%H:%M:%S'`;
	chomp $date;
	print "$date\tReading sequences\n";
    }
    
    while ((($current_seq, $current_id, @comments) = &ReadNextSequence($in, $in_format, $input_dir)) &&
	   (($current_seq ne "") || ($current_id ne ""))) {
	
	print "; analysing sequence $current_id\n" if ($hyperverbose);
	### remove tabs and blank spaces ###    
	$current_seq = &FoldSequence($current_seq,0);
	
	### statistics about sequences ###
	$sequence_number++;  
	$id_list[$sequence_number] = $current_id;
	$seq_length[$sequence_number] = length($current_seq);
	$last_pos = $seq_length[$sequence_number] - $oligo_length + 1;
	$max_last_pos = &max($max_last_pos, $last_pos);
	if ($origin eq "-0") {
	    $reference_pos = $seq_length[$sequence_number];
	} elsif ($origin < 0) {
	    $reference_pos = $seq_length[$sequence_number] - $origin;
	} else {
	    $reference_pos = $origin;
	}
	
	#### count oligonucleotides ####
	$offset = 0;
	$current_pos = 1;
	while ($current_pos <= $last_pos) {
	    $relative_pos = $current_pos - $reference_pos;
	    $class = int(($relative_pos - 1)/$class_interval);
	    $oligo_seq = lc(substr($current_seq,$current_pos-1,$oligo_length));
	    $rc = lc(&ReverseComplement($oligo_seq));
	    $current_pos++;
	    print ";\t\t$current_pos\t$relative_pos\n" if (($hyperverbose) && ($current_pos%$class_interval == 1));
	    if ((defined(%selected_pattern)) && 
		!($selected_pattern{$oligo_seq}) && 
		!($selected_pattern{$rc})) {
		next;
	    }
	    if (($no_overlap) 
		&& ($last_pos{$oligo_seq} > 0) 
		&& ($current_pos < ($last_pos{$oligo_seq} + $oligo_length))) {
		$overlaps{$oligo_seq}++;
	    } else {
		$occurrences{$oligo_seq}++;
		$class_freq{$oligo_seq}[$class]++;
		$last_pos{$oligo_seq} = $current_pos;
	    }
	}
	undef %last_pos;
    }
    undef $current_seq; ### release the memory occupied
    close $in;


    ### return sequence lengthes
    if ($hyperverbose) {
	for $s (1..$sequence_number) {
	    print ";\t$s\t$id_list[$sequence_number] \t$seq_length[$s]\n";
	}
    }
    
    ### statistics on sequence lengthes
    $date = `date '+%H:%M:%S'`;
    chomp $date;
    print ";$date\tcalculating stats on sequence lengthes ...\n" if ($hyperverbose);
    for $s (1..$sequence_number) {
	$sum_seq_length += $seq_length[$s];
	if ($seq_length[$s] >= $oligo_length) {
	    if ($sum_strands) {
		$nb_possible_pos += 2*($seq_length[$s] + 1 - $oligo_length);
	    } else {
		$nb_possible_pos += $seq_length[$s] + 1 - $oligo_length;
	    }
	}
	$max_seq_length = &max($max_seq_length, $seq_length[$s]);
	$last_pos = $seq_length[$s] - $oligo_length + 1;
	$current_max_class = int(($last_pos-1)/$class_interval); 
	for $class (0..$current_max_class-1) {
	    $seq_per_class[$class]++;
	    $pos_per_class[$class] += $class_interval;
	    $sum_seq_per_class++;
	}
	$seq_per_class[$current_max_class]++;
	$pos_per_class[$current_max_class] += ($last_pos-1) % $class_interval;
	#print "$s\t$id_list[$sequence_number] \t$seq_length[$s]\t",$last_pos-1, "\t", ($last_pos-1) % $class_interval,"\n";
    }
}


sub CalcClasses {
  ### class definition
  $max_class = int(($max_last_pos-1)/$class_interval);
  $class_nb = $max_class + 1;
  for $class (0..$max_class) {
    $class_min[$class] = $class*$class_interval + 1;
    $class_max[$class] = ($class+1)*$class_interval;
    $class_center[$class] = ($class_min[$class] + $class_max[$class])/2;
  }
  if (&IsNatural($min_pos)) {
    $min_calc_class = int(($min_pos-1)/$class_interval);
  } else {
    $min_calc_class = 0;
  }
  if (&IsNatural($max_pos)) {
    $max_calc_class = int(($max_pos-1)/$class_interval);
  } else {
    $max_calc_class = $max_class;
  }
  $calc_class_nb = $max_calc_class - $min_calc_class + 1;
  $sum_pos_per_class  = 0;
  for $class ($min_calc_class..$max_calc_class) {
    $sum_pos_per_class += $pos_per_class[$class];
  }
}




sub CalcExpected {
  ### calculate expected occurrences for each class
  $date = `date '+%H:%M:%S'`;
  chomp $date;
  print ";$date\tcalculating expected occurrences ...\n" if ($hyperverbose);
  foreach $oligo_seq (sort keys %occurrences) {
    foreach $class ($min_calc_class..$max_calc_class) {
      $in_bound_occurrences{$oligo_seq} += $class_freq{$oligo_seq}[$class];
    }
    foreach $class ($min_calc_class..$max_calc_class) {
      ### check that the class_freq has been defined
      unless (&IsNatural($class_freq{$oligo_seq}[$class])) {
	$class_freq{$oligo_seq}[$class] = 0;
      }
      #		if ($seq_per_class[$class] > 0) {
      #			$rel_freq{$oligo_seq}[$class] =  $class_freq{$oligo_seq}[$class]/$seq_per_class[$class];
      #		} else {
      #			$rel_freq{$oligo_seq}[$class] = 0;
      #		}
      $exp_occ{$oligo_seq}[$class] =  $in_bound_occurrences{$oligo_seq} * $pos_per_class[$class]/$sum_pos_per_class;
      $max_freq = &max($max_freq,$class_freq{$oligo_seq}[$class],$exp_occ{$oligo_seq}[$class]);
      $min_freq = &min($min_freq,$class_freq{$oligo_seq}[$class],$exp_occ{$oligo_seq}[$class]);
    }
  }
}

sub CalcChi {
    ### calculate chi2 to compare the position distribution with a flat line
    if ($return{'chi'}) {
	$date = `date '+%H:%M:%S'`;
	chomp $date;
	print ";$date\tcalculating chi values ...\n" if ($hyperverbose);
	foreach $oligo_seq (sort keys %occurrences) {
	    @chi_values = ();
	    foreach $class ($min_calc_class..$max_calc_class) {
		push @chi_values, $class_freq{$oligo_seq}[$class];
	    }
	    foreach $class ($min_calc_class..$max_calc_class) {
		push @chi_values, $exp_occ{$oligo_seq}[$class];
	    }
	    $chi_square{$oligo_seq} = &ChiSquare("goodfit", 2, $calc_class_nb, @chi_values);

	    #### suppress the checking of applicability condition on the chi-square
	    if ($no_check) {
		$chi_square{$oligo_seq} =~ s/\(//;
		$chi_square{$oligo_seq} =~ s/\)//;
	    }

	    #### check the threshold on chi-square
	    if ((&IsReal($low_thr{'chi'})) && 
		($chi_square{$oligo_seq} < $low_thr{'chi'})) {	
		delete $occurrences{$oligo_seq};
		delete $chi_square{$oligo_seq};
	    }
	}
    }
}

sub PrintHelp {
  open HELP, "| more";
  print HELP <<End_of_help; 
NAME
	position-analysis
	
        1998 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
DESCRIPTION
	Detection of oligonucleotides with a biased distribution in a sequence set. 
	The program begins by detecting all positions where each possible 
	oligonucleotide is found in the input sequence. 
	Positions are then grouped into class frequencies, and the class frequencies are 
	are compared to those expected under a flat distribution hypothesis, i.e. if
	the frequency of each word was constant along the sequences. 
		
USAGE
	position-analysis [-i inputfile]  [-format input_format]
                [-o outputfile] -l length -ci class_interval
                [-1str | -2str] [-grouprc | -nogrouprc]

	position-analysis [-h | -help]
		provides a detailed or synthetic documentation


OPTIONS
	-i file	inputfile. This file should contain the sequences.
	-format	input file format. Must be followed by one of the 
		following options:
		   fasta (default)
		   wconsensus
		   IG
		   filelist
		   raw
		See below for the description of these formats.
	-o file	outputfile. Returns a list of the oligonucleotides 
		encountered in the sequences, with their frequencies.
	-v	verbose. 
	-vv	hyperverbose
		same as verbose but returns additional info (sequence lengthes)
	-l	oligonucleotide length.
	-ci	class interval (default 20 bases). 
		The width of the position classes (in number of bases)
	-grouprc        group reverse complement pairs
	-nogrouprc      do not group reverse complement pairs
	-sort		sort oligonucleotides according to the bias in distribution profile
	-1str	
		inactivates the summation of occurrences on both strands.	
	-2str
		oligonucleotide occurrences found on both stands are summed. 
	-noov	no overlap
			overlapping occurrences of the same pattern are 
			only taken into account once
	-return	fields_to_return
			supported fields:
				distrib	occurrences found in each position class
				exp	expected occurrences for each class
				graph	a rgaph file per oligont profile
				chi	chi-square value
			several fields can be entered, separated by commas
	-lth #	lower threshold on chi2
		return only words with a chi2 value > #
	-oth #	lower threshold on occurrences
		return only words with a number of occurrences > #
	-pl pattern_file
		a file containing a selection of patterns. 
		The analysis is then restricted to these patterns.
		The first word of each new line is considered as a new pattern.
		A score can be associated to each pattern with the option -sc.
	-sc #	score column
		(only valid whith the option -pl)
		the column containing a score value for each pattern of the 
		pattern file
	-minpos #
		minimal position to take into account for the chi-square calculation
		This value must be a multiple of the class interval.
	-maxpos #
		maximal position to take into account for the chi-square calculation
		This value must be a multiple of the class interval.
	-nocheck
		do not check the applicability condition on the
		chi-square. By default, the program checks that each
		class has at least 5 observations. The chi-square is
		bracketed for words which do not fill this
		conditions. It is now recognized that this condition
		is too restrictive, and that the chi2 is still valid
		with smaller clas effective. We allow to suppress the
		checking, but the responsibility is left to the user,
		to decide whether the chi2 is or not significant.
	-origin
		reference for calculating positions. 

		If a negative value, coordinates are calculated with
		respect to the specified position relative to rather
		than the start of the sequence.

		To calculate the positions relative to sequence end,
		use the option:
			     -origin -0

End_of_help
  close HELP;
  exit(0);
}

sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_of_help; 
position-analysis options
----------------------
-h		display complete help message
-help		display this list of options
-i		input file
-format		input format. Accepted: fasta (default), wconsensus, IG, raw, filelist
-o 		output file
-v		verbose
-vv		hyperverbose
-l		oligonucleotide length
-ci		class interval (default 20 bases). 
-1str		inactivate summation of occ on both strands
-2str		sum occurences on both strands (default)
-grouprc	group reverse complement pairs (default)
-nogrouprc	do not group reverse complement pairs
-noov		no overlap
-sort		sort oligonucleotides according to the bias in distribution profile
-return		chi,distrib,exp,graph
-lth		lower threshold on chi2
-oth		lower threshold on occurrences
-pl		pattern list
-pl		origin (-0 to calculatre positions relative to the end of the sequence)
-sc		score column
-minpos		minimal position for chi-square calculation
-maxpos		maximal position for chi-square calculation
-nocheck	do not check applicability condition for the chi2
End_of_help
    close HELP;
    exit(0);
}

sub ReadArguments {
#### read arguments ####
    foreach $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp();
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions();
	    
	    ### input file
	} elsif ($ARGV[$a] eq "-i") {
	    $inputfile = $ARGV[$a+1];
	    
	    ### output file
	} elsif ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    
	    ### oligomer length
	} elsif (($ARGV[$a] eq "-l") && (&IsNatural($ARGV[$a+1]))) {
	    $oligo_length = $ARGV[$a+1];
	    
	    ### class interval
	} elsif (($ARGV[$a] eq "-ci") && (&IsNatural($ARGV[$a+1]))) {
	    $class_interval = $ARGV[$a+1];
	    
	    ### sequence format
	} elsif ($ARGV[$a] eq "-format") {
	    $in_format = lc($ARGV[$a+1]);
	    
	    ### strands
	} elsif ($ARGV[$a] eq "-1str") {
	    $sum_strands = 0;
	    $group_rc = 0;
	} elsif ($ARGV[$a] eq "-2str") {
	    $sum_strands = 1;
	    
	    ### grouping of reverse complements
	} elsif ($ARGV[$a] eq "-grouprc") {
	    $sum_strands = 1;
	    $group_rc = 1;
	} elsif ($ARGV[$a] eq "-nogrouprc") {
	    $group_rc = 0;
	    
	    ### sort the result according to significance
	} elsif ($ARGV[$a] eq "-sort") {
	    $sort_result = 1;
	    
	    ### no overlap between successive matches
	} elsif ($ARGV[$a] eq "-noov") {
	    $no_overlap = 1;
	    
	    ### lower threshold on chi square
	} elsif ($ARGV[$a] =~ /^-lth/) { 
	    $low_thr{'chi'} = $ARGV[$a+1];
	    $return{'chi'} = 1;
	    unless (($low_thr{'chi'} >= 0) && (&IsReal($low_thr{'chi'}))) {
		&FatalError("Threshold on chi2 must be a positive number") ;
	    }
	    
	    ### lower threshold on occurrences
	} elsif ($ARGV[$a] =~ /^-oth/) { 
	    $low_thr{'occ'} = $ARGV[$a+1];
	    unless (&IsNatural($low_thr{'occ'})) {
		&FatalError("Threshold on occurrences must be a natural number") ;
	    }
	    
	    ### return values
	} elsif ($ARGV[$a] eq "-return") {
	    @fields_to_return = split ",", $ARGV[$a+1];
	    foreach $field (@fields_to_return) {
		if ($field =~ /dist/) {
		    $return{'distrib'} = 1;
		    
		} elsif ($field =~ /chi/) {
		    $return{'chi'} = 1;
		    
		} elsif ($field =~ /exp/) {
		    $return{'exp'} = 1;
		    
		} elsif ($field =~ /graph/) {
		    $return{'graph'} = 1;
		}
	    }
	    
	    ### do not check applicability condition for the chi2
	} elsif ($ARGV[$a] eq "-nocheck") {
	    $no_check = 1;
	    
	    ### predefined pattern list
	} elsif ($ARGV[$a] =~ /-pl/) {
#	    die "BOUM\t$pattern_file\n";
	    $pattern_file = $ARGV[$a+1];
	    
	    ### score column
	} elsif ($ARGV[$a] eq "-sc") {
	    $score_column = $ARGV[$a+1];
	    unless (&IsNatural($score_column)) {
		&FatalError( "Score column must be a natural number\n");
	    }
	    
	    ### score column
	} elsif ($ARGV[$a] =~ /^-orig/) {
	    $origin = $ARGV[$a+1];
	    unless (&IsInteger($origin)) {
		&FatalError( "Invalid value $origin\tOrigin must be an integer number\n");
	    }
	    
	    ### min and max positions
	} elsif (($ARGV[$a] eq "-minpos") && (&IsNatural($ARGV[$a+1]))) {
	    $min_pos = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-maxpos") && (&IsNatural($ARGV[$a+1]))) {
	    $max_pos = $ARGV[$a+1];
	    


	}


    }

}
