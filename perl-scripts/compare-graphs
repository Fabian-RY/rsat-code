#!/usr/bin/perl -w
############################################################
#
# $Id: compare-graphs,v 1.6 2007/03/27 09:27:05 rsat Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

compare-graphs

=head1 DESCRIPTION

Computes the intersection, the union or the difference of two graphs

=head1 AUTHORS

gvdstock@ulb.ac.be
sylvain@scmbb.ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE
    
compare-graphs -graph1 graph1 -graph2 graph2 -return intersection|difference|union [-out_format gml|dot|tab] [-scol #] [-tcol #] [-wcol #] [-o output_file] [-v #] [...]

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph2;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();


    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::out = STDOUT;
    
    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	tab=>1,
    );
    $supported_input_formats = join (",", keys %supported_input_format);
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;

    ## Output formats
    local $output_format = "tab";
    %supported_output_format =(
			       dot=>1,
			       gml=>1,
			       tab=>1

    );
    
    $supported_output_formats = join (",", keys %supported_output_format);
    
    ## Supported return options
    local $return_format = "";
    %supported_return_format =(
      intersection=>1,
      union=>1,
      difference=>1
    );
    $supported_return_formats = join (",", keys %supported_return_format);
    
    $directed = 0;
    
    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values
    if (!exists($main::infile{graph1}) || !exists($main::infile{graph2})) {
      &RSAT::error::FatalError("You must specify two graph file");
    }
    my $error = "0";
    if (!-e ($main::infile{graph1}) || -z ($main::infile{graph1})) {
      $error = ("The file $main::infile{graph1} does not exist or is not valid\n");
    }
    if (!-e ($main::infile{graph2}) || -z ($main::infile{graph2})) {
      $error .= ("\tThe file $main::infile{graph2} does not exist or is not valid");
    }
    if ($error ne 0){
      &RSAT::error::FatalError("$error");
    }
    if ($return_format eq "") {
      &RSAT::error::FatalError("You must specify a return format : $supported_return_formats");
    }
    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ## Read and load input
    my $graph1 = new RSAT::Graph2;
    my $graph2 = new RSAT::Graph2;
    
    $graph1->read_from_table($main::infile{graph1}, $source_col,$target_col, $weight_col);
    $graph2->read_from_table($main::infile{graph2}, $source_col,$target_col, $weight_col);
    
    ## As it appeared quite difficult to work with graphs having more than one edge between two
    ## nodes, we decided to remove any duplicated edges.
    
    $graph1->remove_duplicated_arcs($directed);
    $graph2->remove_duplicated_arcs($directed);
    
    open(FILE, ">test.tab");
    print FILE $graph2->to_tab;
    
    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    
    ########################################################################""
    ## Calculation of the number of common and not common arcs and nodes

    my ($nodes_graph1, $arcs_graph1) = $graph1->properties;
    my ($nodes_graph2, $arcs_graph2) = $graph2->properties;
    my ($common) = &in_common($graph1, $graph2);
    my $graph1_only_arc = $arcs_graph1 - $common;
    my $graph2_only_arc = $arcs_graph2 - $common;
    my $message = "Intersection info\n";
    $message = (join("\t",$main::infile{graph1},$nodes_graph1,"node(s) and",$arcs_graph1,"arc(s)\n"));
    $message .= ";\t".(join("\t",$main::infile{graph2},$nodes_graph2,"node(s) and",$arcs_graph2,"arc(s)\n"));
    $message .= ";\t"."$common\t"."unique arcs in common\n";
    $message .= ";\t".$graph1_only_arc."\tarcs of $main::infile{graph1} are not in $main::infile{graph2}\n";
    $message .= ";\t".$graph2_only_arc."\tarcs of $main::infile{graph2} are not in $main::infile{graph1}\n";
    if ($main::verbose >= 1){  
      print $main::out ";\t$message";
      unless ($main::out eq "STDOUT") {
        &RSAT::message::Info("$message");
      }
    }
    ################################################################
    ## Execute the command
    
    my $return_graph;
    if ($return_format eq "intersection") {
      if ($arcs_graph2 < $arcs_graph1){
        $return_graph = &intersect($graph2, $graph1);
      } else {
        $return_graph = &intersect($graph1, $graph2);
      }
    } elsif ($return_format eq "union") {
      $return_graph = &union($graph1, $graph2);
    } elsif ($return_format eq "difference") {
      $return_graph = &difference($graph1, $graph2);
    }
    
    ################################################################
    ## Print output
    print $main::out $return_graph->to_text($output_format);
    
    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help 
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Input file 1
=pod

=item B<-graph1 graph1_input_file>

First graph file

=cut
	} elsif ($arg eq "-graph1") {
	    $main::infile{graph1} = shift(@arguments);

	    	    ## Input file 2
=pod

=item B<-graph2 graph2_input_file>

Second graph file

=cut
	} elsif ($arg eq "-graph2") {
	    $main::infile{graph2} = shift(@arguments);
	
	    	    ## Directed option
=pod

=item B<-directed>

boolean

=cut
	    	    
	} elsif ($arg eq "-directed") {
	    $directed = 1;

	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);

	    	    
	    ### Input format  
=pod

=item B<-in_format input_format>

Input format. Supported: tab

=cut
	} elsif ($arg eq "-in_format") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});


	    ### return  
=pod

=item B<-return return>

return : intersection , union or difference

=cut
	} elsif ($arg eq "-return") {
	    $return_format = shift(@arguments);
	    &RSAT::error::FatalError("$return_format\tInvalid input format. Supported: $supported_return_formats")
		unless ($supported_return_format{$return_format});


		
	    ### Output format  
=pod

=item B<-out_format format>

Output format. Supported: tab, dot, gml

=cut 
	} elsif ($arg eq "-out_format") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});


	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes. 

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes. 

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight nodes. 

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }

	    
	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
## Intersection
## This function takes two graphs as arguments and computes their
## intersection in a third graph

sub intersect {

  my ($graph1, $graph2) = @_;
     
  my $inter_graph = new RSAT::Graph2;
  
  my %seen_arcs = ();
  
  my @arcs_g1 = $graph1->get_attribute("arcs");
  my %arcs_name_id_g1 = $graph1->get_attribute("arcs_name_id");
  my @arcs_g2 = $graph2->get_attribute("arcs");
  my %arcs_name_id_g2 = $graph2->get_attribute("arcs_name_id");
  my %nodes_name_id = $graph2->get_attribute("nodes_name_id");
  my %nodes_color = $graph2->get_attribute("nodes_color");
  my %nodes_label = $graph2->get_attribute("nodes_label");
  
  my $arccpt = 0;
  my $j = 1;
  my @inter_graph_array;
  for (my $i = 0; $i < scalar(@arcs_g1); $i++) { # charge le graph 1
    if ($i % 1000 == 0) {
        &RSAT::message::TimeWarn("$i lines treated") if ($verbose  >= 4);
    }
    my $source_name = $arcs_g1[$i][0]; 
    my $target_name = $arcs_g1[$i][1];
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_".($j);
    push @arcs_id, $arc_id1; # arcs du graph 1, "dirigés"
    if (!$directed) {
      my $arc_id2 = $target_name."_".$source_name."_".($j);
      push @arcs_id, $arc_id2; # ajouts des arcs du graph 1 "non dirigés"
    }
    foreach my $arc_id (@arcs_id){
      my $arc_intern_id = $arcs_name_id_g2{$arc_id};
      if (!exists($seen_arcs{$arc_id})) {
        my $source_intern_id = $nodes_name_id{$source_name};
        my $target_intern_id = $nodes_name_id{$target_name};
        if (defined($arc_intern_id)) {
          my $source_node_color = $nodes_color{$source_intern_id} || "#000088";
	  my $source_node_label = $nodes_label{$source_intern_id} || $source_name;
	  my $target_node_color = $nodes_color{$target_intern_id} || "#000088";
	  my $target_node_label = $nodes_label{$target_intern_id} || $target_name;
	  my $arc_label = $arcs_g2[$arc_intern_id][2];
          my $arc_color = $arcs_g2[$arc_intern_id][3];
          $inter_graph_array[$arccpt][0] = $source_name;
          $inter_graph_array[$arccpt][1] = $target_name;
          $inter_graph_array[$arccpt][2] = $arc_label;
          $inter_graph_array[$arccpt][3] = $source_node_color;
          $inter_graph_array[$arccpt][4] = $target_node_color;
          $inter_graph_array[$arccpt][5] = $arc_color;
	  $arccpt ++;
	  for (my $j = 0; $j < scalar(@arcs_id); $j++) {
	    $seen_arcs{$arcs_id[$j]}++;
	  }
	  if (!$directed) {
	    last;
	  }
	} 
      }
    }
  }
  $inter_graph->load_from_array(@inter_graph_array);
  return $inter_graph;
}

################################################################
## Union of two graphs
## This function creates in Graph $graph2 all the edges that are in Graph $graph1 but 
## absent in $graph2

sub union {
  my ($graph1, $graph2) = @_; 
  
  my $union_graph = new RSAT::Graph2;
  
  my @arcs_g1 = $graph1->get_attribute("arcs");
  my %arcs_name_id_g1 = $graph1->get_attribute("arcs_name_id");
  my @arcs_g2 = $graph2->get_attribute("arcs");
  my %arcs_name_id_g2 = $graph2->get_attribute("arcs_name_id");
  my %nodes_name_id_g1 = $graph1->get_attribute("nodes_name_id");
  my %nodes_name_id_g2 = $graph2->get_attribute("nodes_name_id");
  my %nodes_color_g1 = $graph1->get_attribute("nodes_color");
  my %nodes_color_g2 = $graph2->get_attribute("nodes_color");
  my %nodes_label_g1 = $graph1->get_attribute("nodes_label");
  my %nodes_label_g2 = $graph2->get_attribute("nodes_label");

  my @union_graph_array = @arcs_g1;
  
  my %seen_arcs = ();
  
#   filling union_graph_array with graph1

  for (my $i = 0; $i < scalar(@union_graph_array); $i++) {
  
    my $source_name = $union_graph_array[$i][0]; 
    my $target_name = $union_graph_array[$i][1];
        
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_".1;
    push @arcs_id, $arc_id1; # arcs du graph 1, "dirigés"
    if (!$directed) {
      my $arc_id2 = $target_name."_".$source_name."_".1;
      push @arcs_id, $arc_id2; # ajouts des arcs du graph 1 "non dirigés"
    }
    my $arc_color = "#00ff00"; # by default color of edges belongs to graph1 is green
    foreach my $arc_id (@arcs_id) {
      my $arc_intern_id = $arcs_name_id_g2{$arc_id};
      if (defined($arc_intern_id)) {
        $arc_color = "#ff0000";
      }
    }
    $union_graph_array[$i][5] = $arc_color;
    my $source_name_id = $nodes_name_id_g1{$source_name};
    my $target_name_id = $nodes_name_id_g1{$target_name};
    my $source_node_color = $nodes_color_g1{$source_name_id};
    my $target_node_color = $nodes_color_g1{$target_name_id};
    $union_graph_array[$i][3] = $source_node_color;
    $union_graph_array[$i][4] = $target_node_color;
    for (my $j = 0; $j < scalar(@arcs_id); $j++) {
      $seen_arcs{$arcs_id[$j]}++;
    }
  }    
    
#   filling union_graph_array with graph2 without intersection
  my $j = scalar(@union_graph_array);
  my $arc_color = "#0000ff";
  for (my $i = 0; $i < scalar(@arcs_g2); $i++) {
    my $source_name = $arcs_g2[$i][0]; 
    my $target_name = $arcs_g2[$i][1];
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_".1;
    push @arcs_id, $arc_id1; # arcs du graph 1, "dirigés"
    if (!$directed) {
      my $arc_id2 = $target_name."_".$source_name."_".1;
      push @arcs_id, $arc_id2; # ajouts des arcs du graph 1 "non dirigés"
    }
    foreach my $arc_id (@arcs_id) {
      my $arc_intern_id_g1 = $arcs_name_id_g1{$arc_id};
      my $arc_intern_id_g2 = $arcs_name_id_g2{$arc_id};
      my $seen_arc = $seen_arcs{$arc_id};
      if (!defined($seen_arc) && defined($arc_intern_id_g2)) {
        my $arc_label = $arcs_g2[$i][2];
        my $source_name_id = $nodes_name_id_g2{$source_name};
        my $target_name_id = $nodes_name_id_g2{$target_name};
        my $source_node_color = $nodes_color_g2{$source_name_id};
        my $target_node_color = $nodes_color_g2{$target_name_id};
        $union_graph_array[$j][0] = $source_name;
        $union_graph_array[$j][1] = $target_name;
        $union_graph_array[$j][2] = $arc_label;
        $union_graph_array[$j][3] = $source_node_color;
        $union_graph_array[$j][4] = $target_node_color;
        $union_graph_array[$j][5] = $arc_color;
        $j++;
	for (my $j = 0; $j < scalar(@arcs_id); $j++) {
          $seen_arcs{$arcs_id[$j]}++;
        }
      }
    }
  }
  $union_graph->load_from_array(@union_graph_array);
  #$union_graph->remove_duplicated_arcs();
  return ($union_graph);
}

################################################################
## Difference of two graphs
## 
## 

sub difference {

  my ($graph1, $graph2) = @_;

  my $diff_graph = new RSAT::Graph2;
    
  my @arcs_g1 = $graph1->get_attribute("arcs");
  my @arcs_g2 = $graph2->get_attribute("arcs");
  my %arcs_name_id_g1 = $graph1->get_attribute("arcs_name_id");
  my %arcs_name_id_g2 = $graph2->get_attribute("arcs_name_id");
  my %nodes_name_id_g1 = $graph1->get_attribute("nodes_name_id");
  my %nodes_name_id_g2 = $graph2->get_attribute("nodes_name_id");
  my %nodes_color_g1 = $graph1->get_attribute("nodes_color");
  my %nodes_color_g2 = $graph2->get_attribute("nodes_color");
  my %nodes_label_g1 = $graph1->get_attribute("nodes_label");
  my %nodes_label_g2 = $graph2->get_attribute("nodes_label");
  
  my @diff_graph_array = ();
  
  my $j = 0;
  
  my %seen_arcs = ();

  for (my $i = 0; $i < scalar(@arcs_g1); $i++) { # charge le graph 1
  
    my $source_name = $arcs_g1[$i][0]; 
    my $target_name = $arcs_g1[$i][1];
    
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_".1;
    my $arc_id_rev = $source_name."_".$target_name."_".1;
    if (!$directed) {
      $arc_id_rev = $target_name."_".$source_name."_".1;
    }
    if (!exists($arcs_name_id_g2{$arc_id1}) && !exists($arcs_name_id_g2{$arc_id_rev})) {
      if (!exists($seen_arcs{$arc_id1}) && !exists($seen_arcs{$arc_id_rev})) {
	  
	my $arc_label = $arcs_g1[$i][2];
        my $source_name_id = $nodes_name_id_g1{$source_name};
        my $target_name_id = $nodes_name_id_g1{$target_name};
        my $source_node_color = $nodes_color_g1{$source_name_id};
        my $target_node_color = $nodes_color_g1{$target_name_id};
        $diff_graph_array[$j][0] = $source_name;
        $diff_graph_array[$j][1] = $target_name;
        $diff_graph_array[$j][2] = $arc_label;
        $diff_graph_array[$j][3] = $source_node_color;
        $diff_graph_array[$j][4] = $target_node_color;
        $diff_graph_array[$j][5] = "#000088";
        $j++;
	$seen_arcs{$arc_id1}++;
	$seen_arcs{$arc_id_rev}++;
      }  
    }
  }
  $diff_graph->load_from_array(@diff_graph_array);
  return ($diff_graph);
}

################################################################
## arcs in common between two graphs
## 
## 
sub in_common {
  my ($graph1, $graph2) = @_;
  my $common = 0;
  my $graph1_not_graph2 = 0;
  my $graph2_not_graph1 = 0; 
  my %seen_arcs = ();
  my @arcs_g1 = $graph1->get_attribute("arcs");
  my %arcs_name_id_g1 = $graph1->get_attribute("arcs_name_id");
  my @arcs_g2 = $graph2->get_attribute("arcs");
  my %arcs_name_id_g2 = $graph2->get_attribute("arcs_name_id");
  my $max_arc_nb = $graph2->get_attribute("nb_arc_bw_node");
  for (my $i = 0; $i < scalar(@arcs_g1); $i++) { # run through the arcs of graph1
    my $source_name = $arcs_g1[$i][0];
    my $target_name = $arcs_g1[$i][1];
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_1";
    push @arcs_id, $arc_id1; 
    if (!$directed) {
      my $arc_id2 = $target_name."_".$source_name."_1";
      push @arcs_id, $arc_id2; 
    }
    foreach my $arc_id (@arcs_id) {
      my $arc_intern_id = $arcs_name_id_g2{$arc_id};
      if (!exists($seen_arcs{$arc_id})) {
        if (defined($arc_intern_id)) {
	  $common++;
	  foreach (my $j = 0; $j < scalar(@arcs_id); $j++) {
	    $seen_arcs{$arcs_id[$j]}++;
	  }
  	  if (!$directed) {
	    last;
	  }
        }
      } else {
        if (!$directed) {
          last;
        }
      }
    }
  }
  return ($common);
}
################################################################
#### verbose message
sub Verbose {
    print $main::out "; compare-graphs ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=cut
