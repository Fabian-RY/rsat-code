#!/usr/bin/perl -w
############################################################
#
# $Id: random-graph,v 1.1 2007/05/07 14:18:51 rsat Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

random-graph

=head1 DESCRIPTION

Generate random graphs either from an existing graph or from scratch.

=head1 AUTHORS

<Sylvain Brohee> sylvain@scmbb.ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE
    
random-graph [-i inputfile] [-o outputfile] [-v #] [...]

random-graph [-node #] [-edge #] [-o outputfile] [-n #] [-self] [-duplicated] [-nodefile]



=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph2;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();


    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::out = STDOUT;
    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	tab=>1,
	gml=>1
    );
    $supported_input_formats = join (",", keys %supported_input_format);
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;

    ## Output formats
    local $output_format = "dot";
    %supported_output_format =(
			       dot=>1,
			       gml=>1,
			       tab=>1
			       
    );
    $supported_output_formats = join (",", keys %supported_output_format);

    # number of required nodes
    $req_nodes = 0;
    
    # number of required edges
    $req_edges = 0;

    # number of required edges
    $self = 0;
    
    # maxium degree
    $max_degree = -1;
    
    # duplicated edges
    $duplicated = 0;
    
    # directed edges
    $directed = 0;
    
    # nodes
    @nodes = ();

    # nodes
    $random_type = "";
    
    %supported_random_type =(
			       scratch=>1,
			       node_degree=>1, 
			       node_degree_distrib=>1
    );
    
    $supported_random_type = join (",", keys %supported_random_type);        
    
    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values
    if ($req_nodes == 0 && !$main::infile{input}) {
       &RSAT::error::FatalError("When using no starting graph, you must specify the number of requested edges (-edge)");
    }
    if ($main::infile{input} && !-e $main::infile{input}) {
      &RSAT::error::FatalError("\t", "File", $main::infile{input}, "does not exist");
    }
    if ($main::infile{nodefile} && !-e $main::infile{nodefile}) {
      &RSAT::error::FatalError("\t", "File", $main::infile{nodefile}, "does not exist");
    }
    if ($main::infile{nodefile} && $main::infile{input}) {
      &RSAT::error::FatalError("\t", "Cannot specify both a file containing node names and a graph file");
    }
    if ($random_type eq "") {
      &RSAT::error::FatalError("\t", "You must specify a randomization type.");
    } elsif (($random_type eq "node_degree" || $random_type eq "node_degree_distrib") && !exists($main::infile{input})) {
      &RSAT::error::FatalError("\t", "You must specify an input graph when using randomization type", $random_type);
    } elsif (($random_type eq "node_degree" || $random_type eq "node_degree_distrib") && ($duplicated || $self || $directed || $max_degree > 0)) {
      &RSAT::error::FatalError("\t", "Option -duplicate, -self, -max_degree and -directed are not compatible with randomization type", $random_type);
    }
    if ($output_format eq "tab") {
      $main::verbose_out = $main::out;
    } else {
      $main::verbose_out = STDOUT;
    }
    ################################################################
    ## Read an input graph if available
    my $graph = new RSAT::Graph2();
    if ($main::infile{input}) {
      $graph->graph_from_text($input_format,$main::infile{input}, $source_col, $target_col, $weight_col);
      @nodes =  $graph->get_nodes();
    }
    
    ################################################################
    ## Read the node of the node file
    if ($infile{nodefile}) {
      my $l = 0;
      &RSAT::message::TimeWarn("Reading nodes from file", $infile{nodefile}) if ($main::verbose >= 2);
      my ($node_handle) = &OpenInputFile($infile{nodefile});
      while (my $line = <$node_handle>) {
	$l++;  
	next if ($line =~ /^\#/); ## Skip header lines
	next if ($line =~ /^--/); ## Skip comment lines
	next if ($line =~ /^;/); ## Skip comment lines
	next unless ($line =~ /\S/); ## Skip empty lines
	chomp($line);
	my @fields = split /\s+/, $line;
	my $node =  $fields[0];
	if ($node) {
	  push @nodes, $node;
	} else {
	  &RSAT::message::Warning("Line", $l, "starts with space. Skipped.");
	}
      }
      close $node_handle;
    }
    
    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ## Create the random graph
    if ($random_type eq 'scratch') {
      my $nodes_ref = \@nodes;
      $graph = $graph->create_random_graph($nodes_ref, $req_nodes, $req_edges, $self, $duplicated , $directed, $max_degree);
    } elsif ($random_type eq 'node_degree') {
      $graph = $graph->randomize();
    } elsif ($random_type eq 'node_degree_distrib') {
      $graph = $graph->random_graph_degree_distrib();
    }
         
    
    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);
    

    ################################################################
    ## Print output
    print $out $graph->to_text($output_format); 
    
    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::verbose_out "; Job started $start_time\n";
	print $main::verbose_out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ### Input format  
=pod

=item B<-input_format input_format>

Input format. Supported: tab, gml

=cut
	} elsif ($arg eq "-in_format") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});
=pod

=item B<-random_type >

Randomization type. Supported: scratch, node_degree, node_degree_distrib
From scratch, builds a graph totally at random. You may specify the nodes names either by indicating an input graph file (-i option) or a file containing file names (-nodefile option).

With the node_degree randomization type, each node will keep the same degree that in the input graph (edge randomization).

With the node_degree_distrib randomization type, the global distribution of node degree will remain the same as in the input graph but each nodes will have another degrees.


=cut
	} elsif ($arg eq "-random_type") {
	    $random_type = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid randomization type. Supported: $supported_random_type")
		unless ($supported_random_type{$random_type});

	    ### Output format  
=cut

=item B<-output_format output_format>

Output format. Supported: tab, dot, gml

=cut 
	} elsif ($arg eq "-out_format") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});


	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes. 

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes. 

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight nodes. 

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }	    
	    ##  number of edges
=pod

=item B<-edges #>

Number of requested edges.

=cut
	} elsif ($arg eq "-edges") {
	    $req_edges = shift (@arguments);
	    unless (&IsNatural($req_edges) && ($req_edges > 0)) {
		&RSAT::error::FatalError(join("\t", $req_edges, "Invalid value for the number of requested edges. Must be a strictly positive natural number"));
	    }
	    ##  number of nodes
=pod

=item B<-nodes #>

Number of requested nodes

=cut
	} elsif ($arg eq "-nodefile") {
          $main::infile{nodefile} = shift(@arguments);
          
	    ##  number of nodes
=pod

=item B<-nodefile #>

Number of requested nodes

=cut
	} elsif ($arg eq "-nodes") {
	    $req_nodes = shift (@arguments);
	    unless (&IsNatural($req_nodes) && ($req_nodes > 0)) {
		&RSAT::error::FatalError(join("\t", $req_nodes, "Invalid value for the number of requested nodes. Must be a strictly positive natural number"));
	    }
	   

	    ##  maximal degree of the nodes
=pod

=item B<-degree #>

Maximal degree of the nodes in the random graph

=cut
	} elsif ($arg eq "-degree") {
	    $max_degree = shift (@arguments);
	    unless (&IsNatural($max_degree) && ($max_degree > 0)) {
		&RSAT::error::FatalError(join("\t", $max_degree, "Invalid value for the number of requested nodes. Must be a strictly positive natural number"));
	    }	
	    	   ## Directed option
=pod

=item B<-directed>

Specifies whether the edges must be considered as directed, i.e., an edge 
from node A to node B is different from an edge from B to A (by default, edges are not directed).

=cut
	    	    
	} elsif ($arg eq "-directed") {
	    $directed = 1;
	    
=pod

=item B<-duplicate>

Specifies whether more than one edge may link two nodes.

=cut
	    	    
	} elsif ($arg eq "-duplicate") {
	    $duplicated = 1;
=pod
=item B<-self>

Allows self loops (by default, self loops are not permitted)


=cut	    
	} elsif ($arg eq "-self") {
	    $main::self = 1;
	    

	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}

     }

}


################################################################
#### verbose message
sub Verbose {
    print $main::verbose_out "; convert-graph ";
    &PrintArguments($main::verbose_out);
    if (defined(%main::infile)) {
	print $main::verbose_out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::verbose_out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
}

__END__

=pod

=head1 SEE ALSO

=cut
