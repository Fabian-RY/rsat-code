###############################################################
#
# Manipulation of Position-Specific Scoring Matrices (PSSM)
#
package RSAT::matrix;

#%alphabet_index = ();

require "RSA.seq.lib";
use RSAT::table;
use RSAT::stats;

@ISA = qw( RSAT::GenericObject RSAT::table);

=pod

=head1 NAME

    RSAT::matrix

=head1 DESCRIPTION

Main class for manipuating profile matrices (also called PSSM,
Position-Specific Scoring Matrices, count matrices, position-weight matrices).

PSSM can be used to represent the binding specificity of a transcription
factor or the conserved residues of a protein domain.

Each row of the matrix corresponds to one residue (nucleotide or amino-acid
depending on the sequence type).  Each column corresponds to one position in
the alignment.  The value within each cell represents the frequency of each
residue at each position.

This converter takes as input PSSM generated by different pattern discovery
programs (consensus, tab, gibbs, MEME, MotifSampler), and exports them in
different formats.

=head1 OUTPUT FORMATS

=over

=item B<counts>

Each cell of the matrix indicates the number of occurrences of the
residue at a given position of the alignment.

=item B<profile>

The matrix is printed vertically (each matrix column becomes a row in
the output text). Additional parameters (consensus, information) are
indicated besides each position, and a histogram is drawed.

=item B<crude frequencies>

Relative frequencies are calculated as the counts of residues divided
by the total count of the column.

S<Fij=Cij/SUMi(Cij)>

where 

=over

=item Cij 

is the absolute frequency (counts) of residue i at position j of the alignment

=item Fij

is the relative frequency of residue i at position j of the alignment

=back


=item frequencies corrected with pseudo-weights

Relative frequencies can be corrected by a pseudo-weight (b) to reduce
the bias due to the small number of observations.

S<F''ij=Cij+b*Pi/[SUMi(Cij)+b]>

where 

=over

=item Pi 

is the prior frequency for residue i

=item b

is the pseudo-weight, which is "shared" between residues according to
their prior frequencies.

=back



=item weights

Weights are calculated according to the formula from Hertz (1999), as
the natural logarithm of the ratio between the relative frequency
(corrected for pseudo-weights) and the prior residue probability.

S<Wij=ln(F''ij/Pi)>

=item information

The crude information content is calculated according to the formula
from Hertz (1999).

S<Iij = Fij*ln(Fij/Pi)>

In addition, we calculate a "corrected" information content which
takes pseudo-weights into account.


S<I''ij = F''ij*ln(F''ij/Pi)>

=item P-value

The P-value indicates the probability to observe at least Cij
occurrences of a residue at a given position of the matrix. It is
calculated with the binomial formula:

    k=C.j    C.j!      k      Cij-k
Pij= SUM  ---------- Pi (1-Pi)
    k=Cij k!(C.j-k)!

where

=over

=item Cij 

is the number of occurrences of residue i at position j of
the matrix.

=item C.j 

is the sum of all residue occurrences at position j of the
matrix.

=item Pi 

is the prior probability of residue i.

=back

=item parameters

Returns a series of parameters associated to the matrix. The list of
parameters to be exported depends on the input formats (each pattern
discovery program returns specific parameters, which are more or less
related to each others but not identical).

Some additional parameters are optionally calculated

=over

=item consensus

The degenerate consensus is calculated by collecting, at each
position, the list of residues with a positive weight. Contrarily to
most applications, this consensus is thus weighted by prior residue
frequencies: a residue with a high frequency might not be represented
in the consensus if this frequency does not significantly exceed the
expected frequency. Uppercases are used to highlight weights >= 1.

The consensus is exported as regular expression, and with the IUPAC
code for ambiguous nucleotides (http://www.chem.qmw.ac.uk/iupac/misc/naseq.html).

       	A			(Adenine) 
	C			(Cytosine)
	G			(Guanine)
	T			(Thymine)
	R	= A or G        (puRines)
	Y	= C or T        (pYrimidines)
	W	= A or T        (Weak hydrogen bonding)
	S	= G or C        (Strong hydrogen bonding)
	M	= A or C        (aMino group at common position)
	K	= G or T        (Keto group at common position)
	H	= A, C or T     (not G)
	B	= G, C or T     (not A)
	V	= G, A, C       (not T)
	D	= G, A or T     (not C)
	N	= G, A, C or T  (aNy)

The strict consensus indicates, at each position, the residue with the
highest positive weight.

=item information

The total information is calculated by summing the information content
of all the cells of the matrix. This parameters is already returned by
the program consensus (Hertz), but not by other programs.

=back

=back

=head1 METHODS

=over

=cut


################################################################
=pod

=item B<new()>

Create an empty matrix.

=cut
sub new {
    my ($class, %args) = @_;
    my $matrix = bless {
	nrow=>0,
	ncol=>0,
	%args
	}, $class;
    return $matrix;
}


################################################################
=pod

=item B<init>

Initialize the matrix.

=cut

sub init {
    my ($self) = @_;

    ## initialize the matrix
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    warn "Initializing the matrix $nrow rows, $ncol columns\n" if ($main::verbose >= 5);
    foreach my $r (1..$nrow) {
	foreach my $c (1..$ncol) {
	    $self->setCell($r,$c,0);
	}
    }
}

################################################################
=pod 

=item B<set_parameter()>

Sets an attribute and add it to the list of parameters to export.

=cut
sub set_parameter {
    my ($self, $key, $value) = @_;
    $self->force_attribute($key, $value);
    $self->push_attribute("parameters", $key);
}

################################################################
=pod

=item B<reset()>

Empty the matrix

=cut
sub reset {
    my ($self) = @_;
    warn "Resetting the matrix to empty\n" if ($main::verbose >= 5);
    undef(@{$self->{alphabet}});
    undef(@{$self->{table}});
    $self->force_attribute("nrow", 0);
    $self->force_attribute("ncol", 0);
}


################################################################
=pod

=item B<index_alphabet>

Index the alphabet in a hash table, indicating which row of the matrix
corresponds to which letter of the alphabet.

=cut
sub index_alphabet {
    my ($self) = @_;
    my @alphabet = $self->getAlphabet();
    my $row = 0;
    foreach my $letter (@alphabet) {
	$self->add_hash_attribute("alphabet_index", lc($letter), $row);
#	$alphabet_index{$letter} = $row;
#	&RSAT::message::Debug("Alphabet index", $letter, $row) if ($main::verbose >= 10);
	$row++;
    }
}


################################################################
=pod

=item getPrior()

Return prior frequencies. If these were not defined previously,
estimate them on the basis of equiprrobable residues. 

=cut
sub getPrior() {
    my ($self) = @_;
    my %prior = ();
    if ($self->get_attribute("prior_specified")) {
	%prior = $self->get_attribute("prior");
    } else {
	if (scalar(keys %prior) <= 0) {
	    &main::Warning( "No prior defined: using equiprobable residues") if ($main::verbose >= 3);
	    my @alphabet = $self->getAlphabet();
	    my $alphabet_size = scalar(@alphabet);
	    foreach my $letter (@alphabet) {
		$prior{$letter} = 1/$alphabet_size;
		&RSAT::message::Debug("RSAT::matrix::setPrior", $letter, $prior{$letter}) if ($main::verbose >= 10);
	    }
	    $self->setPrior(%prior);
	}
    }
    if ($main::verbose >= 10) {
	foreach my $letter (sort keys %prior) {
	    warn join("\t", "; getPrior", $letter, $prior{$letter}), "\n";
	}
    }
#g    warn "CHECK getPrior\t", join " ", %prior if ($main::verbose >= 10);
    return %prior;
}

################################################################
=pod 

=item setPrior(%prior)

Specify prior frequencies. The priors are provided as a hash table,
where keys are residues and values prior probabilities.

=cut
sub setPrior {
    my ($self, %prior) = @_;

    &RSAT::message::Info (join("\t", "setPrior", join(" ", %prior))) if ($main::verbose >= 3);
    $self->set_array_attribute("prior", %prior);
    $self->force_attribute("prior_specified", 1);

#    ## Update the alphabet
#    $self->set_array_attribute("alphabet", keys(%prior));

    ## The previously calculated weights are not valid anymore
    $self->force_attribute("frequencies_specified", 0);
    $self->force_attribute("weight_specified", 0);

    ## Report the new prior
    if ($main::verbose >= 10) {
	%check = $self->get_attribute("prior");
	&RSAT::message::Info (join("\t", "&RSAT::matrix::setPrior", join(" ", %prior))) if ($main::verbose >= 4);
	foreach my $letter (sort keys %check) {
	    warn join("\t", "; setPrior", $letter, $prior{$letter}), "\n";
	}
    }
}



################################################################
## PROBLEM ###
=pod

=item addRow(@new_row)

Add a new row to the matrix

=cut
sub addRow {
    my ($self,@new_row) = @_;
    
    ## Update number of rows
    my $nrow = $self->nrow()+1;
	$self->force_attribute("nrow", $nrow);
    warn ("Matrix: updating number of rows\t", $self->nrow(), "\n") if ($main::verbose >= 5);
    
    ## update number of colmuns
    my $row_size = scalar(@new_row);
    if ($row_size >= $self->ncol()) {
	warn ("Matrix: updating number of columns\t", $row_size, "\n") if ($main::verbose >= 5);
	$self->force_attribute("ncol", scalar(@new_row));
    }
    
    ## update matrix content
    for my $c (0..$#new_row) {
	${$self->{table}}[$c][$nrow-1] = $new_row[$c];
    }
}

################################################################
=pod

=item getParameters()

Return the list of parameters associated to the matrix

=cut
sub getParameters {
    my ($self) = @_;
    return @{$self->{parameters}};
}

################################################################
=pod

=item getMatrix()

Return the whole matrix as a vector

=cut
sub getMatrix {
    my ($self) = @_;
    return @{$self->{table}};
}

################################################################
=pod

=item setMatrix($nrow, $ncol, @matrix)

Specify the whole matrix

=cut
sub setMatrix {
    my ($self,$nrow, $ncol, @matrix) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{table}} = @matrix;
}



################################################################
=pod

=item toString(sep=>$sep, col_width=>$col_width, type=>$type, comment_char=>$comment_string)

Return a string description of the matrix in the same format as Jerry
Hertz programs. Additional parameters are also exported as comments,
when the verbosity is > 0.

Supported parameters:

=over

=item comment_string

A character or string to print before each row of the matrix.

=back

=cut
sub toString {
    my ($self, %args) = @_;
    my $to_print = "";

    ## Separator between row names (residues) and matrix content
    my $pipe =  "|";
    if (defined($args{pipe})) {
      $pipe = $args{pipe};
    }
    $self->force_attribute("pipe", $pipe);

    ## Matrix type
    $type = $args{type} || "counts";

    %supported_types = (profile=>1,
			counts=>1,
			frequencies=>1,
			weights=>1,
			information=>1,
			parameters=>1
			);
    &main::FatalError("Invalid matrix type $type") unless $supported_types{$type};

    ## Set formatting parameters provided in arguments as matrix attribute
    foreach my $key ("sep", "col_width", "decimals") {
	if (defined($args{$key})) {
	    $self->force_attribute($key, $args{$key});
	}
    }

    ## Format for the matrix entries
    my $sep = $self->get_attribute("sep") || "\t";
    my $col_width = $self->get_attribute("col_width");
    my $decimals = $self->get_attribute("decimals");

    ## Calculate number width
    my $number_width = 0;
    if ($col_width) {
	$number_width = $col_width - 1;
    }
    if ($type eq "counts") {
	$decimals = 0;
    } else {
	unless ($decimals) {
	    $decimals = $number_width - 2;
	}
    }

    ################################################################
    ## Print parameters
    if ($type eq "parameters") {
	$to_print .= $self->_printParameters($to_print);

	################################################################
	## Print a profile (vertical matrix with consensus on the right side)
    } elsif ($type eq "profile") {

	$to_print .= $self->_printProfile($to_print);

    } else {

	################################################################
	## Print a matrix
	my @matrix = ();
	if ($type eq "counts") {
	    @matrix = @{$self->{table}};
	} else {
	    @matrix = @{$self->{$type}};
	}
	my @alphabet = $self->getAlphabet();
	my $ncol = $self->ncol();
	my $nrow = $self->nrow();

	## Header of the matrix
	if ($main::verbose >= 1) {
	    $to_print .= ";\n";
	    $to_print .= "; Matrix type: $type\n";
	    if (($col_width) && ($col_width < 6)) {
		$to_print .= ";P";
	    } else {
		$to_print .= "; Pos";
	    }
	    $to_print .= $sep.$pipe if ($pipe);
	    for my $c (0..($ncol-1)) {
		my $pos = $c+1;
		if ($col_width) {
		    $to_print .= sprintf "%${col_width}s", $pos;
		} else {
		    $to_print .= $sep;
		    $to_print .= $pos;
		}
	    }
	    $to_print .= "\n";

	    $to_print .= $self->_printSeparator($ncol, $to_print);
	}

	## Print the matrix
	for $a (0..$#alphabet) {
	    my @row = &RSAT::matrix::get_row($a+1, $ncol, @matrix);
	    if (defined($args{comment_string})) {
		$to_print .= $args{comment_string};
	    }
 	    $to_print .= $self->_printMatrixRow($alphabet[$a], @row);
	}

	################################################################
	##Print column statistics
	if ($self->get_attribute("margins")) {
	    $prefix_letter = substr($type, 0, 1);
	    $to_print .= $self->_printSeparator($ncol, $to_print);
	    
	    ## Sum per column
	    my @col_sum = &RSAT::matrix::col_sum($nrow, $ncol, @matrix);
	    push @col_sum, &main::sum(@col_sum);
	    $to_print .= $self->_printMatrixRow("; ".$prefix_letter.".sum", @col_sum);
	    
	    ## Maximum per column
	    my @col_max = &RSAT::matrix::col_max($nrow, $ncol, @matrix);
	    push @col_max, &main::max(@col_max);
	    $to_print .= $self->_printMatrixRow("; ".$prefix_letter.".max", @col_max);
	    
	    ## Minimum per column
	    my @col_min = &RSAT::matrix::col_min($nrow, $ncol, @matrix);
	    push @col_min, &main::min(@col_min);
	    $to_print .= $self->_printMatrixRow("; ".$prefix_letter.".min", @col_min);
	}
    }
    return $to_print;
}




################################################################
=pod

=item getWeights()

Return the weight matrix

=cut
sub getWeights {
    my ($self) = @_;
    unless ($self->get_attribute("weight_specified") >= 1) {
	$self->calcWeights();
    }
    return @{$self->{weights}};
}

################################################################
=pod

=item setWeights($nrow, $ncol, @weights)

Specify the weight matrix

=cut
sub setWeights {
    my ($self,$nrow, $ncol, @weights) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{weights}} = @weights;
    $self->force_attribute("weight_specified", 1);
}

################################################################
=pod 

=item calcWeights()

Calculate weights from the frequency matrix.

=cut
sub calcWeights {
    my ($self) = @_;

    ## Get frequency matrix
    my @frequencies = $self->getFrequencies();

    ## Get alphabet
    my @alphabet = $self->getAlphabet();
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("&RSAT::matrix::calcWeights()\tCannot calculate weigths, because the alphabet has not been specified yet.");
    }

    ## Get or calculate prior residue probabilities
    my %prior = $self->getPrior();
    
    ## get matrix size
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    
    ## Calculate the weights
    my @weights = ();
    for my $c (0..($ncol-1)) {
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $freq = $frequencies[$c][$r];
	    if ($freq == 0) {
		$weights[$c][$r] = "-Inf";
	    } elsif ($prior <= 0) {
		$weights[$c][$r] = "NA";
	    } else {
		$weights[$c][$r] = log($freq/$prior);
	    }
#	    &RSAT::message::Debug("weight", "r:".$r, "c:".$c, "l:".$letter, "f:".$freq, "pr:".$prior, "w:".$weights[$c][$r]) if ($main::verbose >= 10);
	}
    }
    $self->setWeights($nrow,$ncol,@weights);
    $self->force_attribute("weight_specified", 1);
}

################################################################
=pod

=item getInformation()

Return the information content matrix. 

=cut
sub getInformation {
    my ($self) = @_;
    $self->calcInformation();
    return @{$self->{information}};
}

################################################################
=pod

=item setInformation($nrow, $ncol, @information)

Specify the information content matrix.

=cut
sub setInformation {
    my ($self,$nrow, $ncol, @information) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{information}} = @information;
    $self->force_attribute("information_specified", 1);
}


################################################################
=pod 

=item calcInformation()

Calculate information content from the weight matrix.

Caching: if already calculated, do not calculate anymore.
attribute "force": force calculaton even if aready calculated.

=cut
sub calcInformation {
    my ($self, $force) = @_;

    ## Caching
    if (($self->get_attribute("information_calculated")) && !($force)) {
	warn "Information already calculated before\n" if ($main::verbose >= 3);
	return;
    }

    ## Calculate frequencies if required
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }
    my @frequencies = $self->getFrequencies();
#    my @frequencies = $self->getCrudeFrequencies();

    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("&RSAT::matrix::calcInformation()\tCannot calculate weigths, because the alphabet has not been specified yet.");
    }
    $self->set_parameter("alphabet.size", scalar(@alphabet));

    ## Get or calculate prior residue probabilities
    my %prior = $self->getPrior();
    my $min_prior = &RSAT::stats::min(values %prior);
    $self->set_parameter("min.prior", $min_prior);

    ## Maximal number of bits per column
    my $max_bits = log(scalar(@alphabet))/log(2);
    $self->set_parameter("max.bits", $max_bits);

    ## Maximal information per column
    my $max_info_per_col = -log($min_prior);
    $self->set_parameter("max.info.per.col", $max_info_per_col);

    ## Matrix size
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();

    ## Calculate information contents
    my @information = (); ## Information matrix 
    my @column_information = (); ## Information per column
    my $total_information = 0; ## Total information for the matrix
    for my $c (0..($ncol-1)) {
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $freq = $frequencies[$c][$r];
	    if ($freq == 0) {
		$information[$c][$r] = 0;
	    } else {
		$information[$c][$r] = $freq * log($freq/$prior);
	    }
	    $column_information[$c] += $information[$c][$r];
	    $total_information += $information[$c][$r];
#	    &RSAT::message::Debug("Information", $r, $c, $information[$c][$r], $total_information) if ($main::verbose >= 10);
	}
    }
    $self->setInformation($nrow,$ncol,@information);


    ## Information per column
    $self->push_attribute("column.information", @column_information);

    ## Total information for the matrix
    $self->set_parameter("total.information", $total_information);
    $self->set_parameter("information.per.column", $total_information/$self->ncol());

    ## Remember that info was calculated once
    $self->force_attribute("information_calculated", 1);
}


################################################################
=pod

=item getFrequencies()

Return the matrix of frequencies. Beware: these frequencies are taking
pseudp-weights into account.

=cut
sub getFrequencies {
    my ($self) = @_;
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }
    return @{$self->{frequencies}};
}

################################################################
=pod

=item setFrequencies($nrow, $ncol, @frequencies)

Specify the matrix of frequencies. Beware: these frequencies are
taking pseudp-weights into account.

=cut
sub setFrequencies {
    my ($self,$nrow, $ncol, @frequencies) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{frequencies}} = @frequencies;
    $self->force_attribute("frequencies_specified", 1);
}

################################################################
=pod

=item getCrudeFrequencies()

Return the matrix of crude frequencies, i.e. NOT corrected by
pseudo-weights.

=cut
sub getCrudeFrequencies {
    my ($self) = @_;
    unless ($self->get_attribute("crudeFrequencies_specified")) {
	$self->calcFrequencies();
    }
    return @{$self->{crudeFrequencies}};
}

################################################################
=pod

=item setCrudeFrequencies($nrow, $ncol, @crudeFrequencies)

Specify the matrix of crude frequencies, i.e; NOT corrected by
pseudo-weights.

=cut
sub setCrudeFrequencies {
    my ($self,$nrow, $ncol, @crudeFrequencies) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{crudeFrequencies}} = @crudeFrequencies;
    $self->force_attribute("crudeFrequencies_specified", 1);
}

################################################################
=pod 

=item calcFrequencies()

Calculate frequencies from the count matrix (corrected with pseudo-weights).

=cut
sub calcFrequencies {
    my ($self) = @_;

    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("&RSAT::matrix::calcFrequencies()\tCannot calculate weigths, because the alphabet has not been specified yet.");
    }

    ## Matrix size
    my ($nrow, $ncol) = $self->size();
    if (($nrow <= 0) ||
	($ncol <= 0)) {
	&main::FatalError("&RSAT::matrix::calcFrequencies()\tCannot calculate weigths for an empty matrix.");
    }

    ## Get or calculate prior residue probabilities
    my %prior = $self->get_attribute("prior");
    if (scalar(keys %prior) <= 0) {
	&main::Warning( "No prior defined: using equiprobable residues") if ($main::verbose >= 3);
	my $alphabet_size = scalar(@alphabet);
	foreach my $letter (@alphabet) {
	    $prior{$letter} = 1/$alphabet_size;
	    &RSAT::message::Debug($letter, $prior{$letter}) if ($main::verbose >= 10);
	}
    }

    &RSAT::message::Debug("&RSAT::matrix::calcFrequencies()", "residue priors", join(" ", %prior)) 
      if ($main::verbose >= 4);

    ## pseudo-weight
    my $pseudo = $self->get_attribute("pseudo") || 0;

    ## count matrix
    my @matrix = $self->getMatrix();

    ## Calculate the frequencies
    my @frequencies = ();
    my @crude_frequencies = ();
#    my @col_sum = &RSAT::matrix::col_sum(@matrix);
    my $alphabet_size = scalar(keys(%prior));

    for my $c (0..($ncol-1)) {
	my $col_sum = 0;
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $occ = $matrix[$c][$r];
	    $col_sum += $occ;

	    if ($self->get_attribute("equi_pseudo")) {
		## Equiprobable repartition of the pseudo-weight
		$frequencies[$c][$r] = $occ + $pseudo/$alphabet_size;
#		&RSAT::message::Info("Equiprobable distribution of the pseudo-weight") if ($main::verbose >= 10);
	    } else {
		## Distribute pseudo-weight according to prior
		$frequencies[$c][$r] = $occ + $pseudo*$prior{$letter};
#		&RSAT::message::Info("Pseudo-weight distributed according to prior") if ($main::verbose >= 10);
	    }
#	    &RSAT::message::Debug("freq", $r, $c, $letter, $prior, $pseudo, $occ, $col_sum) unless ($letter);
#	    &RSAT::message::Debug("freq", $r, $c, $letter, $prior, $pseudo, $occ, $col_sum) if ($main::verbose >= 10);
#      die("HELLO");
	}
	for my $r (0..($nrow-1)) {
	  if ($col_sum eq 0) {
	    $crude_frequencies[$c][$r] = 0;
	  } else {
	    $crude_frequencies[$c][$r] = $matrix[$c][$r]/$col_sum;
	  }
	  if (($col_sum + $pseudo) > 0) {
	    $frequencies[$c][$r] /= ($col_sum + $pseudo);
	  } else {
	    $frequencies[$c][$r] = 0;
	  }
#	  &RSAT::message::Debug("freq", $r, $c, $pseudo, 
#				$col_sum, 
#				"a:".$matrix[$c][$r], 
#				"f:".$crude_frequencies[$c][$r], 
#				"f':".$frequencies[$c][$r])
#	    if ($main::verbose >= 10);
	}
    }

    $self->setFrequencies($nrow,$ncol,@frequencies);
    $self->setCrudeFrequencies($nrow,$ncol,@crude_frequencies);
}

################################################################
=pod 

=item calcProbabilities()

Calculate probabilities (with the binomial distribution) from the
count matrix.

=cut
sub calcProbabilities {
    my ($self) = @_;

    die "The procedure calcProbabilities() is in construction";

    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("&RSAT::matrix::calcProbabilities()\tCannot calculate weigths, because the alphabet has not been specified yet.");
    }

    ## Matrix size
    my ($nrow, $ncol) = $self->size();
    if (($nrow <= 0) ||
	($ncol <= 0)) {
	&main::FatalError("&RSAT::matrix::calcProbabilities()\tCannot calculate weigths for an empty matrix.");
    }

    
    ## Get or calculate prior residue probabilities
    my %prior = $self->get_attribute("prior");
    if (scalar(keys %prior) <= 0) {
	&main::Warning( "No prior defined: using equiprobable residues") if ($main::verbose >= 3);
	my $alphabet_size = scalar(@alphabet);
	foreach my $letter (@alphabet) {
	    $prior{$letter} = 1/$alphabet_size;
	    warn join "\t", ";", $letter, $prior{$letter}, "\n" if ($main::verbose >= 10);
	}
    }

    ## pseudo-weight
    my $pseudo = $self->get_attribute("pseudo");
    
    ## count matrix
    my @matrix = $self->getMatrix();
    
    ## Calculate the frequencies
    my @frequencies = ();
    my @crude_frequencies = ();
#    my @col_sum = &RSAT::matrix::col_sum(@matrix);
    
    for my $c (0..($ncol-1)) {
	my $col_sum = 0;
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $occ = $matrix[$c][$r];
	    $col_sum += $occ;
	    $frequencies[$c][$r] = $occ + $pseudo*$prior{$letter};
	    warn join "\t", "freq", $r, $c, $letter, $prior, $pseudo, $occ, $col_sum, "\n" if ($main::verbose >= 10);
	}
	for my $r (0..($nrow-1)) {
	    if ($col_sum eq 0) {
		$crude_frequencies[$c][$r] = 0;
	    } else {
		$crude_frequencies[$c][$r] = $matrix[$c][$r]/$col_sum;
	    }
	    $frequencies[$c][$r] /= ($col_sum + $pseudo);
	    warn join( "\t", "freq", $r, $c, $pseudo, 
		       $col_sum, 
		       "a:".$matrix[$c][$r], 
		       "f:".$crude_frequencies[$c][$r], 
		       "f':".$frequencies[$c][$r]), "\n" 
			   if ($main::verbose >= 10);
	}
    }

    $self->setFrequencies($nrow,$ncol,@frequencies);
    $self->setCrudeFrequencies($nrow,$ncol,@crude_frequencies);
}


################################################################
=pod

=item &calcConsensus($force)

Calculate the consensus. 

Caching: if already calculated, do not calculate anymore.

Attribute "force": force calculaton even if aready calculated.

=cut
sub calcConsensus {
    my ($self, $force) = @_;

    ## Caching
    if (($self->get_attribute("consensus_calculated")) && !($force)) {
	warn "Consensus already calculated before\n" if ($main::verbose >= 3);
	return;
    }

    ## Calculate weight only if required
    unless ($self->get_attribute("weight_specified")) {
	$self->calcWeights();
    }
    my @weights = $self->getWeights();

    my @alphabet = $self->getAlphabet();
    
    ## Calculate consensus
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    my $consensus = "";
    my $consensus_strict = "";
    for my $c (0..($ncol-1)) {
	my $col_max = 0;
	my $col_consensus = "-";
	my %positive_score = ();
	for my $r (0..($nrow - 1)) {
	    my $weight = $weights[$c][$r];
	    if ((&main::IsReal($weight)) && ($weight >= 0)) {
		my $letter = $alphabet[$r];
		$positive_score{$letter} = $weight;
		if ($weight > $col_max) {
		    $col_max = $weight;
#		die join "\t", $c, $r, $col_max, $alphabet[$r], $col_consensus;
		    $col_consensus = $letter;
		}
	    }
	}
	
	## Calculate degenerate code
	my  $regular = $col_consensus;
	if (scalar(keys %positive_score) >= 2) {
	    $regular = "[";
	    $regular .= join "", sort keys %positive_score;
	    $regular .= "]";
	}
	
	## Use uppercase for scores >= 1
	if ($col_max >= 1) {
	    $consensus_strict .= uc($col_consensus);
	    $consensus .= uc($regular);
	} else {
	    $consensus_strict .= lc($col_consensus);
	    $consensus .= lc($regular);
	}
    }
    my $consensus_IUPAC = &main::regular_to_IUPAC($consensus);

    ## Strict consensus 
    $self->set_parameter("consensus.strict", $consensus_strict);

    ## Degenerate consensus in IUPAC format
    $self->set_parameter("consensus.IUPAC", $consensus_IUPAC);

    ## Degenerate consensus in regexp format
    $self->set_parameter("consensus.regexp", $consensus);

    ## Remember that the consensus has been calculated
    $self->force_attribute("consensus_calculated", 1);

}

################################################################
=pod

=item _printProfile()

Print the matrix in profile format (one column per residue, one row
per position), with additional columns for the consensus, some
statistics and the profile (graphical representations)

=cut

sub _printProfile {
    my ($self, $to_print) = @_;
    @matrix = @{$self->{table}};
    my @alphabet = $self->getAlphabet();
    my $ncol = $self->ncol();
    my $nrow = $self->nrow();
    my $max_profile = $self->get_attribute("max_profile");
    unless ($max_profile) {
      if (scalar(@aqlphabet) == 4) {
	$max_profile = 24;
      } else {
	$max_profile = 20;
      }
    }
    my $comment_char = "|";


    ## Temporarily suppress the pipe 
    my $pipe_bk = $self->get_attribute("pipe");

    $self->force_attribute("pipe", "");

    $to_print .= "; Profile matrix\n";

    ## Get the consensus
    $self->calcConsensus();
    my @consensus_strict = split "|", $self->get_attribute("consensus.strict");
    my @consensus_IUPAC = split "|", $self->get_attribute("consensus.IUPAC");

    ## Get the information per column
    my @information = $self->getInformation();
    my @weights = $self->getWeights();
    my @info_sum = &RSAT::matrix::col_sum($nrow, $ncol, @information);

    ## Maximal information content per column, for scaling the pseudo-logo profile
    my $max_bits = $self->get_attribute("max.bits");
    my $max_info_per_col = $self->get_attribute("max.info.per.col");

    ## profile header
    my $profile_scale = "";
    for my $i (1..$max_profile) {
      my $scale_value = $i*$max_bits/$max_profile;
      if ($scale_value == sprintf("%d", $scale_value) ) {
	$profile_scale .= $scale_value;
      } else {
	$profile_scale .= "-";
      }
    }
    $to_print .= $self->_printMatrixRow(";pos", 
					@alphabet, 
					$comment_char,
					"sum",
					"max_frq",
#					"max",
#					"min",
					"inf_sum",
					"strict",
					"IUPAC",
					$profile_scale,
				       );

#    $to_print .= $self->_printSeparator(scalar(@alphabet));

    ## print each matrix column as a row in the output
    my $matrix_max = &main::checked_max(&RSAT::matrix::col_max($nrow, $ncol, @matrix));
    my $scale = $max_profile/$matrix_max;

    for my $c (0..($ncol-1)) {
	my @row = &RSAT::matrix::get_column($c+1, $nrow, @matrix);
	my @row_weights = &RSAT::matrix::get_column($c+1, $nrow, @weights);
	my $sum = &main::sum(@row);
	my $max = &main::checked_max(@row);
	my $min = &main::checked_min(@row);
	my $profile_length = &main::round($max*$scale);

	## Logo-type profile
	my $column_info = $info_sum[$c];
	my $column_info_bits = $column_info / $max_info_per_col;

	my $consensus_profile = "";
	my $cum_len = 0;
	my $prev_cum_len = 0;
	for my $i (0..$#row) {
	  my $residue = $alphabet[$i];
	  if (($max_info_per_col > 0) && ($sum > 0)) {
	    $cum_len += $profile_length * ($row[$i]/$sum) * ($column_info/$max_info_per_col);
	  }
	  for my $j (($prev_cum_len+1)..sprintf("%d",$cum_len)) {
	    if ($row_weights[$i] >= 1) {
	      $consensus_profile .= uc($alphabet[$i]);
	    } else {
	      $consensus_profile .= lc($alphabet[$i]);
	    }
	  }
	  $prev_cum_len = sprintf("%d",$cum_len);
	}


	if ($sum <= 0) {
	    $rel_max = "NA";
	} else {
	    $rel_max = sprintf("%5.2f", $max/$sum);
	}
	$to_print .= $self->_printMatrixRow($c+1,
					    @row, 
					    $comment_char,
					    $sum,
					    $rel_max,
#					    $max,
#					    $min,
					    sprintf("%5.2f",$info_sum[$c]),
					    $consensus_strict[$c],
					    $consensus_IUPAC[$c],
					    $consensus_profile,
					   );

    }
    $self->force_attribute("pipe", $pipe_bk);
    return ($to_print);
}

################################################################
=pod

=item _printParameters()

Return a string with the parameter values

=cut 

sub _printParameters {
    my ($self, $to_print) = @_;
    $to_print .= ";\n";
    $to_print .= "; Matrix parameters\n";
    
    ## Matrix size
    $to_print .= ";\t".$self->ncol()."\tcolumns\n";
    $to_print .= ";\t".$self->nrow()."\trows\n";
    
    ## Alphabet
    $to_print .= "; Alphabet\t";
    $to_print .= join(" ", $self->getAlphabet());
    $to_print .= "\n";
    
    ## Prior probabilities
    my %prior = $self->getPrior();
    foreach my $letter (sort keys %prior) {
	$to_print .= join ("\t", ";", $letter, $prior{$letter})."\n";
    }
    
    ## Matrix attributes
    my ($proba_min, $proba_max) = $self->proba_range();
    my ($Wmin, $Wmax) = $self->weight_range();

    my @params = $self->get_attribute("parameters");
    my %printed = ();
    for my $param (@params) {
	## Print only once if the param was entered several times
	next if $printed{$param};
	$printed{$param}++;
	
	if ($self->get_attribute($param)) {
	    if (&main::IsReal($self->get_attribute($param))) {
		$to_print .= sprintf "; %-29s\t%g\n", $param, $self->get_attribute($param);
		} else {
		    $to_print .= sprintf "; %-29s\t%s\n", $param, $self->get_attribute($param);
		}
	}
    }
    return ($to_print);
}


################################################################
=pod

=item _printMatrixRow($row_name, @values)

Print a row for the matrix output.

=cut

sub _printMatrixRow {
    my ($self, $row_name, @values) = @_;
    my $row_string = $row_name;
    my $ncol = scalar(@values);

    ## Format for the matrix entries
    my $col_width = $self->get_attribute("col_width");
    my $number_width = 0;
    if ($col_width) {
  	$number_width = $col_width - 1;
    } else {
	$number_width = 5;
    }

    ## Number of decimals for floating numbers
    my $decimals = $self->get_attribute("decimals");
    unless ($decimals) {
	if ($type eq "counts") {
  	    $decimals = 0;
  	} else {
  	    $decimals = $number_width - 3;
  	}
    }

    ## Separator between columns
    my $sep = $self->get_attribute("sep") || "\t";
#    my $sep="boum";

#    &RSAT::message::Debug("w=".$col_width, "sep='".$sep."'", "pos=".$pos, "decimals=".$decimals, "number_width=".$number_width) if ($main::verbose >= 10);
    
    ## Print the matrix row
    my $pipe = $self->get_attribute("pipe");
    $row_string .= $sep.$pipe if ($pipe);
    for $c (0..($ncol-1)) {
	my $value = $values[$c];
	if ($col_width) {
	    my $value_format = "%${number_width}s";
	    if (&main::IsReal($value)){
		if ($type eq "counts") {
		    $value_format = "%${number_width}d";
		} else {
		    $value_format= "%${number_width}.${decimals}f";
		}
	    }
	    $row_string .= sprintf " ${value_format}", $value;
	} else {
	    $row_string .= $sep.$value;
	}
    }
    $row_string .= "\n";
    return $row_string;
}

################################################################
=pod

=item get_row($row_nb, $ncol, @table)

Return a row of the table as a list.

=cut
sub get_row {
    my ($row_nb, $ncol, @table) = @_;
    my @row = ();
    for my $c (0..($ncol-1)) {
	push @row, $table[$c][$row_nb-1];
    }
    return @row;
}

################################################################
=pod

=item get_column($col_nb, $nrow, @table)

Return a column of the table as a list.

=cut
sub get_column {
    my ($col_nb, $nrow, @table) = @_;
    my @col = ();

    for my $r (0..($nrow-1)) {
	push @col, $table[$col_nb-1][$r];
    }
    return @col;
}



################################################################
=pod 

=item col_sum($nrow, $ncol, @table)

Calculate the sum of each column of a table (is applied to the
different types of table used in this class).

Return a vector of the same length as the table width.

=cut
sub col_sum {
    my ($nrow, $ncol, @table) = @_;   
#    die join "\t", $nrow, $ncol, join( " ", @{$matrix[0]});

    warn join("\t", "; Calculating sum per column for a table",$nrow, $ncol),"\n"
	if ($main::verbose > 3);

    my @col_sum = ();
    for my $c (0..($ncol-1)) {
	my $col_sum = 0;
	for my $r (0..($nrow-1)) {
	    $col_sum += $table[$c][$r];
	}
	push @col_sum, $col_sum;
    }
    return(@col_sum);
}


################################################################
=pod 

=item col_max($nrow, $ncol, @table)

Calculate the max of each column of a table (is applied to the
different types of table used in this class).

Return a vector of the same length as the table width.

=cut
sub col_max {
    my ($nrow, $ncol, @table) = @_;

    warn join("\t", "; Calculating max per column",$nrow, $ncol),"\n"
	if ($main::verbose > 3);

    my @col_max = ();
    for my $c (0..($ncol-1)) {
	my @col_values = ();
	for my $r (0..($nrow-1)) {
	    push @col_values, $table[$c][$r];
	}
	my $col_max = &main::checked_max(@col_values);
	push @col_max, $col_max;
    }
    return(@col_max);
}

################################################################
=pod 

=item col_min($nrow, $ncol, @table)

Calculate the min of each column of a table (is applied to the
different types of table used in this class).

Return a vector of the same length as the table width.

=cut
sub col_min {
    my ($nrow, $ncol, @table) = @_;

    warn join("\t", "; Calculating min per column",$nrow, $ncol),"\n"
	if ($main::verbose > 3);

    my @col_min = ();
    for my $c (0..($ncol-1)) {
	my @col_values = ();
	for my $r (0..($nrow-1)) {
	    push @col_values, $table[$c][$r];
	}
	my $col_min = &main::checked_min(@col_values);
	push @col_min, $col_min;
    }
    return(@col_min);
}

################################################################
=pod

=item B<seq_proba($sequence)>

Calculate the probability of each segment of an input sequence. 

The probability of a segment of sequence of lenghth w is the product of the
corrected frequencies.

If the input sequence has length L > w, the return value is a vector of L-w+1
probability values.

=cut

sub seq_proba {
    my ($self, $sequence) = @_;
    my @proba = ();

    my $L = length($sequence);
    my ($nrow, $ncol) = $self->size();

    &RSAT::message::TimeWarn(join("\t", "seq_proba", "sequence length:".$L)) if ($main::verbose >= 5);

    if ($L < $ncol) {
	&RSAT::message::Warning("Sequence length ($L) is shorter than the matrix width ($ncol). Skipped.");
    }

    ## Iterate over sequence segments
    for my $i (0..$L-$ncol) {
	my $segment = substr($sequence, $i, $ncol);
#	my $segment_proba = 1;
#	for my $c (0..($ncol-1)) {
#	my $letter = shift @letters;
#	    my $letter = substr($segment, $c, 1);
#	    my $r = $self->{"alphabet_index"}->{$letter};
#	    my $letter_proba = $self->{"frequencies"}[$c][$r];
#	    $segment_proba *= $letter_proba;
#	}
	my $segment_proba = $self->segment_proba($segment);
	push @proba, $segment_proba;
#	&RSAT::message::Debug("segment proba", $i, $segment, $segment_proba) if ($main::verbose >= 10);
    }

    return @proba;
}



################################################################
=pod 

=item B<segment_proba($segment)>

Calculate the probability of a segment of sequence. The length of the sequence
segment must equal the matrix width.

The probability of a segment of sequence of lenghth w is the product of the
corrected frequencies.

=cut

sub segment_proba {
    my ($self, $segment) = @_;
    
    $segment = lc($segment);
#    return(1);

    my $segment_proba = 1;
    my $seq_len = length($segment);
    my $r;
    for my $c (0..($seq_len-1)) {
	my $letter = substr($segment, $c, 1);
	my  $letter_proba = 0;
	if (defined($self->{"alphabet_index"}->{$letter})) {
	    $r = $self->{"alphabet_index"}->{$letter};
	    $letter_proba = $self->{"frequencies"}[$c][$r];
	} else {
	  if ((lc($letter) eq "n") &&
	      ($self->get_attribute("n_treatment") eq "score")) {
	    $letter_proba = 1;
	  }
	}
	$segment_proba *= $letter_proba;
#	&RSAT::message::Debug("segment_proba", "letter:".$letter, "col:".$c, "row:".$r, "P(letter)=".$letter_proba, "P(segm)=".$segment_proba) if ($main::verbose >= 10);
    }
    
#    &RSAT::message::Debug("segment_proba", $segment, "P(segm)=".$segment_proba) if ($main::verbose >= 10);
    return $segment_proba;
}

################################################################
=pod

=item B<proba_range()>

Return the range (min and max possible values) for a sequence segment
probability. 

The min (max) value is the product of the minimal (maximal) per column
from the matrix of corrrected frequencies.

Usage: my ($proba_min, proba_max)  = $matrix->proba_range();

=cut

sub proba_range {
    my ($self) = @_;
    my $proba_min = 1;
    my $proba_max = 1;

    ## Calculate frequencies if required
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }

    my ($nrow, $ncol) = $self->size();
    my @frequencies = $self->getFrequencies();    

    foreach my $c (0..($ncol-1)) {
	my $col_min = 1;
	my $col_max = 0;
	foreach my $r (0..($nrow-1)) {
	    my $freq = $frequencies[$c][$r];
	    $col_min = &RSAT::stats::min($col_min, $freq);
	    $col_max = &RSAT::stats::max($col_max, $freq);
	}
	$proba_min *= $col_min;
	$proba_max *= $col_max;
    }
    
    $self->set_parameter("min(P(S|M))", $proba_min);
    $self->set_parameter("max(P(S|M))", $proba_max);
    $self->set_parameter("proba_range", $proba_max-$proba_min);
    &RSAT::message::Info(join("\t", "min(P(S|M))", $proba_min)) if ($main::verbose >= 4);
    &RSAT::message::Info(join("\t", "max(P(S|M))", $proba_max)) if ($main::verbose >= 4);
    return ($proba_min, $proba_max);
}


################################################################
=pod

=item B<weight_range()>

Return the range (min and max possible values) for a sequence segment
weight. Attention, these values are only correct for Bernoulli models.

The min (max) value is the sum of the minimal (maximal) per column
from the matrix of weights.

Usage: my ($Wmin, $Wmax, $Wrange)  = $matrix->weight_range();

=cut

sub weight_range {
    my ($self) = @_;
    my $tmp_Wmin = 0;
    my $tmp_Wmax = 0;
    my ($nrow, $ncol) = $self->size();
    my @weights = $self->getWeights();    

    foreach my $c (0..($ncol-1)) {
	my $col_min="NA";
	my $col_max="NA";
	foreach my $r (0..($nrow-1)) {
	    my $weight = "NA";
	    if (defined($weights[$c][$r])) {
		$weight = $weights[$c][$r];
		if ($col_min eq "NA") {
		    $col_min = $weight;
		} else {
		    $col_min = &RSAT::stats::min($col_min, $weight);
		}
		if ($col_max eq "NA") {
		    $col_max = $weight;
		} else {
		    $col_max = &RSAT::stats::max($col_max, $weight);
		}
	    }
	    &RSAT::message::Debug("weight_range", "weight", $c, $r, $weight) if ($main::verbose >= 5);
	}
	$tmp_Wmin += $col_min;
	$tmp_Wmax += $col_max;
	&RSAT::message::Debug("Weights", "column:".$c, "min:".$tmp_Wmin, "max:".$tmp_Wmax, "range:", $tmp_Wmax - $tmp_Wmin) if ($main::verbose >= 5);
    }

    my $tmp_Wrange = $tmp_Wmax-$tmp_Wmin;
    $self->set_parameter("Wmin", $tmp_Wmin);
    $self->set_parameter("Wmax", $tmp_Wmax);
    $self->set_parameter("Wrange", $tmp_Wrange);
    if ($main::verbose >= 3) {
	&RSAT::message::Info(join("\t", "Wmin", $self->get_attribute("Wmin"))) ;
	&RSAT::message::Info(join("\t", "Wmax", $self->get_attribute("Wmax"))) ;
	&RSAT::message::Info(join("\t", "Wrange", $self->get_attribute("Wrange"))) ;
    }

    return ($tmp_Wmin, $tmp_Wmax, $tmp_Wrange);
}


################################################################
=pod

=item B<treat_null_values>

Replace undefined values by 0 in the count matrix.

=cut
sub treat_null_values {
  my ($self) = @_;
  my $nrow = $self->nrow();
  my $ncol = $self->ncol();
  my @matrix = $self->getMatrix();
  for my $c (0..($ncol-1)) {
#    &RSAT::message::Debug ("BEFORE", "col", $c, join("; ", @{$matrix[$c]})) if ($main::verbose >= 10);
    for my $r (0..($nrow-1)) {
      unless (defined($matrix[$c][$r])) {
#	&RSAT::message::Debug("column", $c, "row", $r, "replacing undefined value by 0") if ($main::verbose >= 10);
	$matrix[$c][$r] = 0;
      }
    }
#    &RSAT::message::Debug ("AFTER", "col", $c, join("; ", @{$matrix[$c]})) if ($main::verbose >= 10);
  }
  $self->setMatrix($nrow, $ncol, @matrix);
}


################################################################
=pod

=item B<add_site>

Add a site (sequence) to the matrix and update the count matrix
accordingly.

=cut
sub add_site() {
  my ($self, $site_seq, %args) = @_;
  my $site_id = $args{id} || $site_seq;
  my $score =  $args{score} || 1;

  my @letters = split "|", $site_seq;

  $self->push_attribute("sequences", $site_seq);
  if ($site_id) {
    $self->push_attribute("site_ids", $site_id);
  }

  my @alphabet = $self->getAlphabet();
  ## Index the alphabet
  my %alphabet = ();
  foreach my $l (0..$#alphabet) {
    $alphabet{$alphabet[$l]} = $l;
  }
  
  &RSAT::message::Debug("Adding site", $site_seq, $site_id, "len=".scalar(@letters), "alphabet", join(":", @alphabet)), 
    if ($main::verbose >= 4);
  
  ## Update the count matrix with the new sequence
  foreach my $c (0..$#letters) {
    if (defined($alphabet{$letters[$c]})) {
      my $row = $alphabet{$letters[$c]};
      if (($args{max_score}) &&
	  (defined(${$self->{table}}[$c][$row]))) {
	  ${$self->{table}}[$c][$row] = &RSAT::stats::max($score, ${$self->{table}}[$c][$row]);
      } else {
	${$self->{table}}[$c][$row] += $score;
      }
    } else {
      &RSAT::message::Warning("&RSAT::matrix::add_site()", $site_seq, "Unrecognized character at position", $c, $letters[$c]) 
	if ($main::verbose >= 5);
    }
  }

  ## update the number of columns
  my $ncol = &RSAT::stats::max($self->ncol(), scalar(@letters));
  $self->force_attribute("ncol",  $ncol);

}

################################################################
=pod

=item B<calcTheorScoreDistrib>

Calculate the theoretial score distribution.  The computation is
performed using the algorithm described by Bailey (Bioinformatics,
1999).

By default, the score distribution is computed for the weight
(log-likelihood), but the methods can also be used to calculate the
distribution of other scores (e.g. counts, crude frequencies,
frequencies, ...).

Usage:
 $self->calcTheorScoreDistrib();
 $self->calcTheorScoreDistrib("counts");

=cut
sub calcTheorScoreDistrib {
  my ($self, $score_type) = @_;
  $score_type = $score_type || "weights";

  ################################################################
  ## This parameter drastically affects the speed of computation By
  ## reducing the score to 2 decimals, the nmber of possible scors is
  ## reduced to ~5000 for a typical weight matrix
  ## This prevents the comptation time to increase exponentially with
  ## the matrix width.
  my $score_format = "%.2f";

  my @scores;
  if (lc($score_type) eq "counts") {
    @scores = $self->getMatrix();
  } elsif (lc($score_type) eq "weights") {
    @scores = $self->getWeights();
  } elsif (lc($score_type) eq "crudefrequencies") {
    @scores = $self->getCrudeFrequencies();
  } elsif (lc($score_type) eq "frequencies") {
    @scores = $self->getFrequencies();
  }

  &RSAT::message::TimeWarn("Calculating theoretical distribution of", $score_type, 
			   "matrix", $self->get_attribute("name")) if ($main::verbose >= 2);

  my $nrow = $self->nrow();
  my $ncol = $self->ncol();
  my @alphabet = $self->getAlphabet();
  my %prior = $self->getPrior();

  my %score_proba = ();
  $score_proba{0} = 1; ## Initialize the score probabilities

  ################################################################
  ## Compute the distribution of scores
  for my $c (0..($ncol-1)) {
    my @row = &RSAT::matrix::get_column($c+1, $nrow, @matrix);
    my @row_scores = &RSAT::matrix::get_column($c+1, $nrow, @scores);
    my %current_score_proba = ();
    for my $r (0..($nrow-1)) {
      my $letter = $alphabet[$r];
      my $prior = $prior{$letter};
      my $residue_score = sprintf("${score_format}", $scores[$c][$r]);
      for my $prev_score (keys %score_proba) {
	my $current_score = $prev_score + $residue_score;
	$current_score_proba{$current_score} +=
	  $score_proba{$prev_score}*$prior;
#	&RSAT::message::Debug("col=".$c, "row=".$r, $letter, $prior, $residue_score,
#			      "prev_score",$prev_score,
#			      "current_score", $current_score,
#			     ) if ($main::verbose >= 10);

      }
    }

    &RSAT::message::TimeWarn("calcTheorDistrib()", "column", $c, 
			     "prev scores: ", scalar(keys(%score_proba)), 
			     "current scores:", scalar(keys(%current_score_proba)), 
			    ) if ($main::verbose >= 3);
    %score_proba = %current_score_proba;
  }
  $self->set_hash_attribute($score_type."_proba", %score_proba);
  $self->force_attribute($score_type."_proba_specified", 1);

  ## Compute the cumulative distribution
  my $score_proba_cum = 0;
  my %score_proba_cum = ();
  my @sorted_scores = sort {$a <=> $b} (keys (%score_proba));
  foreach my $score (@sorted_scores) {
    $score_proba_cum += $score_proba{$score};
    $score_proba_cum{$score} = $score_proba_cum;
  }
  $self->set_hash_attribute($score_type."_cum_proba", %score_proba_cum);
  $self->force_attribute($score_type."_cum_proba_specified", 1);

  ## Compute the inverse cumulative distribution
  my $score_proba_inv_cum = 0;
  my %score_proba_inv_cum = ();
  @sorted_scores = sort {$b <=> $a} (keys (%score_proba));
  foreach my $score (@sorted_scores) {
    $score_proba_inv_cum += $score_proba{$score};
    $score_proba_inv_cum{$score} = $score_proba_inv_cum;
  }
  $self->set_hash_attribute($score_type."_inv_cum_proba", %score_proba_inv_cum);
  $self->force_attribute($score_type."_inv_cum_proba_specified", 1);
}


################################################################
=pod

=item getTheorScoreDistrib()

Return the weight matrix

Usage:

=over

=item density function

my %weight_proba = $matrix->getTheorScoreDistrib("weights");

=item cumulative density function (CDF)

my %weight_proba = $matrix->getTheorScoreDistrib("weights", "cum");

=item inverse cumulative density function (iCDF)

my %weight_proba = $matrix->getTheorScoreDistrib("weights", "inv_cum");

=back

=cut
sub getTheorScoreDistrib {
  my ($self, $score_type, $distrib_type) = @_;

  $score_type = $score_type || "weights";
  my $distrib_key = $score_type;
  if ($distrib_type) {
    $distrib_key .= "_".$distrib_type;
  }
  $distrib_key .= "_proba";

  ## Check if the distribution has aleady been calculated
  unless ($self->get_attribute($distrib_key."_specified")) {
    $self->calcTheorScoreDistrib($score_type);
  }

  &RSAT::message::Info("Returning distribution", $distrib_key) if ($main::verbose >= 3);
  return %{$self->{$distrib_key}};
}

return 1;


__END__

=pod

=back

