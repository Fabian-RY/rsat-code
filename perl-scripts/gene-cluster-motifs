#!/usr/bin/perl
############################################################
#
# $Id: gene-cluster-motifs,v 1.5 2000/12/29 21:21:13 jvanheld Exp $
#
# Time-stamp: <2000-11-12 10:08:47 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
  push (@INC, "$`lib/");
}
require "RSA.lib.pl";
require "RSA.cgi.lib.pl";
require "RSA.classes.pl";

###read parameters
if ($#ARGV < 0) {
  die ("Usage : multiple-family-analysis -org organism -fam family_file \n", 
       "\t[-noup] [-nocalc] [-nosynt] [-v]\n");
}
&ReadArguments;


############################### check parameters ###############################

### family file ###
if ($family_file eq "") {
  die "Error: you should specify a family file\n";  
} 

### organism ###
if ($organism eq "") {
  die "Error: you should specify an organism\n$supported_organisms\n";  
} 
unless ($supported_organism{$organism}) {
  die ("Error: organism $organism is not supported\n",
       "Supported organisms:\n$supported_organisms\n");
}
&InitParameters;


### read gene name and identifiers
warn "; Reading ORF information ...\n" 
    if ($verbose);
&ReadOrfPositions($organism);
&ReadSynonyms($organism);

&ReadKnownSites;
&ReadSiteLibrary;

&ReadFamilies;

### some verbose
if ($verbose) {
  print "; multiple-family analysis\n";
  printf "; families     \t%d\n", $#families + 1;
  foreach $family (@families) {
    printf ";\t%s\n", $family;
  }
  printf "; upstream region\n";
  printf ";\tstrands\t%s\n", $strands;
  printf ";\tfrom\t%d\n", $from;
  printf ";\tto\t%d\n", $to;
  printf ";\tsize\t%d\n", $size;
  printf "; sig threshold\t%.1f\n", $th;
  printf "; dyad type    \t%s\n", $type;
  printf "; exp freq     \t%s\n", $exp;
}

### write composition of the families in the separated directories
&SetFileNames;

### initialize one directory for each family
foreach $family_name(@families) {
  $dir = "${family_name}/";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }
  open FAM, ">$family{$family_name}->{family_file}" ||
      die "Error: cannot write family file $family{$family_name}->{family_file}\n";
  foreach $id (@{$family{$family_name}->{members}}) {
    print FAM "$id\t$name{$id}\n";
    
  }
  close FAM;
}

### perform analysis
&AnalyzeFamilies unless ($no_calc);
&SyntheticTable unless ($no_synt);

if ($verbose) {
  $done_date = `date`;
  print ";Job started\t$start_date";
  print ";Job done\t", `date`;
}
exit(0);

sub SetFileNames {
  $sp = "0-$max_sp";
  $dyad_options = "-v ";
  $dyad_options .= "-sort ";
  $dyad_options .= "-${strands} ";
  $dyad_options .= "-type $type ";
  $dyad_options .= "-noov " if ($noov);
  $dyad_options .= "-l $dyad_element_length ";
  $dyad_options .= "-thosig $th ";
  $dyad_options .= "-sp $sp ";
  if ($exp eq "ncf") {
    $dyad_options .= "-ncf ";
    $dyad_options .= "-org $organism ";
  } elsif ($exp eq "mncf") {
    $dyad_options .= "-mncf ";
    $dyad_options .= "-org $organism ";
  }
  
  $dyad_suffix = "_dyads";
  $dyad_suffix .= "_up${seq_length}";
  $dyad_suffix .= "_l${dyad_element_length}";
  $dyad_suffix .= "_sp${sp}";
  $dyad_suffix .= "_${strands}";
  $dyad_suffix .= "_${type}";
  $dyad_suffix .= "_sig${th}";
  if ($noov) {
    $dyad_suffix .= "_noov";
  } else {
    $dyad_suffix .= "_ov";
  }
  if ($exp eq "ncf") {
    $dyad_suffix .= "_ncf";
  } elsif ($exp eq "mncf") {
    $dyad_suffix .= "_mncf";
  }

  foreach $family_name (@families) {
    $family{$family_name}->{family_file} = "$family_name/${family_name}.fam";
    $family{$family_name}->{known_site_file} = "$family_name/${family_name}_known_sites";
    $family{$family_name}->{seq_file} = "$family_name/${family_name}_up${seq_length}.wc";
    
    $family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/${family_name}_oligos_up${seq_length}_${min_oligo_length}-${max_oligo_length}nt_${strands}_sig${th}";
    $family{$family_name}->{oligo_file} .= "_noov" if ($noov);
    $family{$family_name}->{oligo_assembly_file} = $family{$family_name}->{oligo_file}."_contigs";
    
    
    $family{$family_name}->{dyad_file} = "$family_name/dyads_${family_name}/$family_name".$dyad_suffix;
    $family{$family_name}->{dyad_assembly_file} = $family{$family_name}->{dyad_file}."_contigs";
    $family{$family_name}->{ft_file} = $family{$family_name}->{dyad_file}.".ft";
    $family{$family_name}->{fmap_file} = $family{$family_name}->{dyad_file}.".gif";
    $family{$family_name}->{htmap_file} = $family{$family_name}->{dyad_file}.".html";
  }  
}

################### SUBROUTINE DEFINITION ###################"

sub OldReadFamily {
  print "\n; Reading family\t$family_name\n" if ($verbose);
  unless (-r $family{$family_name}->{family_file}) {
    die "Error : family $family_name: cannot read family file '$family{$family_name}->{family_file}'\n";
  }
  
  @{$family{$family_name}->{members}} = {};
#  @{$member{$family_name}} = ();
  
  open FAM, $family{$family_name}->{family_file} || die "Error : cannot read file $family{$family_name}->{family_file}\n" ;
  while (<FAM>) {
    next if (/^;/);
    next unless (/\S/);
    chomp;
    @fields = split /\s+/;
    $query = uc($fields[0]);
    $id = $orf_id{$query};
    if ($id eq "") {
      print STDERR "\t;WARNING ! $query unknown gene name \n";
    } else {
      push @{$family{$family_name}->{members}}, $id;
#      push @{$member{$family_name}}, $id;
      print "\t$query\t$id\t$name{$id}\n" if ($verbose);
    }
  }
  close FAM;
  
}

sub OldUpstreamSequences {
  warn "\n; Generating upstream sequences for family $family_name\n" if ($verbose);
  #  unless (-e  $family{$family_name}->{seq_file}) {
  system "rm -f $family{$family_name}->{seq_file} "; 
  foreach $id ( @{$family{$family_name}->{members}}) {
    print "\t$id\t$name{$id}\n" if ($verbose);
    $command =  "grep -i $id $upstream_sequence_file | replace-string -query '$id' -by '$name{$id}' >> $family{$family_name}->{seq_file}";
    system $command;
  }
}

sub UpstreamSequences {
  warn "; Generating upstream sequences for family $family_name\n" if ($verbose);
  $command = "retrieve-seq -type upstream -org $organism";
  $command .= " -i $family{$family_name}->{family_file}";
  $command .= " -o $family{$family_name}->{seq_file}";
  $command .= " -from $from -to $to ";
  $command .= " -format $seq_format";
  warn "$command\n" if ($verbose > 1);
  system $command;
}



### oligo-analysis
sub OligoAnalysis {
  $dir = "${family_name}/oligos_${family_name}";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }
  die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
  
  
  system "echo '' > $family{$family_name}->{oligo_file}";
  
  for $oligo_length ($min_oligo_length..$max_oligo_length) {
    $oligo_options = "-v ";
    $oligo_options .= "-sort ";
    $oligo_options .= "-${strands} ";
    $oligo_options .= "-l $oligo_length ";
    $oligo_options .= "-thosig $th ";
    $oligo_options .= "-org $organism ";
    $oligo_options .= "-ncf ";
#    $oligo_options .= "-expfreq $RSA/data/yeast/oligo-frequencies/${oligo_length}nt.non-coding.freq ";
    $oligo_options .= "-return occ,proba,zscore ";
    $oligo_options .= "-noov " if ($noov);
    
    $oligo_suffix = "_oligos";
    $oligo_suffix .= "_up${seq_length}";
    $oligo_suffix .= "_${oligo_length}nt";
    $oligo_suffix .= "_${strands}";
    $oligo_suffix .= "_sig${th}";
    $oligo_suffix .= "_noov" if ($noov);
    
    $oligo_file = "$family_name/oligos_${family_name}/$family_name".$oligo_suffix;    
    $command = "oligo-analysis -i $family{$family_name}->{seq_file} -format $seq_format -o $oligo_file $oligo_options";
    
    warn "\n$command\n" if ($verbose > 1);
    system $command;
    
    system "cat $oligo_file | grep -v ';' >> $family{$family_name}->{oligo_file}";
  }
  ### fragment assembly
  $fmap_file = $family{$family_name}->{oligo_file}.".gif";
  $htmap_file = $family{$family_name}->{oligo_file}.".html";
  
  $command = "pattern-assembly -i $family{$family_name}->{oligo_file} -sc 7 -${strands} -v -o $family{$family_name}->{oligo_assembly_file} -maxfl 1 -maxpat 200 ";
  print "\n$command\n" if ($verbose);
  system $command;
  
  ### feature-map for oligo-analysis
  $origin = -$from + 1;
  $command = "dna-pattern -i $family{$family_name}->{seq_file} -format $seq_format -pl $family{$family_name}->{oligo_file} -origin $origin -sc 7 -N 4 ";
  $command .= " | features-from-dnapat ";
  $command .= " | feature-map -scalebar -scalestep 50 -legend -from $from -to $to -o $fmap_file -scorethick -htmap > $htmap_file ";
  
  print "\n$command\n" if ($verbose);
  system $command;
}

### dyad analysis
sub DyadAnalysis {
  $dir = "${family_name}/dyads_${family_name}";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }
  die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
  $command = "dyad-analysis -i $family{$family_name}->{seq_file} -format $seq_format -o $family{$family_name}->{dyad_file} $dyad_options";
  print "\n$command\n" if ($verbose);
  system $command;
  
  ### fragment assembly
  $command = "pattern-assembly -v -i $family{$family_name}->{dyad_file} -o $family{$family_name}->{dyad_assembly_file} -$strands -maxfl 2 -sc 7 -maxpat 200 ";
  print "\n$command\n" if ($verbose);
  system $command;

  ### feature-maps
  &DrawFeatureMaps;
}

### read known known_site for each family
sub ReadKnownSites {
  %known_site = ();
  %known_site_source = ();
  $known_site_file = "known-consensus";
  if (-e $known_site_file) {
    open KNOWN_SITE, $known_site_file;
    while (<KNOWN_SITE>) {
      next if (/^;/);
      next unless (/\S/);
      chomp;
      @fields = split "\t";
      $family_name = $fields[0];
      $source = $fields[2];
      $known_site = uc($fields[1]);
      #$known_site = uc(&compress_pattern($known_site,"n"));
      $known_site =~ s/N/n/g;
      push @{$known_site{$family_name}}, $known_site;
      push @{$known_site_source{$family_name}}, $source;
    }
    close KNOWN_SITE;
  }
}
  
sub ReadSiteLibrary {
  @site_library = ();
  $library_file = "known_sites.tab";
  if (-e $library_file) {
    open LIBRARY, $library_file;
    while (<LIBRARY>) {
      next if (/^;/);
      next unless (/\S/);
      chomp;
      my @fields = split "\t";
      my $source = $fields[2] || $library_file;
      my $id = uc($fields[1]);
      my $sequence = uc($fields[0]);
      $sequence =~ s/N/n/g;
      
      $pattern = RSA::pattern->new(id=>$id,
				   sequence=>$sequence,
				   source=>source);
      push @site_library, $pattern;
    }
    close LIBRARY;
  }
}
  
### build a synthetic table ###
sub SyntheticTable {
  print "; Generating synthetic table\n" if ($verbose);
  $dir = "synthetic_tables";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }  
  
  ### synthesize the results of all families into a single file
  
  ### headers
  $row = 0;
  $row{family} = $row++;
  $row{genes} = $row++;
  $row{known} = $row++;
  $row{oligo} = $row++;
  #$row{oligo_rev} = $row++;
  #$row{oligo_sc} = $row++;
  $row{dyad} = $row++;
  #$row{dyad_rev} = $row++;
  #$row{dyad_sc} = $row++;
  while (($header,$row) = each %row) {
    $table[$row][0] = "<B>$header</B>";
  }
  $col = 0;

  #$table[$r][$c] = "family";
  #$table[$r][$c] = "genes";
  #$table[$r][$c] = "known sites (experimental)";
  #$table[$r][$c] = "oligo";
  #$table[$r][$c] = "reverse oligo";
  #$table[$r][$c] = "oligo score";
  #$table[$r][$c] = "dyad";
  #$table[$r][$c] = "reverse dyad";
  #$table[$r][$c] = "dyad score";

  foreach $family_name (@families) {
    $col++;
#    &ReadFamily;
    
    ### check directory
    $dir = "${family_name}/dyads_${family_name}";
    unless (-d $dir) {
      print "Error: cannot find directory $dir\n";
    }
    
    ### family name
    $table[$row{family}][$col] = "<B>$family_name</B>";

    ### list of genes
    $table[$row{genes}][$col] = join " ", @{$family{$family_name}->{members}};
    
    ### known patterns
    $table[$row{known}][$col] = "";
    for $c (0..$#{$known_site{$family_name}}) {
      $table[$row{known}][$col] .= ${known_site{$family_name}}[$c];
      $table[$row{known}][$col] .= "<BR>(".${known_site_source{$family_name}}[$c].")" if (${known_site_source{$family_name}}[$c]);
      $table[$row{known}][$col] .= "<P>";
    }
    
    #### oligo-analysis
    open OLIGOS, "$family{$family_name}->{oligo_assembly_file}";
    print "extracting info from\t$family{$family_name}->{oligo_assembly_file}\n" if ($verbose);
    undef @patterns;
    undef @sorted_patterns;
    undef %rc;
    undef %score;
    undef %type;
    while (<OLIGOS>) {
      chomp;
      next if (/^;/);
      next unless (/\S/);
      if ((/contig/) || (/isol/)) {
	@fields = split "\t";
	my $sequence = uc($fields[0]);
	$pattern = new RSA::pattern(sequence=>$sequence);
	push @patterns, $pattern;
	$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
	$score{$pattern} = $fields[2];
	$type{$pattern} = $fields[3];
      }
    }
    @sorted_patterns = sort { $score{$b} <=> $score{$a} } @patterns;
    $table[$row{oligo}][$col] = "<TABLE>\n";
    $table[$row{oligo}][$col] .= "<TR>\n";

    ### print oligo sequence
    $table[$row{oligo}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= uc($sorted_patterns[$p]->get_attribute("sequence")); 
      $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{oligo}][$col] .= "</TD>\n";

    ### print reverse complementary oligo
    $table[$row{oligo}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= uc($rc{$sorted_patterns[$p]});
      $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{oligo}][$col] .= "</TD>\n";

    ### print oligo score
    $table[$row{oligo}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= "$score{$sorted_patterns[$p]}";
      $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{oligo}][$col] .= "</TD>\n";

    ### print matching patterns
    $table[$row{oligo}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      my @matches = ();
      foreach $site (@site_library) {
	if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
	    ($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
	  #my $match = $site->get_attribute("sequence");
	  my $match = $site->get_id();
	  push @matches, $match;
	}
      }
      $table[$row{oligo}][$col] .= join(";",@matches);
      #$table[$row{oligo}][$col] .= "hello";
      $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{oligo}][$col] .= "</TD>\n";
    
    $table[$row{oligo}][$col] .= "</TR>\n";
    $table[$row{oligo}][$col] .= "</TABLE>\n";
    close OLIGOS;

    ### dyad analysis
    open DYADS, "$family{$family_name}->{dyad_assembly_file}";
    print "extracting info from\t$family{$family_name}->{dyad_assembly_file}\n" if ($verbose);
    undef @patterns;
    undef @sorted_patterns;
    undef %rc;
    undef %score;
    undef %type;
    while (<DYADS>) {
      chomp;
      next if (/^;/);
      next unless (/\S/);
      if ((/contig/) || (/isol/)) {
	@fields = split "\t";
	my $sequence = $fields[0];
	$pattern = new RSA::pattern(sequence=>$sequence);
	push @patterns, $pattern;
	$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
	$score{$pattern} = $fields[2];
	$type{$pattern} = $fields[3];
      }
    }
    @sorted_patterns = sort {$score{$b} <=> $score{$a}} @patterns;
    $table[$row{dyad}][$col] = "<TABLE>\n";
    $table[$row{dyad}][$col] .= "<TR>\n";

    ### print dyad sequence
    $table[$row{dyad}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $sequence = $sorted_patterns[$p]->get_attribute("sequence");
      $compressed = uc(&compress_pattern($sequence, "n"));
      $compressed =~ s/N/n/g;
      $table[$row{dyad}][$col] .= $compressed;
      $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{dyad}][$col] .= "</TD>\n";

    ### reverse complementary dyad
    $table[$row{dyad}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $compressed = uc(&compress_pattern($rc{$sorted_patterns[$p]},"n"));
      $compressed =~ s/N/n/g;
      $table[$row{dyad}][$col] .= $compressed;
      $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{dyad}][$col] .= "</TD>\n";

    ### dyad scores
    $table[$row{dyad}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{dyad}][$col] .= "$score{$sorted_patterns[$p]}";
      $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{dyad}][$col] .= "</TD>\n";

    ### print matching patterns
    $table[$row{dyad}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      my @matches = ();
      foreach $site (@site_library) {
	if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
	    ($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
	  #my $match = $site->get_attribute("sequence");
	  my $match = $site->get_id();
	  push @matches, $match;
	}
      }
      $table[$row{dyad}][$col] .= join(";",@matches);
      $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{dyad}][$col] .= "</TD>\n";
    
    $table[$row{dyad}][$col] .= "</TR>\n";
    $table[$row{dyad}][$col] .= "</TABLE>\n";
    close DYADS;
  }
  
  $table_file = "synthetic_tables/table".$dyad_suffix;
  $table_file .= "_tr" if ($transpose);
  open TABLE, "> ${table_file}.html";
  print TABLE "<HTML><BODY>\n";
  print TABLE "<H1>$table_file</H1>\n";
    
  print TABLE "<TABLE BORDER=1>\n";

  if ($transpose) {
    foreach $r (0..8) {
      print TABLE "<TR>\n";
      foreach $c (0..$col) {
	print TABLE "<TD>", $table[$r][$c], "</TD>\n";
      }
      print TABLE "</TR>\n";
    }
  } else {
    foreach $c (0..$col) {
      print TABLE "<TR>\n";
      foreach $r (0..8) {
	print TABLE "<TD>", $table[$r][$c], "</TD>\n";
      }
      print TABLE "</TR>\n";
    }
  }

  print TABLE "</TABLE>\n";
  print TABLE "<HR>", &AlphaDate;
  print TABLE "</BODY>\n";
  print TABLE "</HTML>\n";
  close TABLE;
  chdir "synthetic_tables";
#  system "html_dir.csh > index.html";
  chdir "../";
}

sub DrawFeatureMaps {
  $origin = -$from + 1;
  $command = "dna-pattern -pl $family{$family_name}->{dyad_file} -format $seq_format -i $family{$family_name}->{seq_file}  -sc 7 -origin $origin -N 4 ";
  $command .= "| features-from-dnapat -o $family{$family_name}->{ft_file} ";
  $command .= "; feature-map -i $family{$family_name}->{ft_file} -o $family{$family_name}->{fmap_file} ";;
  $command .= "-from $from -to $to ";
  $command .= "-legend ";
  $command .= "-scalebar -scalestep 50 ";
  $command .= "-scorethick ";
  $command .= "-mlen 520 ";
  $command .= "-title '${family_name}$dyad_suffix' ";
  $command .= "-htmap >  $family{$family_name}->{htmap_file}";
  #  $command .= " ;  xv -o $family{$family_name}->{fmap_file} &";
  print "\n$command\n" if ($verbose);
  system $command;
}


#### initialization
sub InitParameters {
  $from = -400 unless defined($from);
  $to = 0 unless defined($to);
  $seq_length = abs($to - $from) + 1;
#  $upstream_sequence_file = "$RSA//data/yeast/sequences/all_up${seq_length}.wc";
  $seq_format = "wc";
  
  $min_oligo_length = 6;
  $max_oligo_length = 6;
  $min_matching_score = 4;
  
  $dyad_element_length = 3;
  
  if (defined($force{type})) {
    $type = $force{type}; ### force
  } else {
    $type = "any";
  }
  if (defined($force{strands})) {
    $strands = $force{strands}; ### force
  } else {
    $strands = "2str";
  }
  if (defined($force{exp})) {
    $exp = $force{exp}; ### force
  } else {
    $exp = "ncf";
  }
  if (&IsReal($force{th})) {
    $th = $force{th}; ### force
  } elsif ($#families > 0) {
    $th = &round(10*abs(log($#families + 1)/log(10)))/10;
  } else {
    $th = 0;
  } 
  $noov = 1;

  $max_sp = 16;
  $start_date = `date`;

}

    
sub AnalyzeFamilies {
  print "; Analyzing family $family_name\t", `date` if ($verbose);
  foreach $family_name (@families) {
#    &ReadFamily;
    
    ### retrieve upstream sequences
    &UpstreamSequences unless ($no_up);
    
    ### oligo-analysis
    &OligoAnalysis unless ($no_oligo);

    ### dyad analysis
    &DyadAnalysis unless ($no_dyads);

    ### delete upstream sequence file
#    system "rm $family{$family_name}->{seq_file}";
  }
}


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	multiple-family-analysis

        1999 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        multiple-family-analysis [-i inputfile] [-o outputfile] [-v]

DESCRIPTION
	Runs a combination of programs in order to discover significant
	patterns in the upstream regions of several gene families.

	This script is a way to auto;atize the systematic analysis of
	multiple clusters of co-regulated genes, such as those
	obtained with DNA chip experiments.

	The program reads the composition of several families in a
	single text file, then executes different program discovery
	programs, and generates a summary report.

	Results are subdifided in directories created on the fly, one
	directory per family plus one summary directory.
	
OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-fam	family file
	-org	organism
	-from	upstream region left limit
	-to	upstream region right limit
	-1str   strand-sensitive analysis
	-2str   strand-insensitive analysis
FILE FORMAT
    FAMILY FILE
	The family file specifies the co;position of several gene families.
	It is a text file containing 2 tab-separated columns.
	col 1:	gene name (or ID)
	col 2: family name
	
	Lines starting with a semicolumn (;) are ignored, allowing to
	document the family files with comments..
	
	Example
		; genes responding to Phosphate stress
		pho5	PHO
		pho8	PHO
		; genes responding to nitrogen starvation
		DAL5    NIT
		GAP1    NIT
		...
HOW TO PROCEED
    1) create a directory for the set of families

    2) witin this directory, create a text file contaning the
       description of family composition, as described above
    
    3) run the command

       multiple-family-analysis -orf organism -fam family_file \
           -v -from -200 -to 49

    4) Open Netscape and locate the directory.  There is one folder
       per family. 

       Browse each folder, and pay a special attention to the files
       with extension .html.  These files contain a dynamic
       feature-map. By positioning the cursor above one feature, you
       can see the corresponding information at the bottom of the
       Netscape window.

    5) There is also a folder with summary tables, one table for each
       set of conditions that has been tested (threshold, upstream
       region limits, ...).


End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
multiple-family-analysis options
--------------------------------
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-fam	family file
	-org	organism
	-from	upstream region left limit
	-to	upstream region right limit
	-1str   strand-sensitive analysis
	-2str   strand-insensitive analysis
End_short_help
  close HELP;
  exit;
}


sub ReadArguments {
#### read arguments ####
  foreach my $a (0..$#ARGV) {
    ### verbose ###
    if ($ARGV[$a] eq "-v") {
      $verbose = 1;
    } elsif ($ARGV[$a] eq "-vv") {
      $verbose = 2;
    
      ### detailed help
    } elsif ($ARGV[$a] eq "-h") {
      &PrintHelp;
      
      ### list of options
    } elsif ($ARGV[$a] eq "-help") {
      &PrintOptions;
      
      ### family file
    } elsif ($ARGV[$a] eq "-fam") {
      $family_file = $ARGV[$a+1];

      ### upstream sequence lmits
    } elsif (($ARGV[$a] eq "-from") &&
	     (&IsInteger($ARGV[$a+1]))) {
      $from = $ARGV[$a+1];
    } elsif (($ARGV[$a] eq "-to") &&
	     (&IsInteger($ARGV[$a+1]))){
      $to = $ARGV[$a+1];

      ### strands 
    } elsif ($ARGV[$a] eq "-1str") {
      $force{strands} = "1str";
    } elsif ($ARGV[$a] eq "-2str") {
      $force{strands} = "2str";

      ### organism
    } elsif ($ARGV[$a] eq "-org") {
      $organism = $ARGV[$a+1];

      #### inactivate some tasks
      
      ### inactivate upstream sequence retrieval
    } elsif ($ARGV[$a] eq "-noup") {
      $no_up = 1;

      ### inactivate synthetic table
    } elsif ($ARGV[$a] eq "-nosynt") {
      $no_synt = 1;

      ### inactivate calculations
    } elsif ($ARGV[$a] eq "-nocalc") {
      $no_calc = 1;

      ### inactivate oligo-analysis
    } elsif ($ARGV[$a] =~ /-nooligo/) {
      $no_oligo = 1;

      ### inactivate dyad-analysis
    } elsif ($ARGV[$a] =~ /-nodyads/) {
      $no_dyads = 1;

      
    } elsif ($ARGV[$a] =~ /^-transp/) {
      $transpose = 1;

    } elsif ($ARGV[$a] =~ /^-th/) {
      $force{th} = $ARGV[$a+1];

    } elsif ($ARGV[$a] =~ /^-type/) {
      $force{type} = $ARGV[$a+1];

    } elsif ($ARGV[$a] =~ /^-exp/) {
      $force{exp} = $ARGV[$a+1];
    }
  }
}



sub OldReadFamilies {
  ### read family list
  open FAM, "$family_file" || die "Error: cannot open family file $family_file\n";
  while (<FAM>) {
    next if (/^;/);
    next unless (/\S/);
    chomp;
    @fields = split;
    $family_name = shift @fields;
    push @families, $family_name;
    @{$family{$family_name}->{members}} = @fields;
  }
  close FAM;
}


sub ReadFamilies {
  print "\n; Reading family file\t$family_file\n" 
      if ($verbose);
  unless (-r $family_file) {
    die "Error : cannot read family file $family_file\n";
  }
  
  open FAM, $family_file || 
      die "Error : cannot read file $family{$family_name}->{family_file}\n" ;
  $line = 0;
  while (<FAM>) {
    $line++;
    next if (/^;/);
    next unless (/\S/);
    chomp;
    @fields = split /\s+/;

    ### family name
    $family_name = uc($fields[1]);
    unless ($family_name =~ /\S/) {
      warn ("Error family file $family_file line $line\t",
	    "family not specified\n");
      next;
    }
    
    ### gene name or ID
    $query = uc($fields[0]);
    unless ($query =~ /\S/) {
      warn ("Error family file $family_file line $line\t",
	    "gene not specified\n");
      next;
    }

#    while (($key,$value) = each %orf_id) {
#      print "$key\t$value\n";
#    }
    ### identify the gene
    $id = $orf_id{$query};
    if ($id eq "") {
      print STDERR "\t;WARNING ! $query unknown gene name \n";
    } else {
      push @{$family{$family_name}->{members}}, $id;
      print "\t$family_name\t$query\t$id\t$name{$id}\n" 
	  if ($verbose > 1);
    }
    
  }
  close FAM;

  @families = keys %family;
}
