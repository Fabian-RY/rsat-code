#!/usr/bin/perl -w
############################################################
#
# $Id: compare-graphs,v 1.15 2007/04/03 10:19:57 rsat Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

compare-graphs

=head1 DESCRIPTION

Computes the intersection, the union or the difference of two graphs.
In case more than one edge exist between two nodes, the program removes one of those.

=head1 AUTHORS

Gilles Vanderstocken <gvdstock@ulb.ac.be>

Sylvain Brohee <sylvain@scmbb.ulb.ac.be>

=head1 CATEGORY

util

=head1 USAGE
    
compare-graphs -Q query_graph_file -R reference_graph_file -return intersection|difference|union [-out_format gml|dot|tab] [-outweight Q|R|sum|mean|mean.g|min|max|Q::R] [-null value] [-scol_R #] [-tcol_R #] [-wcol_R #] [-scol_Q #] [-tcol_Q #] [-wcol_Q #] [-in_format_R tab|gml] [-in_format_Q tab|gml] [-o output_file] [-v #] 

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph2;


################################################################
## Main package
package main;
{

    ################################################################
    ## Initialise parameters
    my $start_time = &AlphaDate();


    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
    $main::out = STDOUT;
    
    ## Input formats
    local $input_format_R = "tab";
    local $input_format_Q = "tab";
    
    %supported_input_format =(
	tab=>1,
	gml=>1
    );
    
    $supported_input_formats = join (",", keys %supported_input_format);
    
    local $source_col_R = 1;
    local $target_col_R = 2;
    local $weight_col_R = 0;
    local $source_col_Q = 1;
    local $target_col_Q = 2;
    local $weight_col_Q = 0;

    ## Output formats
    local $output_format = "tab";
    %supported_output_format =(
			       dot=>1,
			       gml=>1,
			       tab=>1

    );
    
    $supported_output_formats = join (",", keys %supported_output_format);
    
    ## Supported return options
    local $return_format = "";
    %supported_return_format =(
      intersection=>1,
      union=>1,
      difference=>1
    );
    $supported_return_formats = join (",", keys %supported_return_format);
   
    $directed = 0;
    
    ## Supported outweight options
    local $outweight ="";
    %supported_outweight =(
      "Q"=>1,
      "R"=>1,
      "sum"=>1,
      "mean"=>1,
      "mean.g"=>1,
      "min"=>1,
      "max"=>1,
      "Q::R"=>1
    );
    $supported_outweight = join (",", keys %supported_outweight);
    
    # Defaut undefined value
    $nullvalue = "<NULL>";
    
    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values
    if (!exists($main::infile{graph_R}) || !exists($main::infile{graph_Q})) {
      &RSAT::error::FatalError("You must specify two graph file");
    }
    my $error = "0";
    if (!-e ($main::infile{graph_R}) || -z ($main::infile{graph_R})) {
      $error = ("The file $main::infile{graph_R} does not exist or is not valid\n");
    }
    if (!-e ($main::infile{graph_Q}) || -z ($main::infile{graph_Q})) {
      $error .= ("\tThe file $main::infile{graph_Q} does not exist or is not valid");
    }
    if ($error ne 0){
      &RSAT::error::FatalError("$error");
    }
    if ($return_format eq "") {
      &RSAT::error::FatalError("You must specify a return format : $supported_return_formats");
    }
    if ($outweight eq "") {
      &RSAT::error::FatalError("You must specify a outweight option : $supported_outweight");
    }
    ################################################################
    ## Open output stream
    $main::out = &OpenOutputFile($main::outfile{output});

    ################################################################
    ## Read and load input
    my $graph1 = new RSAT::Graph2;
    my $graph2 = new RSAT::Graph2;
    $graph1->graph_from_text($input_format_R, $main::infile{graph_R}, $source_col_R, $target_col_R, $weight_col_R);
    $graph2->graph_from_text($input_format_Q, $main::infile{graph_Q}, $source_col_Q, $target_col_Q, $weight_col_Q);
    
    ## As it appeared quite difficult to work with graphs having more than one edge between two
    ## nodes, we decided to remove any duplicated edges.
    
    $graph1->remove_duplicated_arcs($directed);
    $graph2->remove_duplicated_arcs($directed);
    
    ################################################################
    ## Print verbose
    &Verbose() if ($main::verbose);

    
    ########################################################################""
    ## Calculation of the number of common and not common arcs and nodes

    my ($nodes_graph1, $arcs_graph1) = $graph1->properties;
    my ($nodes_graph2, $arcs_graph2) = $graph2->properties;
    my ($common) = &in_common($graph1, $graph2);
    my $graph1_only_arc = $arcs_graph1 - $common;
    my $graph2_only_arc = $arcs_graph2 - $common;
    my $message = "Intersection info\n";
    $message = (join("\t",$main::infile{graph_R},$nodes_graph1,"node(s) and",$arcs_graph1,"arc(s)\n"));
    $message .= ";\t".(join("\t",$main::infile{graph_Q},$nodes_graph2,"node(s) and",$arcs_graph2,"arc(s)\n"));
    $message .= ";\t"."$common\t"."unique arcs in common\n";
    $message .= ";\t".$graph1_only_arc."\tarcs of $main::infile{graph_R} are not in $main::infile{graph_Q}\n";
    $message .= ";\t".$graph2_only_arc."\tarcs of $main::infile{graph_Q} are not in $main::infile{graph_R}\n";
    if ($main::verbose >= 1){  
      print $main::out ";\t$message";
      unless ($main::out eq "STDOUT") {
        &RSAT::message::Info("$message");
      }
    }
    ################################################################
    ## Execute the command
    
    my $return_graph;
    if ($return_format eq "intersection") {
      $return_graph = &intersect($graph1, $graph2);
    } elsif ($return_format eq "union") {
      $return_graph = &union($graph1, $graph2);
    } elsif ($return_format eq "difference") {
      $return_graph = &difference($graph1, $graph2);
    }
    
    ################################################################
    ## Print output
    print $main::out $return_graph->to_text($output_format);
    
    ################################################################
    ## Finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }
    
     
    ################################################################
    ## Close output stream
    close $main::out if ($main::outfile{output});
    
    
    exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help 
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
    my $arg;
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    while (scalar(@arguments) >= 1) {
      $arg = shift (@arguments);
	## Verbosity
=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }

	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();

	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Input file 1
=pod

=item B<-Q reference_graph_input_file>

First graph file

=cut
	} elsif ($arg eq "-R") {
	    $main::infile{graph_R} = shift(@arguments);

	    	    ## Input file 2
=pod

=item B<-R query_graph_input_file>

Second graph file

=cut
	} elsif ($arg eq "-Q") {
	    $main::infile{graph_Q} = shift(@arguments);
	
	    	    ## Directed option
=pod

=item B<-directed>

Indicates whether the graphs must be considered as directed, i.e., an edge 
from node A to node B is different from an edge from B to A.

=cut
	    	    
	} elsif ($arg eq "-directed") {
	    $directed = 1;

	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);

	    	    
	    ### Input format  
=pod

=item B<-in_format_R input_format>

Input format of reference graph. Supported: tab,gml

=cut
	} elsif ($arg eq "-in_format_R") {
	    $input_format_R = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format_R});

=pod

=item B<-in_format_Q input_format>

Input format of query graph. Supported: tab,gml

=cut
	} elsif ($arg eq "-in_format_Q") {
	    $input_format_Q = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format_Q});		


	    ### return  
=pod

=item B<-return return>

return : intersection , union or difference

=cut
	} elsif ($arg eq "-return") {
	    $return_format = shift(@arguments);
	    &RSAT::error::FatalError("$return_format\tInvalid input format. Supported: $supported_return_formats")
		unless ($supported_return_format{$return_format});


			    
	    ## Outweight option
=pod

=item B<-outweight>

Label or weight of the arc

supported : Q, R, sum, mean, mean.g, min, max, Q::R 

=item I<Q> : weight of the query graph

=item I<R> : weight of the reference graph

=item I<sum> : sum between the weight of the two graphs

=item I<mean> : mean between the weight of the two graphs

=item I<mean.g> : geometrical mean between the weight of the two graphs

=item I<min> : minimum weight

=item I<max> : maximum weight

=item I<Q::R> : weight of the two graphs



=cut
	} elsif ($arg eq "-outweight") {
	    $outweight = shift(@arguments);
	    &RSAT::error::FatalError("$outweight\tInvalid outweight option. Supported: $supported_outweight")
		unless ($supported_outweight{$outweight});
		
	    ### Output format  
=pod

=item B<-out_format format>

Output format. Supported: tab, dot, gml

=cut 
	} elsif ($arg eq "-out_format") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});

	    ### NULL Value
=pod

=item B<-null value>

When the arc label between two nodes is non computable, the null value appears. Default value is <NULL> when is not specified.

=cut 
	} elsif ($arg eq "-null") {
	    $nullvalue = shift(@arguments);
# 	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
# 		unless ($supported_output_format{$output_format});


		
	    ## Source column
=pod

=item B<-scol_R>

Source column of reference graph for tab-delimited input, default = 1. Column containing the source nodes. 

=cut
	} elsif ($arg eq "-scol_R") {
	    $source_col_R = shift (@arguments);
	    unless (&IsNatural($source_col_R) && ($source_col_R > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col_R, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }
	    
=item B<-scol_Q>

Source column of query graph for tab-delimited input, default = 1. Column containing the source nodes. 

=cut
	} elsif ($arg eq "-scol_Q") {
	    $source_col_Q = shift (@arguments);
	    unless (&IsNatural($source_col_Q) && ($source_col_Q > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col_Q, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }
	    
	    ## Target column
=pod

=item B<-tcol_R>

Target column of reference graph for tab-delimited input, default = 2. Column containing the target nodes. 

=cut
	} elsif ($arg eq "-tcol_R") {
	    $target_col_R = shift (@arguments);
	    unless (&IsNatural($target_col_R) && ($target_col_R > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col_R, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }
	    ## Target column
=pod

=item B<-tcol_Q>

Target column of query graph for tab-delimited input, default = 2. Column containing the target nodes. 

=cut
	} elsif ($arg eq "-tcol_Q") {
	    $target_col_Q = shift (@arguments);
	    unless (&IsNatural($target_col_Q) && ($target_col_Q > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col_Q, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol_R>

Weight column of reference graph for tab-delimited input. Column containing the weight nodes. 

=cut
	} elsif ($arg eq "-wcol_R") {
	    $weight_col_R = shift (@arguments);
	    unless (&IsNatural($weight_col_R) && ($weight_col_R > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col_R, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }
=pod

=item B<-wcol_Q>

Weight column of query graph for tab-delimited input. Column containing the weight nodes. 

=cut
	} elsif ($arg eq "-wcol_Q") {
	    $weight_col_Q = shift (@arguments);
	    unless (&IsNatural($weight_col_Q) && ($weight_col_Q > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col_Q, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }
	    
	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
## Intersection
## This function takes two graphs as arguments and computes their
## intersection in a third graph

sub intersect {

  my ($graph1, $graph2) = @_;
  my $inter_graph = new RSAT::Graph2;
  my %seen_arcs = ();
  my @arcs_g1 = $graph1->get_attribute("arcs");
  my %arcs_name_id_g1 = $graph1->get_attribute("arcs_name_id");
  my @arcs_g2 = $graph2->get_attribute("arcs");
  my %arcs_name_id_g2 = $graph2->get_attribute("arcs_name_id");
  my %nodes_name_id = $graph2->get_attribute("nodes_name_id");
  my %nodes_color = $graph2->get_attribute("nodes_color");
  my %nodes_label = $graph2->get_attribute("nodes_label");
  my $val = scalar(@arcs_g1);
  my $arccpt = 0;
  my $j = 1;
  my @inter_graph_array  = ();
  for (my $i = 0; $i < scalar(@arcs_g1); $i++) { # charge le graph 1
    if ($i % 1000 == 0) {
        &RSAT::message::TimeWarn("$i lines treated") if ($verbose  >= 4);
    }
    my $source_name = $arcs_g1[$i][0]; 
    my $target_name = $arcs_g1[$i][1];
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_".($j);
    push @arcs_id, $arc_id1; # arcs du graph 1, "dirigés"
    if (!$directed) {
      my $arc_id2 = $target_name."_".$source_name."_".($j);
      push @arcs_id, $arc_id2; # ajouts des arcs du graph 1 "non dirigés"
    }
    foreach my $arc_id (@arcs_id){
      my $arc_intern_id_g2 = $arcs_name_id_g2{$arc_id};
      
      if (!exists($seen_arcs{$arc_id})) {
        my $source_intern_id = $nodes_name_id{$source_name};
        my $target_intern_id = $nodes_name_id{$target_name};
        if (defined($arc_intern_id_g2)) {
          my $source_node_color = $nodes_color{$source_intern_id} || "#000088";
	  my $source_node_label = $nodes_label{$source_intern_id} || $source_name;
	  my $target_node_color = $nodes_color{$target_intern_id} || "#000088";
	  my $target_node_label = $nodes_label{$target_intern_id} || $target_name;
          my $weight = &calculate_weight($arcs_g1[$i][2], $arcs_g2[$arc_intern_id_g2][2]);
	  my $arc_label = $weight;
          my $arc_color = $arcs_g2[$arc_intern_id_g2][3];
          $inter_graph_array[$arccpt][0] = $source_name;
          $inter_graph_array[$arccpt][1] = $target_name;
          $inter_graph_array[$arccpt][2] = $arc_label;
          $inter_graph_array[$arccpt][3] = $source_node_color;
          $inter_graph_array[$arccpt][4] = $target_node_color;
          $inter_graph_array[$arccpt][5] = $arc_color;
	  $arccpt ++;
	  for (my $j = 0; $j < scalar(@arcs_id); $j++) {
	    $seen_arcs{$arcs_id[$j]}++;
	  }
	  if (!$directed) {
	    last;
	  }
	} 
      }
    }
  }
  $inter_graph->load_from_array(@inter_graph_array);
  return $inter_graph;
}

################################################################
## Union of two graphs
## This function creates in Graph $graph2 all the edges that are in Graph $graph1 but 
## absent in $graph2

sub union {
  my ($graph1, $graph2) = @_; 
  
  my $union_graph = new RSAT::Graph2;
  
  my @arcs_g1 = $graph1->get_attribute("arcs");
  my %arcs_name_id_g1 = $graph1->get_attribute("arcs_name_id");
  my @arcs_g2 = $graph2->get_attribute("arcs");
  my %arcs_name_id_g2 = $graph2->get_attribute("arcs_name_id");
  my %nodes_name_id_g1 = $graph1->get_attribute("nodes_name_id");
  my %nodes_name_id_g2 = $graph2->get_attribute("nodes_name_id");
  my %nodes_color_g1 = $graph1->get_attribute("nodes_color");
  my %nodes_color_g2 = $graph2->get_attribute("nodes_color");
  my %nodes_label_g1 = $graph1->get_attribute("nodes_label");
  my %nodes_label_g2 = $graph2->get_attribute("nodes_label");

  my @union_graph_array = @arcs_g1;
  my @arcs_attributes = ();
  my %seen_arcs = ();
  
#   filling union_graph_array with graph1

  for (my $i = 0; $i < scalar(@union_graph_array); $i++) {
  
    my $source_name = $union_graph_array[$i][0]; 
    my $target_name = $union_graph_array[$i][1];
    my $arc_label_g1 = $union_graph_array[$i][2];
        
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_".1;
    push @arcs_id, $arc_id1; # arcs du graph 1, "dirigés"
    if (!$directed) {
      my $arc_id2 = $target_name."_".$source_name."_".1;
      push @arcs_id, $arc_id2; # ajouts des arcs du graph 1 "non dirigés"
    }
    my $arc_label = "$arc_label_g1";
    my $arc_color = "#00ff00"; # by default color of edges belongs to graph1 is green
    my $arc_attribute = "Q.not.R";
    foreach my $arc_id (@arcs_id) {
      my $arc_intern_id = $arcs_name_id_g2{$arc_id};
      if (defined($arc_intern_id)) {
        my $arc_label_g2 = $arcs_g2[$arc_intern_id][2]; 
	$arc_color = "#ff0000";
	$arc_attribute = "Q.and.R";
	$arc_label = &calculate_weight($arc_label_g1, $arc_label_g2);
      }
    }
    my $source_name_id = $nodes_name_id_g1{$source_name};
    my $target_name_id = $nodes_name_id_g1{$target_name};
    my $source_node_color = $nodes_color_g1{$source_name_id};
    my $target_node_color = $nodes_color_g1{$target_name_id};
    $union_graph_array[$i][2] = $arc_label;
    $union_graph_array[$i][3] = $source_node_color;
    $union_graph_array[$i][4] = $target_node_color;
    $union_graph_array[$i][5] = $arc_color;
    $arcs_attributes[$i] = $arc_attribute;
    # si la couleur du noeud est #00ff00, l'arc n'appartient qu'à g1 et donc tu mets
    # 1not2 dans graph attribute à la valeur $i
    # si la couleur du noeud est #ff0000, l'arc appartient à l'intersection et donc tu mets
    # 1and2 dans graphe attribute à la valeur $i
    
    
    for (my $j = 0; $j < scalar(@arcs_id); $j++) {
      $seen_arcs{$arcs_id[$j]}++;
    }
  }    

#   filling union_graph_array with graph2 without intersection
  my $j = scalar(@union_graph_array);
  my $arc_color = "#0000ff";
  my $arc_attribute = "not.Q.R";
  for (my $i = 0; $i < scalar(@arcs_g2); $i++) {
    my $source_name = $arcs_g2[$i][0]; 
    my $target_name = $arcs_g2[$i][1];
    my $arc_label_g2 = $arcs_g2[$i][2];
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_".1;
    push @arcs_id, $arc_id1; # arcs du graph 1, "dirigés"
    if (!$directed) {
      my $arc_id2 = $target_name."_".$source_name."_".1;
      push @arcs_id, $arc_id2; # ajouts des arcs du graph 1 "non dirigés"
    }
    foreach my $arc_id (@arcs_id) {
      my $arc_intern_id_g1 = $arcs_name_id_g1{$arc_id};
      my $arc_intern_id_g2 = $arcs_name_id_g2{$arc_id};
      my $seen_arc = $seen_arcs{$arc_id};
      if (!defined($seen_arc) && defined($arc_intern_id_g2)) {
        my $arc_label = $arc_label_g2;
# 	my $arc_label = $arcs_g2[$i][2];
        my $source_name_id = $nodes_name_id_g2{$source_name};
        my $target_name_id = $nodes_name_id_g2{$target_name};
        my $source_node_color = $nodes_color_g2{$source_name_id};
        my $target_node_color = $nodes_color_g2{$target_name_id};
        $union_graph_array[$j][0] = $source_name;
        $union_graph_array[$j][1] = $target_name;
        $union_graph_array[$j][2] = $arc_label;
        $union_graph_array[$j][3] = $source_node_color;
        $union_graph_array[$j][4] = $target_node_color;
        $union_graph_array[$j][5] = $arc_color;
	$arcs_attributes[$j] = $arc_attribute;
	# il ne reste plus que les arcs qui n'appartiennent qu'à g2 donc tu mets not1,2 
        # dans @graph_attribute à la valeur $j
        $j++;
	for (my $j = 0; $j < scalar(@arcs_id); $j++) {
          $seen_arcs{$arcs_id[$j]}++;
        }
      }
    }
  }
  $union_graph->load_from_array(@union_graph_array);
  $union_graph->set_array_attribute("arcs_attribute", @arcs_attributes);
  return ($union_graph);
}

################################################################
## Difference of two graphs
## 
## 

sub difference {

  my ($graph1, $graph2) = @_;

  my $diff_graph = new RSAT::Graph2;
    
  my @arcs_g1 = $graph1->get_attribute("arcs");
  my @arcs_g2 = $graph2->get_attribute("arcs");
  my %arcs_name_id_g1 = $graph1->get_attribute("arcs_name_id");
  my %arcs_name_id_g2 = $graph2->get_attribute("arcs_name_id");
  my %nodes_name_id_g1 = $graph1->get_attribute("nodes_name_id");
  my %nodes_name_id_g2 = $graph2->get_attribute("nodes_name_id");
  my %nodes_color_g1 = $graph1->get_attribute("nodes_color");
  my %nodes_color_g2 = $graph2->get_attribute("nodes_color");
  my %nodes_label_g1 = $graph1->get_attribute("nodes_label");
  my %nodes_label_g2 = $graph2->get_attribute("nodes_label");
  
  my @diff_graph_array = ();
  
  my $j = 0;
  
  my %seen_arcs = ();

  for (my $i = 0; $i < scalar(@arcs_g1); $i++) { # charge le graph 1
  
    my $source_name = $arcs_g1[$i][0]; 
    my $target_name = $arcs_g1[$i][1];
    
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_".1;
    my $arc_id_rev = $source_name."_".$target_name."_".1;
    if (!$directed) {
      $arc_id_rev = $target_name."_".$source_name."_".1;
    }
    if (!exists($arcs_name_id_g2{$arc_id1}) && !exists($arcs_name_id_g2{$arc_id_rev})) {
      if (!exists($seen_arcs{$arc_id1}) && !exists($seen_arcs{$arc_id_rev})) {
	  
	my $arc_label = $arcs_g1[$i][2];
        my $source_name_id = $nodes_name_id_g1{$source_name};
        my $target_name_id = $nodes_name_id_g1{$target_name};
        my $source_node_color = $nodes_color_g1{$source_name_id};
        my $target_node_color = $nodes_color_g1{$target_name_id};
        $diff_graph_array[$j][0] = $source_name;
        $diff_graph_array[$j][1] = $target_name;
        $diff_graph_array[$j][2] = $arc_label;
        $diff_graph_array[$j][3] = $source_node_color;
        $diff_graph_array[$j][4] = $target_node_color;
        $diff_graph_array[$j][5] = "#000088";
        $j++;
	$seen_arcs{$arc_id1}++;
	$seen_arcs{$arc_id_rev}++;
      }  
    }
  }
  $diff_graph->load_from_array(@diff_graph_array);
  return ($diff_graph);
}

################################################################
## arcs in common between two graphs
## 
## 
sub in_common {
  my ($graph1, $graph2) = @_;
  my $common = 0;
  my $graph1_not_graph2 = 0;
  my $graph2_not_graph1 = 0; 
  my %seen_arcs = ();
  my @arcs_g1 = $graph1->get_attribute("arcs");
  my %arcs_name_id_g1 = $graph1->get_attribute("arcs_name_id");
  my @arcs_g2 = $graph2->get_attribute("arcs");
  my %arcs_name_id_g2 = $graph2->get_attribute("arcs_name_id");
  my $max_arc_nb = $graph2->get_attribute("nb_arc_bw_node");
  for (my $i = 0; $i < scalar(@arcs_g1); $i++) { # run through the arcs of graph1
    my $source_name = $arcs_g1[$i][0];
    my $target_name = $arcs_g1[$i][1];
    my @arcs_id = ();
    my $arc_id1 = $source_name."_".$target_name."_1";
    push @arcs_id, $arc_id1; 
    if (!$directed) {
      my $arc_id2 = $target_name."_".$source_name."_1";
      push @arcs_id, $arc_id2; 
    }
    foreach my $arc_id (@arcs_id) {
      my $arc_intern_id = $arcs_name_id_g2{$arc_id};
      if (!exists($seen_arcs{$arc_id})) {
        if (defined($arc_intern_id)) {
	  $common++;
	  foreach (my $j = 0; $j < scalar(@arcs_id); $j++) {
	    $seen_arcs{$arcs_id[$j]}++;
	  }
  	  if (!$directed) {
	    last;
	  }
        }
      } else {
        if (!$directed) {
          last;
        }
      }
    }
  }
  return ($common);
}
################################################################
#### verbose message
sub Verbose {
    print $main::out "; compare-graphs ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::out ";\t$key\t$value\n";
	}
    }
}
################################################################
#### calculate_outweight
sub calculate_weight {
  my ($weight_g1, $weight_g2) = @_;
  my $result = $nullvalue;
  my $real = &IsReal($weight_g1);
  my $real2 = &IsReal($weight_g2);
#   $result = join("::",$weight_g1,$weight_g2);


  if ($outweight eq "R") {
    $result = $weight_g1;
  }
  if ($outweight eq "Q") {
    $result = $weight_g2;
  }
  if ($outweight eq "Q::R") {
    $result = join("::",$weight_g1,$weight_g2);
  } 
  
  if (($real eq 1) && ($real2 eq 1)) {
    if ($outweight eq "mean") {
      $result = ($weight_g1+$weight_g2)/2;
    } elsif ($outweight eq "mean.g") {
      $result = sqrt($weight_g1*$weight_g2);
    } elsif ($outweight eq "sum") {
      $result = ($weight_g1+$weight_g2);
    } elsif ($outweight eq "min") {
      if ($weight_g1<$weight_g2) {
        $result = $weight_g1;
      } else {
        $result = $weight_g2;
      }
    } elsif ($outweight eq "max") {
      if ($weight_g1<$weight_g2) {
        $result = $weight_g2;
      } else {
        $result = $weight_g1;
      }
    }
 
    if ($result eq $nullvalue && $main::verbose >= 2) {
      &RSAT::message::Warning("\t","Could not compute $outweight between $weight_g1 and $weight_g2");
    }
  }
  return ($result);
}


__END__

=pod

=head1 SEE ALSO

=over

=item I<compare-graphs>

=item I<compare-graph-clusters>

=item I<convert-graph>

=item I<graph-get-clusters>

=item I<graph-neighbours>

=item I<graph-node-degree>

=item I<graph-set-attributes>

=back

=cut
