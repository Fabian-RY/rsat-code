###############################################################
#
# Manipulation of Position-Specific Scoring Matrices (PSSM)
#
package RSAT::matrix;

#%alphabet_index = ();

require "RSA.seq.lib";
use RSAT::table;
use RSAT::stats;

@ISA = qw( RSAT::GenericObject RSAT::table);

=pod

=head1 NAME

    RSAT::matrix

=head1 DESCRIPTION

Main class for manipuating profile matrices (also called PSSM,
Position-Specific Scoring Matrices, count matrices, position-weight matrices).

PSSM can be used to represent the binding specificity of a transcription
factor or the conserved residues of a protein domain.

Each row of the matrix corresponds to one residue (nucleotide or amino-acid
depending on the sequence type).  Each column corresponds to one position in
the alignment.  The value within each cell represents the frequency of each
residue at each position.

This converter takes as input PSSM generated by different pattern discovery
programs (consensus, tab, gibbs, MEME, MotifSampler), and exports them in
different formats.

=head1 OUTPUT FORMATS

=over

=item B<counts>

Each cell of the matrix indicates the number of occurrences of the
residue at a given position of the alignment.

=item B<profile>

The matrix is printed vertically (each matrix column becomes a row in
the output text). Additional parameters (consensus, information) are
indicated besides each position, and a histogram is drawed.

=item B<crude frequencies>

Relative frequencies are calculated as the counts of residues divided
by the total count of the column.

S<Fij=Cij/SUMi(Cij)>

where 

=over

=item Cij 

is the absolute frequency (counts) of residue i at position j of the alignment

=item Fij

is the relative frequency of residue i at position j of the alignment

=back


=item frequencies corrected with pseudo-weights

Relative frequencies can be corrected by a pseudo-weight (b) to reduce
the bias due to the small number of observations.

S<F''ij=Cij+b*Pi/[SUMi(Cij)+b]>

where 

=over

=item Pi 

is the prior frequency for residue i

=item b

is the pseudo-weight, which is "shared" between residues according to
their prior frequencies.

=back



=item weights

Weights are calculated according to the formula from Hertz (1999), as
the natural logarithm of the ratio between the relative frequency
(corrected for pseudo-weights) and the prior residue probability.

S<Wij=ln(F''ij/Pi)>

=item information

The crude information content is calculated according to the formula
from Hertz (1999).

S<Iij = Fij*ln(Fij/Pi)>

In addition, we calculate a "corrected" information content which
takes pseudo-weights into account.

S<I''ij = F''ij*ln(F''ij/Pi)>

=item P-value

The P-value indicates the probability to observe at least Cij
occurrences of a residue at a given position of the matrix. It is
calculated with the binomial formula:

    k=C.j    C.j!      k      Cij-k
Pij= SUM  ---------- Pi (1-Pi)
    k=Cij k!(C.j-k)!

where

=over

=item Cij 

is the number of occurrences of residue i at position j of
the matrix.

=item C.j 

is the sum of all residue occurrences at position j of the
matrix.

=item Pi 

is the prior probability of residue i.

=back

=item parameters

Returns a series of parameters associated to the matrix. The list of
parameters to be exported depends on the input formats (each pattern
discovery program returns specific parameters, which are more or less
related to each others but not identical).

Some additional parameters are optionally calculated

=over

=item consensus

The degenerate consensus is calculated by collecting, at each
position, the list of residues with a positive weight. Contrarily to
most applications, this consensus is thus weighted by prior residue
frequencies: a residue with a high frequency might not be represented
in the consensus if this frequency does not significantly exceed the
expected frequency. Uppercases are used to highlight weights >= 1.

The consensus is exported as regular expression, and with the IUPAC
code for ambiguous nucleotides (http://www.chem.qmw.ac.uk/iupac/misc/naseq.html).

       	A			(Adenine) 
	C			(Cytosine)
	G			(Guanine)
	T			(Thymine)
	R	= A or G        (puRines)
	Y	= C or T        (pYrimidines)
	W	= A or T        (Weak hydrogen bonding)
	S	= G or C        (Strong hydrogen bonding)
	M	= A or C        (aMino group at common position)
	K	= G or T        (Keto group at common position)
	H	= A, C or T     (not G)
	B	= G, C or T     (not A)
	V	= G, A, C       (not T)
	D	= G, A or T     (not C)
	N	= G, A, C or T  (aNy)

The strict consensus indicates, at each position, the residue with the
highest positive weight.

=item information

The total information is calculated by summing the information content
of all the cells of the matrix. This parameters is already returned by
the program consensus (Hertz), but not by other programs.

=back

=back

=head1 METHODS

=over

=cut


################################################################
=pod

=item B<new()>

Create an empty matrix.

=cut
sub new {
    my ($class, %args) = @_;
    my $matrix = bless {
	nrow=>0,
	ncol=>0,
	%args
	}, $class;
    return $matrix;
}


################################################################
=pod

=item B<init>

Initialize the matrix.

=cut

sub init {
    my ($self) = @_;

    ## initialize the matrix
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    warn "Initializing the matrix $nrow rows, $ncol columns\n" if ($main::verbose >= 5);
    foreach my $r (1..$nrow) {
	foreach my $c (1..$ncol) {
	    $self->setCell($r,$c,0);
	}
    }
}

################################################################
=pod 

=item B<set_parameter()>

Sets an attribute and add it to the list of parameters to export.

=cut
sub set_parameter {
    my ($self, $key, $value) = @_;
    $self->force_attribute($key, $value);
    $self->push_attribute("parameters", $key);
}

################################################################
=pod

=item B<reset()>

Empty the matrix

=cut
sub reset {
    my ($self) = @_;
    warn "Resetting the matrix to empty\n" if ($main::verbose >= 5);
    undef(@{$self->{alphabet}});
    undef(@{$self->{table}});
    $self->force_attribute("nrow", 0);
    $self->force_attribute("ncol", 0);
}


################################################################
=pod

=item B<index_alphabet>

Index the alphabet in a hash table, indicating which row of the matrix
corresponds to which letter of the alphabet.

=cut
sub index_alphabet {
    my ($self) = @_;
    my @alphabet = $self->getAlphabet();
    my $row = 0;
    foreach my $letter (@alphabet) {
	$self->add_hash_attribute("alphabet_index", uc($letter), $row);
#	$alphabet_index{$letter} = $row;
#	&RSAT::message::Debug("Alphabet index", $letter, $row) if ($main::verbose >= 0);
	$row++;
    }
}


################################################################
=pod

=item getPrior()

Return prior frequencies. If these were not defined previously,
estimate them on the basis of equiprrobable residues. 

=cut
sub getPrior() {
    my ($self) = @_;
    my %prior = ();
    if ($self->get_attribute("prior_specified")) {
	%prior = $self->get_attribute("prior");
    } else {
	if (scalar(keys %prior) <= 0) {
	    &main::Warning( "No prior defined: using equiprobable residues") if ($main::verbose >= 3);
	    my @alphabet = $self->getAlphabet();
	    my $alphabet_size = scalar(@alphabet);
	    foreach my $letter (@alphabet) {
		$prior{$letter} = 1/$alphabet_size;
		warn join "\t", ";", $letter, $prior{$letter}, "\n" if ($main::verbose >= 10);
	    }
	    $self->setPrior(%prior);
	}
    }
    if ($main::verbose >= 10) {
	foreach my $letter (sort keys %prior) {
	    warn join("\t", "; getPrior", $letter, $prior{$letter}), "\n";
	}
    }
    warn "CHECK getPrior\t", join " ", %prior if ($main::verbose >= 10);
    return %prior;
}

################################################################
=pod 

=item setPrior(%prior)

Specify prior frequencies. The priors are provided as a hash table,
where keys are residues and values prior probabilities.

=cut
sub setPrior {
    my ($self, %prior) = @_;
    warn "; CHECK setPrior\t", join(" ", %prior), "\n" if ($main::verbose >= 10);
    $self->set_hash_attribute("prior", %prior);

#    %check = $self->get_attribute("prior");

    $self->force_attribute("prior_specified", 1);
    if ($main::verbose >= 10) {
	warn "setPrior\n";
	foreach my $letter (sort keys %prior) {
	    warn join("\t", "; setPrior", $letter, $prior{$letter}), "\n";
	}
    }
}



################################################################
## PROBLEM ###
=pod

=item addRow(@new_row)

Add a new row to the matrix

=cut
sub addRow {
    my ($self,@new_row) = @_;
    
    ## Update number of rows
    my $nrow = $self->nrow()+1;
	$self->force_attribute("nrow", $nrow);
    warn ("Matrix: updating number of rows\t", $self->nrow(), "\n") if ($main::verbose >= 5);
    
    ## update number of colmuns
    my $row_size = scalar(@new_row);
    if ($row_size >= $self->ncol()) {
	warn ("Matrix: updating number of columns\t", $row_size, "\n") if ($main::verbose >= 5);
	$self->force_attribute("ncol", scalar(@new_row));
    }
    
    ## update matrix content
    for my $c (0..$#new_row) {
	${$self->{table}}[$c][$nrow-1] = $new_row[$c];
    }
}

################################################################
=pod

=item getParameters()

Return the list of parameters associated to the matrix

=cut
sub getParameters {
    my ($self) = @_;
    return @{$self->{parameters}};
}

################################################################
=pod

=item getMatrix()

Return the whole matrix as a vector

=cut
sub getMatrix {
    my ($self) = @_;
    return @{$self->{table}};
}

################################################################
=pod

=item setMatrix($nrow, $ncol, @matrix)

Specify the whole matrix

=cut
sub setMatrix {
    my ($self,$nrow, $ncol, @matrix) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{table}} = @matrix;
}


# ################################################################
# =pod

# =item setCell($row, $col, $value)

# Specify the content of a single cell. 

# =cut
# sub setCell {
#     my ($self,$row, $col, $value) = @_;
# #    warn join("\t", "Setting cell", 
# #	      "row", $row, 
# #	      "column", $col, 
# #	      "value", $value), "\n" 
# #		  if (main::verbose >= 10); 
#     ${$self->{table}}[$col-1][$row-1] = $value;
# }


# ################################################################
# =pod

# =item getCell($row, $col)

# Return the content of a single cell. 

# =cut
# sub getCell {
#     my ($self,$row, $col) = @_;
#     return ${$self->{table}}[$col-1][$row-1];
# }



################################################################
=pod

=item readFromFile($file, $format)

Read a matrix from a file

=cut
sub readFromFile {
    my ($self, $file, $format, %args) = @_;
    if (($format =~ /consensus/i) || ($format =~ /^wc/i)) {
	$self->_readFromConsensusFile($file);
    } elsif ($format =~ /gibbs/i) {
	$self->_readFromGibbsFile($file);
    } elsif ($format =~ /tab/i) {
	$self->_readFromTabFile($file, %args);
    } elsif ($format =~ /MotifSampler/i) {
	$self->_readFromMotifSamplerFile($file);
    } elsif ($format =~ /meme/i) {
	$self->_readFromMEMEFile($file);
    } elsif ($format =~ /clustal/i) {
	$self->_readFromClustalFile($file);
    } else {
	&main::FatalError("Invalid format for reading matrix\t$format");
    }

    ## Check that the matrix contains at least one row and one col
    if (($self->nrow() > 0) && ($self->ncol() > 0)) {
	warn join("\t", "; Matrix read", 
		  "nrow = ".$self->nrow(),
		  "ncol = ".$self->ncol(),
		  "prior : ".join (" ", $self->getPrior()),
		  ), "\n" if ($main::verbose >= 3);
    } else {
	&main::FatalError("The file $file does not seem to contain a matrix in format $format. Please check the file format and contents.");
    }
}


################################################################
=pod

=item _readFromGibbsFile($file)

Read a matrix from a gibbs file. This method is called by the method 
C<readFromFile($file, "gibbs")>.

=cut
sub _readFromGibbsFile {
    my ($self, $file) = @_;
    
    ## open input stream
    my $in = STDIN;
    if ($file) {
	open INPUT, $file;
	$in = INPUT;
    }
    $in_matrix = 0;
    my @matrix = ();
    my @alphabet = ();
    my $ncol = 0;
    my $nrow = 0;
    my $last_ncol = 0;
    my $last_nrow = 0;
    while (<$in>) {
	next unless (/\S/);
	s/\r//;
	chomp();
	if (/Information \(relative entropy\) contribution in tenth bits\:/) {
	    $in_matrix = 1;
	    $self->setAlphabet("A","C","G","T");   # default nucletodide alphabet
	    next;
	} elsif (/site/) {
	    ### Empty the previous matrix because it was not the definitive result
	    $in_matrix = 0;
	    @last_matrix = @matrix;
	    $last_nrow = $nrow;
	    $last_ncol = $ncol;
	    @matrix = ();
	    $nrow = 0;
	    $ncol = 0;
#		$self->reset();
	    next;
	} elsif ((/^\s*POS/) && ($in_matrix)) {
	    s/\r//;
	    chomp;
	    @header = split " +";
	    @alphabet = @header[1..$#header-1];
#		$self->setAlphabet(@alphabet);
	} elsif (/model map = (\S+); betaprior map = (\S+)/) {
	    $self->set_parameter("model.map", $1);
	    $self->set_parameter("betaprior.map", $2);
	} elsif (/MAP = (\S+)/) {
	    $self->set_parameter("MAP", $1);
	} elsif (/seed: (\S+)/) {
	    $self->set_parameter("seed", $1);
	} elsif (/^gibbs /) {
	    $self->set_parameter("command", $_);
	} elsif ($in_matrix) {
	    ## Add a column to the matrix (gibbs rows correspond to our columns)
	    s/\r//;
	    chomp;
	    s/^\s+//;
	    @fields = split " +";
	    @values = @fields[1..$#header-1];
	    $nrow = scalar(@values);
	    foreach my $v (0..$#values) {
		$values[$v] =~ s/^\.$/0/;
		$matrix[$ncol][$v] = $values[$v];
	    }
	    $ncol++;
	}
    }
    close $in if ($file);

    $self->setAlphabet (@alphabet);
    $self->force_attribute("nrow", $last_nrow);
    $self->force_attribute("ncol", $last_ncol);
    $self->setMatrix ($last_nrow, $last_ncol, @last_matrix);
}


################################################################
=pod

=item _readFromConsensusFile($file)

Read a matrix from a consensus file. This method is called by the
method C<readFromFile($file, "consensus")>.

=cut
sub _readFromConsensusFile {
    my ($self, $file) = @_;
    warn ("; Reading matrix from consensus file\t",$file, "\n") if ($main::verbose >= 3);
    
#	($in, $dir) = &main::OpenInputFile($file);
#
    
    ## open input stream
    my $in = STDIN;
    if ($file) {
	open INPUT, $file;
	$in = INPUT;
    }
    my $current_matrix_nb = 0;
    my %prior = ();
    while (<$in>) {
	next unless (/\S/);
	s/\r//;
	chomp();

	## The following information (final cycle) is only exported
	## when the number of cycles is automatic. I don't understand
	## the reason for this. I need to ask Jerry. Inbetween, I
	## always use the same information (THE LIST OF TOP MATRICES
	## FROM EACH CYCLE).

	last if (/THE LIST OF MATRICES FROM FINAL CYCLE/);

	## Read the command line
	if (/COMMAND LINE: /) {
	    $command = $'; # '
	    $self->set_parameter("command", $command);

	    ## Start a new matrix (one consensus file contains several matrices)
	} elsif (/MATRIX\s(\d+)/) {
	    $current_matrix_nb = $1;
	    $self->setPrior(%prior);
	    next;

	    ## Read prior frequency for one residue in the consensus header
	} elsif (/letter\s+\d:\s+(\S+).+prior frequency =\s+(\S+)/) {
	    my $letter = $1;
	    my $prior = $2;
	    warn join ("\t", "; prior from consensus file", $letter, $prior), "\n" if ($main::verbose >= 3);
	    $prior{$letter} = $prior;
	    $self->setPrior(%prior);
#	    $self->add_hash_attribute("prior",$letter, $prior);
#	    $self->force_attribute("prior_specified", 1);
	    
	} elsif  ($current_matrix_nb == 1) {

	    ## Matrix content (counts) for one residue
	    if (/^\s*(\S+)\s+\|/) {
		my @fields = split / +/, $_;
		## residue associated to the row
		my $residue = shift @fields;
		
		## skip the | between residue and numbers
		shift @fields unless &main::IsReal($fields[0]);	
		
		$self->addIndexedRow($residue, @fields);
		
		## Other matrix parameters
	    } elsif (/number of sequences = (\d+)/) {
		$self->set_parameter("nb.sequences", $1); 
	    } elsif (/unadjusted information = (\S+)/) {
		$self->set_parameter("unadjusted.information", $1); 
	    } elsif (/sample size adjusted information = (\S+)/) {
		$self->set_parameter("adjusted.information", $1); 
	    } elsif (/ln\(p\-value\) = (\S+)   p\-value = (\S+)/) {
		$self->set_parameter("ln.Pval", $1); 
		$self->set_parameter("Pval", $2); 
	    } elsif (/ln\(expected frequency\) = (\S+)   expected frequency = (\S+)/) {
		$self->set_parameter("ln.exp", $1); 
		$self->set_parameter("exp", $2); 
	    }
	}
    }
    close $in if ($file);
}


################################################################
=pod

=item _readFromTabFile($file)

Read a matrix from a tab-delimited file. This method is called by the
method C<readFromFile($file, "tab")>.

=cut
sub _readFromTabFile {
    my ($self, $file, %args) = @_;
    warn ("; Reading matrix from tab file\t",$file, "\n") if ($main::verbose >= 3);
    
#	($in, $dir) = &main::OpenInputFile($file);
#
    
    ## open input stream
    my $in = STDIN;
    if ($file) {
	open INPUT, $file;
	$in = INPUT;
    }
    my $current_matrix_nb = 0;

    ## read header
    if ($args{header}) {
	$header = <$in>;
	$header =~ s/\r//;
	chomp ($header);
	$header =~ s/\s+/\t/g;
	@header = split "\t", $header;
	$self->push_attribute("header", @header);
    }
    while (<$in>) {
	next unless (/\S/);
	s/\r//;
	chomp();
	s/\s+/\t/g;
	if (/^\s*(\S+)\s+/) {
	    my @fields = split /\t/, $_;

#	    warn join("\t", @fields), "\n" if ($main::verbose >= 0);

	    ## residue associated to the row
	    my $residue = shift @fields;
	    
	    ## skip the | between residue and numbers
	    shift @fields unless &main::IsReal($fields[0]);	
	    
	    $self->addIndexedRow($residue, @fields);
	}
    }
    close $in if ($file);
}


################################################################
=pod

=item _readFromMEMEFile($file)

Read a matrix from a MEME file. This method is called by the
method C<readFromFile($file, "MEME")>.

=cut

sub _readFromMEMEFile {
    my ($self, $file) = @_;
    warn ("; Reading matrix from consensus file\t",$file, "\n") if ($main::verbose >= 3);
    
    ## open input stream
#    ($in, $dir) = &main::OpenInputFile($file);
    my $in = STDIN;
    if ($file) {
	open INPUT, $file;
	$in = INPUT;
    }

    my $current_matrix_nb = 0;
    my $current_col = 0;
    my $in_proba_matrix = 0;
    my $in_blocks = 0;
    my $width_to_parse = 0;
    my %alphabet = ();
    my @frequencies = ();
#    my @matrix = ();
    my $parsed_width = 0;
    while (<$in>) {
	next unless (/\S/);
	s/\r//;
	chomp();
	$_ = &main::trim($_);
	if (/MOTIF\s+(\d+)\s+width =\s+(\d+)\s+sites =\s+(\d+)\s+llr =\s+(\d+)\s+E-value =\s+(\S+)/) {
	    warn "Parsing matrix parameters\n" if ($main::verbose >= 5);

	    $current_matrix_number = $1;
	    $width_to_parse = $2;
	    $self->set_attribute("ncol", $2);
	    $self->set_parameter("sites", $3);
	    $self->set_parameter("llr", $4);
	    $self->set_parameter("E-value", $5);
	    
	    $self->init();
#	    @matrix = $self->getMatrix();

	    ## Parse alphabet
	} elsif (/Letter frequencies in dataset/) {
	    warn "Reading letter frequencies\n" if ($main::verbose >= 5);
	    my $alphabet = <$in>;
	    $alphabet = &main::trim($alphabet);
	    %residue_frequencies = split /\s+/, $alphabet;

	    $self->setPrior(%residue_frequencies);

	    my @alphabet = sort (keys %residue_frequencies);
	    $self->setAlphabet(@alphabet);
	    
	    ## Index the alphabet
	    foreach my $l (0..$#alphabet) {
		$alphabet{$alphabet[$l]} = $l;
	    }

	    ## Specify the number of rows of the matrix
	    $self->force_attribute("nrow", scalar(@alphabet));

	    ## Parse BLOCKS format
	} elsif (/Motif (\d+) in BLOCKS format/) {
	    $current_matrix_number = $1;
	    $in_blocks = 1;
	    warn "; Starting to parse BLOCKS format\n" if ($main::verbose >= 5);
	} elsif ($in_blocks) {
	    if (/(\S+)\s+\(\s*\d+\)\s+(\S+)/) {
		my $seq_id = $1;
		my $seq = $2;
		my @letters = split "|", $seq;
		$parsed_width = &main::max($parsed_width, scalar(@letters));
		warn join ("\t", ";\tAdding site", $seq_id, $seq, scalar(@letters)), "\n" 
		    if ($main::verbose >= 5);
		foreach my $c (0..$#letters) {
		    my $row = $alphabet{$letters[$c]};
#		    warn join ("\t","Incrementing column", $c, "row", $row, "letter", $letters[$c]), "\n" if ($main::verbose >= 10);
		    ${$self->{table}}[$c][$row]++;
#		    $matrix[$c][$row]++;
		}
	    } elsif (/\/\//) {
		warn "; BLOCKS format parsed\n" if ($main::verbose >= 5);
#		$self->setMatrix(@matrix);
#		$self->force_attribute("ncol", $parsed_width);
		$in_blocks = 0;
	    }
	    
#	} elsif (/Motif (\d+) position-specific probability matrix/) {
#	    $current_matrix_number = $1;
#	    $in_proba_matrix = 1;
#	    warn ("; Parsing motif $current_matrix_number\n") if ($main::verbose >= 10);
#	    next;
#	}
#	if (/letter-probability matrix: alength= (\d+) w= (\d+) n= (\d+) E= (\S+)/) {
#	    warn join ("\t", 
#		       $1." rows",
#		       $2." columns",
#		       "n=".$3,
#		       "E=".$4,
#		       ), "\n" if ($main::verbose >= 1);
#	    $self->force_attribute("nrow", $1);
#	    $width_to_parse = $2;
#	    $self->set_parameter("n", $3);
#	    $self->set_parameter("E", $4);
#	} elsif ($in_proba_matrix) {
#	    $current_col++;
#	    my @fields = split /\s+/;
#	    warn (join "\t", @fields, "\n") if ($main::verbose >= 10);
#	    
#	    foreach my $r (0..$#fields) {
#		$frequencies[$current_col-1][$r] = $fields[$r];
#	    }
#	    
#	    ## Terminate the reading of this matrix
#	    if ($current_col == $width_to_parse) {
#		warn "; Read ".$current_col." columns\n" if ($main::verbose >= 10);
#		$in_proba_matrix = 0;
#		$self->setFrequencies(@frequencies);
#	    }
	}
    }
    close $in if ($file);
}

################################################################
=pod

=item _readFromMotifSamplerFile($file)

Read a matrix from a MotifSampler file. This method is called by the
method C<readFromFile($file, "MotifSampler")>.

TO BE IMPLEMENTED

=cut

sub _readFromMotifSamplerFile {
    &RSAT::error::FatalError("The MotifSampler format is not yet supported in this version of the program.");
}




################################################################
=pod

=item _readFromClustalFile($file)

Read a matrix from a multiple alignment in clustal format (extension
 .aln).  This method is called by the method C<readFromFile($file,
 "clustal")>.

=cut
sub _readFromClustalFile {
    my ($self, $file) = @_;
    
    ## open input stream
    my $in = STDIN;
    if ($file) {
	open INPUT, $file;
	$in = INPUT;
    }

    ## Check the header
    my $header = <$in>;
    unless ($header =~ /clustal/i) {
	&main::Warning("This file does not contain the clustal header");
    }

    ## Read the sequences
    my %sequences = ();
    warn "; Reading sequences\n" if ($main::verbose >= 3);
    while (<$in>) {
	next unless (/\S/);
	s/\r//;
	chomp();
	if (/^\s*(\S+)\s+(.+)$/) {
	    my $seq_id = $1;
	    next if ($seq_id eq "*"); ## asterisks are used to mark conservation
	    my $new_seq = $2;
	    
	    ## index the new sequence
	    $sequences{$seq_id} .= $new_seq;
	    warn join ("\t", ";", "Sequence", $seq_id, 
		       length($new_seq), length($sequences{$seq_id}),
		       ),"\n" if ($main::verbose >= 5);
	}
    }
    
    ## Calculate count matrix
    my %matrix = ();
    my %prior = ();
    my $ncol = 0;
    my $nrow = 0;
    warn "; Calculating profile matrix from sequences\n" if ($main::verbose >= 3);
    foreach my $seq_id (sort keys %sequences) {
	my $sequence = $sequences{$seq_id};
	$sequence =~ s/\s+//g;

	################################################################
	## Distinguish between insertions and leading/trailing gaps
	$terminal_gap_char = ".";

	## Substitute leading gaps
	if ($sequence =~ /^(\-+)/) {
	    $leading_gap_len = length($1);
	    my $leading_gap = ${terminal_gap_char}x$leading_gap_len;
	    $sequence =~ s|^(\-+)|${leading_gap}|;
	}
	## Substitute trailing gaps
	if ($sequence =~ /(\-+)$/) {
	    $trailing_gap_len = length($1);
	    my $trailing_gap = ${terminal_gap_char}x$trailing_gap_len;
	    $sequence =~ s|(\-+)$|${trailing_gap}|;
	}
	warn join ("\t",";", $seq_id,$sequence), "\n" if ($main::verbose >= 5);
	    
	$ncol = &main::max($ncol, length($sequence));
	warn join ("\t", ";", "Sequence", $seq_id, length($sequence)),"\n" if ($main::verbose >= 5);
	my @sequence = split '|', $sequence;
	foreach my $i (0..$#sequence) {
	    my $res = uc($sequence[$i]);
	    next if ($res eq "N"); ## BEWARE: THIS IS FOR DNA ONLY
#	    next if ($res eq "-");
	    next if ($res eq "."); ## leading and trailing gaps
	    next if ($res eq "*");
	    $prior{$res}++;
	    $matrix{$res}->[$i] += 1;
	}
    }
    $self->set_attribute("ncol", $ncol);

    ## Define prior probabilities, alphabet, and matrix size
    my @alphabet = sort keys %prior;
    my $alpha_sum = 0;
    foreach my $res (@alphabet) {
	$alpha_sum += $prior{$res};
    }
    foreach my $res (@alphabet) {
	if ($alpha_sum > 0) {
	    $prior{$res} /= $alpha_sum;
	} else {
	    $prior{$res} = 0;
	}
#	warn join "\t", $res, $alpha_sum, $prior{$res};
    }
    $self->setPrior(%prior);

    ## Store the matrix
    my @matrix = ();
    foreach my $r (0..$#alphabet) {
	my $res = $alphabet[$r];
	my @row = @{$matrix{$res}};
	$nrow++;
	foreach $i (0..($ncol-1)) {
	    $row[$i] = 0 unless (defined($row[$i]));
	}
	$self->addRow(@row);
	warn join ("\t", "Adding row", $r, $res, join ":", @row, "\n"), "\n" if ($main::verbose >= 4); 
    }
    $self->setAlphabet(@alphabet);
    $self->force_attribute("ncol", $ncol);
    $self->force_attribute("nrow", $nrow);

    warn join ("\t", "; Matrix size",  
	       $nrow,
	       $ncol,
	       $self->nrow(), 
	       $self->ncol()), "\n" 
		  if ($main::verbose >= 3);
    close $in if ($file);
}

################################################################
=pod

=item toString(sep=>$sep, col_width=>$col_width, type=>$type, comment_char=>$comment_string)

Return a string description of the matrix in the same format as Jerry
Hertz programs. Additional parameters are also exported as comments,
when the verbosity is > 0.

=cut
sub toString {
    my ($self, %args) = @_;
    my $to_print = "";

    ## Matrix type
    $type = $args{type} || "counts";

    %supported_types = (profile=>1,
			counts=>1,
			frequencies=>1,
			weights=>1,
			information=>1,
			parameters=>1
			);
    &main::FatalError("Invalid matrix type $type") unless $supported_types{$type};

    ## Set formatting parameters provided in arguments as matrix attribute
    foreach my $key ("sep", "col_width", "decimals") {
	if (defined($args{$key})) {
	    $self->force_attribute($key, $args{$key});
	}
    }

    ## Format for the matrix entries
    my $sep = $self->get_attribute("sep") || "\t";
    my $col_width = $self->get_attribute("col_width");
    my $decimals = $self->get_attribute("decimals");

    ## Calculate number width
    my $number_width = 0;
    if ($col_width) {
	$number_width = $col_width - 1;
    }
    if ($type eq "counts") {
	$decimals = 0;
    } else {
	unless ($decimals) {
	    $decimals = $number_width - 2;
	}
    }

    
    ################################################################
    ## Print parameters
    if ($type eq "parameters") {
	$to_print .= $self->_printParameters($to_print);
	

	################################################################
	## Print a profile (vertical matrix with consensus on the right side)
    } elsif ($type eq "profile") {

	$to_print .= $self->_printProfile($to_print);

    } else {

	################################################################
	## Print a matrix
	my @matrix = ();
	if ($type eq "counts") {
	    @matrix = @{$self->{table}};
	} else {
	    @matrix = @{$self->{$type}};
	}
	my @alphabet = $self->getAlphabet();
	my $ncol = $self->ncol();
	my $nrow = $self->nrow();
	
	## Header for the matrix
	if ($main::verbose >= 1) {
	    $to_print .= ";\n";
	    $to_print .= "; Matrix type: $type\n";
	    if (($col_width) && ($col_width < 6)) {
		$to_print .= ";P";
	    } else {
		$to_print .= "; Pos";
	    }
	    $to_print .= $sep."|";
	    for my $c (0..($ncol-1)) {
		my $pos = $c+1;
		if ($col_width) {
		    $to_print .= sprintf "%${col_width}s", $pos;
		} else {
		    $to_print .= $sep;
		    $to_print .= $pos;
		}
	    }
	    $to_print .= "\n";

	    $to_print .= $self->_printSeparator($ncol, $to_print);
	}

	## Print the matrix
	for $a (0..$#alphabet) {
	    my @row = &RSAT::matrix::get_row($a+1, $ncol, @matrix);
	    if (defined($args{comment_string})) {
		$to_print .= $args{comment_string};
	    }
 	    $to_print .= $self->_printMatrixRow($alphabet[$a], @row);
	}

	################################################################
	##Print column statistics
	if ($self->get_attribute("margins")) {
	    $prefix_letter = substr($type, 0, 1);
	    $to_print .= $self->_printSeparator($ncol, $to_print);
	    
	    ## Sum per column
	    my @col_sum = &RSAT::matrix::col_sum($nrow, $ncol, @matrix);
	    push @col_sum, &main::sum(@col_sum);
	    $to_print .= $self->_printMatrixRow("; ".$prefix_letter.".sum", @col_sum);
	    
	    ## Maximum per column
	    my @col_max = &RSAT::matrix::col_max($nrow, $ncol, @matrix);
	    push @col_max, &main::max(@col_max);
	    $to_print .= $self->_printMatrixRow("; ".$prefix_letter.".max", @col_max);
	    
	    ## Minimum per column
	    my @col_min = &RSAT::matrix::col_min($nrow, $ncol, @matrix);
	    push @col_min, &main::min(@col_min);
	    $to_print .= $self->_printMatrixRow("; ".$prefix_letter.".min", @col_min);
	}
    }
    return $to_print;
}




################################################################
=pod

=item getWeights()

Return the weight matrix

=cut
sub getWeights {
    my ($self) = @_;
    unless ($self->get_attribute("weight_specified")) {
	$self->calcWeight();
    }
    return @{$self->{weights}};
}

################################################################
=pod

=item setWeights($nrow, $ncol, @weights)

Specify the weight matrix

=cut
sub setWeights {
    my ($self,$nrow, $ncol, @weights) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{weights}} = @weights;
    $self->force_attribute("weight_specified", 1);
}

################################################################
=pod 

=item calcWeights()

Calculate weights from the frequency matrix.

=cut
sub calcWeights {
    my ($self) = @_;

    ## Calculate frequencies if required
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }
    my @frequencies = $self->getFrequencies();    

    
    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }
    
    ## Get or calculate prior residue probabilities
    my %prior = $self->getPrior();
    
    ## get matrix size
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    
    ## Calculate the weights
    my @weights = ();
    for my $c (0..($ncol-1)) {
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
#	    my $prior = 0.25;
	    my $freq = $frequencies[$c][$r];
	    if ($freq == 0) {
		$weights[$c][$r] = "-Inf";
	    } elsif ($prior <= 0) {
		$weights[$c][$r] = "NA";
	    } else {
		$weights[$c][$r] = log($freq/$prior);
	    }
	    warn join "\t", "weight", "r:".$r, "c:".$c, "l:".$letter, "f:".$freq, "pr:".$prior, $weights[$c][$r], "\n" 
		if ($main::verbose >= 10);
	}
    }
    $self->setWeights($nrow,$ncol,@weights);
}

################################################################
=pod

=item getInformation()

Return the information content matrix. 

=cut
sub getInformation {
    my ($self) = @_;
    $self->calcInformation();
    return @{$self->{information}};
}

################################################################
=pod

=item setInformation($nrow, $ncol, @information)

Specify the information content matrix.

=cut
sub setInformation {
    my ($self,$nrow, $ncol, @information) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{information}} = @information;
    $self->force_attribute("information_specified", 1);
}


################################################################
=pod 

=item calcInformation()

Calculate information content from the weight matrix.

Caching: if already calculated, do not calculate anymore.
attribute "force": force calculaton even if aready calculated.

=cut
sub calcInformation {
    my ($self, $force) = @_;

    ## Caching
    if (($self->get_attribute("information_calculated")) && !($force)) {
	warn "Information already calculated before\n" if ($main::verbose >= 3);
	return;
    }

    ## Calculate frequencies if required
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }
    my @frequencies = $self->getFrequencies();    
#    my @frequencies = $self->getCrudeFrequencies();    

    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }

    ## Get or calculate prior residue probabilities
    my %prior = $self->getPrior();

    ## Matrix size
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();

    ## Calculate information contents
    my @information = (); ## Informatiion matrix 
    my @column_information = (); ## Information per column
    my $total_information = 0; ## Total information for the matrix
    for my $c (0..($ncol-1)) {
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $freq = $frequencies[$c][$r];
	    if ($freq == 0) {
		$information[$c][$r] = 0;
	    } else {
		$information[$c][$r] = $freq * log($freq/$prior);
	    }
	    $column_information[$c] += $information[$c][$r];
	    $total_information += $information[$c][$r];
	    warn join "\t", "information", $r, $c, $information[$c][$r], $total_information, "\n" if ($main::verbose >= 10);
	}
    }
    $self->setInformation($nrow,$ncol,@information);


    ## Information per column
    $self->push_attribute("column.information", @column_information);

    ## Total information for the matrix
    $self->set_parameter("total.information", $total_information);
    $self->set_parameter("information.per.column", $total_information/$self->ncol());

    ## Remember that info was calculated once
    $self->force_attribute("information_calculated", 1);
}


################################################################
=pod

=item getFrequencies()

Return the matrix of frequencies. Beware: these frequencies are taking
pseudp-weights into account.

=cut
sub getFrequencies {
    my ($self) = @_;
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }
    return @{$self->{frequencies}};
}

################################################################
=pod

=item setFrequencies($nrow, $ncol, @frequencies)

Specify the matrix of frequencies. Beware: these frequencies are
taking pseudp-weights into account.

=cut
sub setFrequencies {
    my ($self,$nrow, $ncol, @frequencies) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{frequencies}} = @frequencies;
    $self->force_attribute("frequencies_specified", 1);
}

################################################################
=pod

=item getCrudeFrequencies()

Return the matrix of crude frequencies, i.e. NOT corrected by
pseudo-weights.

=cut
sub getCrudeFrequencies {
    my ($self) = @_;
    unless ($self->get_attribute("crudeFrequencies_specified")) {
	$self->calcFrequencies();
    }
    return @{$self->{crudeFrequencies}};
}

################################################################
=pod

=item setCrudeFrequencies($nrow, $ncol, @crudeFrequencies)

Specify the matrix of crude frequencies, i.e; NOT corrected by
pseudo-weights.

=cut
sub setCrudeFrequencies {
    my ($self,$nrow, $ncol, @crudeFrequencies) = @_;
    $self->force_attribute("nrow", $nrow);
    $self->force_attribute("ncol", $ncol);
    @{$self->{crudeFrequencies}} = @crudeFrequencies;
    $self->force_attribute("crudeFrequencies_specified", 1);
}

################################################################
=pod 

=item calcFrequencies()

Calculate frequencies from the count matrix (corrected with pseudo-weights).

=cut
sub calcFrequencies {
    my ($self) = @_;
    
    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }

    ## Matrix size
    my ($nrow, $ncol) = $self->size();
    if (($nrow <= 0) ||
	($ncol <= 0)) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }

    
    ## Get or calculate prior residue probabilities
    my %prior = $self->get_attribute("prior");
    if (scalar(keys %prior) <= 0) {
	&main::Warning( "No prior defined: using equiprobable residues") if ($main::verbose >= 3);
	my $alphabet_size = scalar(@alphabet);
	foreach my $letter (@alphabet) {
	    $prior{$letter} = 1/$alphabet_size;
	    warn join "\t", ";", $letter, $prior{$letter}, "\n" if ($main::verbose >= 10);
	}
    }

    ## pseudo-weight
    my $pseudo = $self->get_attribute("pseudo");
    
    ## count matrix
    my @matrix = $self->getMatrix();
    
    ## Calculate the frequencies
    my @frequencies = ();
    my @crude_frequencies = ();
#    my @col_sum = &RSAT::matrix::col_sum(@matrix);
    
    for my $c (0..($ncol-1)) {
	my $col_sum = 0;
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $occ = $matrix[$c][$r];
	    $col_sum += $occ;
	    $frequencies[$c][$r] = $occ + $pseudo*$prior{$letter};
	    warn join "\t", "freq", $r, $c, $letter, $prior, $pseudo, $occ, $col_sum, "\n" if ($main::verbose >= 10);
	}
	for my $r (0..($nrow-1)) {
	    if ($col_sum eq 0) {
		$crude_frequencies[$c][$r] = 0;
	    } else {
		$crude_frequencies[$c][$r] = $matrix[$c][$r]/$col_sum;
	    }
	    $frequencies[$c][$r] /= ($col_sum + $pseudo);
	    warn join( "\t", "freq", $r, $c, $pseudo, 
		       $col_sum, 
		       "a:".$matrix[$c][$r], 
		       "f:".$crude_frequencies[$c][$r], 
		       "f':".$frequencies[$c][$r]), "\n" 
			   if ($main::verbose >= 10);
	}
    }

    $self->setFrequencies($nrow,$ncol,@frequencies);
    $self->setCrudeFrequencies($nrow,$ncol,@crude_frequencies);
}

################################################################
=pod 

=item calcProbabilities()

Calculate probabilities (with the binomial distribution) from the
count matrix.

=cut
sub calcProbabilities {
    my ($self) = @_;
    

    die "The procedure calcProbabilities() is in construction";

    ## Get alphabet
    my @alphabet = $self->get_attribute("alphabet");
    if (scalar(@alphabet) <= 0) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }

    ## Matrix size
    my ($nrow, $ncol) = $self->size();
    if (($nrow <= 0) ||
	($ncol <= 0)) {
	&main::FatalError("Cannot calculate weigths for an empty matrix.");
    }

    
    ## Get or calculate prior residue probabilities
    my %prior = $self->get_attribute("prior");
    if (scalar(keys %prior) <= 0) {
	&main::Warning( "No prior defined: using equiprobable residues") if ($main::verbose >= 3);
	my $alphabet_size = scalar(@alphabet);
	foreach my $letter (@alphabet) {
	    $prior{$letter} = 1/$alphabet_size;
	    warn join "\t", ";", $letter, $prior{$letter}, "\n" if ($main::verbose >= 10);
	}
    }

    ## pseudo-weight
    my $pseudo = $self->get_attribute("pseudo");
    
    ## count matrix
    my @matrix = $self->getMatrix();
    
    ## Calculate the frequencies
    my @frequencies = ();
    my @crude_frequencies = ();
#    my @col_sum = &RSAT::matrix::col_sum(@matrix);
    
    for my $c (0..($ncol-1)) {
	my $col_sum = 0;
	for my $r (0..($nrow-1)) {
	    my $letter = $alphabet[$r];
	    my $prior = $prior{$letter};
	    my $occ = $matrix[$c][$r];
	    $col_sum += $occ;
	    $frequencies[$c][$r] = $occ + $pseudo*$prior{$letter};
	    warn join "\t", "freq", $r, $c, $letter, $prior, $pseudo, $occ, $col_sum, "\n" if ($main::verbose >= 10);
	}
	for my $r (0..($nrow-1)) {
	    if ($col_sum eq 0) {
		$crude_frequencies[$c][$r] = 0;
	    } else {
		$crude_frequencies[$c][$r] = $matrix[$c][$r]/$col_sum;
	    }
	    $frequencies[$c][$r] /= ($col_sum + $pseudo);
	    warn join( "\t", "freq", $r, $c, $pseudo, 
		       $col_sum, 
		       "a:".$matrix[$c][$r], 
		       "f:".$crude_frequencies[$c][$r], 
		       "f':".$frequencies[$c][$r]), "\n" 
			   if ($main::verbose >= 10);
	}
    }

    $self->setFrequencies($nrow,$ncol,@frequencies);
    $self->setCrudeFrequencies($nrow,$ncol,@crude_frequencies);
}


################################################################
=pod

=item &calcConsensus($force)

Calculate the consensus. 

Caching: if already calculated, do not calculate anymore.

Attribute "force": force calculaton even if aready calculated.

=cut
sub calcConsensus {
    my ($self, $force) = @_;

    ## Caching
    if (($self->get_attribute("consensus_calculated")) && !($force)) {
	warn "Consensus already calculated before\n" if ($main::verbose >= 3);
	return;
    }

    ## Calculate weight only if required
    unless ($self->get_attribute("weight_specified")) {
	$self->calcWeights();
    }
    my @weights = $self->getWeights();

    my @alphabet = $self->getAlphabet();
    
    ## Calculate consensus
    my $nrow = $self->nrow();
    my $ncol = $self->ncol();
    my $consensus = "";
    my $consensus_strict = "";
    for my $c (0..($ncol-1)) {
	my $col_max = 0;
	my $col_consensus = "-";
	my %positive_score = ();
	for my $r (0..($nrow - 1)) {
	    my $weight = $weights[$c][$r];
	    if ((&main::IsReal($weight)) && ($weight >= 0)) {
		my $letter = $alphabet[$r];
		$positive_score{$letter} = $weight;
		if ($weight >= $col_max) {
		    $col_max = $weight;
#		die join "\t", $c, $r, $col_max, $alphabet[$r], $col_consensus;
		    $col_consensus = $letter;
		}
	    }
	}
	
	## Calculate degenerate code
	my  $regular = $col_consensus;
	if (scalar(keys %positive_score) >= 2) {
	    $regular = "[";
	    $regular .= join "", sort keys %positive_score;
	    $regular .= "]";
	}
	
	## Use uppercase for scores >= 1
	if ($col_max >= 1) {
	    $consensus_strict .= uc($col_consensus);
	    $consensus .= uc($regular);
	} else {
	    $consensus_strict .= lc($col_consensus);
	    $consensus .= lc($regular);
	}
    }
    my $consensus_IUPAC = &main::regular_to_IUPAC($consensus);

    ## Strict consensus 
    $self->set_parameter("consensus.strict", $consensus_strict);

    ## Degenerate consensus in IUPAC format
    $self->set_parameter("consensus.IUPAC", $consensus_IUPAC);

    ## Degenerate consensus in regexp format
    $self->set_parameter("consensus.regexp", $consensus);

    ## Remember that the consensus has been calculated
    $self->force_attribute("consensus_calculated", 1);

}

################################################################
=pod

=item _printProfile()

Print the matrix in profile format (one column per residue, one row
per position), with additional columns for the consensus, some
statistics and the profile (graphical representations)

=cut

sub _printProfile {
    my ($self, $to_print) = @_;
    @matrix = @{$self->{table}};
    my @alphabet = $self->getAlphabet();
    my $ncol = $self->ncol();
    my $nrow = $self->nrow();
    my $max_profile = $self->get_attribute("max_profile");
    my $comment_char = "|";

    $to_print .= "; Profile matrix\n";
    
    ## Get the consensus
    $self->calcConsensus();
    my @consensus_strict = split "|", $self->get_attribute("consensus.strict");
    my @consensus_IUPAC = split "|", $self->get_attribute("consensus.IUPAC");

    ## Get the information per column
    my @information = $self->getInformation();
    my @info_sum = &RSAT::matrix::col_sum($nrow, $ncol, @information);

    ## profile header
    $to_print .= $self->_printMatrixRow("pos", 
					@alphabet, 
					$comment_char,
					"sum",
					"max",
					"max/sum",
					"min",
					"strict",
					"IUPAC",
					"inf_sum",
					"="x$max_profile
				       );

    $to_print .= $self->_printSeparator(scalar(@alphabet)+1);

    ## print each matrix column as a row in the output
    my $matrix_max = &main::checked_max(&RSAT::matrix::col_max($nrow, $ncol, @matrix));
    my $scale = $max_profile/$matrix_max;
#	die join ("\t", $max_), "\n";
    

    for my $c (0..($ncol-1)) {
	my @row = &RSAT::matrix::get_column($c, $nrow, @matrix);
	my $sum = &main::sum(@row);
	my $max = &main::checked_max(@row);
	my $min = &main::checked_min(@row);
	my $profile = &main::round($max*$scale);
	if ($sum <= 0) {
	    $rel_max = "NA";
	} else {
	    $rel_max = sprintf("%5.2f", $max/$sum);
	}
	$to_print .= $self->_printMatrixRow($c, 
					    @row, 
					    $comment_char,
					    $sum,
					    $max,
					    $rel_max,
					    $min,
					    $consensus_strict[$c],
					    $consensus_IUPAC[$c],
					    sprintf("%5.2f",$info_sum[$c]),
					    "*"x$profile
					   );

    }
    return ($to_print);
}

################################################################
=pod

=item _printParameters()

Return a string with the parameter values

=cut 

sub _printParameters {
    my ($self, $to_print) = @_;
    $to_print .= ";\n";
    $to_print .= "; Matrix parameters\n";
    
    ## Matrix size
    $to_print .= ";\t".$self->ncol()."\tcolumns\n";
    $to_print .= ";\t".$self->nrow()."\trows\n";
    
    ## Alphabet
    $to_print .= "; Alphabet\t";
    $to_print .= join(" ", $self->getAlphabet());
    $to_print .= "\n";
    
    ## Prior probabilities
    my %prior = $self->getPrior();
    foreach my $letter (sort keys %prior) {
	$to_print .= join ("\t", ";", $letter, $prior{$letter})."\n";
    }
    
    ## Matrix attributes
    my ($proba_min, $proba_max) = $self->proba_range();
    my ($weight_min, $weight_max) = $self->weight_range();

    my @params = $self->get_attribute("parameters");
    my %printed = ();
    for my $param (@params) {
	## Print only once if the param was entered several times
	next if $printed{$param};
	$printed{$param}++;
	
	if ($self->get_attribute($param)) {
	    if (&main::IsReal($self->get_attribute($param))) {
		$to_print .= sprintf "; %-29s\t%g\n", $param, $self->get_attribute($param);
		} else {
		    $to_print .= sprintf "; %-29s\t%s\n", $param, $self->get_attribute($param);
		}
	}
    }
    return ($to_print);
}


################################################################
=pod

=item _printMatrixRow($row_name, @values)

Print a row for the matrix output.

=cut

sub _printMatrixRow {
    my ($self, $row_name, @values) = @_;
    my $row_string = $row_name;
    my $ncol = scalar(@values);

    ## Format for the matrix entries
    my $col_width = $self->get_attribute("col_width");
    my $number_width = 0;
    if ($col_width) {
  	$number_width = $col_width - 1;
    } else {
	$number_width = 5;
    }

    ## Number of decimals for floating numbers
    my $decimals = $self->get_attribute("decimals");
    unless ($decimals) {
	if ($type eq "counts") {
  	    $decimals = 0;
  	} else {
  	    $decimals = $number_width - 3;
  	}
    }

    ## Separator between columns
    my $sep = $self->get_attribute("sep") || "\t";
#    my $sep="boum";

#    &RSAT::message::Debug("w=".$col_width, "sep='".$sep."'", "pos=".$pos, "decimals=".$decimals, "number_width=".$number_width) if ($main::verbose >= 10);
    
    ## Print the matrix row
    $row_string .= $sep."|";
    for $c (0..($ncol-1)) {
	my $value = $values[$c];
	if ($col_width) {
	    my $value_format = "%${number_width}s";
	    if (&main::IsReal($value)){
		if ($type eq "counts") {
		    $value_format = "%${number_width}d";
		} else {
		    $value_format= "%${number_width}.${decimals}f";
		}
	    }
	    $row_string .= sprintf " ${value_format}", $value;
	} else {
	    $row_string .= $sep.$value;
	}
    }
    $row_string .= "\n";
    return $row_string;
}

################################################################
=pod

=item get_row($row_nb, $ncol, @table)

Return a row of the table as a list.

=cut
sub get_row {
    my ($row_nb, $ncol, @table) = @_;
    my @row = ();
    for my $c (0..($ncol-1)) {
	push @row, $table[$c][$row_nb-1];
    }
    return @row;
}

################################################################
=pod

=item get_column($col_nb, $nrow, @table)

Return a column of the table as a list.

=cut
sub get_column {
    my ($col_nb, $nrow, @table) = @_;
    my @col = ();

    for my $r (0..($nrow-1)) {
	push @col, $table[$col_nb-1][$r];
    }
    return @col;
}



################################################################
=pod 

=item col_sum($nrow, $ncol, @table)

Calculate the sum of each column of a table (is applied to the
different types of table used in this class).

Return a vector of the same length as the table width.

=cut
sub col_sum {
    my ($nrow, $ncol, @table) = @_;   
#    die join "\t", $nrow, $ncol, join( " ", @{$matrix[0]});

    warn join("\t", "; Calculating sum per column for a table",$nrow, $ncol),"\n"
	if ($main::verbose > 3);

    my @col_sum = ();
    for my $c (0..($ncol-1)) {
	my $col_sum = 0;
	for my $r (0..($nrow-1)) {
	    $col_sum += $table[$c][$r];
	}
	push @col_sum, $col_sum;
    }
    return(@col_sum);
}


################################################################
=pod 

=item col_max($nrow, $ncol, @table)

Calculate the max of each column of a table (is applied to the
different types of table used in this class).

Return a vector of the same length as the table width.

=cut
sub col_max {
    my ($nrow, $ncol, @table) = @_;

    warn join("\t", "; Calculating max per column",$nrow, $ncol),"\n"
	if ($main::verbose > 3);

    my @col_max = ();
    for my $c (0..($ncol-1)) {
	my @col_values = ();
	for my $r (0..($nrow-1)) {
	    push @col_values, $table[$c][$r];
	}
	my $col_max = &main::checked_max(@col_values);
	push @col_max, $col_max;
    }
    return(@col_max);
}

################################################################
=pod 

=item col_min($nrow, $ncol, @table)

Calculate the min of each column of a table (is applied to the
different types of table used in this class).

Return a vector of the same length as the table width.

=cut
sub col_min {
    my ($nrow, $ncol, @table) = @_;

    warn join("\t", "; Calculating min per column",$nrow, $ncol),"\n"
	if ($main::verbose > 3);

    my @col_min = ();
    for my $c (0..($ncol-1)) {
	my @col_values = ();
	for my $r (0..($nrow-1)) {
	    push @col_values, $table[$c][$r];
	}
	my $col_min = &main::checked_min(@col_values);
	push @col_min, $col_min;
    }
    return(@col_min);
}

################################################################
=pod

=item B<seq_proba($sequence)>

Calculate the probability of each segment of an input sequence. 

The probability of a segment of sequence of lenghth w is the product of the
corrected frequencies.

If the input sequence has length L > w, the return value is a vector of L-w+1
probability values.

=cut

sub seq_proba {
    my ($self, $sequence) = @_;
    my @proba = ();

    my $L = length($sequence);
    my ($nrow, $ncol) = $self->size();

    &RSAT::message::TimeWarn("seq_proba", $L) if ($main::verbose >= 0);


    if ($L < $ncol) {
	&RSAT::message::Warning("Sequence length ($L) is shorter than the matrix width ($ncol). Skipped.");
    }

    ## Iterate over sequence segments
    for my $i (0..$L-$ncol) {
	my $segment = substr($sequence, $i, $ncol);
#	my $segment_proba = 1;
#	for my $c (0..($ncol-1)) {
#	my $letter = shift @letters;
#	    my $letter = substr($segment, $c, 1);
#	    my $r = $self->{"alphabet_index"}->{$letter};
#	    my $letter_proba = $self->{"frequencies"}[$c][$r];
#	    $segment_proba *= $letter_proba;
#	}
	my $segment_proba = $self->segment_proba($segment);
	push @proba, $segment_proba;
#	&RSAT::message::Debug("segment proba", $i, $segment, $segment_proba) if ($main::verbose >= 10);
    }

    return @proba;
}



################################################################
=pod 

=item B<segment_proba($segment)>

Calculate the probability of a segment of sequence. The length of the sequence
segment must equal the matrix width.

The probability of a segment of sequence of lenghth w is the product of the
corrected frequencies.

=cut

sub segment_proba {
    my ($self, $segment) = @_;
    my $segment_proba = 1;
    my $seq_len = length($segment);
    my $r;
    for my $c (0..($seq_len-1)) {
	my $letter = uc(substr($segment, $c, 1));
	my  $letter_proba = 0;
	if (defined($self->{"alphabet_index"}->{$letter})) {
	    $r = $self->{"alphabet_index"}->{$letter};
	    $letter_proba = $self->{"frequencies"}[$c][$r];
	}
	$segment_proba *= $letter_proba;
#	&RSAT::message::Debug("segment_proba", "letter:".$letter, "col:".$c, "row:".$r, "P(letter)=".$letter_proba, "P(segm)=".$segment_proba) if ($main::verbose >= 10);
    }
    
#    &RSAT::message::Debug("segment_proba", $segment, "P(segm)=".$segment_proba) if ($main::verbose >= 0);
    return $segment_proba;
}

################################################################
=pod

=item B<proba_range()>

Return the range (min and max possible values) for a sequence segment
probability. 

The min (max) value is the product of the minimal (maximal) per column
from the matrix of corrrected frequencies.

Usage: my ($proba_min, proba_max)  = $matrix->proba_range();

=cut

sub proba_range {
    my ($self) = @_;
    my $proba_min = 1;
    my $proba_max = 1;

    ## Calculate frequencies if required
    unless ($self->get_attribute("frequencies_specified")) {
	$self->calcFrequencies();
    }

    my ($nrow, $ncol) = $self->size();
    my @frequencies = $self->getFrequencies();    

    foreach my $c (0..($ncol-1)) {
	my $col_min = 1;
	my $col_max = 0;
	foreach my $r (0..($nrow-1)) {
	    my $freq = $frequencies[$c][$r];
	    $col_min = &RSAT::stats::min($col_min, $freq);
	    $col_max = &RSAT::stats::max($col_max, $freq);
	}
	$proba_min *= $col_min;
	$proba_max *= $col_max;
    }
    
    $self->set_parameter("min(P(S|M))", $proba_min);
    $self->set_parameter("max(P(S|M))", $proba_max);
    &RSAT::message::Info(join("\t", "min(P(S|M))", $proba_min)) if ($main::verbose >= 4);
    &RSAT::message::Info(join("\t", "max(P(S|M))", $proba_max)) if ($main::verbose >= 4);
    return ($proba_min, $proba_max);
}


################################################################
=pod

=item B<weight_range()>

Return the range (min and max possible values) for a sequence segment
weight. Attention, these values are only correct for Bernoulli models.

The min (max) value is the sum of the minimal (maximal) per column
from the matrix of weights.

Usage: my ($weight_min, weight_max)  = $matrix->weight_range();

=cut

sub weight_range {
    my ($self) = @_;
    my $weight_min;
    my $weight_max;

    ## Calculate frequencies if required
    unless ($self->get_attribute("weight_specified")) {
	$self->calcWeight();
    }

    my ($nrow, $ncol) = $self->size();
    my @weights = $self->getWeights();    

    foreach my $c (0..($ncol-1)) {
	my $col_min = 0;
	my $col_max = 1;
	foreach my $r (0..($nrow-1)) {
	    my $freq = $weights[$c][$r];
	    $col_min = &RSAT::stats::min($col_min, $freq);
	    $col_max = &RSAT::stats::max($col_max, $freq);
	}
	$weight_min += $col_min;
	$weight_max += $col_max;
    }

    $self->set_parameter("min(weight)", $weight_min);
    $self->set_parameter("max(weight)", $weight_max);
    &RSAT::message::Info(join("\t", "min(weight)", $weight_min)) if ($main::verbose >= 4);
    &RSAT::message::Info(join("\t", "max(weight)", $weight_max)) if ($main::verbose >= 4);

    return ($weight_min, $weight_max);
}



return 1;


__END__

=pod

=back

