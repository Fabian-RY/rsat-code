#!/usr/bin/perl -w
############################################################
#
# $Id: footprint-scan,v 1.12 2008/06/18 15:50:20 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

footprint-scan

=head1 DESCRIPTION

Scan promoters of orthologous genes with one or several
position-specific scoring matrices (PSSM) in order to detect conserved
hits.

=head1 AUTHORS

Jacques.van.Helden@ulb.ac.be

=head1 CATEGORY

util

=head1 USAGE

footprint-scan [-i inputfile] [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=head1 SEE ALSO

=head1 WISH LIST

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "footprint.lib.pl";

################################################################
## Main package
package main;
{

  ################################################################
  ## Initialise parameters
  my $start_time = &AlphaDate();
  $program_version = do { my @r = (q$Revision: 1.12 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  %main::infile = ();
  %main::outfile = ();

  $main::verbose = 0;
  $main::in = STDIN;
  $main::out = STDOUT;

  local $no_die = 1; ## Don't die when a problem occurs
  local $skip = 0;
  local $last = 0;

  ## parameters for promoter retrieval
  local $taxon;			## Reference taxon
  local $organism_name;		## Query organism
  local @query_genes = ();	## list of query genes
  local $infer_operons = 0;     ## Infer operon leader genes
  local $dist_thr = 55;	        ## Distance threshold for operon inference
  local $sep_genes = 0;	        ## Analyze each gene separately
  local $max_genes = undef;     ## Analyze a restricted number of genes
  local $query_prefix;

  ## Matrix scanning parameters
  local @matrix_files = ();
  local $strands = "-2str"; ## Strands for pattern matching
  local $pseudo = 1;
  local $bg_pseudo = 0.05;
  local $strands = "-2str"; ## Strands for pattern discovery and pattern matching
  local $matrix_dir="data/matrices";
  local $matrix_file = $matrix_dir."/PHO4_matrix.tab";
  local $matrix_format = "tab";
  local $markov = 1;
  local $map_format = "png";
  local $plot_format = "png";
  local %lth = ();
  local %uth = ();
  local $occ_sig_opt = "";
  local $occ_sig_graph_opt = "";
  local $scan_opt = "";

  ## Supported-tasks adde to those of footprint.lib.pl
  $supported_task{occ_sig} = 1;
  $supported_task{occ_sig_graph} = 1;
  $supported_task{scan} = 1;
  $supported_task{map} = 1;
  $supported_task{synthesis} = 1;
  $supported_tasks = join (",", keys %supported_task);

  ################################################################
  ## Read argument values
  &ReadArguments();

  ################################################################
  ## Check argument values

  #### Organism
  &RSAT::OrganismManager::check_name($organism_name);
  my $organism = new RSAT::organism();
  $organism->set_attribute("name", $organism_name);
  $organism->check_name($organism_name);

  ## Check parameters for footprint analysis
  &CheckFootprintParameters();

  ################################################################
  ## Check parameters for matrix-scan
  local $ms_parameters = " -v 1";
  if (defined($main::infile{bg})) {
    $ms_parameters .= " -bgfile ".$main::infile{bg};
  } elsif ($bg_method eq "input") {
    $ms_parameters .= " -bginput ";
    if (defined($markov)) {
      $ms_parameters .= " -markov ".$markov;
    } else {
      &RSAT::error::FatalError("The option -bginput requires o specify a Markov model (option -markov)");
    }
  } else {
    &RSAT::error::FatalError("You must define a background model using either -bgfile or -bginput ");
  }

  ## Matrix file and format
  &RSAT::error::FatalError("You must specify a matrix file (option -m)") unless (scalar(@matrix_files) > 0);
  foreach my $file (@matrix_files) {
    $ms_parameters .= " -m ".$file;
  }
  &RSAT::error::FatalError("You must specify the matrix format (option -matrix_format)") unless (defined($matrix_format));
  $ms_parameters .= " -matrix_format ".$matrix_format;

  ## Matrix suffix
  &RSAT::error::FatalError("You must specify a matrix suffix (option -matrix_suffix)") unless (defined($matrix_suffix));

  ## Sequence format
  $ms_parameters .= " -seq_format fasta";

  ## Thresholds
  foreach my $key (keys(%lth)) {
    $ms_parameters .= " -lth ".$key." ".$lth{$key};
  }
  foreach my $key (keys(%uth)) {
    $ms_parameters .= " -uth ".$key." ".$uth{$key};
  }

  ## Strands
  $ms_parameters .= " ".$strands;

  ## Origin for the positions
  $ms_parameters .= " -origin -0";

  ## Pseudo-count for the matrix
  $ms_parameters .= " -pseudo ".$pseudo;

  ## Pseudo-frequency for the background model
  $ms_parameters .= " -bg_pseudo ".$bg_pseudo;

  ################################################################
  ## Analyze query genes separately or altogether
  if ($sep_genes) {
    $outfile{synthesis} = join( "/", "footprints", $taxon, $organism_name,
				join ("_", $matrix_suffix,  $organism_name, $taxon, "synthesis"));
    $outfile{synthesis_tab} = $outfile{synthesis}.".tab";
    $outfile{synthesis_html} = $outfile{synthesis}.".html";
    my $g = 0;
    my $gene_nb = scalar(@query_genes);
    local $current_gene;
    foreach $current_gene (@query_genes) {
      $g++;
      if (($skip > 0) && ($g <= $skip)) {
	&RSAT::message::Info("Skipping gene", $g."/".$gene_nb, $current_gene) if ($main::verbose >= 2);
	next;
      }
      if (($last > 0) && ($g >= $last)) {
	&RSAT::message::Info("Last gene", $g."/".$gene_nb, $current_gene) if ($main::verbose >= 2);
	last;
      }
      &RSAT::message::TimeWarn("Analyzing gene", $g."/".$gene_nb, $current_gene) if ($main::verbose >= 1);
      eval {
	&RunFootprintScan($current_gene);
      };
      if ($@) {
	if ($no_die) {
	  ## Catch error and report in in log file
	  print $out join("\t", "ERROR", $current_gene, $@);
	  &RSAT::message::Warning("ERROR", $current_gene, $@);
	} else {
	  &RSAT::error::FatalError($@);
	}
      }
    }

    ## Create the synthetic table
    if ($task{synthesis}) {

      ## Open the file for the synthetic table
      my ($syn) = &OpenOutputFile($outfile{synthesis_tab});
      my $syn_dir = `dirname $outfile{synthesis_tab}`;
      chomp($syn_dir);

      my $g = 0;
      my $occ_sig_header = "";
      foreach my $gene (sort {$top_sig{$b} <=> $top_sig{$a}} keys %top_sig) {
	$g++;

	## Grep the header for the synthesis
	unless ($occ_sig_header) {
	  $occ_sig_header = `grep '^#' $occ_sig_file{$gene}`;
	  chomp $occ_sig_header;
	  $occ_sig_header =~ s/occ_sig_rank/gene_rank/;
	  $occ_sig_header =~ s/^#//;
	  print $syn join("\t", "#gene", $occ_sig_header, "file"), "\n";
	}

	## Compute a HTML link
	my $links = "";
	if (-e $occ_sig_file{$gene}) {
	  my $file = $occ_sig_file{$gene}; $file =~ s|${syn_dir}/||g;
	  $links .= join("", "<a href='", $file, "'>[sig]</a>");
	}
	if (-e $occ_sig_graph_file{$gene}) {
	  my $file = $occ_sig_graph_file{$gene}; $file =~ s|${syn_dir}/||g;
	  $links .= join("", " <a href='", $file, "'>[sigplot]</a>");
	}
	if (-e $occ_freq_graph_file{$gene}) {
	  my $file = $occ_freq_graph_file{$gene}; $file =~ s|${syn_dir}/||g;
	  $links .= join("", " <a href='", $file, "'>[freqplot]</a>");
	}

#	&RSAT::message::Debug("SYNTHESIS DIR", $syn_dir, $sig_file, $links) if ($main::verbose >= 10);


	## Print the table
	print $syn join("\t", $gene, $top_sig_row{$gene}, $g, $links), "\n";
      }

      ## Generate the HTML table
      my $html_cmd = "add-gene-info -org ".$organism_name;
      $html_cmd .= " -i ".$outfile{synthesis_tab};
      $html_cmd .= " -info name,descr,upstr_neighb_name";
      $html_cmd .= " | text-to-html -chunk 7000 -font variable";
      $html_cmd .= " -o ".$outfile{synthesis_html};
      &doit($html_cmd, $dry, $die_on_error, $verbose, 0, $job_prefix);
    }

  } else {
    &RunFootprintScan(@query_genes);
  }

  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose);


  ################################################################
  ## Finish verbose
  if ($main::verbose >= 1) {
    my $done_time = &AlphaDate();
    print $main::out "; Job started $start_time\n";
    print $main::out "; Job done    $done_time\n";
  }


  ################################################################
  ## Close output stream
  close $main::out if ($main::outfile{output});


  ################################################################
  ## Report the index files
  if ($create_index) {
    if ($main::verbose >= 2) {
      print ("; Index files\n");
      foreach my $key (sort keys %index_list) {
	print join ("\t", ";", $key, $index_list{$key}), "\n";
      }
    }
  }

  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
#    system "pod2text -c $0";
    system "cat $0 $ENV{RSAT}/perl-scripts/lib/footprint.lib.pl | pod2text -c";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
## Read arguments 
sub ReadArguments {
  local $arg;
  local @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);

=pod

=head1 OPTIONS

=cut

    ## Read the options that are common to all footprint-detection programs
    if (&ReadFootprintOptions()) {
      next;

=pod

=over 4

=item B<-m matrixfile>

Matrix file. This argument is mandatory.

This argument can be used iteratively to scan the sequence with
multiple matrices.

=cut

    } elsif ($arg eq "-m") {
      push @matrix_files, shift(@arguments);


=pod

=item B<-matrix_format matrix_format>

Matrix format. Default is tab. This argument is mandatory.

=cut

    } elsif ($arg eq "-matrix_format") {
      $main::matrix_format = lc(shift(@arguments));

=pod

=item B<-matrix_suffix matrix_suffix>

Matrix suffix. This argument is mandatory.

The matrix suffix will be concatenated to the output prefix, in order
to maintain separate output files for distinct analyses performed on
the same promoter sequences.

=cut
    } elsif ($arg eq "-matrix_suffix") {
      $main::matrix_suffix = shift(@arguments);

=pod

=item B<-pseudo #>

Pseudo-count for the matrix (default: 1). See matrix-scan for details.

=cut
    } elsif ($arg eq "-pseudo") {
      $main::pseudo = shift(@arguments);
      &RSAT::error::FatalError(join("\t", $main::pseudo,
				    "Invalid value for pseudo count. Must be a real value."))
	unless (&IsReal($main::pseudo));

=pod

=item B<-bgfile background_file>

Background model file.

=cut
    } elsif ($arg eq "-bgfile") {
      $main::infile{bg} = shift(@arguments);

=pod

=item B<-bginput>

Calculate background model from the input sequence set.

=cut
    } elsif ($arg eq "-bginput") {
      &RSAT::error::FatalError("Options -bgfile and -bginput  are mutually exclusive") if (defined($infile{bg}));
      $main::bg_method = "input";
      &RSAT::error::FatalError("The options -bginput and -bgfile are mutually exclusive.")
	if defined($main::infile{bg});

=pod

=item B<-markov>

Order of the markov chain for the background model. 

This option is incompatible with the option -bgfile. 

=cut
    } elsif ($arg eq "-markov") {
      $main::markov = shift(@arguments);
      &RSAT::error::FatalError("Markov order must be a natural number.") 
	unless &RSAT::util::IsNatural($main::markov);
      &RSAT::error::FatalError("The options -markov and -bgfile are mutually exclusive.") 
	if defined($infile{bg});

=item B<-bg_pseudo #>

Pseudo frequency for the background model. Value must be a real
between 0 and 1.

If this option is not specified, the pseudo-frequency value depends on
the background calculation.

For -bginput and -window, the pseudo frequency is automatically
calculated from the length (L) of the sequence following this formula:

  sqrt(L)/(L+sqrt(L))

For -bgfile, default value is 0.01. 

In other cases, if the length (L) of the training sequence is known
(e.g. all promoters for the considered organism), the value can be set
manually by using the option -bg_pseudo. In such case, the background
pseudo-frequency might be set, as suggested by Thijs et al., to the
following value:

  sqrt(L)/(L+sqrt(L))


=cut
    } elsif ($arg eq "-bg_pseudo") {
      $main::bg_pseudo = shift(@arguments);
      &RSAT::error::FatalError(join("\t", $main::bg_pseudo,
				    "Invalid format for bg_pseudo, should be a Real number between 0 and 1."))
	unless ((&IsReal($main::bg_pseudo)) && (0 <= $main::bg_pseudo) && ($main::bg_pseudo <= 1));
      $main::bg_pseudo_user_specified = 1;

=pod

=item B<-occ_sig_opt>

Additional options passed to matrix-scan for the test of 
over-representation of matrix hits.

Examples:

To return only the "best" score for each gene
   -occ_sig_opt '-uth rank 1'

To analyze the distribution only above a weight threshold of 7.
   -occ_sig_opt '-lth score 7'

To analyze the distribution for sites having a P-value threshold of 1e-3.
   -occ_sig_opt '-uth pval 1e-3'

Note: the argument passed to matrix-scan is delimited by single
quotes, and can thus not contain any quote.

=cut
    } elsif ($arg eq "-occ_sig_opt") {
      my $new_occ_sig_opt = shift(@arguments);
      $occ_sig_opt .= " ".$new_occ_sig_opt;

=pod

=item B<-occ_sig_graph_opt>

Additional options passed to XYgraph for drawing the occurrence
significance graph.

Note: the argument passed to matrix-scan is delimited by single
quotes, and can thus not contain any quote.

=cut
    } elsif ($arg eq "-occ_sig_graph_opt") {
      my $new_occ_sig_graph_opt = shift(@arguments);
      $occ_sig_graph_opt .= " ".$new_occ_sig_graph_opt;

=pod

=item B<plot_format>

Format for the occurrence plots (occurrence frequencies, occurrence sinificance).
Supported: all formats supported by the program XYgraph

=cut
    } elsif ($arg eq "-plot_format") {
      $main::plot_format = shift(@arguments);

=pod

=item B<-scan_opt>

Additional options passed to matrix-scan for site detection and
feature-map drawing.

Examples:

Scan sequences with an upper threshold of 0.001 on pval.
   -scan_opt '-uth pval 0.001'

Note: the argument passed to matrix-scan is delimited by single
quotes, and can thus not contain any quote.

=cut
    } elsif ($arg eq "-scan_opt") {
      my $new_scan_opt = shift(@arguments);
      $scan_opt .= " ".$new_scan_opt;

    } else {
      &FatalError(join("\t", "Invalid option", $arg));
    }
  }


}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; footprint-scan ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	  printf $main::out ";\t%-13s\t%s\n", $key, $value;
	}
    }
}



################################################################
## Run footprint scan flow chart for one or several query genes
sub RunFootprintScan {
  local (@current_query_genes) = @_;

  local $start_time = &AlphaDate();
  local $batch_cmd = "";
  local $out = "";
  local $genes = "";


  ################################################################
  ## Initialize output directory + output files
  local $query_prefix = &GetQueryPrefix(); ## Automatic name for the query gene file
  $outfile{prefix} = &GetOutfilePrefix();
  &InitOutput();

  ## Output files for matrix-scan
  $outfile{matrix_prefix} = $outfile{prefix}."_".$matrix_suffix;
  $outfile{occ_sig} = $outfile{matrix_prefix}."_occ_sig.tab";
  $outfile{occ_freq_graph} = $outfile{matrix_prefix}."_occ_freq.".$plot_format;
  $outfile{occ_sig_graph} = $outfile{matrix_prefix}."_occ_sig.".$plot_format;
  $outfile{sites} = $outfile{matrix_prefix}."_sites.tab";
  $outfile{map} = $outfile{matrix_prefix}."_sites.".$map_format;

  ################################################################
  ## Open file to the HTML index
  &OpenIndex() if ($create_index);

  ################################################################
  ## Print query genes in the gene file
  foreach my $gene (@current_query_genes) {
    print $genes $gene, "\t", $organism_name, "\n";
  }
  &IndexOneFile("genes", $outfile{genes}) if ($create_index);

  ################################################################
  ## Print verbose
  &Verbose() if ($verbose);

  ################################################################
  ## Identify ortholog genes
  &GetOrthologs();

  ################################################################
  ## Predict operon leader genes for the orthologous genes
  &InferOrthoOperons() if ($infer_operons);

  ################################################################
  ## Retrieve sequences from orthologs
  &RetrieveOrthoSeq();

  ################################################################
  ## Purge sequences
  &PurgeOrthoSeq();

  ################################################################
  ## Scan the promoters of one group of orhtologous genes with one
  ## position-specific scoring matrix

  ## Estimate over-representation in hits for all threshold values
  &OccurrenceSig();
  &OccurrenceSigGraph();
  &GetTopSig() if (($task{synthesis}) && !($batch));

  ## Scan sequences to detect hits
  &OrthoScan();
  &OrthoMap();

  ################################################################
  ## Finish verbose
  if ($verbose >= 1) {
    my $done_time = &AlphaDate();
    print $out "; Job started $start_time\n";
    print $out "; Job done    $done_time\n";
  }

  ################################################################
  ## Close output stream
  close $out if ($outfile{log});
  close $genes if ($outfile{genes});
  if ($create_index) {
    print $index "</table>\n";
    print $index "</blockquote>";
    print $index "<hr size=2 color='#000088'>";
    print $index "</body>";
    print $index "</html>";
    close $index;
  }

  ################################################################
  ## Add one file to the index file
  sub IndexOneFile {
    my ($name, $file, %args) = @_;
    $short_file = `basename $file`;
    print $index "<tr valign=top>\n";
    print $index "<td>", $name, "</td>\n<td><a href=".$short_file.">".$short_file."</a></td>\n";
    if ($args{image}) {
      #    print $index "<td><a href=".$short_file."><img width=100 src=".$short_file."></a></td>\n";
      print $index "</tr><tr><td colspan=\"2\">(Click on image below)</td></tr><tr><td colspan=\"2\"><a href=".$short_file."><img width=\"100%\" src=".$short_file."></a></td>\n";
    }
    print $index ("</tr>\n\n");
  }


  ################################################################
  ## Send the command to a batch queue (e.g. PC cluster)
  if ($batch) {
    &doit($batch_cmd, $dry, $die_on_error, $verbose, 1, $job_prefix);
  }

}

__END__
