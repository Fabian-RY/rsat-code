################################################################
## cluster_motifs.R
##
## This script takes as input a matrix comparison file (that can be
## generated by compare-matrices), performs hierarchical
## clustering.
##
## It returns the resulting tree in json format, which can be loaded
## by the d3 library for display purposes.

## TO DO
## - Define an argument infile.consensus, providing a 3-columns file with the logo ID + its consensus in direct and reverse complementary strands. This consensus file should be exported by comapre-matrices.
## -> this consensus could e used to display trees in R, without requiring the

## Load required libraries
library("RJSONIO")
library("ctc")
library("reshape")
library("dendroextras")

## Redefine the main directory (this should be adapted to local configuration)
dir.main <- getwd()

dir.rsat <- Sys.getenv("RSAT")
if (dir.rsat == "") {
  stop("The environment variable RSAT is not defined.")
}

## Load some libraries
source(file.path(dir.rsat, 'R-scripts/config.R'))
source(file.path(dir.rsat, 'R-scripts/cluster_motifs_lib.R'))


## Options
plot.tree <- FALSE
export <- 'json'


################################################################
## Read arguments from the command line.
##
## Arguments passed on the command line will over-write the default
## arguments specified above.
args = commandArgs(trailingOnly=TRUE);
print("Parsing command-line arguments")
if (length(args >= 1)) {
  print(args)
  for(i in 1:length(args)){
    eval(parse(text=args[[i]]))
  }
}

## Check parameters
check.param()

##################################
## Read matrix comparison table
compare.matrices.table <- read.csv(infile, sep = "\t", comment.char = ";")
names(compare.matrices.table)[1] <- sub("^X.", "", names(compare.matrices.table)[1])


################################################################
## Read description table 
description.table <- read.csv(description.file, sep = "\t", comment.char = ";")
matrix.labels <-  as.vector(description.table$label)
names(matrix.labels) <- as.vector(description.table$id)

##############################################
## Extract the score from the matrix comparison table

## Check that the compare-matrices table contains the required score column
if (length(grep(pattern=score, names(compare.matrices.table))) < 1) {
  stop(paste(sep="", "Input file (", infile, ") does not contain the score column (", score, ")."))
}

## Extract score values
score.values <- compare.matrices.table[,score]

################################################################
## Convert user-selected score to distance metrics
convert.scores(score.values, score)

## Add a column with score column to the compare matrices table, will
## be used to generate a cross-table
compare.matrices.table$score.dist <- score.dist

################################################################
## Build a distance matrix from the distance score list
dist.table <- t(xtabs(score.dist ~ name1+name2, compare.matrices.table) )
## Ensure that symmetrical distances are defined
for (i in 1:nrow(dist.table)) {
  for (j in i:ncol(dist.table)) {
    if (i==j) {next}
    dist.max <- max(dist.table[i,j], dist.table[j,i])
    dist.table[i,j] <- dist.max
    dist.table[j,i] <- dist.max
  }
}
#print(dist.table)
write.table(dist.table, file = distance.table, quote = FALSE, row.names = TRUE, col.names=NA, sep = "\t")

## Convert distance table into a distance matrix, required by hclust()
dist.matrix <- as.dist(dist.table)

################
### Inefficient (but probably more robust) way to build a distance matrix, involving two loops
## matrix.names <- sort(unique(as.vector(as.matrix((compare.matrices.table[,c(1,2)])))))
## matrix.nb <- length(matrix.names)
## dist.matrix <- data.frame(matrix(NA, nrow=matrix.nb, ncol=matrix.nb))
## names(dist.matrix) <- matrix.names
## rownames(dist.matrix) <- matrix.names
## for (i in 1:matrix.nb) {
##   for (j in i:matrix.nb) {
##     ## Identify the relevant rows in matrix comparison table
##     matrix.id1 <- matrix.names[i]
##     matrix.id2 <- matrix.names[j]
##     matches <- ((compare.matrices.table[,1] == matrix.id1 & compare.matrices.table[,2] == matrix.id2) |
##                 (compare.matrices.table[,1] == matrix.id2 & compare.matrices.table[,2] == matrix.id1))
##     if (sum(matches) >= 1) {
##       current.score <- compare.matrices.table[which(matches),score]
##     } else {
##       current.score <- "NA"
##     }    
##     dist.matrix[i,j] <- current.score
##     dist.matrix[j,i] <- current.score
##   }
## }


##############################################
### Build the tree by hierarchical clustering, and export it in Newick format
tree <- hclust(dist.matrix, method = hclust.method)
tree$labels <- as.vector(description.table$label)
if (plot.tree) {
  plot(tree) 
}
if (export == "newick") {
  newick.file <- paste(sep='.', out.prefix, "newick")
  verbose(paste("Exporing newick file", newick.file), 1)
  write(hc2Newick(tree, flat = TRUE), file=newick.file)
}

#######################################
### Creates and parse the json file
halfway.tree <- hclustToTree(tree)
jsonTree <- toJSON(halfway.tree)
## Fix some little technical issues for JSON compatibility with the tree display javascript
jsonTree <- gsub("\\],", "\\]", jsonTree, perl = TRUE)
jsonTree <- paste("{\n\"name\": \"\",\n\"children\":", jsonTree, "}", sep = "")
jsonTree <- gsub("\n\"order\":\\s+\\d+", "", jsonTree, perl = TRUE)
#jsonTree <- gsub(",\\s*\n\\s*}", "\n}", jsonTree, perl = TRUE)


#############################
### Prints the .json file 
json.file <- paste(out.prefix, ".json", sep="")
verbose(paste("JSON tree file", json.file), 1)
writeLines(jsonTree, con=json.file)



## ################################
## ################################
## Jaime: please check if the following commented code is still required

## ################################
## ## Convert distance matrix (one row per motif x one column per motif)
## ## into a distance table, with one row per matrix pair.
## m <- as.matrix(dist.matrix)
## row.names(m) <- as.vector(description.table$label)
## colnames(m) <- as.vector(description.table$label)
## m2 <- melt(m)[melt(upper.tri(m))$value,]
## names(m2) <- c(";label1", "label2", "distance")
## write.table(m2, file = distance.table, quote = FALSE, row.names = FALSE, sep = "\t")



###########################
### Traversing the tree ###
###########################

#tree$labels <- as.vector(description.table$consensus)
tree$labels <- paste(as.vector(description.table$consensus), 1:length(description.table$consensus))

#############################################################
## Bottom-up traversal of the tree to orientate the logos
merge.level <- 1
motifs.info <- list()

merge.levels.leaves <- leaves.per.node(tree)
for (merge.level in 1:nrow(tree$merge)) {

  child1 <- tree$merge[merge.level,1]
  child2 <- tree$merge[merge.level,2]

  ########################################
  ## Case 1: merging between two leaves ##
  ########################################
  if ((child1 < 0) && (child2 < 0)) {
    
    ## Identify the two motifs
    n1 <- min(-child1,-child2) ## row number of the first motif in the description table
    n2 <- max(-child1,-child2) ## row number of the second motif in the description table
    
    id1 <- get.id(n1) ## Id of the first motif
    id2 <- get.id(n2) ## Id of the second motif
    
    ## Comparison number in the compare-matrices table
    compa.nb <- get.compa.nb(id1,id2)
    
    ## Choose the relative orientation of the two motifs
    strand <- as.vector(compare.matrices.table[compa.nb, "strand"])
    consensus1 <- as.vector(description.table[n1,"consensus"]) ## Consensus of the first motif
    motifs.info[[id1]][["strand"]] <- "D" 
    if (strand == "R") {
      consensus2 <- as.vector(description.table[n2,"rc_consensus"]) ## Consensus of the second motif
      motifs.info[[id2]][["strand"]] <- "R"
    } else {
      consensus2 <- as.vector(description.table[n2,"consensus"]) ## Consensus of the second motif
      motifs.info[[id2]][["strand"]] <- "D"
    }
    
    ## Add the offset to the logos
    offset <- as.vector(compare.matrices.table[compa.nb, "offset"])
    spacer <- paste(collapse="",rep(x="-",times=abs(offset)))
    
    if (offset < 0) {
      consensus1 <- paste(sep="", spacer, consensus1)
    } else {
      consensus2 <- paste(sep="", spacer, consensus2)
    }
    
    ## Reset the consensus with the aligned and re-oriented consensus
    tree$labels[n1] <- paste(consensus1, n1)      
    tree$labels[n2] <- paste(consensus2, n2)
    
    ## Store the strand of the cluster, the consensuses and numbers
    motifs.info[[id1]][["consensus"]] <- consensus1
    motifs.info[[id1]][["number"]] <- n1
    
    motifs.info[[id2]][["consensus"]] <- consensus2
    motifs.info[[id2]][["number"]] <- n2

    motifs.info[[id1]][["spacer"]] <- length(unlist(strsplit(motifs.info[[id1]][["consensus"]], "-")))-1
    motifs.info[[id2]][["spacer"]] <- length(unlist(strsplit(motifs.info[[id2]][["consensus"]], "-")))-1
  }


  ############################################
  ## Case 2: merging a motif with a cluster ##
  ############################################
  if(((child1 < 0) && (child2 > 0)) || ((child1 > 0) && (child2 < 0))){
    
    n1 <- abs(min(child1, child2))
    n2 <- merge.levels.leaves[[merge.level]][which(merge.levels.leaves[[merge.level]] != n1)]
    N2 <- abs(max(child1, child2))
    
    ## Get ids
    motifs.info[[get.id(n1)]][["number"]] <- as.numeric(n1)
    motifs.info[[get.id(n1)]][["spacer"]] <- 0
    ids2 <- get.id(n2)
    
    ## Find the central motif of the cluster
    central.motifs <- central.motifs.ids(get.id(n1), ids2)
    id1 <- central.motifs[1]
    id2 <- central.motifs[2]
    
    ## Get the comparison number in the compare-matrices table
    compa.nb <- get.compa.nb(id1,id2)
    
    ## Get the strand
    strand <- as.vector(compare.matrices.table[compa.nb, "strand"])
    
    ## Identified the new and the aligned motif
    switch.ids <- 0
    if(length(motifs.info[[id1]]) > 2){
      aligned <- id1
      new <- id2
      temporal <- n1
      n1 <- n2
      n2 <- temporal
      switch.ids <- 1
    } else{
      aligned <- id2
      new <- id1
    }

    ## Get the offset
    offset <- as.vector(compare.matrices.table[compa.nb, "offset"])

    ## Assign values for the cases
    case <- 0
    if(switch.ids == 1){
      
      if(strand == "D"){
        
        if(motifs.info[[aligned]][["strand"]] == "D"){
          case <- 1
        } else{
          case <- 2
        }
      } else{
       if(motifs.info[[aligned]][["strand"]] == "D"){
          case <- 3
        } else{
          case <- 4
        } 
      }
    }else{
      if(strand == "D"){
        if(motifs.info[[aligned]][["strand"]] == "D"){
          case <- 5
        } else{
          case <- 6
        }
      } else{   
        if(motifs.info[[aligned]][["strand"]] == "D"){
          case <- 7
        } else{
          case <- 8
        } 
      } 
    }

    ## Get the spacers
    aligned.spacer <- as.numeric(motifs.info[[aligned]][["spacer"]])
    new.spacer <- as.numeric(motifs.info[[new]][["spacer"]])

    ## Choose the consensus for the new motif
    consensus.new <-as.vector(description.table[as.numeric(motifs.info[[new]][["number"]]),"consensus"])
    motifs.info[[new]][["strand"]] <- "D"
    motifs.info[[new]][["consensus"]] <- consensus.new
    
    ## Reset the offset
    if(case %in% c(1,3,5,8)){

      if(case == 3){
        ids <- get.id(n2)
        inverted.aligment.ids <- inverted.aligment(ids)
        for(id in names(inverted.aligment.ids)){
          motifs.info[[id]] <- inverted.aligment.ids[[id]]
        }
        new.spacer <- as.numeric(motifs.info[[new]][["spacer"]])
      }

      if(case %in% c(1,3)){
        spacer.diff <- (aligned.spacer - new.spacer)
      } else if (case %in% c(5,8)){
        spacer.diff <- (new.spacer - aligned.spacer)
      }
      
      offset <- offset + spacer.diff
      
    } else if(case %in% c(2,4,6,7)){

      ## Get the ids of the aligment that will be inverted
      if(case %in% c(2,4)){
        ids <- get.id(n2)
      } else if(case %in% c(6,7)){
        ids <- get.id(n1)
      }
      
      ## Invert the aligment and store the information in a list
      inverted.aligment.ids <- inverted.aligment(ids)
      
      ## Change the information in motifs.info list
      for(id in names(inverted.aligment.ids)){
        motifs.info[[id]] <- NULL
        motifs.info[[id]] <- inverted.aligment.ids[[id]]
      }
      
      aligned.spacer <- as.numeric(motifs.info[[aligned]][["spacer"]])
      new.spacer <- as.numeric(motifs.info[[new]][["spacer"]])

      if(case %in% c(6,7)){
        length.diff <- nchar(as.vector(description.table[as.numeric(motifs.info[[new]][["number"]]), "consensus"])) - nchar(as.vector(description.table[as.numeric(motifs.info[[aligned]][["number"]]), "consensus"]))
        spacer.diff <- (new.spacer - aligned.spacer)
      } else if(case %in% c(2,4)){
        length.diff <- nchar(as.vector(description.table[as.numeric(motifs.info[[aligned]][["number"]]), "consensus"])) - nchar(as.vector(description.table[as.numeric(motifs.info[[new]][["number"]]), "consensus"]))
        spacer.diff <- (aligned.spacer - new.spacer)
      }

      offset <- length.diff - offset + spacer.diff
      tree$labels[as.numeric(motifs.info[[new]][["number"]])] <- paste(motifs.info[[new]][["consensus"]], as.numeric(motifs.info[[new]][["number"]]))
    }

    ## Create the spacer
    spacer <- paste(collapse="",rep(x="-",times = abs(offset)))

    ##
    if(offset <= 0){
    
      for (id in get.id(n1)){
        motifs.info[[id]][["consensus"]] <- paste(spacer, motifs.info[[id]][["consensus"]], sep="")
        motifs.info[[id]][["spacer"]] <- length(unlist(strsplit(motifs.info[[id]][["consensus"]], "-")))-1
        tree$labels[as.numeric(motifs.info[[id]][["number"]])] <- paste(motifs.info[[id]][["consensus"]], as.numeric(motifs.info[[id]][["number"]]))
      }
    }
    else{
      
      for (id in get.id(n2)){
        motifs.info[[id]][["consensus"]] <- paste(spacer, motifs.info[[id]][["consensus"]], sep="")
        motifs.info[[id]][["spacer"]] <- length(unlist(strsplit(motifs.info[[id]][["consensus"]], "-")))-1
        tree$labels[as.numeric(motifs.info[[id]][["number"]])] <- paste(motifs.info[[id]][["consensus"]], as.numeric(motifs.info[[id]][["number"]]))
      }
    }
  }


  ##########################################
  ## Case 3: merging between two clusters ##
  ##########################################
  if ((child1 > 0) && (child2 > 0)) {

    N1 <- abs(min(child1, child2))
    N2 <- abs(max(child1, child2))
    
    n1 <- merge.levels.leaves[[N1]]
    n2 <- merge.levels.leaves[[N2]]

    ## Get ids
    ids1 <- get.id(n1)
    ids2 <- get.id(n2)
    
    ## Find the central motif of the cluster
    central.motifs <- central.motifs.ids(ids1, ids2)
    id1 <- central.motifs[1]
    id2 <- central.motifs[2]
    
    ## Get the comparison number in the compare-matrices table
    compa.nb <- get.compa.nb(id1,id2)
    
    ## Get the strand
    strand <- as.vector(compare.matrices.table[compa.nb, "strand"])

    ## Get the previous orientation of the aligned motifs
    prev.strand.1 <- motifs.info[[id1]][["strand"]]
    prev.strand.2 <- motifs.info[[id2]][["strand"]]
    change.offset <- 0

    ## Get the offset
    offset <- as.vector(compare.matrices.table[compa.nb, "offset"])

    ## Switch the ids
    if(id1 %in% ids2 == TRUE){
      temporal <- ids2
      ids1 <- ids2
      ids2 <- temporal
    }

    ## Get the current spacer of both motifs
    cluster.1.spacer <- as.numeric(motifs.info[[id1]][["spacer"]])
    cluster.2.spacer <- as.numeric(motifs.info[[id2]][["spacer"]])
    case <- 0

    ## Assign the value for the cases
    if(strand == "D"){
      if(prev.strand.1 == "R" && prev.strand.2 == "R"){
        case <- 1	
      } else if(prev.strand.1 == "R" && prev.strand.2 == "D"){
        case <- 2	
      } else if(prev.strand.1 == "D" && prev.strand.2 == "R"){
        case <- 3	
      } else if(prev.strand.1 == "D" && prev.strand.2 == "D"){
        case <- 4	
      }
    }else{
      if(prev.strand.1 == "R" && prev.strand.2 == "R"){
        case <- 5	
      } else if(prev.strand.1 == "R" && prev.strand.2 == "D"){
        case <- 6	
      } else if(prev.strand.1 == "D" && prev.strand.2 == "R"){
        case <- 7	
      } else if(prev.strand.1 == "D" && prev.strand.2 == "D"){
        case <- 8	
      }
    }
    
    ## Cases in which is required invert the aligment
    if(case %in% c(2,3,8)){
      
      ## Get the ids of the aligment that will be inverted
      ids <- get.id(n2)
      
      ## Invert the aligment and store the information in a list
      inverted.aligment.ids <- inverted.aligment(ids)
      
      ## Change the information in motifs.info list
      for(id in names(inverted.aligment.ids)){
        motifs.info[[id]] <- inverted.aligment.ids[[id]]
      }
      
      cluster.1.spacer <- as.numeric(motifs.info[[id1]][["spacer"]])
      cluster.2.spacer <- as.numeric(motifs.info[[id2]][["spacer"]])  
    }
    
    ## According to the cases, reset the offset
    if(case %in% c(1,2,5,6)){
      offset <- nchar(as.vector(description.table[as.numeric(motifs.info[[id1]][["number"]]), "consensus"])) - nchar(as.vector(description.table[as.numeric(motifs.info[[id2]][["number"]]), "consensus"]))  - offset + (cluster.1.spacer - cluster.2.spacer)
    } else if(case %in% c(3,4,7,8)){
      offset <- offset + (cluster.1.spacer - cluster.2.spacer)
    }
    
    ## Add the spacer to the motifs
    if(offset <= 0){
      spacer <- paste(collapse="",rep(x="-",times = abs(offset)))
      
      for (id in ids1){
        motifs.info[[id]][["consensus"]] <- paste(spacer, motifs.info[[id]][["consensus"]], sep="")
        motifs.info[[id]][["spacer"]] <- length(unlist(strsplit(motifs.info[[id]][["consensus"]], "-")))-1
        tree$labels[as.numeric(motifs.info[[id]][["number"]])] <- paste(motifs.info[[id]][["consensus"]], as.numeric(motifs.info[[id]][["number"]]))
      }
    }
    else{
      spacer <- paste(collapse="",rep(x="-",times = abs(offset)))
      
      for (id in ids2){
        motifs.info[[id]][["consensus"]] <- paste(spacer, motifs.info[[id]][["consensus"]], sep="")
        motifs.info[[id]][["spacer"]] <- length(unlist(strsplit(motifs.info[[id]][["consensus"]], "-")))-1
        tree$labels[as.numeric(motifs.info[[id]][["number"]])] <- paste(motifs.info[[id]][["consensus"]], as.numeric(motifs.info[[id]][["number"]]))
      }
    }
  }
}

## Jaime: aqui tienes que recoger el ancho del alineamiento + espacio para los numeros (3 letras)
## Y adaptar para que el parametro mar este correcto
alignment.width <- 23

## Export the tree with the aligment
plot.format <- "pdf" ## Default for testing inside the loop
for (plot.format in c("pdf", "png")) {
  w.inches <- 10 ## width in inches
  h.inches <- 7 ## height in inches
  resol <- 72 ## Screen resolution
  tree.drawing.file <- paste(sep="", out.prefix, "_hclust_tree.", plot.format)
  verbose(paste("Exporting hclust tree drawing", tree.drawing.file), 1)
  if (plot.format == "pdf") {
    pdf(file=tree.drawing.file, width=w.inches, height=h.inches)
  } else if (plot.format == "png") {
    png(filename=tree.drawing.file, width=w.inches*resol, height=h.inches*resol)
  }
 #dev.new(width=10, height=7)
  par(mar=c(3,2,1,alignment.width),family="mono")
  plot(as.dendrogram(tree), horiz=TRUE)
  dev.off()
}

## Produce the aligment table
alignment.table <- lapply(motifs.info, function(X){
  return(c(X[["number"]], X[["strand"]], X[["spacer"]], X[["consensus"]]))
})
alignment.table <- as.data.frame(t(data.frame(alignment.table)))
alignment.table$id <- as.vector(rownames(alignment.table))
alignment.table <- alignment.table[,c(5,1:4)]
colnames(alignment.table) <- c("#id", "number", "strand", "offset", "aligned_consensus")
alignment.file <- paste(sep="", out.prefix, "_alignment_table.tab")
write.table(alignment.table, alignment.file, sep = "\t", quote = FALSE, row.names = FALSE)



