#!/usr/bin/perl -w
############################################################
#
# $Id: chip-motifs,v 1.37 2010/04/16 08:14:46 jvanheld Exp $
#
############################################################

## use strict;

=pod

=head1 NAME

chip-seq-analysis

=head1 VERSION

$program_version

=head1 DESCRIPTION

Pipeline for discoering motifs from ChIP-seq (or ChIP-chip) peak
sequences.

=head1 AUTHORS

=over

=item Jacques van Helden <Jacques.van.Helden@ulb.ac.be>

=item Morgane Thomas-Chollier <thomas-c@molgen.mpg.de>

=item Matthieu Defrance <defrance@ccg.unam.mx>

=item Olivier Sand <oly@bigre.ulb.ac.be> for the Web services

=back


=head1 CATEGORY

Pattern discovery

=head1 USAGE

chip-seq-analysis [-i inputfile] [-o outputfile] [-v #] [...]

=head1 INPUT FORMAT

The program takes as input either one (test) or two sequence files
(test versus control).

All input sequences formats supported by convert-sequences are
supported.

=head1 OUTPUT FORMAT

The pipeline runs a series of programs generating each one or several
result file. An HTML index is generated in order to synthesize the
results and give access to the individual result files. 

The index file is formed from the output directory (option -outdir)
and the file prefix (option -prefix).

  [output_dir]/[prefix]_synthesis.html

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require "RSA.disco.lib";
require "footprint.lib.pl";
use RSAT::util;


################################################################
## Main package
package main;
{

  ################################################################
  ## Initialize parameters

  ## Check that the RSAT paths of the programs required for the script are specified
  $PYTHON =  $ENV{RSAT}."/python_scripts" unless ($PYTHON);
  $SCRIPTS = $ENV{RSAT}."/perl-scripts" unless ($SCRIPTS);
  $BIN = $ENV{RSAT}."/bin" unless ($BIN);

  my $start_time = &AlphaDate();
  $program_version = do { my @r = (q$Revision: 1.37 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  #    $program_version = "0.00";

  %main::param = ();
  @main::param_list = ();

  %main::dir = ();
  %main::infile = ();
  %main::outfile = ();

  $main::verbose = 0;
  $main::out = STDOUT;

  ## Sequence types (can be eiter 'test' or 'test' + 'ctrl')
  @seq_types = ();

  ## Pattern types (oligos, positions, local-word-analysis,... with the oligo length suffix)
  @pattern_types = ();


  ################################################################
  ## Supported tasks
  @supported_tasks = qw (
			 all
			 seqlen
			 purge
			 profiles

			 oligos
			 dyads
			 positions
			 local_words

			 oligo_diff

			 ref_motif
			 word_compa
			 motif_compa
			 synthesis
			 clean_seq
			);

  my @future_tasks = qw(
			motif_cluster
			oligo-diff
			tomtom
			to_bed
		       );
  $supported_tasks = join ",", @supported_tasks;
  %supported_task = ();
  foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
  }
  %task = ();			## List of tasks to be executed


  ################################################################
  ## Set default parameters
  &DefaultParameters();

  ################################################################
  ## Read argument values
  &ReadArguments();

  &CheckArguments();

  &SetOutFileNames();

  ################################################################
  ## Open output stream
  $main::out = &OpenOutputFile($main::outfile{log});

  ################################################################
  ## Print verbose
  &Verbose() if ($main::verbose);

  foreach my $seq_type (@seq_types) {
      &PurgeOneSeq($infile{$seq_type.'_seq'}, $seq_type) if ($task{purge});
      &SequenceLengths($infile{$seq_type.'_seq'}, $seq_type) if ($task{seqlen});
      &CompositionProfiles($infile{$seq_type.'_seq'}, $seq_type) if ($task{profiles});
    }

  if ($main::infile{ctrl_seq}) {
    &OligoDiff() if ($task{oligo_diff});
  } else {
    &OligoAnalysis() if ($task{oligos});
    &DyadAnalysis() if ($task{dyads});
    &PositionAnalysis() if ($task{positions});
    &LocalWords() if ($task{local_words});
  }

  if (defined($main::infile{ref_motif})) {
    &RefMotif() if ($task{ref_motif});
  }

  &WordsVersusWords() if ($task{word_compa});

  &MotifVersusMotifs() if ($task{motif_compa});

  &Synthesis() if ($task{synthesis});

  &CleanSequences() if ($task{clean_seq});

  if ($main::verbose >= 1) {
    &TimeWarn("Log file", $main::outfile{log});
  }

  print $out &RSAT::util::ReportExecutionTime($start_time) if ($main::verbose >= 1);

  ################################################################
  ## Close output stream
  close $main::out if ($main::outfile{output});
  exit(0);
}

################################################################
################### SUBROUTINE DEFINITION ######################
################################################################


################################################################
## Display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
## Display short help message
sub PrintOptions {
    &PrintHelp();
}


################################################################
## Set parameter values for all the programs
sub DefaultParameters {
  &RSAT::message::TimeWarn("Setting default parameter values") if ($main::verbose >= 1);

  ## Formats
  $main::param{seq_format} = "fasta"; push(@main::param_list, "seq_format");
  $main::param{img_format} = "png"; push(@main::param_list, "img_format");

  ## Motif formats
  $main::param{ref_motif_format} = "jaspar"; push(@main::param_list, "ref_motif_format");
  $main::param{db_motif_format} = "jaspar"; push(@main::param_list, "db_motif_format");

  ## Purge-seq
  $main::param{purge_match_length} = 30; push(@main::param_list, "purge_match_length");
  $main::param{purge_mismatches} = 0; push(@main::param_list, "purge_mismatches");

  ## residue profiles (position-analysis)
  $main::param{profiles_ci} = 10; push(@main::param_list, "profiles_ci");
  $main::param{profiles_max_graphs} = 20; push(@main::param_list, "profiles_ci");
  $main::param{profiles_strand} = "-2str"; push(@main::param_list, "profiles_strand");
  @main::profiles_oligo_lengths = (1,2);
  $main::param{profiles_oligo_lengths} = join(',',@profiles_oligo_lengths); push(@main::param_list, "profiles_oligo_lengths");

  ## Pattern discovery options
  $main::param{min_ratio} = 1; push(@main::param_list, "strand"); ## For oligo-analysis, dyad-analysis and oligo-diff
  $main::param{min_sig} = 0; push(@main::param_list, "strand");
  $main::param{strand} = "-2str"; push(@main::param_list, "strand");
  $main::param{noov} = "-noov"; push(@main::param_list, "noov");
  $main::param{oligo_min_len} = 6; push(@main::param_list, "oligo_min_len");
  $main::param{oligo_max_len} = 7; push(@main::param_list, "oligo_max_len");
  $main::param{patterns_max_rank} = 25; push(@main::param_list, "patterns_max_rank");

  ## oligo-analysis
  $main::param{oligo_min_mkv} = -3; push(@main::param_list, "oligo_min_mkv");
  $main::param{oligo_max_mkv} = -3; push(@main::param_list, "oligo_max_mkv");

  ## dyad-analysis

  ## position-analysis
  $main::param{positions_ci} = 20; ## Class interval for position-analysis

  ## local-word-analysis
  $main::param{local_words_ci} = 20; ## Class interval for local-word-analysis

  ## matrix-from-patterns
  $main::param{matrix_nmotifs} = 3; push(@main::param_list, "matrix_nmotifs");


}


################################################################
## Define one output file name by concatenating arguments
sub OutFileName {
    my ($extension, @name_elements) = @_;
    my $out_file_name = $dir{output}."/".$main::param{prefix};
    $out_file_name .= join ("_", @name_elements);
    $out_file_name .= $extension;
    return($out_file_name);
}



################################################################
## Set output file names
sub SetOutFileNames {
  ## Purged sequences
  foreach my $seq_type (@seq_types) {
    $main::outfile{"purged_".$seq_type} = &OutFileName(".fasta", 
						 $seq_type,
						 "purged",
						 "ml".$main::param{purge_match_length},
						 "mis".$main::param{purge_mismatches});


    ## Sequence lengths
    $main::outfile{$seq_type."_seqlen"} = &OutFileName(".tab", $seq_type."_seqlen");
    $main::outfile{$seq_type."_seqlen_distrib"} = &OutFileName(".tab", $seq_type."_seqlen_distrib");
    $main::outfile{$seq_type."_seqlen_distrib_graph"} = &OutFileName(".".$param{img_format}, $seq_type."_seqlen_distrib");
#    if ($infile{ctrl_seq}) {
#	$main::outfile{"ctrl_seqlen"} = &OutFileName(".tab", "ctrl_seqlen");
#	$main::outfile{"ctrl_seqlen_distrib"} = &OutFileName(".tab", "ctrl_seqlen_distrib");
#	$main::outfile{"ctrl_seqlen_distrib_graph"} = &OutFileName($param{img_format}, "ctrl_seqlen_distrib");
#    }

    ## Compositional Profiles
    for my $ol (@profiles_oligo_lengths) {
      ## Profiles of oligo frequencies as a function of the position
      $main::outfile{$ol."nt_".$seq_type."_profiles"} = &OutFileName(".tab", $seq_type."_profiles".$main::param{profiles_strand}.$main::param{noov},$ol."nt",
						       "ci".$main::param{profiles_ci});

      ## oligo frequencies in the sequence set
      $main::outfile{$ol."nt_".$seq_type."_freq"} = &OutFileName(".tab", $seq_type."_freq"."-1str".$main::param{noov},$ol."nt");
      $main::outfile{$ol."nt_".$seq_type."_transit"} = &OutFileName(".tab", $seq_type."_transitions"."-1str".$main::param{noov},$ol."nt");
      $main::outfile{$ol."nt_".$seq_type."_heatmap"} = &OutFileName(".".$main::param{img_format}, $seq_type."_heatmap"."-1str".$main::param{noov},$ol."nt");

      ## HTML index to the individual oligonucleotide profiles
      $main::outfile{$ol."nt_".$seq_type."_profiles_index"} = $main::outfile{$ol."nt_".$seq_type."_profiles"};
      $main::outfile{$ol."nt_".$seq_type."_profiles_index"} =~ s/\.tab$//;
      $main::outfile{$ol."nt_".$seq_type."_profiles_index"} .= "_graph_index.html";
    }

    ## Compositional profiles
    for my $ol (1,2) {
      $main::outfile{$ol."nt_".$seq_type."_profiles_graph"} = $main::outfile{$ol."nt_".$seq_type."_profiles"};
      $main::outfile{$ol."nt_".$seq_type."_profiles_graph"} =~ s/\.tab$//;
      $main::outfile{$ol."nt_".$seq_type."_profiles_graph"} .= ".".$main::param{img_format};
    }
  }

  ## Reference motif
  if (defined($main::infile{ref_motif})) {
    $main::outfile{"ref_motif"} = &OutFileName($main::param{ref_motif_format}, "ref_motif");
    $main::outfile{"ref_motif_transfac"} = &OutFileName(".tf", "ref_motif");
    $main::outfile{"ref_motif_info"} = &OutFileName(".tab", "ref_motif_info");
    $main::outfile{"ref_motif_logo"} = &OutFileName("", "ref_motif_logo");
    $main::outfile{"ref_motif_enriched"} = &OutFileName("tab", "ref_motif_enriched");
  }

  ################################################################
  ## Pattern discovery results
  my $pattern_type = "";
  if ($main::infile{ctrl_seq}) {
    for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
      ## oligo-diff
      $pattern_type = 'oligo_diff_'.$len.'nt';
      $main::outfile{$pattern_type} = &OutFileName(".tab", "oligo_diff".$main::param{strand}.$main::param{noov},$len."nt");
      push @pattern_types, $pattern_type;
    }
  } else {
    for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
      for my $markov ($main::param{oligo_min_mkv}..$main::param{oligo_max_mkv}) {
	## Convert negative markov orders relative to the oligo length
	$markov += $len if ($markov < 0);
	## oligo-analysis
	$pattern_type = 'oligos_'.$len.'nt_mkv'.$markov;
	$main::outfile{$pattern_type} = &OutFileName(".tab", "oligos".$main::param{strand}.$main::param{noov},
						     $len."nt", "mkv".$markov);
	push @pattern_types, $pattern_type;

	## local-word-analysis
	$pattern_type = 'local_words_'.$len.'nt_mkv'.$markov;
	$main::outfile{$pattern_type} = &OutFileName(".tab", "local_words".$main::param{strand}.$main::param{noov},
						     $len."nt", "ci".$main::param{local_words_ci},
						     "mkv".$markov);
	push @pattern_types, $pattern_type;
      }
      ## position-analysis
      $pattern_type = 'positions_'.$len.'nt';
      $main::outfile{$pattern_type} = &OutFileName(".tab", "positions".$main::param{strand}.$main::param{noov},
						   $len."nt", "ci".$main::param{positions_ci});
      push @pattern_types, $pattern_type;
    }

    ## dyad-analysis
    $main::outfile{dyads} = &OutFileName(".tab", "dyads".$main::param{strand}.$main::param{noov},
					 "3nt_sp0-20_bg_monads");
    push @pattern_types, "dyads";
  }

  &RSAT::message::Info("Pattern types", join (",", @pattern_types)) if ($main::verbose >= 1);
  &RSAT::message::Info("Sequence types", join (",", @seq_types)) if ($main::verbose >= 1);

  ## Conversion from patterns to matrices + logos
  foreach my $pattern_type (@pattern_types) {
    $main::outfile{$pattern_type.'_pssm'} = $main::outfile{$pattern_type};
    $main::outfile{$pattern_type.'_pssm'} =~ s/\.tab$//;
    $main::outfile{$pattern_type.'_pssm'} .= "_pssm";
    $main::outfile{$pattern_type.'_asmb'} = $main::outfile{$pattern_type.'_pssm'}.".asmb";
    $main::outfile{$pattern_type.'_pssm_sig'} = $main::outfile{$pattern_type.'_pssm'}."_sig_matrices.txt";
    $main::outfile{$pattern_type.'_pssm_gibbs'} = $main::outfile{$pattern_type.'_pssm'}."_gibbs_matrices.txt";
    $main::outfile{$pattern_type.'_pssm_counts'} = $main::outfile{$pattern_type.'_pssm'}."_count_matrices.txt";
    foreach my $logo_nb (1..$main::param{matrix_nmotifs}) {
      $main::outfile{$pattern_type.'_pssm_logo'.$logo_nb} = $main::outfile{$pattern_type.'_pssm'}."_gibbs_matrices_m".$logo_nb."_logo.".$main::param{img_format};
      $main::outfile{$pattern_type.'_pssm_logo_rc'.$logo_nb} = $main::outfile{$pattern_type.'_pssm'}."_gibbs_matrices_m".$logo_nb."_logo_rc.".$main::param{img_format};
    }
  }

  ## Comparison between significance of the discovered patterns
  $main::outfile{word_compa} = &OutFileName(".tab", "word_comparison");
  $main::outfile{word_compa_heatmap} = &OutFileName(".png", "word_comparison_heatmap");

  ## Synthesis of the discovered motifs + comparison with reference motif and annotated motifs
  $main::outfile{motifs_discovered} = &OutFileName(".tf", "motifs_discovered");
  $main::outfile{motifs_disco_compa} = &OutFileName(".tab", "motifs_disco_compa");
  $main::outfile{motifs_disco_compa_clusters_mcl} = &OutFileName(".mcl", "motifs_disco_compa_clusters");
  $main::outfile{motifs_disco_compa_clusters_tab} = &OutFileName(".tab", "motifs_disco_compa_clusters");
  $main::outfile{motifs_disco_compa_clusters_graph} = &OutFileName(".tab", "motifs_disco_compa_clusters_graph");
  $main::outfile{motifs_disco_compa_cluster_intra_degree} = &OutFileName(".tab", "motifs_disco_compa_cluster_intra_degree");
  $main::outfile{motifs_disco_compa_gml} = &OutFileName(".gml", "motifs_disco_compa");
  #    $main::outfile{motifs_disco_compa_dot} = &OutFileName(".dot", "motifs_disco_compa");
  $main::outfile{motifs_disco_compa_png} = &OutFileName(".png", "motifs_disco_compa");
  #    $main::outfile{motifs_disco_vs_db} = &OutFileName(".tab", "motifs_disco_vs_db");
  #    $main::outfile{motifs_disco_ref} = &OutFileName(".tf", "motifs_disco_ref");


}

################################################################
## Purge sequences
sub PurgeOneSeq {
  my ($seq_file, $seq_type) = @_;
  &RSAT::message::TimeWarn("Purging sequences", $seq_type) if ($main::verbose >= 1);
  my $cmd = $SCRIPTS."/convert-seq";
  $cmd .= " -i ".$seq_file;
  $cmd .= " -from ".$main::param{seq_format};
  $cmd .= " -to fasta";
  $cmd .= " -mask non-dna";
  $cmd .= "| $SCRIPTS/purge-sequence -dna";
  $cmd .= " -ml ".$main::param{purge_match_length};
  $cmd .= " -mis ".$main::param{purge_mismatches};
  $cmd .= " -o ".$main::outfile{"purged_".$seq_type};
  &one_command($cmd, 1);
}


################################################################
## Compute sequence lengths
sub SequenceLengths {
  my ($seq_file, $seq_type) = @_;
  &RSAT::message::TimeWarn("Computing sequence lengths", $seq_type) if ($main::verbose >= 1);
  my $cmd = $SCRIPTS."/sequence-lengths";
  $cmd .= " -i ".$main::infile{$seq_type.'_seq'};
  $cmd .= " -o ".$main::outfile{$seq_type.'_seqlen'};
  $cmd .= " ; cut -f 2 ".$main::outfile{$seq_type.'_seqlen'};
  $cmd .= " | ".$SCRIPTS."/classfreq -v 1 -ci 10 -o ".$main::outfile{$seq_type.'_seqlen_distrib'};
  $cmd .= " ; ".$SCRIPTS."/XYgraph -lines -legend";
  $cmd .= " -format ".$main::param{img_format};
  my $title = "Sequence lengths";
  $title .= "; ".$main::param{title} if ($main::param{title});
  $cmd .= " -title '".$title."'";
  $cmd .= " -ysize 200 -ycol 4 -yleg1 'Number of peaks'";
  $cmd .= " -xsize 800 -xcol 3 -xleg1 'Peak length'";
  $cmd .= " -i ".$main::outfile{$seq_type.'_seqlen_distrib'};
  $cmd .= " -o ".$main::outfile{$seq_type.'_seqlen_distrib_graph'};
  &one_command($cmd, 1);
}

################################################################
## Run position-analysis to compute composition profiles (residues,
## dinucleotides)
sub CompositionProfiles {
  my ($seq_file, $seq_type) = @_;
  for my $ol (@profiles_oligo_lengths) {
    &RSAT::message::TimeWarn("Computing composition profiles", $ol."nt") if ($main::verbose >= 1);
    my $cmd =$SCRIPTS."/position-analysis -v 1";
    $cmd .= " -i ".$main::outfile{"purged_".$seq_type};
    $cmd .= " -format fasta";
    $cmd .= " -sort ";
    $cmd .= " -return chi,sig,distrib,graphs,rank";
#    $cmd .= " -max_graphs ".$main::param{profiles_max_graphs};
    $cmd .= " ".$main::param{profiles_strand};
    $cmd .= " ".$main::param{noov};
    $cmd .= " -seqtype dna";
    $cmd .= " -l ".$ol;
    $cmd .= " -ci ".$main::param{profiles_ci};
    $cmd .= " -img_format ".$main::param{img_format};
    $cmd .= " -title '".$main::param{title}."'";
    $cmd .= " -origin center ";
    $cmd .= " -o ".$main::outfile{$ol."nt_".$seq_type."_profiles"};
    &one_command($cmd, 1);

    ## Draw the XY graph with composition profiles
    my $color_file = $ENV{RSAT}."/perl-scripts/lib/color_palettes/".$ol."nt".$main::param{profiles_strand}."_colors.tab";
    my $col_nb = 4**$ol + 1;
    $cmd = 'grep -v ";" '.$main::outfile{$ol."nt_".$seq_type."_profiles"}.' | sort | '.$SCRIPTS.'/transpose-table | grep -P \'(^id)|(^\-?\d+)\'';
    $cmd .= " | ".$SCRIPTS."/XYgraph -xcol 1 -ycol 2-".$col_nb;
    $cmd .= " -lines -legend -header";
    if (-e $color_file) {
      $cmd .= " -colors ".$color_file;
    } else {
      &RSAT::message::Warning("Cannot find residue color specification file", $color_file);
    }
#    $cmd .= " -symbols "; ## THIS OPTION IS NOT WORKING ANYMORE : THE LEGEND DISPLAYS SYMBOLS BUT NOT THE GRAPH. THIS HAS TO BE FIXED
    my $title = $ol."nt composition profiles : ";
    $title .= "; ".$seq_type." sequence";
    $title .= "; ".$main::param{title} if ($main::param{title});
    $cmd .= " -title '".$title."'";
    $cmd .= " -xleg1 'Position' -xsize 800";
    $cmd .= " -yleg1 'Occurrences' -ysize 300";
    $cmd .= " -o ".$main::outfile{$ol."nt_".$seq_type."_profiles_graph"};
    &one_command($cmd, 1);

    ## Compute background models of order 0 (Bernoulli) and 1 (Markov)
    ## from the input sequence
    $cmd = $BIN."/count-words -v 1";
    $cmd .= " -i ".$main::outfile{"purged_".$seq_type};
    $cmd .= " -l ".$ol;
    $cmd .= " -1str";
    $cmd .= " ".$main::param{noov};
    $cmd .= " -o ".$main::outfile{$ol."nt_".$seq_type."_freq"};
    $cmd .= "; ".$SCRIPTS."/convert-background-model -from oligos -to transitions ";
    $cmd .= " -i ".$main::outfile{$ol."nt_".$seq_type."_freq"};
    $cmd .= " -o ".$main::outfile{$ol."nt_".$seq_type."_transit"};
    $cmd .= " ; cut -f 1-5,7 ".$main::outfile{$ol."nt_".$seq_type."_transit"};
    $cmd .= " | ".$SCRIPTS."/draw-heatmap -min 0 -max 1  -out_format png -col_width 50";
    $cmd .= " -o ".$main::outfile{$ol."nt_".$seq_type."_heatmap"};
    &one_command($cmd, 1);
  }
}


################################################################
## Run oligo-analysis on the test set
sub OligoAnalysis {
  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    for my $markov ($main::param{oligo_min_mkv}..$main::param{oligo_max_mkv}) {
      ## Convert negative markov orders relative to the oligo length
      $markov += $len if ($markov < 0);
      my $pattern_type = 'oligos_'.$len.'nt'.'_mkv'.$markov;
      &RSAT::message::TimeWarn("Running oligo-analysis", $len."nt", "markov=".$markov) if ($main::verbose >= 1);
      my $cmd = $SCRIPTS."/oligo-analysis -v 1";
      $cmd .= " -i ".$main::outfile{"purged_test"};
      $cmd .= " -format fasta";
      $cmd .= " -sort -lth ratio ".$main::param{min_ratio};
      $cmd .= " -sort -lth occ_sig ".$main::param{min_sig};
      $cmd .= " -uth rank ".$main::param{patterns_max_rank};
      $cmd .= " -return occ,proba,rank";
      $cmd .= " ".$main::param{strand};
      $cmd .= " ".$main::param{noov};
      $cmd .= " -seqtype dna";
      $cmd .= " -l ".$len;
      $cmd .= " -markov ".$markov;
      $cmd .= " -pseudo 0.01";
      $cmd .= " -o ".$main::outfile{$pattern_type};
      &one_command($cmd, 1);
      &MatrixFromPatterns($main::outfile{$pattern_type}, $main::outfile{$pattern_type.'_pssm'}, $pattern_type);
    }
  }
}

################################################################
## Run oligo-diff to compare the test set to the control set
sub OligoDiff {
  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    my $pattern_type = 'oligo_diff_'.$len.'nt';
    &RSAT::message::TimeWarn("Running oligo-diff", $len."nt") if ($main::verbose >= 1);
    my $cmd = $SCRIPTS."/oligo-diff -v 2";
    $cmd .= " -test ".$main::outfile{"purged_test"};
    $cmd .= " -ctrl ".$main::outfile{"purged_ctrl"};
    $cmd .= " -nopurge"; ## The input sequences have already been purged
    $cmd .= " -l ".$len;
    $cmd .= " ".$main::param{strand};
    $cmd .= " ".$main::param{noov};
    $cmd .= " -side test";
#    $cmd .= " -sort";
    $cmd .= " -lth ratio ".$main::param{min_ratio};
    $cmd .= " -lth occ_sig ".$main::param{min_sig};
    $cmd .= " -uth rank ".$main::param{patterns_max_rank};
#    $cmd .= " -return occ,proba,rank";
#    $cmd .= " -seqtype dna";
#    $cmd .= " -pseudo 0.01";
    $cmd .= " -o ".$main::outfile{$pattern_type};
    &one_command($cmd, 1);
    &MatrixFromPatterns($main::outfile{$pattern_type}, $main::outfile{$pattern_type.'_pssm'}, $pattern_type);
  }
}


################################################################
## Run dyad-analysis on the test set
sub DyadAnalysis {
  &RSAT::message::TimeWarn("Running dyad-analysis") if ($main::verbose >= 1);
  my $cmd = $SCRIPTS."/dyad-analysis -v 1";
  $cmd .= " -i ".$main::outfile{"purged_test"};
  $cmd .= " -format fasta";
  $cmd .= " -sort -lth ratio ".$main::param{min_ratio};
  $cmd .= " -sort -lth occ_sig ".$main::param{min_sig};
  $cmd .= " -uth rank ".$main::param{patterns_max_rank}." -return occ,proba,rank";
  $cmd .= " ".$main::param{strand};
  $cmd .= " ".$main::param{noov};
  $cmd .= " -seqtype dna";
  $cmd .= " -l 3 -sp 0-20 ";
  $cmd .= " -bg monads";
  $cmd .= " -pseudo 0.01";
  $cmd .= " -o ".$main::outfile{dyads};
  &one_command($cmd, 1);
  &MatrixFromPatterns($main::outfile{dyads}, $main::outfile{dyads_pssm}, "dyads");
}


################################################################
## Run position-analysis to discover oligonucleotides with positional
## biases
sub PositionAnalysis {
  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    my $pattern_type = 'positions_'.$len.'nt';
    &RSAT::message::TimeWarn("Running position-analysis", $len."nt") if ($main::verbose >= 1);
    my $cmd = $SCRIPTS."/position-analysis -v 1";
    $cmd .= " -i ".$main::outfile{"purged_test"};
    $cmd .= " -format fasta";
    $cmd .= " -sort ";
    $cmd .= " -return chi,sig,distrib,graphs,rank";
    $cmd .= " -rth ".$main::param{patterns_max_rank};
    $cmd .= " -lth_sig ".$main::param{min_sig};
    $cmd .= " -max_graphs ".$main::param{patterns_max_rank};
    $cmd .= " ".$main::param{strand};
    $cmd .= " ".$main::param{noov};
    $cmd .= " -seqtype dna";
    $cmd .= " -l ".$len;
    $cmd .= " -ci ".$main::param{profiles_ci};
    $cmd .= " -img_format ".$main::param{img_format};
    $cmd .= " -title '".$main::param{title}."'";
    $cmd .= " -origin center ";
    $cmd .= " -o ".$main::outfile{$pattern_type};
    &one_command($cmd, 1);
    &MatrixFromPatterns($main::outfile{$pattern_type}, $main::outfile{$pattern_type."_pssm"}, $pattern_type);
  }
}


################################################################
## Run local-word-analysis on the test set
sub LocalWords {
  for my $len ($main::param{oligo_min_len}..$main::param{oligo_max_len}) {
    for my $markov ($main::param{oligo_min_mkv}..$main::param{oligo_max_mkv}) {
      ## Convert negative markov orders relative to the oligo length
      $markov += $len if ($markov < 0);
      my $pattern_type = 'local_words_'.$len.'nt'.'_mkv'.$markov;
      &RSAT::message::TimeWarn("Running local-word-analysis", $len."nt") if ($main::verbose >= 1);
      my $cmd = $PYTHON."/local-word-analysis -v 3";
      $cmd .= " -i ".$main::outfile{"purged_test"};
      #  $cmd .= " -format fasta";
      $cmd .= " --center=0";
      $cmd .= " --min=occ_sig ".$main::param{min_sig};
      $cmd .= " --sort=-occ_sig";
      $cmd .= " --max=rank ".$main::param{patterns_max_rank};
      $cmd .= " --max=w_rank ".1; ## Only return the most significant window for each word
      # " -return occ,proba,rank";
      if ($main::param{strand} eq "-1str") {
	$cmd .= " +";
      } else {
	$cmd .= " +-";
      }
      $cmd .= " --overlap" if ($main::param{noov} eq "ovlp");
      $cmd .= " --window=".$main::param{local_words_ci};
      #  $cmd .= " -seqtype dna";
      $cmd .= " -l ".$len;
      $cmd .= " --markov ".$markov;
      #  $cmd .= " -pseudo 0.01";
      $cmd .= " -o ".$main::outfile{$pattern_type};
      &one_command($cmd, 1);
      &MatrixFromPatterns($main::outfile{$pattern_type}, $main::outfile{$pattern_type.'_pssm'}, $pattern_type);
    }
  }
}

################################################################
## Convert reference motif and generate logos
sub RefMotif {

  ## Copy the reference motif in the output directory
  my $cmd = "rsync -ruptvl ";
  $cmd .= " ".$main::infile{ref_motif};
  $cmd .= " ".$main::outfile{ref_motif};
  &one_command($cmd, 1);

  ## Generate the logos and compute parameters (information content,
  ## consensus, ...) for the reference motif
  $cmd = $SCRIPTS."/convert-matrix -v 1 -from ".$main::param{ref_motif_format};
  $cmd .= " -to tab";
  $cmd .= " -return counts,parameters,logo";
  $cmd .= " -logo_file ".$main::outfile{ref_motif_logo};
  $cmd .= " -i ".$main::infile{ref_motif};
  $cmd .= " -o ".$main::outfile{ref_motif_info};
  &one_command($cmd, 1);

  ## Convert the reference motif to TRANSFAC format, because this
  ## format holds information about the motif name, ID etc
  $cmd = $SCRIPTS."/convert-matrix -v 1 -from ".$main::param{ref_motif_format};
  $cmd .= " -to transfac";
  $cmd .= " -return counts,parameters";
  $cmd .= " -logo_file ".$main::outfile{ref_motif_logo};
  $cmd .= " -i ".$main::infile{ref_motif};
  $cmd .= " -o ".$main::outfile{ref_motif_transfac};
  &one_command($cmd, 1);
}


################################################################
## Compare the significance of words (oligos, dyads) discovered by
## the different approaches
sub WordsVersusWords {
  my $cmd = $SCRIPTS."/compare-scores -v 1 ";
  my $file_nb = 0;
  foreach my $pattern_type (@pattern_types) {
    my $pattern_file = $main::outfile{$pattern_type};
    my $sig_col;
    $file_nb++;
    $cmd .= " -i ".$pattern_file;
    if ($pattern_type =~ /oligos_/) {
      $sig_col = 8;
    } elsif ($pattern_type =~ /oligo_diff/) {
      $sig_col = 11;
    } elsif ($pattern_type =~ /dyads/) {
      $sig_col = 8;
    } elsif ($pattern_type =~ /local_words/) {
      $sig_col = 9;
    } elsif ($pattern_type =~ /positions/) {
      $sig_col = 9;
    } else {
      &RSAT::message::Warning("Unknown score column for pattern type", $pattern_type);
      next;
    }
    $cmd .= " -sc".$file_nb." ".$sig_col;
#    &RSAT::message::Debug($file_nb, $pattern_type, $sig_col, "\n", $pattern_file) if ($main::verbose >= 5);
  }
  $cmd .= " -ic 2 -lc";
  $cmd .= " -null .";
  $cmd .= " -suppress ".$main::dir{output}."/";
  $cmd .= " -suppress ".$main::param{prefix};
  $cmd .= " -suppress '\.tab'";
  $cmd .= " -o ".$main::outfile{word_compa};
  $cmd .= " ; ".$SCRIPTS."/draw-heatmap -min 0 -max 10  -out_format png";
  $cmd .= " -col_width 40 -rownames -gradient fire";
  $cmd .= " -row_height 16";
  $cmd .= " -i ".$main::outfile{word_compa};
  $cmd .= " -o ".$main::outfile{word_compa_heatmap};

  &one_command($cmd, 1);
}

################################################################
## Compare each discovered motifs to each other, and with the
## reference motif
sub MotifVersusMotifs {

  ## Initialize the motif file with the reference motif if provided,
  ## otherwise as an empty file
  my $cmd = "";
  if (defined($main::infile{ref_motif})) {
    $cmd = "cp -f";
    $cmd .= " ".$main::outfile{ref_motif_transfac};
    $cmd .= " ".$main::outfile{motifs_discovered};
  } else {
    $cmd = "rm -f ".$main::outfile{motifs_discovered};
  }

  ## Concatenate all discovered motifs (matrices) in a single file.
  ## Use TRANSFAC format because if allows to associate a name to each
  ## matrix.
  foreach my $pattern_type (@pattern_types) {
    $cmd .= " ; ".$SCRIPTS."/convert-matrix -from tab -to transfac -return counts,parameters";
    $cmd .= " -prefix $pattern_type";
    $cmd .= " -i ".$main::outfile{$pattern_type.'_pssm_counts'};
    $cmd .= " >> ".$main::outfile{motifs_discovered};
  }
#  &one_command($cmd, 1);

  ## Comparison between discovered matrices, and with the reference motif
  $cmd = $SCRIPTS."/compare-matrices -v 1";
  $cmd .= " -format1 transfac -file1 ".$main::outfile{motifs_discovered};;
  $cmd .= " -format2 transfac -file2 ".$main::outfile{motifs_discovered};;
#  $cmd .= " -format2 transfac -file2 ".$main::outfile{ref_motif_transfac};
  $cmd .= " -DR -distinct -triangle";
  $cmd .= " -sort Ncor";
  $cmd .= " -uth rank 1"; ## Only report the best matching shift between a pair of matrices
  $cmd .= " -lth w 4"; ## Min number of aligned columns
  $cmd .= " -lth cor 0.85"; ## Min normalized correlation
  $cmd .= " -lth Ncor 0.7"; ## Min normalized correlation
  $cmd .= " -return matrix_name,direction,Ncor,SW,cor,width,consensus";
  $cmd .= " -o ".$main::outfile{motifs_disco_compa};
#  &one_command($cmd, 1);

  ## Use MCL to partition the motif graph into clusters
  my $mcl_dir = $ENV{mcl_dir};
  unless ($mcl_dir) {
    &RSAT::error::FatalError("Motif comparison requires to install MCL and indicate its path in the file $ENV{RSAT}/RSAT_config.props");
  }
  $cmd = "grep -v '^;' ".$main::outfile{motifs_disco_compa}.">".$main::outfile{motifs_disco_compa}.".mcl";
  $cmd .= "; ".$mcl_dir."/mcl ".$main::outfile{motifs_disco_compa}.".mcl";
  $cmd .= " -I 1.8 --abc -V all ";
  $cmd .= " -o ".$main::outfile{motifs_disco_compa_clusters_mcl};
  $cmd .= " ; ${SCRIPTS}/convert-classes -i ".$main::outfile{motifs_disco_compa_clusters_mcl};
  $cmd .= " -from mcl -to tab ";
  $cmd .= " -o ".$main::outfile{motifs_disco_compa_clusters_tab};
  &one_command($cmd, 1);

  ## Split the motif graph into clusters as defined by MCL, and
  ## compute the intra-cluster degree (k) and weighted degree (wk) of
  ## each node
  $cmd = $SCRIPTS."/graph-get-clusters -i ".$main::outfile{motifs_disco_compa};
  $cmd .= " -in_format tab -scol 1 -tcol 2 -wcol 4 -return clusters ";
  $cmd .= " -clusters ".$main::outfile{motifs_disco_compa_clusters_tab};
  $cmd .= " -out_format tab -o ".$main::outfile{motifs_disco_compa_clusters_graph};
  $cmd .= " ; ".$SCRIPTS."/graph-connex-components -v 1";
  $cmd .= " -i ".$main::outfile{motifs_disco_compa_clusters_graph};
  $cmd .= " -wcol 3";
  $cmd .= " -o ".$main::outfile{motifs_disco_compa_cluster_intra_degree};
  &one_command($cmd, 1);

  ## Generate a GML graph with the matrix comparison result (can be opened with CytoScape or Yed)
  $cmd = $SCRIPTS."/convert-graph -i ".$main::outfile{motifs_disco_compa};
  $cmd .= " -ewidth -ecolors fire";
  $cmd .= " -layout spring";
  $cmd .= " -from tab -to gml -scol 1 -tcol 2 -wcol 3";
  $cmd .= " -o ".$main::outfile{motifs_disco_compa_gml};
#  &one_command($cmd, 1);

  ## Generate a figure of the motif comparison graph
  $cmd = $SCRIPTS."/display-graph -v 2";
  $cmd .= " -in_format gml -i ".$main::outfile{motifs_disco_compa_gml};
  $cmd .= " -ewidth";
  $cmd .= " -layout none";
  $cmd .= " -out_format png -o ".$main::outfile{motifs_disco_compa_png};
#  &one_command($cmd, 1);

#   ## Generate a DOT graph with the matrix comparison result (can be opened with graphviz)
#   $cmd = $SCRIPTS."/convert-graph -i ".$main::outfile{motifs_disco_compa};
#   $cmd .= " -from tab -to dot -scol 1 -tcol 2 -wcol 3";
#   $cmd .= " -o ".$main::outfile{motifs_disco_compa_dot};
#   &one_command($cmd, 1);
}

################################################################
## Convert a list of patterns into PSSMs
sub MatrixFromPatterns {
  my ($pattern_file, $pssm_file, $type) = @_;
  &RSAT::message::TimeWarn("\tMatrix from patterns", $type) if ($verbose >= 1);
  my $cmd = $SCRIPTS."/matrix-from-patterns -v 1 ";
  $cmd .= " -seq ".$infile{test_seq};
  $cmd .= " -pl ".$pattern_file;
  $cmd .= " -bginput -markov 1 ";
  $cmd .= " -max_asmb_nb ".$main::param{matrix_nmotifs};
  $cmd .= " -gibbs_flanks 2";
  $cmd .= " -gibbs_iter 2";
  $cmd .= " -gibbs_msps 0.5";
  $cmd .= " -logo";
#  $cmd .= " -links";
  $cmd .= " -o ".$pssm_file;
  &one_command($cmd, 1);
}



################################################################
## Generate a synthetic table summarizing the main results with links
## to the iriginal result files.
sub Synthesis {
  local $syn = &OpenOutputFile($main::outfile{synthesis});
  local $synthesis_path = `dirname $main::outfile{synthesis}`;
  chomp($synthesis_path);

  ## HTML Header and title
  print $syn "<html>\n";
  print $syn "<head>\n";
  print $syn "<title>chip-seq-analysis ".$main::param{title}."</title>\n";

  ## Page styles
  print $syn "<style type='text/css'>\n";
  print $syn `cat $ENV{RSAT}/perl-scripts/lib/results.css`;
  print $syn "</style>\n";
#  print $syn "<link rel='stylesheet' type='text/css' href='".$ENV{RSAT}."/public_html/main.css'/>\n";

  print $syn "</head>\n";
  print $syn "<body>\n";
  print $syn "<h1>Result: chip-seq-analysis ".$main::param{title}."</h1>\n";

  ## Print the command line
  print $syn "<pre>";
  print $syn "<b>Command:</b>  chip-seq-analysis ";
  &PrintArguments($syn);
  print $syn "</pre>";

  ## Header of the synthetic table
  print $syn "<h2>Synthetic report</h2>";
  print $syn "<p><table class='sortable'>\n";

  &SynthesisSequenceComposition();

  ## Reference motif
  &SynthesisRefMotif();

  ## Header line
  &SyntheticTableAddHeaderRow("Pattern discovery");

  foreach my $pattern_type (@pattern_types) {
    &SynthesisPatternDisco($pattern_type);
  }

  ## Word comparison
  &SynthesisWordCompa();

  ## Motif comparison
  &SynthesisMotifCompa();

  ## Log file
  &SyntheticTableAddRow("Log file",
			"",
 			"txt"=>$main::outfile{"log"},
 		       );


  ## Close the synthetic table
  print $syn "</table></p>\n";

  ## Log file
#  print $syn "<h2>Log</h2>";
#  print $syn "<pre>";
#  print $syn `cat $main::outfile{log}`;
#  print $syn "</pre>";

  ## End of the HTML file
  print $syn "</body>\n";
  print $syn "</html>\n";
  close $syn;
  &RSAT::message::TimeWarn("Synthetic report", $main::outfile{synthesis}) if ($main::verbose >= 1);
}

################################################################
## Compute a file path relative to the synthesis file
sub RelativePath {
  my ($file) = @_;
#  &RSAT::message::Debug("RelativePath", $file) if ($main::verbose >= 10);
  my $rel_file = $file;
  $rel_file =~ s|${synthesis_path}/||;
  return ($rel_file);
}

################################################################
## Add a row to the syhnthetic table
sub SyntheticTableAddRow {
  my ($type, $summary, @files) = @_;
  print $syn "<tr>\n";
  print $syn "<td>$type</td>\n";
  print $syn "<td>$summary</td>\n";
  print $syn "<td>\n";
  my $key;
  my $file;
  while ($key = shift (@files)){
    last unless $key;
    $file = shift(@files);
    &RSAT::message::Debug($key, $file) if ($main::verbose >= 5);
    $file = &RelativePath($file);
    print $syn "<a href='".$file."'>[".$key."]</a><br>\n";
  }
  print $syn "</td>\n";
  print $syn "</tr>\n";
}


################################################################
## Add a header row to the synthetic table
sub SyntheticTableAddHeaderRow {
  my ($header) = @_;
  print $syn "<tr>\n";
  print $syn "<th colspan=3>\n";
  print $syn $header;
  print $syn "</th>\n";
  print $syn "</tr>\n";
}

################################################################
## Add sequence composition on the synthetic report
sub SynthesisSequenceComposition {
  foreach my $seq_type (@seq_types) {

    ## Header line
    &SyntheticTableAddHeaderRow("Sequence composition (".$seq_type." sequences)");

    ## Get number of peaks from sequence length distribution
    my $peak_nb = `grep ';count:' $main::outfile{$seq_type."_seqlen_distrib"}`;
    chomp($peak_nb);
    $peak_nb =~ s/.*count:\s*//;

    ## Get total sequence size from sequence length distribution
    my $seq_size = `grep ';sum:' $main::outfile{$seq_type."_seqlen_distrib"}`;
    chomp($seq_size);
    $seq_size =~ s/.*sum:\s*//;
    $seq_size = round($seq_size/1000);

    ## Sequence lengths
    my $img = &RelativePath($main::outfile{$seq_type."_seqlen_distrib_graph"});
    &SyntheticTableAddRow("Nb of peaks: ".$peak_nb."<br>\nTotal seq. size: ".$seq_size." kb",
			  "<a  href='".$img."'><img height=150 src='".$img."'></a>",
			  "lengths",$main::outfile{$seq_type."_seqlen"},
			  "distrib",$main::outfile{$seq_type."_seqlen_distrib"},
			  "plot",$main::outfile{$seq_type."_seqlen_distrib_graph"},
			 );


    ## Residue composition
    for my $ol (@profiles_oligo_lengths) {
      my $table = "<table><tr>";
      my $img = &RelativePath($main::outfile{$ol."nt_".$seq_type."_heatmap"});
      $table .= "<td>Transition frequencies<br><a  href='".$img."'><img width=200 src='".$img."'></a></td>";
      $img = &RelativePath($main::outfile{$ol."nt_".$seq_type."_profiles_graph"});
      $table .= "<td>Position profile<br><a  href='".$img."'><img height=150 src='".$img."'></a></td>";
      $table .= "</tr></table>";
      &SyntheticTableAddRow($ol."nt composition",
			    $table,
			    $ol."nt freq",$main::outfile{$ol."nt_".$seq_type."_freq"},
			    $ol."nt transitions",$main::outfile{$ol."nt_".$seq_type."_transit"},
			    "profile table",$main::outfile{$ol."nt_".$seq_type."_profiles"},
			    "individual profiles",$main::outfile{$ol."nt_".$seq_type."_profiles_index"},
			   );
    }
  }
}

################################################################
## Add the reference motif to the report
sub SynthesisRefMotif {
  if (defined($main::infile{ref_motif})) {
    &SyntheticTableAddHeaderRow("Reference motif");

    my $logo_table = "<table cellpadding=0 cellspacing=0 align=center border=0>";
    $logo_table .= "<tr>\n";
    my $logo_file = $main::outfile{ref_motif_logo}."_m1.".$main::param{img_format};
    my $logo_file_rc = $main::outfile{ref_motif_logo}."_m1_rc.".$main::param{img_format};
    if (-e $logo_file) {
      my $img = &RelativePath($logo_file);
      $logo_table .= "<td align='right'><a  href='".$img."'><img height=70 src='".$img."'></a></td>\n";
    } elsif ($main::verbose >= 1) {
      &RSAT::message::Warning("Cannot find reference logo", $logo_file);
    }
    if (-e $logo_file_rc) {
      my $img = &RelativePath($logo_file_rc);
      $logo_table .= "<td align='left'><a  href='".$img."'><img height=70 src='".$img."'></a></td>\n";
    } elsif ($main::verbose >= 1) {
      &RSAT::message::Warning("Cannot find reverse complementary logo for the reference motif", $logo_file_rc);
    }
    $logo_table .= "</tr>\n";
    $logo_table .= "</table>\n";
    &SyntheticTableAddRow("Reference motif",
			  $logo_table,
			  $main::param{ref_motif_format},$main::infile{ref_motif},
			  "tf",$main::outfile{ref_motif_transfac},
			  "info",$main::outfile{ref_motif_info},
			 );
  }
}

################################################################
## Synthesis for one pattern discovery algorithm
## Usage:
##   &SynthesisPatternDisco($pattern_type);
## Where pattern type can be oligos, dyads, local_words, oligo-diff
sub SynthesisPatternDisco {
  my ($pattern_type) = @_;

  ## Synthesize results of pattern assembly (assembly consensus + sig scores)
  ($asmb) = &OpenInputFile($main::outfile{$pattern_type.'_asmb'});
  my $pattern_nb = 0;
  my $asmb_or_isol = "";
  my %pattern_info = ();
  while (<$asmb>) {
    next if /^#/; ## Skip header line
    next unless /\S/; ## Skip empty lines
    if (/assembly\s+\#\s+(\d+)/i) {
      ## Assembly number
      $pattern_nb = $1;
      $asmb_or_isol = "asmb";
      next;
    } elsif (/Isolated patterns/) {
      ## Isolated patterns at the end of the assembly file
      $asmb_or_isol = "isol";
      next;
    }
    next if /^;/; ## Skip comments
    if ($asmb_or_isol eq "isol") {
      $pattern_nb++;
    } elsif (!/consensus/) {
      next;
    }
    my ($word, $rc_word, $score) = split "\t";
    $pattern_info[$pattern_nb]->{type} = $asmb_or_isol;
    $pattern_info[$pattern_nb]->{word} = $word;
    $pattern_info[$pattern_nb]->{rc_word} = $rc_word;
    $pattern_info[$pattern_nb]->{score} = $score;
  }
  close $asmb;

  ## Synthesize matrix logos
  my $pattern_table = "<table cellpadding='0' cellspacing='0' align='center' border='0'>";
  foreach my $logo_nb (1..$main::param{matrix_nmotifs}) {
    $pattern_table .= "<tr>\n";
    my $logo_file = $main::outfile{$pattern_type.'_pssm_logo'.$logo_nb};
    my $logo_file_rc = $main::outfile{$pattern_type.'_pssm_logo_rc'.$logo_nb};
    my $start_format="";
    my $end_format="";
    if ($pattern_info[$logo_nb]->{score}>10) {
      $start_format .= "<b>";
      $end_format .= "</b>";
      if ($pattern_info[$logo_nb]->{score}>300) {
	$start_format .= "<font color='red'>";
	$end_format = "</font>".$end_format;
      }
    }
    &RSAT::message::Debug("Logo", $logo_nb, $logo_file) if ($main::verbose >= 5);
    if (-e $logo_file) {
      my $img = &RelativePath($logo_file);
      $pattern_table .= "<td align='right'>";
      $pattern_table .= $start_format;
      $pattern_table .= "$asmb_or_isol";
      $pattern_table .= " (sig=".$pattern_info[$logo_nb]->{score}.")";
      $pattern_table .= "&nbsp;"x5;
      $pattern_table .= $pattern_info[$logo_nb]->{word};
      $pattern_table .= "<br><a  href='".$img."'><img height=70 src='".$img."'></a>";
      $pattern_table .= $start_format;
      $pattern_table .= "</td>\n";
    } elsif ($main::verbose >= 1) {
      &RSAT::message::Warning("Cannot find logo", $logo_file);
    }
    if (-e $logo_file_rc) {
      my $img = &RelativePath($logo_file_rc);
      $pattern_table .= "<td align='left'>";
      $pattern_table .= $start_format;
      $pattern_table .= $pattern_info[$logo_nb]->{rc_word};
      $pattern_table .= "<br><a  href='".$img."'><img height=70 src='".$img."'></a>";
      $pattern_table .= "</td>\n";
    } elsif ($main::verbose >= 1) {
      &RSAT::message::Warning("Cannot find reverse complementary logo", $logo_file_rc);
    }
#    $pattern_table .= "<td align='right'>".$pattern_info[$logo_nb]->{score}."</td>";
    $pattern_table .= "</tr>\n";
  }
  $pattern_table .= "</table>\n";

  &SyntheticTableAddRow($pattern_type,
			$pattern_table,
			$pattern_type,$main::outfile{$pattern_type},
			"assembly",$main::outfile{$pattern_type.'_asmb'},
			"sig matrix",$main::outfile{$pattern_type.'_pssm_sig'},
			"info-gibbs",$main::outfile{$pattern_type.'_pssm_gibbs'},
			"count matrix",$main::outfile{$pattern_type.'_pssm_counts'},
		       );
}

################################################################
## Synthesis of word comparisons
sub SynthesisWordCompa {
  my $img = &RelativePath($main::outfile{word_compa_heatmap});
  &SyntheticTableAddRow("Word comparisons",
			"<a  href='".$img."'><img height=150 src='".$img."'></a>",
			"tab",$main::outfile{word_compa},
			"heatmap",$main::outfile{word_compa_heatmap},
		       );
}

################################################################
## Synthesis of motif comparisons
sub SynthesisMotifCompa {
  my $img = &RelativePath($main::outfile{motifs_disco_compa_png});
  &SyntheticTableAddRow("Motif comparisons",
			"<a  href='".$img."'><img height=300 src='".$img."'></a>",
			"motifs", $main::outfile{motifs_discovered},
			"tab",$main::outfile{motifs_disco_compa},
			"gml",$main::outfile{motifs_disco_compa_gml},
			"png",$main::outfile{motifs_disco_compa_png},
		       );
}

################################################################
## Delete purged sequence files after analysis has been completed.
sub CleanSequences {
  foreach my $seq_type (@seq_types) {
    &RSAT::message::TimeWarn("Cleaning sequences", $seq_type) if ($main::verbose >= 1);
    &one_command("rm -f ".$main::outfile{"purged_".$seq_type}, 1);
  }
}


################################################################
## Read arguments 
sub ReadArguments {
  &RSAT::message::TimeWarn("Reading arguments") if ($main::verbose >= 1);
  my $arg;
  my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
  while (scalar(@arguments) >= 1) {
    $arg = shift (@arguments);
    ## Verbosity

=pod

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
    if ($arg eq "-v") {
      if (&IsNatural($arguments[0])) {
	$main::verbose = shift(@arguments);
      } else {
	$main::verbose = 1;
      }

=pod

=item B<-h>

Display full help message

=cut
    } elsif ($arg eq "-h") {
      &PrintHelp();

=pod

=item B<-help>

Same as -h

=cut
    } elsif ($arg eq "-help") {
      &PrintOptions();

=pod

=item B<-i test_seq_file>

Test peak sequence file (mandatory).

For single-set analysis, this file contains the peak seuences of the
unique set.  For test versus control analysis, it contains the test
sequences.

=cut
    } elsif ($arg eq "-i") {
      $main::infile{test_seq} = shift(@arguments);

=pod

=item B<-ctrl control_seq_file>

Control peak sequence file (optional).

This option is used only for the test versus control analysis.

=cut
    } elsif ($arg eq "-ctrl") {
      $main::infile{ctrl_seq} = shift(@arguments);


=pod

=item B<-ref_motif reference_motif>

Reference motif (optional).

In some cases, we already dispose of a reference motif, for example
the motif annotated in some transcription factor database
(e.g. RegulonDB, Jaspar, TRANSFAC) for the transcription factor of
interest. These annotations may come from low-throughput experiments,
and rely on a poor number of sites, but the reference motif may
nevertheless be informative, because it is based on several
independent studies.

The reference motif is used for two purposes in I<chip-seq-analysis>.

=over

=item Comparison with discovered motifs

Each discovered motif can be compared to the reference motif, in order
to evaluate its likelihood to correspond to the factor of interest.

=item Seed for supervised motif improvement

The reference motif can serve as seed for collecting all the sites in
the peak sequence set, and building a more robust motif based on
several hundreds or thousands of sites. The supervised motif
improvement is performed with I<info-gibbs> (using the option
B<--seedmatrix>).

=back

=cut
    } elsif ($arg eq "-ref_motif") {
      $main::infile{ref_motif} = shift(@arguments);



=pod

=item	B<-outdir output_directory>

Output directory (mandatory).

The result files and index files produced by the different programs
will be stored in this directory.

=cut
    } elsif ($arg eq "-outdir") {
      $main::dir{output} = shift(@arguments);


=pod

=item	B<-prefix output_prefix>

Prefix for the output files

=cut
    } elsif ($arg eq "-prefix") {
      $main::param{prefix} = shift(@arguments);

=pod

=item	B<-title graph_title>

Title displayed on top of the graphs.

=cut
    } elsif ($arg eq "-title") {
      $main::param{title} = shift(@arguments);

=pod

=item	B<-img_format img_format>

Image format. 

All the formats supported by XYgraph can be used.

=cut
    } elsif ($arg eq "-img_format") {
      $main::param{img_format} = shift(@arguments);

=pod

=item B<-task>

Specify a subset of tasks to be executed.

By default, the program runs all necessary tasks. However, in some
cases, it can be useful to select one or several tasks to be executed
separately.

Beware: task selection requires expertise, because most tasks depends
on the prior execution of some other tasks in the workflow. Selecting
tasks before their prerequisite tasks have been completed will provoke
fatal errors.

I<Avilable Tasks.>

=over

=item I<all> (default)

Run all supported tasks.

=item I<purge>

Purge input sequences (test set and, if specified, control set) to
mask redundant fragments before applying pattern discovey
algorithms. Sequence purging is necessary because redundant fragments
would violate the hypothesis of independence underlying the binomial
significance test, resulting in a large number of false positive
patterns.

=item I<seqlen>

Compute sequence lengths and their distribution. 

Sequence lengths are useful for the negative control (selection of
random genome fragments).

Sequence length distribution is informative to get an idea about the
variability of peak lengths.

=item I<profiles>

Compute compositional profiles, i.e. distributions of residues and
dinucleotide frequencies per position (using I<position-analysis>).

Residue profiles may reveal composition biases in the neighborhood of
the peak sequences. Dinucleotide profiles can reveal (for example) an
enrichment in CpG island.

Note that I<chip-seq-analysis> also runs I<position-analysis> with
larger oligonucleotide length (see option -l) to detect motifs on the
basis of positionally biased oligonucleotides (see task B<positions>).

=item I<ref_motif>

This task combines various operations.

=over

=item Formating of the reference motif

Perform various format conversion for the reference motif (compute
parameters, consensus, logo).

=item Motif enrichment

Generate an enriched motif by scanning the peak sequence set with the
reference motif.

=item Motif comparison

Compare all discovered motifs with the reference motif.

=back

=item I<oligos>

Run I<oligo-analysis> to detect over-represented oligonucleotides of a
given length (k, specified with option -l) in the test set (van Helden
et al., 1998). Prior frequencies of oligonucleotides are taken from
Markov model of order m (see option -markov) estimated from the test
set sequences themselves.

=item I<dyads>

Run I<dyad-analysis> to detect over-represented dyads, i.e. pairs of
short oligonucleotides (monads) spaced by a region of fixed width but
variable content (van Helden et al., 2000). Spaced motifs are typical
of certain classes of transcription factors forming homo- or
heterodimers.

By default, chip-seq-analysis analyzes pairs of trinucleotides with
any spacing between 0 and 20.

The expected frequency of each dyad is estimated as the product of its
monad frequencies in the input sequences (option -bg monads of
dyad-analysis).

=item I<positions>

Run I<position-analysis> to detect oligonucleotides showing a
positional bias, i.e. have a non-homogeneous distribution in the peak
sequence set.

This method was initially developed to analyze termination and
poly-adenylation signals in downstream sequences (van Helden et al.,
2001), and it turns out to be very efficient for detecting motifs
centred on the ChIP-seq peaks. For ChIP-seq analysis, the reference
position is the center of each sequence.

Note that I<chip-seq-analysis> also uses I<position-analysis> for the
task B<profiles>, in order to detect compositional biases (residues,
dinucleotides) in the test sequence set.

=item I<local_words>

Run I<local-word-analysis> to detect locally over-represented
oligonucleotides and dyads. 

The program I<local-word-analysis> (Matthieu Defrance,unpublished)
tests the over-representation of each possible word (oligo, dyad)
in positional windows in the input sequence set.

Two types of background models are supported: (i) Markov model of
order m estimated locally (within the window under consideration; (ii)
the frequency observed for a word in the whole sequence set is used as
estimator of the prior probability of this word in the window.

After our first trials, this program gives excellent results in
ChIP-seq datasets, because its senstivitity increases with large
number of sequences (several hundreds/thousands), and its background
model is more stringent than for programs computing the globl
over-representation (oligo-analysis, dyad-analysis).

=item I<word_compa>

Compare the words (oligos-dyads) discovered by the different
algorithms in order to assess their consistency. Draw a heatmap
showing the significance estiamted for each word (row) by each
algorthm (column).

=item I<motif_compa>

Motifs are compared in three ways.


=over

=item I<Discovered versus discovered>

Perform pairwise comparisons between all motifs (matrices) discovered
by the different algorithms, to assess their consistency.

=item I<Discovered versus reference>

Compare each discovered motif to the reference motif.

=item I<Discovered versus database>

Compare each discovered motif to a database of known motifs
(e.g. Jaspar, TRANSFAC, RegulonDB, UniProbe, ...)

=back

=item I<synthesis>

Generate the HTML file providing a synthesis of the results and
pointing towards the individual result files.

=item I<clean_seq>

Delete the purged sequence files after the analysis, in order to save
space.

This task is executed only when it is called explicitly. It is not
part of the tasks running with the option "-task all".

=back

=cut
    } elsif ($arg eq "-task") {
      my @requested_tasks = split ",", shift (@arguments);
      foreach my $task (@requested_tasks) {
	next unless $task;
	if ($supported_task{$task}) {
	  $task{$task} = 1;
	} else {
	  &RSAT::error::FatalError("Task '$task' is not supported. \n\tSupported: $supported_tasks");
	}
      }

=pod

=item B<-nmotifs max_motif_number>

Maximal number of motifs (matrices) to return for pattern discovery
algorithms. Note the distinction between the maximal number of motifs
(matrices) and the maximum number of patterns (words, dyads): a motif
generally corresponds to mutually overlapping several patterns (dyads,
words).

=cut

    } elsif ($arg eq "-nmotifs") {
      $main::param{matrix_nmotifs} = shift (@arguments);

=pod

=item B<-l oligo_len>


Oligonucleotide length for word-counting approaches (oligo-analysis,
position-analysis, local-word-analysis, oligo-diff).

In our experience, optimal results are obtained with hexanucleotides
and heptanucleotides.

Note: the monad length used for dyad-analysis is not affected by those
options. Instead it is fixed to to 3. Indeed, dyad-analysis can detect
larger motifs by sampling various spacings between the two
trinucleotide monads.

=item B<-minol oligo_min_len>

=item B<-maxol oligo_max_len>

Minimal (-minol) and maximal (-maxol) oligonucleotide lengths. If
those options are used, the program iterated over the specified range
of oligonucleotide lengths.

=cut
    } elsif ($arg eq "-l") {
      my $oligo_len = shift (@arguments);
      $main::param{oligo_min_len} = $oligo_len;
      $main::param{oligo_max_len} = $oligo_len;
    } elsif ($arg eq "-minol") {
      $main::param{oligo_min_len} = shift (@arguments);
    } elsif ($arg eq "-maxol") {
      $main::param{oligo_max_len} = shift (@arguments);

=pod

=item B<-markov>

Order of the Markov model used to estimatd
expected oligonucleotide frequencies for I<oligo-analysis> and
I<local-word-analysis>.

Higher order Markov models are more stringent, lower order are more
sensitive, but tend to return a large number of false positives.

Markov models can be specified with either a positive or a negative
value. Positive value indicate the length of the prefix in the
transition matrix. Negative value indicate the order of the Markov
model relative to the oligonucleotide length. For example, the option
-markov -2 gives a model of order m=k-2 (thus, an order 5 for
heptanucleotides, an order 4 for hexanucleotides).

The optimal Markov order depends on the number of sequences in the
test set. Since ChIP-seq data typically contain hundreds to thoursands
of peaks, high Markov orders are generally good, because they are
stringent and still sensitive enough.  In our experience, motifs are
well detected with the most stringent Markov order (-markov -2).

=item B<-min_markov min_markov_order>

=item B<-max_markov max_markov_order>

A miminal and a maximal value can be specified for the Markov
order. The program then iterates over all markov values between
min_markov_order and max_markov_order.


=cut
    } elsif ($arg eq "-markov") {
      $main::param{oligo_min_mkv} = $main::param{oligo_max_mkv} = shift (@arguments);
    } elsif ($arg eq "-min_markov") {
      $main::param{oligo_min_mkv} = shift (@arguments);
    } elsif ($arg eq "-max_markov") {
      $main::param{oligo_max_mkv} = shift (@arguments);

=pod

=item B<-1str | -2str>

Single-strand (-1str) or double-strand (-2str) analysis.

The default is double-strand analysis, since ChIP-seq results have no
particular strand orientation.

=cut
    } elsif ($arg eq "-1str") {
      $main::param{strand} = "-1str";
    } elsif ($arg eq "-2str") {
      $main::param{strand} = "-2str";

=pod

=item B<-noov | -ovlp>

Treatment of self-overlapping words: count (-ovlp) or do not count
(-noov) overlapping occurrences. In -noov mode, only renewing
occurrences are counted.

It is recommended to use the -noov mode (default) to avoid the effect
of self-overlap, which violates the hypothesis of independence of
successive occurrences underlying the binomial significance test
(oligo-analysis, dyad-analysis).

=cut
    } elsif ($arg eq "-noov") {
      $main::param{noov} = "-noov";
    } elsif ($arg eq "-ovlp") {
      $main::param{noov} = "-ovlp";

=pod

=item B<-ci class_interval>

Class interval for I<position-analysis>.

=cut

    } elsif ($arg eq "-ci") {
      $main::param{profiles_ci} = shift(@arguments);
      &RSAT::error::FatalError($main::param{profiles_ci}, "is not a valid value for class interval. Should be a strictly positive Natural number.")
	unless ((&IsNatural($main::param{profiles_ci})) && ($main::param{profiles_ci} > 0));

      ## Other parameters are not accepted
    } else {
      &FatalError(join("\t", "Invalid option", $arg));

    }
  }

=pod

=back

=cut

}

################################################################
## Check arguments
sub CheckArguments {
  &RSAT::message::TimeWarn("Checking arguments") if ($main::verbose >= 1);

  if ($infile{test_seq}) {
    unless (-e $infile{test_seq}) {
      &FatalError("Test sequence file does not exist", $infile{test_seq});
    }
    @main::seq_types = ("test");
  } else {
    &FatalError("You must define the test sequence set (option -i)");
  }

  if ($infile{ctrl_seq}) {
    unless (-e $infile{ctrl_seq}) {
      &FatalError("Control sequence file does not exist", $infile{ctrl_seq});
    }
    push @main::seq_types, ("ctrl");
  }

  ## output directory
  if ($main::dir{output}) {
    &RSAT::util::CheckOutDir($main::dir{output});
  } else {
    &FatalError("You must define the output directory (option -outdir)");
  }

  ## Log file 
  $main::outfile{log} = &OutFileName(".txt", "log");

  ## Synthesis file 
  $main::outfile{synthesis} = &OutFileName(".html", "synthesis");

  ## If all tasks are requested or if no task is defined, execute all
  ## tasks.
  if ((scalar(keys(%task)) == 0) || ($task{all})) {
    %task = %supported_task;
    delete($task{all});
    delete($task{clean_seq});
  }
  foreach my $task (@supported_tasks) {
   push (@tasks, $task) if $task{$task};
  }
  &RSAT::message::Info("Tasks: ", join (",", @tasks)) if ($main::verbose >= 1);
}

################################################################
## Verbose message
sub Verbose {
    print $main::out "; chip-seq-analysis ";
    &PrintArguments($main::out);
    printf $main::out "; %-22s\t%s\n", "Program version", $program_version;

    ## Parameter values
    print $main::out "; Parameter values\n";
    foreach my $param_name (@param_list) {
      print $main::out sprintf ";\t%-22s\t%s\n", $param_name, $param{$param_name};
    }

    ## Input file(s)
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	  printf $main::out ";\t%-22s\t%s\n", $key, $value;
	}
    }

    print $out &PrintThresholdValues();

    ## Output files
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	foreach my $key (sort keys  %main::outfile) {
	  $value = $main::outfile{$key};
	  printf $main::out ";\t%-30s\t%s\n", $key, $value;
	}
    }
}

=pod

=head1 REFERENCES

The program I<chip-seq-analysis> combines a series of tried-and-tested
programs which have been detailed in the following publications.

=over

=item I<oligo-analysis>

van Helden, J., Andre, B. and Collado-Vides, J. (1998). Extracting
regulatory sites from the upstream region of yeast genes by
computational analysis of oligonucleotide frequencies. J Mol Biol 281,
827-42.

=item I<dyad-analysis>

van Helden, J., Rios, A. F. and Collado-Vides, J. (2000). Discovering
regulatory elements in non-coding sequences by analysis of spaced
dyads. Nucleic Acids Res 28, 1808-18.

=item I<position-analysis>

van Helden, J., del Olmo, M. and Perez-Ortin,
J. E. (2000). Statistical analysis of yeast genomic downstream
sequences reveals putative polyadenylation signals. Nucleic Acids Res
28, 1000-10.

=item I<matrix-scan>

Turatsinze, J. V., Thomas-Chollier, M., Defrance, M. and van Helden,
J. (2008). Using RSAT to scan genome sequences for transcription
factor binding sites and cis-regulatory modules. Nat Protoc 3,
1578-88.

=back

=head1 SEE ALSO

=over

=item I<oligo-analysis>

=item I<dyad-analysis>

=item I<position-analysis>

=item I<matrix-scan>


=back

=head1 WISH LIST

=over

=item I<-max_markov>

=item I<-min_markov>

Maximal and minimal values for the Markov order of the background
model used by I<oligo-analysis> and I<local-word-analysis>.

=item B<motif_cluster>

Compare all discovered motifs (plus reference motif if specified) and
cluster them in order to extract a consensus motif.

=back


=cut

__END__
