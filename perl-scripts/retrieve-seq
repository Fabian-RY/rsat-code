#!/usr/bin/perl
############################################################
#
# $Id: retrieve-seq,v 1.35 2004/05/12 20:36:03 jvanheld Exp $
#
# Time-stamp: <2003-08-05 10:24:33 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.classes";
require "RSA.seq.lib";

#### initialize parameters
my $start_time = &AlphaDate;

my %chomosome = ();
my $chrom = "";



$feature_table_file = "";
$seq_label = "gene";  
$sequence_type = "upstream";
@queries = ();
$out_format = "fasta";
$line_width = 60;
$default{from} = -800;
$default{to} = -1;
$input_sequence_format = "filelist";
$prefix = "";

&ReadArguments();


################################################################################
############################### check parameters ###############################
################################################################################

#### accepted feature types
unless (defined %accepted_feature_types) {
    $accepted_feature_types{cds} = 1;
}
$feature_types = join ",", keys (%accepted_feature_types);

#### selection of genome and feature file
unless ($feature_table_file) {
    $feature_table_file = $supported_organism{$organism_name}->{'features'};
}
if ($input_sequence_file) {
    #### manually specified input sequence
    $organism_name = $organism_name || "input sequence";
    warn "; ", &AlphaDate(), "\tManually specified input sequence file\t$input_sequence_file\n" if ($verbose >= 1);
    &CheckOrganism($organism_name, $feature_table_file, $input_sequence_file, $input_sequence_format);
    
} else {
    #### automatic selection of genome file (and feature file)
    warn "; ", &AlphaDate(), "\tChecking organism $organism_name\n" if ($verbose >= 1);
    &CheckOrganism($organism_name, $feature_table_file);
}

#### default boundaries
if ($sequence_type eq "upstream") {
    
    if (defined($supported_organism{$organism_name}->{'up_to'})) {
	$default{to} = $supported_organism{$organism_name}->{'up_to'};
    } else {
	$default{to} = -1;
    }

    if (defined($supported_organism{$organism_name}->{'up_from'})) {
	$default{from} = $supported_organism{$organism_name}->{'up_from'};
#    } elsif (($organism_name eq "yeast") || 
#	($organism_name =~ /Schizosaccharomyces/) ||
#	($organism_name =~ /Saccharomyces/)) {
#	$default{from} = -800;
#    } elsif (($organism_name =~ /Caenorhabditis/) ||
#	     ($organism_name =~ /Arabidopsis/) ||
#	     ($organism_name =~ /Plasmodium/) ||
#	     ($organism_name =~ /Drosophila/)) {
#	$default{from} = -2000;
    } else { #### bacteria
	$default{from} = -400;
    }
} elsif ($sequence_type eq "downstream") {
    $default{from} = 1;
    $default{to} = 200;
#} elsif ($sequence_type = "exons") {
#    unless (defined($supported_organism{$organism_name}->{'exons'})) {
#	&FatalError("There is no informationa about introns for organism ", $organism_name, "\n");
#    }
#    #### read exons
#    ($exons) = &OpenInputFile($supported_organism{$organism_name}->{'exons'}) {
#	while (<$exons>) {
#	    
#	}
#    }
}

#### check output format ####
&CheckOutputSeqFormat($out_format);

#### check limits ####
$from = $default{from} unless (defined($from));
$to = $default{to} unless (defined($to));
if ($to < $from) {
    $tmp = $to;
    $to = $from;
    $from = $tmp;
}
$seq_length = abs($to - $from + 1);

################################################################
## organism data 

#### random fragments
if ($sequence_type eq "random fragments") {
    #### calculate chromosome lengths
    @chroms = sort keys %chromosome_seq;
    @chr_start;
    @chr_len;
    $chr_start[0] = 0;
    for my $c (0..$#chroms) {
	$chr_len[$c] = $chromosome_seq{$chroms[$c]}->get_length();
	$chr_start[$c+1] = $chr_start[$c] +  $chr_len[$c];
	warn join ("\t", ";\tchromosome", $c+1, $chroms[$c], $chr_len[$c], $chr_start[$c], $chr_start[$c+1]), "\n" 
	    if ($verbose >= 2);
    }
    $genome_len = $chr_start[$#chroms+1];
    warn join ("\t", ";", "genome length", $genome_len), "\n"	    
	if ($verbose >= 2);
    
} else {
    ### read feature attributes (position, description, ...)
    &ReadFeatures($organism_name, $feature_table_file, $feature_types);

    #### read synonyms
    unless ($return_all) {
	warn "; ", &AlphaDate(), "\tReading synonyms for $organism_name\n" if ($verbose >= 1);
	&ReadSynonyms($organism_name);
    }
}

#### no overlapping with upstream orfs
if ($noorf) {
    warn "; ", &AlphaDate(), "\tCalculating neighbour ORF limits\n" if ($verbose >= 1);
    &CalcNeighbourLimits();
}

################################################################
# Query ORFs
#

#### retrieve all
if ($return_all) {
    @queries = keys %left;
} 


#### select random ORFs
if ($random_orfs > 0) {
  @queries = &SelectRandomORFs($random_orfs);
} elsif ($length_file) {
    ($len_handle, $input_dir) = &OpenInputFile($length_file);
#    open LEN, $length_file;
    while (<$len_handle>) {
	my @fields = split "\t";
	push @queries, $fields[1];
    }
    close $len_handle;

} elsif ($num_rand_sel) {
    for $i (1..$num_rand_sel) {
	push @queries, $seq_length;
    }

} elsif (@queries == ()) {
    #### read queries
    ($in, $input_dir) = &OpenInputFile($query_file);
    while (<$in>) {
	next if ((/^;/) || (/^\#/) || (/^--/));
	next if (/^--/);
	if ((/(\S+)/) && !(/^;/)) {
	    push @queries, $1;
	}
    }
    close $in;
}
if ($#queries <0) {
    &FatalError("You should enter at least one valid query.");
}

#### output file ####
$out = &OpenOutputFile($outputfile);

#### verbose
&Verbose() if ($verbose);

################################################################
#### retrieve the sequences ####
my $q = 0;
warn "; ", &AlphaDate(), "\tRetrieving sequences\n" if ($verbose >= 1);
foreach my  $query (@queries) {
    $q++;

    $query = &trim($query); ### make sure there are no leading or trailing spaces


    #### check the validity of the query
    unless (($sequence_type eq "random fragments") ||
	    (defined($orf_id{uc($query)}))) {
	my $warn_message = ";WARNING\tinvalid query $query"; 
	push @warnings, $warn_message;
	next;
    }
    
    $orf_id = $orf_id{uc($query)};
    if ($name{$orf_id}) {
	$name = $name{$orf_id}; 
    } else {
	$name = $orf_id;
    }
    $chrom = $chr{$orf_id};
    
    $orf_left = $left{$orf_id};
    $orf_right = $right{$orf_id};
    $orf_strand = $strand{$orf_id};
    $current_from = $from;
    $current_to = $to;
    ### upstream region
    if ($sequence_type eq "upstream") {
	if ($noorf) {
	    $current_from = &max(-$upstr_size{$orf_id}, $from);
	} 
	
	if ($orf_strand eq "D") {
	    $reg_left = $orf_left + $current_from;
	    $reg_right = $orf_left + $current_to;
	} else {
	    $reg_right = $orf_right - $current_from;
	    $reg_left = $orf_right - $current_to;
	}
	
	### downstream region
    } elsif ($sequence_type eq "downstream") {
	if ($noorf) {
	    $current_to = &min($downstr_size{$orf_id}, $to);
	} 
	
	if ($orf_strand eq "D") {
	    $reg_left = $orf_right + $current_from;
	    $reg_right = $orf_right + $current_to;
	} else {
	    $reg_right = $orf_left - $current_from;
	    $reg_left = $orf_left - $current_to;
	}
	
	### ORF (wargning: this does not splice out introns
    } elsif ($sequence_type eq "unspliced ORF") {
	$reg_left = $orf_left;
	$reg_right = $orf_right;
	
    #### select random genommic positions
    } elsif ($sequence_type eq "random fragments") {
#	foreach my $seq_length (@seq_lengths) {
	my $seq_length = $query;
	my $max_pos = $genome_len - ($#chroms + 1) * ($seq_length  - 1); ### skip the last  L-1 positions of each chromosome because they would not allow a sequence of length $seq_length
	my $position = int(rand($max_pos));
	my $c = 0;
	warn join("\t", $seq_length, $position, $max_pos, $genome_len), "\n" if ($verbose >= 3);
	while ($position > ($chr_len[$c] - $seq_length + 1)) {
	    $position -= $chr_len[$c]  - $seq_length + 1; 
	    $c++;
	}
	$chrom = $chroms[$c];
	$chr_length = $chromosome_seq{$chroms[$c]}->get_length();
	$reg_left = $position;
	$reg_right = $reg_left + $seq_length -1;
	if (int(rand(2))) {
	    $orf_strand = "D";
	} else {
	    $orf_strand = "R";
	};

	warn join("\t", $chrom, $reg_left, $reg_right, $orf_strand, $seq_length, $chr_length, $position, $max_pos), "\n" if ($verbose >= 3);

    }
    
    $reg_size =  $reg_right - $reg_left + 1;
    
    ###  sequence ID 
    my $current_id = $prefix;
    if ($sequence_type eq "random fragments") {
	$current_id .= $query = "rand_".$q;
    } elsif ($seq_label eq "orf") {
	$current_id .= $orf_id;
    } elsif ($seq_label eq "gene") {
	$current_id .= $name;
    } elsif ($seq_label eq "orf_gene") {
	$current_id .= join "_", $orf_id, $name;
    } else {
	$current_id .= join("_", 
			   $orf_id,
			   $name,
			   $sequence_type,
			   $current_from,
			   $current_to,
			   $chrom,
			   $orf_strand,
			   $reg_left,
			   $reg_right
			   );
    }
    
    unless ($no_comments) {
	if ($sequence_type eq "random fragments") {
	    @comments = ("random fragment; size: $reg_size; location: $chrom $reg_left $reg_right $orf_strand");
	} else {
	    @comments = ("$query $sequence_type sequence, from $current_from to $current_to, size $reg_size");
	    @comments = (@comments, "sequence size: $reg_size; location: $chrom $reg_left $reg_right $orf_strand");
	    @comments = (@comments, "Gene: $name; ID: $orf_id; gene location: $orf_left $orf_right $orf_strand");
	}
    }
    
    ### substring retrieval
    warn (join "\t", 
	  ";",
	  $query, 
	  $orf_id, 
	  $chrom, 
	  $orf_left, 
	  $orf_right, 
	  $orf_strand,
	  $current_from,
	  $current_to,
	  $reg_left,
	  $reg_right,
	  $reg_size,
	  "\n"
	  )
	if ($verbose >= 2); 
    $current_seq = $chromosome_seq{$chrom}->get_sequence($reg_left,$reg_right,$orf_strand);

    ### print result sequence
    &PrintNextSequence($out,$out_format,$line_width,$current_seq,$current_id, @comments);
}


print $out (join "\n", @warnings), "\n" 
    unless $no_warn;

close $out;

###### verbose ######
if ($verbose) {
    my $done_time = &AlphaDate;
    print $out "; Job started $start_time\n";
    print $out "; Job done    $done_time\n";
}



exit(0);

################################################################
#### subroutine definitions
################################################################

################################################################
#### detailed help message
sub PrintHelp {
    
    my $supported_organisms = &ListSupportedOrganisms("sizes");
    open(HELP, "| more");
    print HELP<<End_help;
USAGE
	retrieve-seq -type type -org organism	
			[-from] [-to] [-format seqformat] [-lw line_width] 
			[-o outpufile] -q query_orf | -i query file | -all

DESCRIPTION
	Returns upstream or downstream sequences for list of query
	genes.

CATEGORY
	genomics
	sequences

OPTIONS
	-org organism
	     When an organism is specified, the program automatically
	     loads the appropriate genome sequence and feature table.

	     If this option is not used, the option -seq must be used
	     instead.

	     (type supported-organism to obtain the list of supported
	     organisms)

	-seq	input sequence file
		(alternative to organism)

		Specify the input sequence file. See INPUT FORMAT
		below.
	-informat	input sequence format
	-prefix
		prefix for sequence identifier
	-feattype
		Feature type.
		Supported: $supported_feature_types
	-type	sequence type
		Currently supported sequence types
			upstream (default)
			downstream
			orf (warning: introns are not spliced out)
			random (random fragments)
		To implement in the future
			introns
			coding

		The sub-option 
		    -type random
		requires to use the -n for specifying the number of sequences.
	-n number of sequecnes (only with -type random) 
	-q query
		The query should be an orf identifier (eg 'metR').
		The query is case-insensitive.
		Multiple queries can be entered by reiteratively using the -q 
		option.
        -i     query file. The first word of each line is taken as a query.
                This option is incompatible with -q.
	-all	return all genomic upstream regions
	-o	followed by the name of the outputfile. 
        -from #1 -to #2 
                where #1 and #2 are numbers. #2 should be higher than #1.
                limits of the region to extract, relative to orf start 
                (=position 0). Use negative values for upstream sequence.
                        example: -from -800 -to -1 
                        will extract the 800 bp upstream the orf start.
			 (this is the default)
	-format	allows to select different output formats, with the following 
		options:
		IG	IntelliGenetics (default format)
		WC	wconsensus format
		raw	only the sequence is returned, without spaces, newlines
			nor comments.
                FastA
	-lw ##	Line width. A newline character will be inserted in the 
		sequence every ## bases. Default is 60. 
		-lw 0 will prevent newline insertion.
        -label label_type
		rule for naming sequences
		supported label types
			orf	ORF identifier
			gene	gene name
				(if the gene has no name, ORF identifier is used instead).
			orf_gene
				concatenate ORF id and gene name
			full	label is a concatenation of ORF identifier,
				gene name, sequence type and limits

	-noorf	the upstream sequence can only contain non-coding sequence.
		i.e. the -from values is modified if a predicted orf
		is encountered within its range. 
		The weaknesses of using this option are that
		- all predicted orf do not correspond to real orf,
		- there is no a priori reason to exclude a regulatory site
		  which would overlap the upstream coding sequence.
	-nocom	no comments. Only the identifier and the sequence are
		returned. By default, the comment indicates the orf and
		upstream sequence coordinates.
	-nowarn
		Prevents warning when a gene cannot be identified.
	-randsels #	
		Return the sequences (specified by the option -type)
		for a random selection of # ORFs.
	-lf	length file 
		(only with the option '-type random')
		Allows to generate random sequences with the same
		lengths as a set of reference sequences. The sequence
		length file can be obtained with the command
			sequence-lengths
		The length file contains two columns : 
		    - sequence ID (ignored)
		    - sequence length
	-features	
		alternate feature table. This option allows to speify
		an alternate file where the ORF locations are found. 
		See below for a description of the feature file format.

INPUT FORMATS
	Input sequence file
		Sequence file is of type chrlist, i.e. this file
		contains a list of other file names, each of which
		contains a raw contig sequence (usually a whole
		chromosome). The raw sequence files cannot contain any
		space or carriage return : the character position in
		the file must correspond to the nucleotide position on
		the chromosome.

	Feature file
		The feature file contains one line per feature, with
		tab-delimited columns providing the following information:
		column	field   description
		1	id	feature identifier
		2	type	feature type (Supported: ${supported_feature_types})
		3	name	feature name
		4	chrom	chomosome.or contig
		5	left	left end position
		6	right	right end position
		7	strand	D (direct) or R (reverse)
		8	descr	short description (optional)

EXAMPLES
	retrieve-seq -type upstream -org Escherichia_coli_K12 \\
		     -q metJ -q meta -q metb		      \\
		     -from +59 -to -200 -noorf
	
	will return the sequence of 260 nucleotides, 200of which 
	extracted upstream the start codon, and the 60 following being 
	the beginning of the coding sequence.

End_help
    close HELP;
    exit;
}

################################################################
#### list of options    
sub PrintShortHelp {
  open(HELP, "| more");
  print HELP<<End_short_help;
retrieve-seq options
--------------------
-org		organism
-seq		sequence file (alternative to organism)
-informat	input sequence format
-prefix		prefix for sequence identifiers
-feattype	accepted feature types. Supported: $supported_feature_types
-type		upstream | downstream | orf | random
-n		number of sequences (only with -type random)
-randsels #	random selection of # ORFs.
-lf		length file 
-i		query file. This option is incompatible with -q.
-q		query
-all		returns all genomic upstream regions
-o		followed by the name of the outputfile. 
-from #1 -to #2	limits of the region to extract, relative to orf start 
-format		output sequence format. accepted: IG, raw, WC
-lw ##		Line width. -lw 0 will prevent newline insertion.
-label orf|gene|orf_gene|full	rule for naming sequences
-noorf		the upstream sequence can only contain non-coding sequence.
-nowarn		prevents warning when a gene can not be identified
-nocom		do not print related information (start, end position, ...)
-features	alternate feature table
End_short_help
  close HELP;
  exit;
}

################################################################
#### read arguments
sub ReadArguments {
    foreach $a (0..$#ARGV) {
	### output file name
	if ($ARGV[$a] eq "-o") {
	    $outputfile = $ARGV[$a+1];
	    
	    ### help request
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintShortHelp;
	    
	    ### output sequence format
	} elsif ($ARGV[$a] eq "-format") {
	    $out_format = lc($ARGV[$a+1]);
	    
	    ### limits of the region to retrieve
	} elsif (($ARGV[$a] eq "-from") && ($ARGV[$a+1] =~ /^[+-]{0,1}(\d+)$/)) {
	    $from = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-to") && ($ARGV[$a+1] =~ /^[+-]{0,1}(\d+)$/)) {
	    $to = $ARGV[$a+1];
	    
	    ### verbose
	} elsif ($ARGV[$a] eq "-v") {
	    if (&IsReal($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }

	    ### verbose
	} elsif (($ARGV[$a] eq "-w") &&
		 (&IsNatural($ARGV[$a+1]))){
	    $verbose = $ARGV[$a+1];

	    #### new query
	} elsif ($ARGV[$a] eq "-q") {
	    @queries = (@queries, $ARGV[$a+1]);
	    
	    #### input file (one query per line)
	} elsif ($ARGV[$a] eq "-i") {
	    $query_file =$ARGV[$a+1];
	    
	    #### specific input file for random selections (one sequence length per line)
	} elsif ($ARGV[$a] eq "-lf") {
	    $length_file =$ARGV[$a+1];
#	    die "HELLO\t$length_file";

	    #### random selection of ORFs
	} elsif ($ARGV[$a] =~ /-randsel/) {
	    $random_orfs =$ARGV[$a+1];
	    unless (&IsNatural($random_orfs)) {
		&FatalError("The number of sequences must be a natural number");
	    }
	    unless ($random_orfs > 0) {
		&FatalError("The number of ORFs must be > 0");
	    }
	    
	    ### return all genomic  upstream regions	
	} elsif ($ARGV[$a] eq "-all") {
	    $return_all = 1;
	    
	    #### organism
	} elsif ($ARGV[$a] eq "-org") {
	    $organism_name =$ARGV[$a+1];
	    &CheckOrganismName($organism_name);

	    #### input sequence file
	} elsif ($ARGV[$a] eq "-seq") {
	    $input_sequence_file =$ARGV[$a+1];

	    #### input sequence format
	} elsif ($ARGV[$a] eq "-informat") {
	    $input_sequence_format =$ARGV[$a+1];

	    #### prefix
	} elsif ($ARGV[$a] eq "-prefix") {
	    $prefix =$ARGV[$a+1];

	    #### number of random segments tor eturn
	} elsif ($ARGV[$a] eq "-n") {
	    $num_rand_sel =$ARGV[$a+1];
	    unless (&IsNatural($num_rand_sel)) {
		&FatalError("The number of sequences must be a natural number");
	    }
	    unless ($num_rand_sel > 0) {
		&FatalError("The number of sequences must be a strictly positive");
	    }

	    #### feature types
	} elsif ($ARGV[$a] eq "-feattype") {
	    my @feature_types = split ",", $ARGV[$a+1];
	    foreach my $feature_type (@feature_types) {
		if ($supported_feature_types{lc($feature_type)}) {
		    $accepted_feature_types{lc($feature_type)}++;
		} else {
		    &FatalError("$feature_type invalid feature type. Supported: $supported_feature_types");
		}
	    }

	    #### sequence type
	} elsif ($ARGV[$a] eq "-type") {
	    if ($ARGV[$a+1] =~ /^up/i) {
		$sequence_type = "upstream";
		$default{from} = -400;
		$default{to} = -1;
		
	    } elsif ($ARGV[$a+1] =~ /^down/i) {
		$sequence_type = "downstream";
		
	    } elsif ($ARGV[$a+1] =~ /^orf/i) {
		$sequence_type = "unspliced ORF";
		$default{from} = "start";
		$default{to} = "stop";
		
	    } elsif ($ARGV[$a+1] =~ /^rand/i) {
		$sequence_type = "random fragments";
		
#	    } elsif ($ARGV[$a+1] =~ /^exon/i) {
#		$sequence_type = "exons";
#		
#	    } elsif ($ARGV[$a+1] =~ /^intron/i) {
#		$sequence_type = "introns";
		
	    } else {
		die ("Error: unsupported sequence type: '$ARGV[$a+1]'", 
		     "\n");
	    }
	    
	    
	    #### line width
	} elsif (($ARGV[$a] eq "-lw") && ($ARGV[$a+1] >= 0)) {
	    $line_width = $ARGV[$a+1];
	    
	    #### use identifiers rather than gene names
	} elsif ($ARGV[$a] eq "-label") {
	    if ((lc($ARGV[$a+1]) eq "orf")) {
		$seq_label = "orf";
	    } elsif ((lc($ARGV[$a+1]) eq "gene")) {
		$seq_label = "gene";
	    } elsif ((lc($ARGV[$a+1]) eq "orf_gene")) {
		$seq_label = "orf_gene";
	    } elsif ((lc($ARGV[$a+1]) eq "full")) {
		$seq_label = "full";
	    } else {
		die "Error: invalid sequence label";
	    }
	    
	    #### do not allow overlapping coding sequences
	} elsif (($ARGV[$a] =~ /^-nocds/i) || 
		 ($ARGV[$a] =~ /^-noorf/i)) {
	    $noorf = 1;

	    #### do not print the comments field
	} elsif ($ARGV[$a] =~ /^-nocom/i) {
	    $no_comments = 1;
	    
	    #### do not warn
	} elsif ($ARGV[$a] =~ /^-nowarn/i) {
	    $no_warn = 1;
	    
	    #### alternative feature file
	} elsif ($ARGV[$a] =~ /^-feat/i) {
	    $feature_table_file = $ARGV[$a+1];
	    
	}
    }
}


################################################################
#### verbose ####
sub Verbose {
    print $out "; retrieve-seq";
    &PrintArguments($out);
    printf $out "; %-14s\t%s\n", "organism", $organism_name;
    printf $out "; %-14s\t%s\n", "sequence type", $sequence_type;
    printf $out "; %-14s\t%s\n", "feature type", $feature_types;
    if ($input_sequence_file) {
	printf $out "; %-14s\t%s\n", "input sequence file", $input_sequence_file;
	printf $out "; %-14s\t%s\n", "input sequence format", $input_sequence_format;
    }
    printf $out "; %-14s\t%s\n", "feature table file", $feature_table_file if ($feature_table_file);
    printf $out "; %-14s\t%s\n", "Output format", $out_format;
    printf $out "; %-14s\t%s\n", "Line width", $line_width;
    printf $out "; %-14s\t%d\n", "Random selection", $random_orfs if ($random_orfs);
    print $out "; clipping to avoid overlap with neighbour ORFs\n" if ($noorf);
    print $out "; relative coordinates\n";
    print $out ";        from    $from\n";
    print $out ";        to      $to\n";
    print $out ";        size    ", abs($to - $from + 1), "\n";
    if (defined($query_file)) {
	printf $out "; %-14s\t%s\n", "Query file", $query_file;
    } else {
	printf $out "; %-14s\t%d\n", "Queries", scalar(@queries);
	unless ($return_all) {
	    foreach $q (@queries) {
		print $out ";	$q\n";
	    }
	}
    }
    print $out ";\n";
}
