#!/usr/bin/perl
############################################################
#
# $Id: multiple-family-analysis,v 1.13 2002/03/18 11:03:03 jvanheld Exp $
#
# Time-stamp: <2002-03-18 12:00:38 jvanheld>
#
############################################################
if ($0 =~ /([^(\/)]+)$/) {
  push (@INC, "$`lib/");
}
require "RSA.lib";
require "RSA.cgi.lib";
require "RSA.classes";

###read parameters
if ($#ARGV < 0) {
  die ("Usage : multiple-family-analysis -org organism -fam family_file \n", 
       "\t[-noup] [-nocalc] [-nosynt] [-v]\n");
}



#### initialisations	    
@supported_tasks = qw (upstream oligos dyads synthesis clean all);
foreach my $task (@supported_tasks) {
    $supported_task{$task} = 1;
}
$supported_tasks = join ",", @supported_tasks;

$noorf = 0;
$default{from} = -800;
$default{to} = 0;
$known_site_file = "known-consensus";
$known_sites_provided = 0;
$exp = "ncf";

&ReadArguments();

#### check selected tasks
unless (defined(%task)) {
    &FatalError("You should select at least one task.");
}
if ($task{all}) {
    foreach my $t (@supported_tasks) {
#	next if ($t eq 'clean'); ### clean needs to be actively called
	$task{$t} = 1;
    }
}

############################### check parameters ###############################

### family file ###
if ($family_file eq "") {
  die "Error: you should specify a family file\n";  
} 

### organism ###
if ($organism_name eq "") {
  die "Error: you should specify an organism\n$supported_organisms\n";  
} 
unless ($supported_organism{$organism_name}) {
  die ("Error: organism $organism_name is not supported\n",
       "Supported organisms:\n$supported_organisms\n");
}
&InitParameters;

### read gene name and identifiers
warn "; Reading ORF information ...\n" 
    if ($verbose);
&ReadOrfPositions($organism_name);
&ReadSynonyms($organism_name);


################################################################
#
# read data
&ReadKnownSites();
&ReadSiteLibrary();
&ReadFamilies();

### some verbose
if ($verbose) {
  print "; multiple-family analysis\n";
  printf "; families     \t%d\n", $#families + 1;
  foreach $family (@families) {
    printf ";\t%s\n", $family;
  }
  printf "; upstream region\n";
  printf ";\tstrands\t%s\n", $strands;
  printf ";\tfrom\t%d\n", $from;
  printf ";\tto\t%d\n", $to;
  printf ";\tsize\t%d\n", $size;
  printf "; sig threshold\t%.1f\n", $th;
  printf "; dyad type    \t%s\n", $type;
  printf "; exp freq     \t%s\n", $exp;
}

### write composition of the families in the separated directories
&SetFileNames();

### initialize one directory for each family
foreach $family_name(@families) {
  $dir = "${family_name}/";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }
  open FAM, ">$family{$family_name}->{family_file}" ||
      die "Error: cannot write family file $family{$family_name}->{family_file}\n";
  foreach $id (@{$family{$family_name}->{members}}) {
    print FAM "$id\t$name{$id}\n";
    
  }
  close FAM;
}

### perform analysis
&AnalyzeFamilies();
&SyntheticTable if ($task{synthesis});

#### report execution time 
if ($verbose) {
  $done_date = `date`;
  print ";Job started\t$start_date";
  print ";Job done\t", `date`;
}
exit(0);


################################################################
#
#                 SUBROUTINE DEFINITION
#
################################################################

#### set the file names as a function of parameters
sub SetFileNames {
  $sp = "0-$max_sp";
  $dyad_options = "-v ";
  $dyad_options .= "-sort ";
  $dyad_options .= "-${strands} ";
  $dyad_options .= "-type $type ";
  $dyad_options .= "-noov " if ($noov);
  $dyad_options .= "-l $dyad_element_length ";
  $dyad_options .= "-thosig $th ";
  $dyad_options .= "-sp $sp ";
  if ($exp_freq_file{dyads}) {
    $dyad_options .= "-expfreq $exp_freq_file{dyads}";
  } elsif ($exp eq "ncf") {
    $dyad_options .= "-ncf ";
    $dyad_options .= "-org $organism_name ";
  } elsif ($exp eq "mncf") {
    $dyad_options .= "-mncf ";
    $dyad_options .= "-org $organism_name ";
  }
  
  $dyad_suffix = "_dyads";
  $dyad_suffix .= "_l${dyad_element_length}";
  $dyad_suffix .= "_sp${sp}";
  $dyad_suffix .= "_${strands}";
  $dyad_suffix .= "_${type}";
  $dyad_suffix .= "_sig${th}";
  if ($noov) {
    $dyad_suffix .= "_noov";
  } else {
    $dyad_suffix .= "_ov";
  }
  if ($exp eq "ncf") {
    $dyad_suffix .= "_ncf";
  } elsif ($exp eq "mncf") {
    $dyad_suffix .= "_mncf";
  }

  $noorf_string = "_noorf" if ($noorf);
  foreach my $family_name (@families) {
      $family{$family_name}->{family_file} = "$family_name/${family_name}.fam";
      $family{$family_name}->{known_site_file} = "$family_name/${family_name}_known_sites";
      $family{$family_name}->{file_prefix} = "${family_name}_up${seq_length}${noorf_string}"; 
      $family{$family_name}->{seq_file} = $family_name."/".$family{$family_name}->{file_prefix}.".${seq_format}";
      $family{$family_name}->{seq_file_purged} = $family_name."/".$family{$family_name}->{file_prefix}."_purged.${seq_format}";
      
      $family{$family_name}->{oligo_file} =  "${family_name}/oligos_${family_name}/".$family{$family_name}->{file_prefix}."_oligos_${min_oligo_length}-${max_oligo_length}nt_${strands}_sig${th}";
      $family{$family_name}->{oligo_file} .= "_noov" if ($noov);
      $family{$family_name}->{oligo_assembly_file} = $family{$family_name}->{oligo_file}."_contigs";
      $family{$family_name}->{oligo_ft_file} = $family{$family_name}->{oligo_file}.".ft";
      
      $family{$family_name}->{dyad_file} = "$family_name/dyads_${family_name}/".$family{$family_name}->{file_prefix}.$dyad_suffix;
      $family{$family_name}->{dyad_assembly_file} = $family{$family_name}->{dyad_file}."_contigs";
      $family{$family_name}->{dyad_ft_file} = $family{$family_name}->{dyad_file}.".ft";
      $family{$family_name}->{fmap_file} = $family{$family_name}->{dyad_file}.".gif";
      $family{$family_name}->{htmap_file} = $family{$family_name}->{dyad_file}.".html";
  }  
}

################### SUBROUTINE DEFINITION ###################"



#### retrieve upstream sequences
sub UpstreamSequences {
  warn "; Generating upstream sequences for family $family_name\n" if ($verbose);
  $command = "retrieve-seq -type upstream -org $organism_name";
  $command .= " -noorf " if ($noorf);
  $command .= " -i $family{$family_name}->{family_file}";
  $command .= " -o $family{$family_name}->{seq_file}";
  $command .= " -from $from -to $to ";
  $command .= " -label orf_gene ";
  $command .= " -format $seq_format";
  &doit($command);

  $command = "purge-sequence -ml 40 -mis 3";
  $command .= " -i $family{$family_name}->{seq_file}";
  $command .= " > $family{$family_name}->{seq_file_purged}";
  &doit($command);
}



### oligo-analysis
sub OligoAnalysis {
  $dir = "${family_name}/oligos_${family_name}";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }
  die "Error : cannot read file $family{$family_name}->{seq_file_purged}\n" unless (-r $family{$family_name}->{seq_file_purged});
  
  
  system "echo '' > $family{$family_name}->{oligo_file}" if ($verbose >=1);
  
  for $oligo_length ($min_oligo_length..$max_oligo_length) {
    $oligo_options = "-v ";
    $oligo_options .= "-sort ";
    $oligo_options .= "-${strands} ";
    $oligo_options .= "-l $oligo_length ";
    $oligo_options .= "-thosig $th ";
    if ($exp_freq_file{oligos}) {
	$oligo_options .= "-expfreq $exp_freq_file{oligos} ";
    } else {
	$oligo_options .= "-org $organism_name ";
	$oligo_options .= "-ncf ";
      }
    $oligo_options .= "-return occ,proba,zscore ";
    $oligo_options .= "-noov " if ($noov);
    
    $oligo_suffix = "_oligos";
    $oligo_suffix .= "_${oligo_length}nt";
    $oligo_suffix .= "_${strands}";
    $oligo_suffix .= "_sig${th}";
    $oligo_suffix .= "_noov" if ($noov);
    
    $oligo_file = "$family_name/oligos_${family_name}/".$family{$family_name}->{file_prefix}.$oligo_suffix;    
    $command = "oligo-analysis -i $family{$family_name}->{seq_file_purged} -format $seq_format -o $oligo_file $oligo_options";
    
    &doit($command);
    system "cat $oligo_file | grep -v ';' >> $family{$family_name}->{oligo_file}";
  }

  ### fragment assembly
  $fmap_file = $family{$family_name}->{oligo_file}.".gif";
  $htmap_file = $family{$family_name}->{oligo_file}.".html";

  $command = "pattern-assembly -i $family{$family_name}->{oligo_file} -sc 7 -${strands} -v -o $family{$family_name}->{oligo_assembly_file} -maxfl 1 -maxpat 200 ";

  &doit($command);

  ### feature-map for oligo-analysis
  die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
  $origin = -$from + 1;
  $command = "dna-pattern -i $family{$family_name}->{seq_file} -format $seq_format -pl $family{$family_name}->{oligo_file} -origin $origin -sc 7 -N 4 ";
  $command .= " | features-from-dnapat -o $family{$family_name}->{oligo_ft_file} ";
  $command .= " ; feature-map -i $family{$family_name}->{oligo_ft_file} -scalebar -scalestep 50 -legend -from $from -to $to -o $fmap_file -scorethick -htmap > $htmap_file ";
  
  &doit($command);
}

### dyad analysis
sub DyadAnalysis {
  $dir = "${family_name}/dyads_${family_name}";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }
  die "Error : cannot read file $family{$family_name}->{seq_file_purged}\n" unless (-r $family{$family_name}->{seq_file_purged});
  $command = "dyad-analysis -i $family{$family_name}->{seq_file_purged} -format $seq_format -o $family{$family_name}->{dyad_file} $dyad_options";

  &doit($command);
  
  ### fragment assembly
  $command = "pattern-assembly -v -i $family{$family_name}->{dyad_file} -o $family{$family_name}->{dyad_assembly_file} -$strands -maxfl 2 -sc 7 -maxpat 200 ";

  &doit($command);

  ### feature-maps
  die "Error : cannot read file $family{$family_name}->{seq_file}\n" unless (-r $family{$family_name}->{seq_file});
  &DrawFeatureMaps;
}

### read known known_site for each family
sub ReadKnownSites {
    %known_site = ();
    %known_site_source = ();
    if (-e $known_site_file) {
	$known_sites_provided = 1;
	open KNOWN_SITE, $known_site_file;
	while (<KNOWN_SITE>) {
	    next if (/^;/);
	    next unless (/\S/);
	    chomp;
	    @fields = split "\t";
	    $family_name = $fields[0];
	    $source = $fields[2];
	    $known_site = uc($fields[1]);
	    #$known_site = uc(&compress_pattern($known_site,"n"));
	    $known_site =~ s/N/n/g;
	    push @{$known_site{$family_name}}, $known_site;
	    push @{$known_site_source{$family_name}}, $source;
	}
	close KNOWN_SITE;
    }
}

sub ReadSiteLibrary {
  @site_library = ();
  $library_file = "known_sites.tab";
  if (-e $library_file) {
    open LIBRARY, $library_file;
    while (<LIBRARY>) {
      next if (/^;/);
      next unless (/\S/);
      chomp;
      my @fields = split "\t";
      my $source = $fields[2] || $library_file;
      my $id = uc($fields[1]);
      my $sequence = uc($fields[0]);
      $sequence =~ s/N/n/g;
      
      $pattern = RSA::pattern->new(id=>$id,
				   sequence=>$sequence,
				   source=>source);
      push @site_library, $pattern;
    }
    close LIBRARY;
  }
}
  
### build a synthetic table ###
sub SyntheticTable {
  print "; Generating synthetic table\n" if ($verbose);
  $dir = "synthetic_tables";
  unless (-d $dir) {
    mkdir $dir, 0755 || die "Error: cannot create directory $dir\n";
  }  
  
  ### synthesize the results of all families into a single file
  
  ### headers
  $row = 0;
  $row{family} = $row++;
  $row{genes} = $row++;
  $row{known} = $row++ if ($known_sites_provided);
  $row{oligo} = $row++;
  $row{dyad} = $row++;
  $row_num = $row-1;
  while (($header,$row) = each %row) {
    $table[$row][0] = "<B>$header</B>";
  }
  $col = 0;

  foreach $family_name (@families) {
    $col++;
    
    ### check directory
    $dir = "${family_name}/dyads_${family_name}";
    unless (-d $dir) {
      print "Error: cannot find directory $dir\n";
    }
    
    ### family name
    $table[$row{family}][$col] = "<B>$family_name</B>";

    ### list of genes
    $table[$row{genes}][$col] = join " ", @{$family{$family_name}->{members}};
    
    ### known patterns
    if ($known_sites_provided) {
	$table[$row{known}][$col] = "";
	for $c (0..$#{$known_site{$family_name}}) {
	    $table[$row{known}][$col] .= ${known_site{$family_name}}[$c];
   	    $table[$row{known}][$col] .= "<BR>(".${known_site_source{$family_name}}[$c].")" if (${known_site_source{$family_name}}[$c]);
            $table[$row{known}][$col] .= "<P>";
        }
    } 
    
    #### oligo-analysis
    open OLIGOS, "$family{$family_name}->{oligo_assembly_file}";
    $map_link = "<A HREF=../$family{$family_name}->{oligo_file}.html>\n";
    print "extracting info from\t$family{$family_name}->{oligo_assembly_file}\n" if ($verbose);
    undef @patterns;
    undef @sorted_patterns;
    undef %rc;
    undef %score;
    undef %type;
    while (<OLIGOS>) {
      chomp;
      next if (/^;/);
      next unless (/\S/);
      if ((/contig/) || (/consensus/) || (/isol/)) {
	@fields = split "\t";
	my $sequence = uc($fields[0]);
	$pattern = new RSA::pattern(sequence=>$sequence);
	push @patterns, $pattern;
	$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
	$score{$pattern} = $fields[2];
	$type{$pattern} = $fields[3];
      }
    }
    @sorted_patterns = sort { $score{$b} <=> $score{$a} } @patterns;
    $table[$row{oligo}][$col] = "<TABLE>\n";
    $table[$row{oligo}][$col] .= "<TR>\n";

    ### print oligo sequence
    $table[$row{oligo}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= uc($sorted_patterns[$p]->get_attribute("sequence")); 
      $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{oligo}][$col] .= "</TD>\n";

    ### print reverse complementary oligo
    $table[$row{oligo}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= uc($rc{$sorted_patterns[$p]});
      $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{oligo}][$col] .= "</TD>\n";

    ### print oligo score
    $table[$row{oligo}][$col] .= "<TD>$map_link\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{oligo}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= "$score{$sorted_patterns[$p]}";
      $table[$row{oligo}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{oligo}][$col] .= "</A></TD>\n";

    ### print matching patterns
    if ($known_sites_provided) {
       $table[$row{oligo}][$col] .= "<TD>\n";
       for $p (0..$#sorted_patterns) {
         my @matches = ();
         foreach $site (@site_library) {
	   if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
	       ($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
	     #my $match = $site->get_attribute("sequence");
	     my $match = $site->get_id();
	     push @matches, $match;
	   }
        }
        $table[$row{oligo}][$col] .= join(";",@matches);
        $table[$row{oligo}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
      }
      $table[$row{oligo}][$col] .= "</TD>\n";
    }
    
    $table[$row{oligo}][$col] .= "</TR>\n";
    $table[$row{oligo}][$col] .= "</TABLE>\n";
    close OLIGOS;

    ### dyad analysis
    open DYADS, "$family{$family_name}->{dyad_assembly_file}";
    $map_link = "<A HREF=../$family{$family_name}->{dyad_file}.html>\n";
    print "extracting info from\t$family{$family_name}->{dyad_assembly_file}\n" if ($verbose);
    undef @patterns;
    undef @sorted_patterns;
    undef %rc;
    undef %score;
    undef %type;
    while (<DYADS>) {
      chomp;
      next if (/^;/);
      next unless (/\S/);
      if ((/contig/) || (/consensus/) || (/isol/)) {
	@fields = split "\t";
	my $sequence = $fields[0];
	$pattern = new RSA::pattern(sequence=>$sequence);
	push @patterns, $pattern;
	$rc{$pattern} = uc(&ReverseComplement($pattern->get_attribute("sequence")));
	$score{$pattern} = $fields[2];
	$type{$pattern} = $fields[3];
      }
    }
    @sorted_patterns = sort {$score{$b} <=> $score{$a}} @patterns;
    $table[$row{dyad}][$col] = "<TABLE>\n";
    $table[$row{dyad}][$col] .= "<TR>\n";

    ### print dyad sequence
    $table[$row{dyad}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $sequence = $sorted_patterns[$p]->get_attribute("sequence");
      $compressed = uc(&compress_pattern($sequence, "n"));
      $compressed =~ s/N/n/g;
      $table[$row{dyad}][$col] .= $compressed;
      $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{dyad}][$col] .= "</TD>\n";

    ### reverse complementary dyad
    $table[$row{dyad}][$col] .= "<TD>\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $compressed = uc(&compress_pattern($rc{$sorted_patterns[$p]},"n"));
      $compressed =~ s/N/n/g;
      $table[$row{dyad}][$col] .= $compressed;
      $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{dyad}][$col] .= "</TD>\n";

    ### dyad scores
    $table[$row{dyad}][$col] .= "<TD>$map_link\n";
    for $p (0..$#sorted_patterns) {
      $table[$row{dyad}][$col] .= "<B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{dyad}][$col] .= "$score{$sorted_patterns[$p]}";
      $table[$row{dyad}][$col] .= "</B>" if ($score{$sorted_patterns[$p]} >= 1);
      $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
    }
    $table[$row{dyad}][$col] .= "</A></TD>\n";

    ### print matching patterns
    if ($known_sites_providde) {
      $table[$row{dyad}][$col] .= "<TD>\n";
      for $p (0..$#sorted_patterns) {
        my @matches = ();
        foreach $site (@site_library) {
	  if (($sorted_patterns[$p]->contains($site, min_score=>$min_matching_score)) ||
	     ($site->contains($sorted_patterns[$p], min_score=>$min_matching_score))) {
	    #my $match = $site->get_attribute("sequence");
 	    my $match = $site->get_id();
 	    push @matches, $match;
	  }
        } 
        $table[$row{dyad}][$col] .= join(";",@matches);
        $table[$row{dyad}][$col] .= "<BR>" unless ($p == $#sorted_patterns);
      }
      $table[$row{dyad}][$col] .= "</TD>\n";
    }

    $table[$row{dyad}][$col] .= "</TR>\n";
    $table[$row{dyad}][$col] .= "</TABLE>\n";
    close DYADS;
  }
  
  $table_file = "synthetic_tables/table".$dyad_suffix;
  $table_file .= "_tr" if ($transpose);
  open TABLE, "> ${table_file}.html";
  print TABLE "<HTML><BODY>\n";
  print TABLE "<H1>$table_file</H1>\n";
    
  print TABLE "<TABLE BORDER=1>\n";

  if ($transpose) {
    foreach $r (0..$row_num) {
      print TABLE "<TR>\n";
      foreach $c (0..$col) {
	print TABLE "<TD>", $table[$r][$c], "</TD>\n";
      }
      print TABLE "</TR>\n";
    }
  } else {
    foreach $c (0..$col) {
      print TABLE "<TR>\n";
      foreach $r (0..$row_num) {
	print TABLE "<TD>", $table[$r][$c], "</TD>\n";
      }
      print TABLE "</TR>\n";
    }
  }

  print TABLE "</TABLE>\n";
  print TABLE "<HR>", &AlphaDate;
  print TABLE "</BODY>\n";
  print TABLE "</HTML>\n";
  close TABLE;
  chdir "synthetic_tables";
#  system "html_dir.csh > index.html";
  chdir "../";
}

sub DrawFeatureMaps {
  $origin = -$from + 1;
  $command = "dna-pattern -pl $family{$family_name}->{dyad_file} -format $seq_format -i $family{$family_name}->{seq_file}  -sc 7 -origin $origin -N 4 ";
  $command .= "| features-from-dnapat -o $family{$family_name}->{dyad_ft_file} ";
  $command .= "; feature-map -i $family{$family_name}->{dyad_ft_file} -o $family{$family_name}->{fmap_file} ";;
  $command .= "-from $from -to $to ";
  $command .= "-legend ";
  $command .= "-scalebar -scalestep 50 ";
  $command .= "-scorethick ";
  $command .= "-mlen 520 ";
  $command .= "-title '${family_name}$dyad_suffix' ";
  $command .= "-htmap >  $family{$family_name}->{htmap_file}";
  #  $command .= " ;  xv -o $family{$family_name}->{fmap_file} &";

  &doit($command);
#  print "\n$command\n" if ($verbose);
#  system $command;
}


#### initialization
sub InitParameters {
  $from = $default{from} unless defined($from);
  $to = $default{to} unless defined($to);
  $seq_length = abs($to - $from) + 1;
  $seq_format = "fasta";
#  $upstream_sequence_file = "$RSA//data/yeast/sequences/all_up${seq_length}.${seq_format}";
  
  $min_oligo_length = 6;
  $max_oligo_length = 6;
  $min_matching_score = 4;
  
  $dyad_element_length = 3;
  
  if (defined($force{type})) {
    $type = $force{type}; ### force
  } else {
    $type = "any";
  }
  if (defined($force{strands})) {
    $strands = $force{strands}; ### force
  } else {
    $strands = "2str";
  }
  if (defined($force{exp})) {
    $exp = $force{exp}; ### force
  }
  if (&IsReal($force{th})) {
    $th = $force{th}; ### force
  } elsif ($#families > 0) {
    $th = &round(10*abs(log($#families + 1)/log(10)))/10;
  } else {
    $th = 0;
  } 
  $noov = 1;

  $max_sp = 16;
  $start_date = `date`;

}

    
sub AnalyzeFamilies {
  foreach $family_name (@families) {
    print "\n; Treating family $family_name\t", `date` if ($verbose);

    ### retrieve upstream sequences
    &UpstreamSequences if ($task{upstream});
    
    ### oligo-analysis
    &OligoAnalysis if ($task{oligos});

    ### dyad analysis
    &DyadAnalysis if ($task{dyads});

    ### delete upstream sequence file
    if ($task{clean}) {
	system "rm $family{$family_name}->{seq_file}" ;
	system "rm $family{$family_name}->{seq_file_purged}" ;
    }

  }
}

sub doit {
    my ($command) = @_;
    print "\n$command\n" if ($verbose >=1);
    system $command unless $dry_run;
}


########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	multiple-family-analysis

        1999 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be)
	
USAGE
        multiple-family-analysis [-i inputfile] [-o outputfile] [-v]

DESCRIPTION
	Runs a combination of programs in order to discover significant
	patterns in the upstream regions of several gene families.

	This script is a way to auto;atize the systematic analysis of
	multiple clusters of co-regulated genes, such as those
	obtained with DNA chip experiments.

	The program reads the composition of several families in a
	single text file, then executes different program discovery
	programs, and generates a summary report.

	Results are subdifided in directories created on the fly, one
	directory per family plus one summary directory.
	
OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-fam	family file
	-org	organism
	-from	upstream region left limit
	-to	upstream region right limit
	-1str   strand-sensitive analysis
	-2str   strand-insensitive analysis
	-task selected_task
		Select the tasks to be performed.
		Supported tasks: $supported_tasks

		Can be used iteratively on the same command line to 
		select multiple tasks.  

		Example:
		    -task upstream -task oligos -task synthesis
		For a full analysis, simply type 
		    -task all
	-dyad_exp_freq
		name of a file containing the expected frequencies for
		dyad-analysis.
	-oligo_exp_freq
		name of a file containing the expected frequencies for
		oligo-analysis.
	-noorf	exclude upstream ORFs from upstream sequences

FILE FORMAT
    FAMILY FILE
	The family file specifies the co;position of several gene families.
	It is a text file containing 2 tab-separated columns.
	col 1:	gene name (or ID)
	col 2: family name
	
	Lines starting with a semicolumn (;) are ignored, allowing to
	document the family files with comments..
	
	Example
		; genes responding to Phosphate stress
		pho5	PHO
		pho8	PHO
		; genes responding to nitrogen starvation
		DAL5    NIT
		GAP1    NIT
		...
HOW TO PROCEED
    1) create a directory for the set of families

    2) witin this directory, create a text file contaning the
       description of family composition, as described above
    
    3) run the command

       multiple-family-analysis -org organism -fam family_file \
           -v -from -200 -to 49

    4) Open Netscape and locate the directory.  There is one folder
       per family. 

       Browse each folder, and pay a special attention to the files
       with extension .html.  These files contain a dynamic
       feature-map. By positioning the cursor above one feature, you
       can see the corresponding information at the bottom of the
       Netscape window.

    5) There is also a folder with summary tables, one table for each
       set of conditions that has been tested (threshold, upstream
       region limits, ...).


End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
multiple-family-analysis options
--------------------------------
-h		(must be first argument) display full help message
-help		(must be first argument) display options
-v		verbose
-vv 		hyperverbose
-fam		family file
-org		organism
-from		upstream region left limit
-to		upstream region right limit
-1str   	strand-sensitive analysis
-2str   	strand-insensitive analysis
-n      	dry run: print commands without executing them
-exp		expected frequency file
-transp		transpose synthetic result table (columns become rows)
-task		selected task (supported: $supported_tasks)
-dyad_exp_freq	expected frequencies for dyad-analysis
-oligo_exp_freq	expected frequencies for oligo-analysis
-noorf		exclude upstream ORFs from upstream sequences
End_short_help
  close HELP;
  exit;
}


sub ReadArguments {
#### read arguments ####
    foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    $verbose = 1;
	} elsif ($ARGV[$a] eq "-vv") {
	    $verbose = 2;
	    
	    #### dry run
	} elsif ($ARGV[$a] eq "-n") {
	    $dry_run = 1;
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[$a] eq "-help") {
	    &PrintOptions;
	    
	    ### family file
	} elsif ($ARGV[$a] eq "-fam") {
	    $family_file = $ARGV[$a+1];

	    ### upstream sequence lmits
	} elsif (($ARGV[$a] eq "-from") &&
		 (&IsInteger($ARGV[$a+1]))) {
	    $from = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-to") &&
		 (&IsInteger($ARGV[$a+1]))){
	    $to = $ARGV[$a+1];

	    ### strands 
	} elsif ($ARGV[$a] eq "-1str") {
	    $force{strands} = "1str";
	} elsif ($ARGV[$a] eq "-2str") {
	    $force{strands} = "2str";

	    ### organism
	} elsif ($ARGV[$a] eq "-org") {
	    $organism_name = $ARGV[$a+1];


	    #### task selection
	} elsif ($ARGV[$a] eq "-task") {
	    $requested_task = $ARGV[$a+1];
	    if ($supported_task{$requested_task}) {
		$task{$requested_task} = 1;
	    } else {
		&FatalError("This task is not supported. Supported: $supported_tasks");
	    }


	    #### transpose synthetic table
	} elsif ($ARGV[$a] =~ /^-transp/) {
	    $transpose = 1;

	    #### clip upstream ORFs fom upstream regions
	} elsif ($ARGV[$a] =~ /^-noorf/) {
	    $noorf = 1;

	    #### threshold
	} elsif ($ARGV[$a] =~ /^-th/) {
	    $force{th} = $ARGV[$a+1];

	    #### dyad type
	} elsif ($ARGV[$a] =~ /^-type/) {
	    $force{type} = $ARGV[$a+1];

	    #### expected frequency file for dyad-analysis 
	} elsif ($ARGV[$a] =~ /^-dyad_exp_freq/) {
	    $exp_freq_file{dyads} = $ARGV[$a+1];

	    #### expected frequency file for oligo-analysis 
	} elsif ($ARGV[$a] =~ /^-oligo_exp_freq/) {
	    $exp_freq_file{oligos} = $ARGV[$a+1];

	} elsif ($ARGV[$a] =~ /^-exp/) {
	    $force{exp} = $ARGV[$a+1];

	}
    }
}



sub OldReadFamilies {
  ### read family list
  open FAM, "$family_file" || die "Error: cannot open family file $family_file\n";
  while (<FAM>) {
    next if (/^;/);
    next unless (/\S/);
    chomp;
    @fields = split;
    $family_name = shift @fields;
    push @families, $family_name;
    @{$family{$family_name}->{members}} = @fields;
  }
  close FAM;
}


sub ReadFamilies {
  print "\n; Reading family file\t$family_file\n" 
      if ($verbose);
  unless (-r $family_file) {
    die "Error : cannot read family file $family_file\n";
  }
  
  open FAM, $family_file || 
      die "Error : cannot read file $family{$family_name}->{family_file}\n" ;
  $line = 0;
  while (<FAM>) {
    $line++;
    next if (/^;/);
    next unless (/\S/);
    chomp;
    @fields = split /\s+/;

    ### family name
    $family_name = uc($fields[1]);
    unless ($family_name =~ /\S/) {
      warn ("Error family file $family_file line $line\t",
	    "family not specified\n");
      next;
    }
    
    ### gene name or ID
    $query = uc($fields[0]);
    unless ($query =~ /\S/) {
      warn ("Error family file $family_file line $line\t",
	    "gene not specified\n");
      next;
    }

#    while (($key,$value) = each %orf_id) {
#      print "$key\t$value\n";
#    }
    ### identify the gene
    $id = $orf_id{$query};
    if ($id eq "") {
      print STDERR "\t;WARNING ! $query unknown gene name \n";
    } else {
      push @{$family{$family_name}->{members}}, $id;
      print "\t$family_name\t$query\t$id\t$name{$id}\n" 
	  if ($verbose > 1);
    }
    
  }
  close FAM;

  @families = keys %family;
}

#### obsolete routines
#  sub OldReadFamily {
#    print "\n; Reading family\t$family_name\n" if ($verbose);
#    unless (-r $family{$family_name}->{family_file}) {
#      die "Error : family $family_name: cannot read family file '$family{$family_name}->{family_file}'\n";
#    }
  
#    @{$family{$family_name}->{members}} = {};
#  #  @{$member{$family_name}} = ();
#    open FAM, $family{$family_name}->{family_file} || die "Error : cannot read file $family{$family_name}->{family_file}\n" ;
#    while (<FAM>) {
#      next if (/^;/);
#      next unless (/\S/);
#      chomp;
#      @fields = split /\s+/;
#      $query = uc($fields[0]);
#      $id = $orf_id{$query};
#      if ($id eq "") {
#        print STDERR "\t;WARNING ! $query unknown gene name \n";
#      } else {
#        push @{$family{$family_name}->{members}}, $id;
#  #      push @{$member{$family_name}}, $id;
#        print "\t$query\t$id\t$name{$id}\n" if ($verbose);
#      }
#    }
#    close FAM;
#  }

#  sub OldUpstreamSequences {
#    warn "\n; Generating upstream sequences for family $family_name\n" if ($verbose);
#    #  unless (-e  $family{$family_name}->{seq_file}) {
#    system "rm -f $family{$family_name}->{seq_file} "; 
#    foreach $id ( @{$family{$family_name}->{members}}) {
#      print "\t$id\t$name{$id}\n" if ($verbose);
#      $command =  "grep -i $id $upstream_sequence_file | replace-string -query '$id' -by '$name{$id}' >> $family{$family_name}->{seq_file}";
#      system $command;
#    }
#  }
