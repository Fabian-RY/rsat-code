#!/usr/bin/perl -w
############################################################
#
# $Id: convert-graph,v 1.24 2007/08/28 13:18:26 rsat Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

## CVS: implemented the option -seed_nodes

## use strict;

=pod

=head1 NAME

convert-graph

=head1 DESCRIPTION

Convert graphs between different formats. 

In the current state, the only supported input format are 
tab-delimited file and gml file. Various output format are already supported (dot,
gml, tab, adjacency table).

In the future, there should be as many input as output formats (the
program should perform interconversions between any supported format).


=head1 AUTHORS

Jacques van Helden <jvanheld@scmbb.ulb.ac.be>

Sylvain Broh√©e <sylvain@scmbb.ulb.ac.be>

=head1 CATEGORY

Graph utilities

=head1 USAGE
    
convert-graph [-i inputfile] [-o outputfile] [-from tab|gml] [-to format tab|dot|gml|adj_matrix_dir|adj_matrix_undir]  [-arc_id] [-v #]

=head1 FORMATS

Tab format is the more intuitive way to encode a graph. It consists in the list of edges
between the nodes. The names of the nodes are separated using the tabulation. 
Some attributes of the edges can be placed in the following columns (weight, label, color).
Orphan nodes can be specified using this format simply by not specifying the target node.

Adjacency matrix is a n x n table (with n the number of nodes). In cell A[i,j], 
you find the weight (or 1 if the graph is unweighted) on the edge between nodes i 
and j. An undirected adjacency matrix is symmetrical : indeed, if an edge exists 
from node A to node B, it also exists from node B to node A. A directed matrix is 
asymmetrical. By default, convert-graph considers the graphs as undirected but if the graph you use is undirected, you can use the -undirected option.

GML format allows to specify the location, the color, the label and
the width of the nodes and of the edges. A GML file is made up of pairs of a key
and a value. Example for keys are graphs, node and edges. You can then add any
specific information for each key. GML format can be used by most graph editors (like
cytoscape and yEd). For more information on the GML format, see http://www.infosun.fim.uni-passau.de/Graphlet/GML/.

DOT is a plain text graph description language. The DOT files are generally used by
the programs composing the GraphViz suite (dot, neato, dotty, ...). It is a simple way of
describing graphs that both humans and computer programs can use. DOT graphs are
typically files that end with the .dot extension. Like GML, with DOT you can specify
a lot of feature for the nodes (color, width, label).

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph2;


################################################################
## Main package
package main;
{

    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();

    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
#    $main::in = STDIN;
    $main::out  = STDOUT;
    
    ## directed
    $directed = 1;
    
    ## arc_id_option
    $arc_id_option = 0;

    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	tab=>1,
	gml=>1,
	adj_matrix=>1
    );
    $supported_input_formats = join (",", keys %supported_input_format);
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;
    local $source_color_col = 0;
    local $target_color_col = 0;
    local $color_col = 0;

    ## Output formats
    local $output_format = "gml";
    %supported_output_format =(
			       dot=>1,
			       gml=>1,
			       tab=>1,
			       adj_matrix=>1);
			      
			       
    $supported_output_formats = join (",", keys %supported_output_format);

    
    &ReadArguments();

    ################################################################
    #### check argument values

    ################################################################
    ## Initialize the graph
    my $graph = new RSAT::Graph2();
    $graph->set_attribute("label", "graph");

    ################################################################
    ## Read the seed nodes
    if ($infile{seed_nodes}) {
      my @seed_nodes = ();
      &RSAT::message::TimeWarn("Loading seed nodes from file", $main::infile{seed_nodes}) if ($main::verbose >= 2);
      ($seed_handle) = &OpenInputFile($main::infile{seed_nodes});
      my $l = 0;
      while (<$seed_handle>) {
	$l++;
	next if (/^;/); ## Skip comment lines
	next if (/^#/); ## Skip header lines
	next unless (/\S/); ## Skip empty lines
	chomp();
	my ($id) = split /\s+/;
	if ($id) {
	  push @seed_nodes, $id;
	} else {
	  &RSAT::message::Warning("File", $infile{clusters}, "Line", $l, "starts with spaces. Skipped");
	}
      }
      close $seed_handle;
      &RSAT::message::TimeWarn("Seed nodes loaded", scalar(@seed_nodes)) if ($main::verbose >= 2);
      $graph->set_seed_nodes(@seed_nodes);
      &RSAT::message::Debug("SEED NODES", join " ", @seed_nodes) if ($main::verbose >= 4);
    }

    ################################################################
    ##### read input
    $graph->graph_from_text($input_format, $main::infile{input}, $source_col, $target_col, $weight_col, $source_color_col, $target_color_col,$color_col, $directed);

    ################################################################
    ###### print output
    ### open output streams
    $main::out = &OpenOutputFile($main::outfile{output});
    if ($output_format eq "tab") {
      $main::verbose_out = $main::out;
    } else {
      $main::verbose_out = STDOUT;
    }
    #### print verbose
    &Verbose() if ($main::verbose);
    print $out $graph->to_text($output_format, $arc_id_option, $directed);

    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::verbose_out "; Job started $start_time\n";
	print $main::verbose_out "; Job done    $done_time\n";
    }

    ################################################################
    ###### close output stream
    close $main::out if ($main::outfile{output});

    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
#    foreach my $a (0..$#ARGV) {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    
=pod
	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ### Input format  
=pod

=item B<-from input_format>

Input format. Supported: tab, gml

=cut
	} elsif ($arg eq "-from") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});


	    ### Output format  
=cut

=item B<-to output_format>

Output format. Supported: tab, dot, gml

=cut 
	} elsif ($arg eq "-to") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});


	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes. (default 1)

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes. (default 2)

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight nodes. (no default)

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }
=pod

=item B<-eccol>

Edge color column. Column containing the color of the edges (RGB). (no default)

=cut
	} elsif ($arg eq "-eccol") {
	    $color_col = shift (@arguments);
	    unless (&IsNatural($color_col) && ($color_col > 0)) {
		&RSAT::error::FatalError(join("\t", $color_col, "Invalid value for the color column. Must be a strictly positive natural number"));
	    }
=pod

=item B<-sccol>

Source node color colum. Column containing the color of the node (RGB). (no default)

A node can only have one color. If in the file, the color of the node changes, only the first defined color 
will be taken into account.

=cut
	} elsif ($arg eq "-sccol") {
	    $source_color_col = shift (@arguments);
	    unless (&IsNatural($source_color_col) && ($source_color_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_color_col, "Invalid value for the color column. Must be a strictly positive natural number"));
	    }
  ## Directed option
=pod


=item B<-undirected>

Specifies whether the edges must be considered as undirected, i.e., an edge 
from node A to node B corresponds to an edge from B to A (by default, edges are directed). Useful for the output as an adjacency table.

=cut
	    	    
	} elsif ($arg eq "-undirected") {
	    $directed = 0;
=pod

=item B<-tccol>

Target node color colum. Column containing the color of the node (RGB). (no default)

A node can only have one color. If in the file, the color of the node changes, only the first defined color 
will be taken into account.

=cut
	} elsif ($arg eq "-tccol") {
	    $target_color_col = shift (@arguments);
	    unless (&IsNatural($target_color_col) && ($target_color_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_color_col, "Invalid value for the color column. Must be a strictly positive natural number"));
	    }	    

=pod

=item B<-arc_id>

Add a unique ID for each arc when using the tab-delimited output.

=cut
	} elsif ($arg eq "-arc_id") {
	    $arc_id_option = 1;

=pod

=item B<-seed_nodes seed_node_file>

This option is currently implemented only for input format "tab".

Select a subgraph induced by a set of seed nodes. When this option is
used, the program only reads arcs whose ends (source and target) are
both members of the seed node set.

Seed nodes are specified in a text file. The first word of each row is
considered as an identifier for a seed node.

Note that the graph-get-clusters program also allows to induce 
graphs from a set of seed nodes (for each input format).

=cut

	} elsif ($arg eq "-seed_nodes") {
	    $main::infile{seed_nodes} = shift(@arguments);


	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::verbose_out "; convert-graph ";
    &PrintArguments($main::verbose_out);
    if (defined(%main::infile)) {
	print $main::verbose_out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::verbose_out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=item I<compare-graphs>

=item I<graph-get-clusters>

=item I<graph-neighbours>

=item I<graph-node-degree>

=item I<graph-set-attributes>

=cut
