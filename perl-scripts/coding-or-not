#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib.pl";
require "RSA.classes.pl";


#### configuration #####
$line_width = 0;
$out_format = "wc";
$start_time = `date '+%d/%m/%y %H:%M:%S %Z'`;



&ReadArguments;

#### default : return sequences of all types
unless (defined(%return)) {
  $return{'ncs'} = 1;
  $return{'cs'} = 1;
  $return{'div'} = 1;
  $return{'conv'} = 1;
  $return{'tandem'} = 1;
  $return{'orf'} = 1;
  $return{'seq'} = 1;
}
   
#### organism
$organism = &CheckOrganism($organism_name);

 
#&OldReadOrganism;

&ReadOrfPositions($organism_name);

#&OldReadOrfpositions;


&PrintVerbose;

### open all output files
open NC_LOCATIONS, ">${organism_name}_non_coding_segments.coord";
open NC_SEQ, ">${organism_name}_non_coding_segments.$out_format" if (($return{'ncs'}) && ($return{seq}));

open DIVERGENT_NC_SEQ, ">${organism_name}_non_coding_segments_divergent.$out_format" if (($return{'div'}) && ($return{seq}));
open CONVERGENT_NC_SEQ, ">${organism_name}_non_coding_segments_convergent.$out_format" if (($return{'conv'}) && ($return{seq}));
open TANDEM_NC_SEQ, ">${organism_name}_non_coding_segments_tandem.$out_format" if (($return{'tandem'}) && ($return{seq}));

open C_LOCATIONS, ">${organism_name}_coding_segments.coord" if ($return{'cs'});
open C_SEQ, ">${organism_name}_coding_segments.$out_format" if (($return{'cs'}) && ($return{seq}));
open ORF_SEQ, ">${organism_name}_ORF_sequences.$out_format" if (($return{'orf'}) && ($return{seq}));

### print headers
print NC_LOCATIONS ";segm_type_nb\tchr\tstart\tend\tleft\tright\n"  if ($return{'ncs'});
print C_LOCATIONS ";segm_type_nb\tORFs\tchr\tstart\tend\tleft\tright\n"  if ($return{'cs'});

foreach my $chromosome ($organism->get_chromosomes()) {
    ### read chromosomal sequence
#    $seq_file = $seq_file{$chr};
    my $chr = $chromosome->get_name();
    my $seq_file = $chromosome->get_sequence()->get_attribute("filename");

#    open SEQ, $seq_file || die "Error: cannot open sequence file $seq_file\n";
#    ($sequence, $seq_id, @seq_comments) = &ReadNextSequence(SEQ, $seq_format);
#    close SEQ;
#    $sequence = &FoldSequence($sequence, 0);
    my $sequence = $chromosome->get_sequence();
    my $chr_length = $sequence->get_length();

    ### sort ORF from current chromosome
#    $ORF_nb{$chr} = $#{$ids{$chr}}+1;;
    my @genes = $chromosome->get_genes();
    print "; $seq_file\t$chr\t$chr_length\t", $#genes+1, "\n";

    @sorted_orfs = sort {
	(($left{$a} <=> $left{$b}) || (($left{$a} == $left{$b}) && ($right{$a} <=> $right{$b})))
	} @genes;

    ### print ORF sequences
    foreach $id (@sorted_orfs) {
	$seq_id = "${id}_${chr}_${start{$id}}_${end{$id}}_${strand{$id}}";
	$current_seq = $sequence->get_sequence($left{$id},$right{$id});
#	warn $seq_id, "\t", $current_seq, "\n";

	if ($strand{$id} eq "R") {
	    $current_seq = &ReverseComplement($current_seq);
	}
	&PrintNextSequence(ORF_SEQ, $out_format,$line_width,$current_seq,$seq_id)  if (($return{'orf'}) && ($return{seq}));
    }
    
    #### coding and non-coding segments
    $coding_end = 0;
    $end_reached = 0;
    $orf_nb = 0;
    $nc_left_ORF = "none";
    
    do {
	### next non-coding segments
	$nc_start = $coding_end+1;
	$cluster++;
	$orf_cluster = "$sorted_orfs[$orf_nb]";
	$coding_start = $left{$sorted_orfs[$orf_nb]};
	$nc_right_ORF = $sorted_orfs[$orf_nb];
	$nc_end = $coding_start - 1;

	@comments = ("non_coding_segment_${cluster}\t$chr\t$nc_start\t$nc_end\t$nc_left_ORF\t$nc_right_ORF");
	print NC_LOCATIONS "$comments[0]\n" if ($return{'ncs'});
	$seq_id = "non_coding_segment_${cluster}_${chr}_${nc_start}_${nc_end}_l${nc_left_ORF}_r${nc_right_ORF}";
	$current_seq = $sequence->get_sequence($nc_start,$nc_end);
	&PrintNextSequence(NC_SEQ, $out_format,$line_width,$current_seq,$seq_id) if (($return{'ncs'}) && ($return{seq}));
	if ($strand{$nc_left_ORF} eq $strand{$nc_right_ORF}) {
	    &PrintNextSequence(TANDEM_NC_SEQ, $out_format,$line_width,$current_seq,$seq_id) if (($return{'tandem'}) && ($return{seq}));
	} elsif (($strand{$nc_left_ORF} eq "R") && ($strand{$nc_right_ORF} eq "D")) {
	    &PrintNextSequence(DIVERGENT_NC_SEQ, $out_format,$line_width,$current_seq,$seq_id)  if (($return{'div'}) && ($return{seq}));
	} elsif (($strand{$nc_left_ORF} eq "D") && ($strand{$nc_right_ORF} eq "R")) {
	    &PrintNextSequence(CONVERGENT_NC_SEQ, $out_format,$line_width,$current_seq,$seq_id)  if (($return{'conv'}) && ($return{seq}));
	}

	### next coding segment
	$coding_end = $right{$sorted_orfs[$orf_nb]};
	$nc_left_ORF = "";

        #### look for next ORF whose left limit is at right
	while (($orf_nb < $#sorted_orfs) && 
	       ($left{$sorted_orfs[$orf_nb+1]} <= $coding_end)) { 
	    $orf_nb++;
	    $orf_cluster .= ";$sorted_orfs[$orf_nb]";
	    $nc_left_ORF = $sorted_orfs[$orf_nb] unless ($coding_end > $right{$sorted_orfs[$orf_nb]});
	    $coding_end = &max($coding_end, $right{$sorted_orfs[$orf_nb]});
	}

	@comments = ("coding_segment_${cluster}\t$orf_cluster\t$chr\t$coding_start\t$coding_end");
	print C_LOCATIONS "$comments[0]\n"  if ($return{'cs'});
	$seq_id = "coding_segment_${cluster}_${chr}_${coding_start}_${coding_end}";
	$current_seq = $sequence->get_sequence($coding_start,$coding_end);
	&PrintNextSequence(C_SEQ, $out_format,$line_width,$current_seq,$seq_id)  if (($return{'cs'}) && ($return{seq}));

	$nc_left_ORF = $sorted_orfs[$orf_nb] unless ($coding_end > $right{$sorted_orfs[$orf_nb]});
	$orf_nb++;

	### last non-coding segment
	if ($orf_nb > $#sorted_orfs) {
	    $end_reached = 1;
	    $nc_start = $coding_end+1;
	    $nc_end = $chr_length;

	    @comments = ("non_coding_segment_${cluster}\t$chr\t$nc_start\t$nc_end");
	    print NC_LOCATIONS "$comments[0]\n"  if ($return{'ncs'});
	    $seq_id = "non_coding_segment_${cluster}_${chr}_${nc_start}_${nc_end}";
	    $current_seq = $sequence->get_sequence($nc_start,$nc_end);
	    &PrintNextSequence(NC_SEQ, $out_format,$line_width,$current_seq,$seq_id, @comments)  if (($return{'ncs'}) && ($return{seq}));

	}
    } until $end_reached;
}

close NC_SEQ;
close DIVERGENT_NC_SEQ;
close CONVERGENT_NC_SEQ;
close TANDEM_NC_SEQ;
close NC_LOCATIONS;
close C_SEQ;
close C_LOCATIONS;
close ORF_SEQ;

$done_time  = `date '+%d/%m/%y %H:%M:%S %Z'`;
print "; Job started $start_time";
print "; Job done    $done_time";


exit(0);

### help ###
sub PrintHelp {
    open HELP, "| more ";
    print HELP "
NAME
	coding-or-not 

	1997,1998 by Jacques van Helden (jvanheld\@ucmb.ulb.ac.be).

DESCRIPTION
	Starting from a complete assembled genome, generate
	non-redundant sets of sequences, partitioned into different
	sequence types (see options).

USAGE
	coding-or-not -org organism

OPTIONS
	-org	organism. Currently supported:
$supported_organisms
	-return	type of sequences to return. 
		The following options are available
		seq	return sequences
			(otherwise, only coordinate files are printed)
		ncs	non-coding segments
			These sequences are further separated into 3 
			subsets, corresponding to the options div, conv 
			and tandem
		div	non-coding sequences separating two genes
			transcribed in divergent directions
		conv	non-coding sequences separating two genes
			transcribed in convergent directions
		tandem  non-coding sequences separating two genes
			transcribed in the same direction (tandem
			genes)
		cs	coding segments
			Warning : 
			- in case of gene overlap, a single segment
			is returned encompassing the two genes in a 
			non-redundant way.
			- the segments are returned in the same strand 
			as in the genome sequence file, which is 
			sometimes the reverse complement of the coding 
			sequence.  . 
		orf	open reading frame sequences
			Contrarily to cs, orf returns every gene sequence
			from the start to the stop codon, and in the
			coding strand 
		

OUTPUT
	coding sequence coordinates are stored in a file named 
		${organism_name}_coding_segments.coord
	non coding sequence coordinates are stored in another file named 
		${organism_name}_non_coding_segments.coord
	coding sequences are stored in a file named 
		${organism_name}_coding_segments.seq
	non coding sequences are stored in another file named 
		${organism_name}_non_coding_segments.seq
";
    close HELP;
    exit(0);
}


sub ReadArguments {
##### read parameters ###
    for $a (0..$#ARGV) {
	if ($ARGV[$a] eq "-org") {
	    $organism_name = $ARGV[$a+1];
	} elsif (($ARGV[$a] eq "-help") || 
		 ($ARGV[$a] eq "-h")) {
	    &PrintHelp;
	} elsif ($ARGV[$a] eq "-return") {
	    chomp($ARGV[$a+1]);
	    @fields_to_return = split ",", $ARGV[$a+1];
	    foreach $field (@fields_to_return) {
		if ($field eq "ncs") {
		    $return{'ncs'} = 1;
		} elsif ($field eq "cs") {
		    $return{'cs'} = 1;
		} elsif ($field eq "div") {
		    $return{'div'} = 1;
		} elsif ($field eq "conv") {
		    $return{'conv'} = 1;
		} elsif (($field =~ /^par/) || 
			 ($field =~ /^tandem/)) {
		    $return{'tandem'} = 1;
		} elsif ($field =~ /^orf/) {
		    $return{'orf'} = 1;
		} elsif ($field =~ /^seq/) {
		    $return{'seq'} = 1;
		} else {
		    die ("\tError : unrecognized request: $field\n",
			 "\tType coding-or-not -help for info\n");

		}	
		
	    }
	}
    }
}


sub OldReadOrganism {
#### initialize parameters according to organism ####
    if ($organism_name eq "yeast") {
#	$feature_file = "$RSA/data/yeast/orfs/ORF_table.txt";
	$id_column = 0;
	$type_column = -1;
	$gene_column = 2;
	$chr_column = 3;
	$start_column = 4;
	$end_column = 5;
	$strand_column = -1; ### there is no such column in the ORF file; 
	### strand C is indicated by the fact that start coord > end coord
	
	push @chr_list, 'I';
	push @chr_list, 'II';
	push @chr_list, 'III';
	push @chr_list, 'IV';
	push @chr_list, 'V';
	push @chr_list, 'VI';
	push @chr_list, 'VII';
	push @chr_list, 'VIII';
	push @chr_list, 'IX';
	push @chr_list, 'X';
	push @chr_list, 'XI';
	push @chr_list, 'XII';
	push @chr_list, 'XIII';
	push @chr_list, 'XIV';
	push @chr_list, 'XV';
	push @chr_list, 'XVI';
	
	foreach $chr (@chr_list) {
	    $seq_file{$chr} = "$RSA/data/yeast/sequences/$chr";
	}
	$seq_format = "raw";
    } elsif ($organism_name eq "coli") {
#	$feature_file = "$RSA/data/coli/sequences/CDS_table.txt";
	$id_column = 0;
	$type_column = 1;
	$gene_column = 2;
	$chr_column = -1;
	$start_column = 3;
	$end_column = 4;
	$strand_column = 5;
	
	push @chr_list, 'genome';
	$seq_file{$chr_list[0]} = "$RSA/data/coli/sequences/$chr_list[$0]";
	$seq_format = "fasta";
    } elsif ($supported_organism{$organism_name}) {
#	$feature_file = $supported_organism{$organism_name}->{'features'};
	$id_column = 0;
	$type_column = 1;
	$gene_column = 2;
	$chr_column = 3;
	$start_column = 4;
	$end_column = 5;
	$strand_column = 6;
	
	push @chr_list, $organism_name;
	$seq_file{$chr_list[0]} = $supported_organism{$organism_name}->{'genome'};
	$seq_format =$supported_organism{$organism_name}->{'seq_format'};
    } else {
	die "Error: you did not specify the organism\n";
    }
}


sub OldReadOrfpositions {
    
#### read all ORF positions ####
    unless (open ORFS, $supported_organism{$organism_name}->{'features'}) {
	die "	Cannot open ORF location file ", $supported_organism{$organism_name}->{'features'}, "\n";
    }
    while (<ORFS>) {
	next if (/^;/);
	next unless (/\S/);
	s/\t\t/\t-\t/;
	chomp;
	@fields = split, /\t/;
	
	### only take into consideration the CDS features
	if (($type_column >= 0) && ($fields[$type_column] ne "CDS")) {
	    next;
	}
	
	$orf_count++;
	$id = $fields[$id_column];
	if ($chr_column < 0) {
	    $chr{$id} = "genome";
	} else {
	    $chr{$id} = $fields[$chr_column];
	}
	push @{$ids{$chr{$id}}}, $id;
	$start{$id} = $fields[$start_column];
	$end{$id} = $fields[$end_column];
	$left{$id} = &min($start{$id},$end{$id});
	$right{$id} = &max($start{$id},$end{$id});
	if ($organism_name eq "yeast") {
	    if ($start{$id} > $end{$id}) {
		$strand{$id} = "R";
	    } else {
		$strand{$id} = "D";
	    }
	} else {
	    $strand{$id} = $fields[$strand_column];
	}
#print "$id\t$chr{$id}\t$left{$id}\t$right{$id}\t$strand{$id}\n";
    }
    close ORFS;
}

sub PrintVerbose {
    printf "; %-16s\t%s\n", "Organism", $supported_organism{$organism_name}->{'name'};
    printf "; %-16s\t%-12s\t%s\n", "feature file", $supported_organism{$organism_name}->{'features'};
    printf "; chromosome sequence file(s)\n";
    foreach $chromosome ($organism->get_chromosomes()) {
	print (";\t", join ("\t", 
			    $chromosome->get_name(),
			    $chromosome->get_sequence()->get_attribute("filename")
			    )
	       , "\n");
    }
    printf "; %-16s\t%-12s\t%s\n", , "ORFs in total", $orf_count;
    printf "; chr\tlength\torfs\n";
}
