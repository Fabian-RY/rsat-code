#!/usr/bin/perl
############################################################
#
# $Id: row-stats,v 1.9 2010/04/17 03:04:32 jvanheld Exp $
#
# Time-stamp: <2002-06-06 13:37:27 jvanheld>
#
############################################################
#use strict;;
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";


#### initialise parameters ####
my $start_time = &AlphaDate;

local %infile = ();
local %outfile = ();

local $verbose = 0;
local $in = STDIN;
local $out = STDOUT;
local $number_format = "%g";
local $sort = 0;

&ReadArguments;


#### check argument values ####


### open output file ###
$out = &OpenOutputFile($outfile{output});

##### read input #####
($in, $input_dir) = &OpenInputFile($infile{input});
$line_nb = 0;
while (<$in>) {
    $line_nb++;
    next unless (/\S/); ## Skip empty lines

    ## Report comment lines
    if (/^;/) {
      print $out $_;
      next;
    }
    chomp(); ## remove the carriage return

    ## Treat header line
    if (/^#/) {
	$header_line = join ("\t",
			     $_,
			     "min",
			     "max",
			     "sum",
			     "avg"
	    );
	$header_line .= "\n";
	unless ($sort) {
	    print $out $header_line;
	}
	next;
    }

    ## Treat other lines
#    &RSAT::message::Debug($line_nb, $_) if ($main::verbose >= 10);
    my $to_print = $_;
    my @values = split "\t";
    my $min = sprintf "${number_format}", &checked_min(@values);
    my $max = sprintf "${number_format}", &checked_max(@values);
    my $sum = sprintf "${number_format}", &checked_sum(@values);
    my $avg = sprintf "${number_format}", &checked_avg(@values);
    $to_print .= "\t";
    $to_print .= join ("\t", $min, $max, $sum, $avg);
    $to_print .= "\n";

    if ($sort) {
      ## Index line for printing after sorting
      $to_print{$line_nb} = $to_print;
      $sum{$line_nb} = $sum;
    } else {
      ## Print immediately to free memory
      print $out $to_print;
    }
}

close $in if ($infile{input});

## Print sorted values
if ($sort) {
    print $out $header_line;
  my @sorted = sort { $sum{$b} <=> $sum{$a} } keys (%sum);
  foreach my $line_nb (@sorted) {
    print $out $to_print{$line_nb};
  }
}

#### verbose ####
&Verbose if ($verbose);

###### close output file ######
my $exec_time = &RSAT::util::ReportExecutionTime($start_time); ## This has to be exectuted by all scripts
print $main::out $exec_time if ($main::verbose >= 1); ## only report exec time if verbosity is specified
close $out if ($outfile{output});

exit(0);




########################## subroutine definition ############################

sub PrintHelp {
#### display full help message #####
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	row-stats

        2001 by Jacques van Helden (jvanheld\@bigre.ulb.ac.be)
	
USAGE
        row-stats [-i inputfile] [-o outputfile] [-v]

DESCRIPTION

	Calculate basic statistics (min, max, avg, ...) on each row of
	a tab-delimited input file.

CATEGORY
	statistics

OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-v	verbose
	-i inputfile
		if not specified, the standard input is used.
		This allows to place the command within a pipe.
	-o outputfile
		if not specified, the standard output is used.
		This allows to place the command within a pipe.
	-nf	number format
		Any format specification that is compliant with the
		perl printf function is supported (e.g. '%7.4f')
	-sort	sort lines by decreasing value of the row sum

INPUT FORMAT

      The input file is a tab-delimited text file. Each row
      corresponds to a new object, and each column to an attribute of
      this object. The first column must contain the ID of the
      object. The remaning columns are supposed to contain a series
      numbers, on which the statistics will be calculated.

OUTPUT FORMAT

       The output file is a tab-delimited text file. Each row
       corresponds to an object (thos from the input file). The first
       column reports the object ID, and the collowing columns contain
       the requested statistics. The header indicates which statistics
       is contained in which column.


End_of_help
  close HELP;
  exit;
}

sub PrintOptions {
#### display short help message #####
  open HELP, "| more";
  print HELP <<End_short_help;
row-stats options
----------------
-h	(must be first argument) display full help message
-help	(must be first argument) display options
-i	input file
-o	output file
-v	verbose
-nf	number format (e.g. '%7.4f')
-sort	sort lines by decreasing value of the row sum
End_short_help
  close HELP;
  exit;
}


################################################################
## Read arguments
##
sub ReadArguments {
  foreach my $a (0..$#ARGV) {
    ### verbose ###
    if ($ARGV[$a] eq "-v") {
      if (&IsNatural($ARGV[$a+1])) {
	$verbose = $ARGV[$a+1];
      } else {
	$verbose = 1;
      }

      ### detailed help
    } elsif ($ARGV[$a] eq "-h") {
      &PrintHelp;

      ### list of options
    } elsif ($ARGV[$a] eq "-help") {
      &PrintOptions;

      ### input file ###
    } elsif ($ARGV[$a] eq "-i") {
      $infile{input} = $ARGV[$a+1];

      ### output file ###
    } elsif ($ARGV[$a] eq "-o") {
      $outfile{output} = $ARGV[$a+1];

      ### number format
    } elsif ($ARGV[$a] eq "-nf") {
      $number_format = $ARGV[$a+1];

      ### sort
    } elsif ($ARGV[$a] eq "-sort") {
      $sort = 1;
    }
  }
}

sub Verbose {
  print $out "; row-stats ";
  &PrintArguments($out);
  if (defined(%infile)) {
    print $out "; Input files\n";
    while (($key,$value) = each %infile) {
      print $out ";\t$key\t$value\n";
    }
  }
  if (defined(%outfile)) {
    print $out "; Output files\n";
    while (($key,$value) = each %outfile) {
      print $out ";\t$key\t$value\n";
    }
  }
}
