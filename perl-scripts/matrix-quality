#!/usr/bin/perl -w
############################################################
#
# $Id: matrix-quality,v 1.29 2007/05/03 23:20:18 jvanheld Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

#use strict;

=pod

=head1 NAME

matrix-quality

=head1 DESCRIPTION

Evaluate the quality of a Position-Specific Scoring Matrix (PSSM), by
comparing score distributions obtained with this matrix in varous sequence sets. 

The most classical use of the program is to compare score
distributions between "positive" sequences (e.g. true binding sites
for the considered transcription factor) and "negative" sequences
(e.g. intergenic sequences between convergently transcribed genes).

=head2 Leave-One-Out test

An important bias can come from an over-fitting of the matrix to the
positive set, in case one would use the same sites for building the
PSSM and for evaluating it. To avoid this bias, the option -loo allows
to perform a Leave-One-Out (LOO) evaluation of the positive set: one
sequence (the "left out sequence") is temporarily discarded from the
positive set, and the remaining sequences are used to build a matrix,
which is then used to score the left out sequence. The process
iterates over all the sequences of the positive set. 
If the left out sequence has one or more "twin" (identical site) in the 
positive set, they are also temporarily excluded from the positive set 
and not included in the matrix used to score the left out sequence.

This option is only valid when the matrix is specified in a format
that includes both the matrix and the sites (sequences) that were used
to build this matrix. This is the case for matrices in MEME or
consensus formats.

=head1 AUTHORS

=item Jacques van Helden <jvanheld@scmbb.ulb.ac.be>

=item with the help of Morgane Thomas-Chollier <mthomas@dbm.ulb.ac.be>

=head1 CATEGORY

=over

=item sequences

=item pattern matching

=item PSSM

=item evaluation

=back

=head1 USAGE

matrix-quality [-i inputfile] [-o outputfile] [-v]

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}

require "RSA.lib";

use RSAT::matrix;
use RSAT::MatrixReader;

################################################################
## Main package
package main;
{

    ################################################################
    #### Initialise parameters
    my $start_time = &AlphaDate();
    $image_format = "png";
    @distrib_files = ();
    @matrix_scan_options = ();
    @alphabet = ("a","c","g","t");
    $seq_format = "fasta";
    $matrix_format = "consensus";
    $decimals = 2;
    %perm_nb = (); ## Number of permutations per sequence set
    $perm_separate_distrib = 0; ## Calcualte the distribution for each permuted matrix separately
    $loo_rm_twin = 1; ## Also exclude twin sites in the loo procedure.
    $pseudo_counts = 1;

    %dir = ();
    @seq_types = (); ## Sequence types
    %infile = ();
    %seqfile = ();
    %outfile = ();

    $main::verbose = 0;
    $main::out = STDOUT;

    ## Parameters for the &doit() command
    $dry = 0;
    $die_on_error = 1;
    $job_prefix = "matrix-quality";
    $batch = 0;

    ## User-specified options added to XYgraph for the distribution curves
    $graph_options = " ";

    ## Reference distribution for the ROC curve
    $roc_ref = "theor";

    ## User-specified options added to XYgraph for the ROC curves
    $roc_options = " ";

    ## Tasks
    %supported_tasks = (
			scan=>1, ## Scan sequences with matrix-scan
			theor=>1, ## Calculate the theoretical distribution
			loo=>1, ## Leave-one-out test on the matrix sites
			permute=>1, ## Scan sequences with permuted matrices
			compare=>1, ## Compare distributions between the various input files
		       );
    $supported_tasks = join (",", sort(keys( %supported_tasks)));
    %tasks = ();

    ################################################################
    ## Read argument values
    &ReadArguments();

    ################################################################
    ## Check argument values

    ## If no tasks has been specified, execute them all
    unless (scalar(keys(%tasks))>0) {
      %tasks = %supported_tasks;
    }

    ## Matrix+sites file is also matrix
    if ($infile{matrix_sites}) {
      $infile{matrix} = $infile{matrix_sites};
    }

    ## Matrix file is mandatory
    &RSAT::error::FatalError("You must define a matrix file, with either option -m or -ms")
      unless ($infile{matrix});

    ## Output prefix is mandatory
    &RSAT::error::FatalError("You must define a prefix for the output files with the option -o")
      unless ($outfile{prefix});
    $outfile{log} = $main::outfile{prefix}."_log.txt";

    ## Create output directory if required
    $dir{output} = `dirname $outfile{prefix}`;
    chomp($dir{output});
    &RSAT::util::CheckOutDir($dir{output});

    ################################################################
    ### open output stream
    $main::out = &OpenOutputFile($outfile{log});

    ################################################################
    ## Read input matrix.
    my $matrix_file = $infile{matrix};

    my @matrices = &RSAT::MatrixReader::readFromFile($matrix_file, $matrix_format);

    ## Check the number of parsed matrices
    if (scalar(@matrices) > 1) {
      &RSAT::message::Warning("File",  $matrix_file, 
			      "contains ".scalar(@matrices)." matrices. ",
			      "Only the first one will be evaluated.");
    }

    local $matrix = shift (@matrices);
    $matrix->set_attribute("pseudo", $pseudo_counts);
    $matrix->set_attribute("decimals", $decimals);
    $matrix->set_attribute("file", $matrix_file);
    local ($matrix_name) = &RSAT::util::ShortFileName($matrix_file);
    $matrix_name =~ s/\.\S+$//; ## suppress the extension from the file name
    $matrix->set_attribute("name", $matrix_name);
    local ($Wmin, $Wmax)  = $matrix->weight_range();

    ## Export input sites with the matrix
    &ExportInputSites($matrix, $matrix_file);

    ## Export the matrix in tab-delimited format
    &ExportTabMatrix($matrix);

    ## Shuffle the columns of the matrix (permutation test)
    local $perm_nb_max = &RSAT::stats::checked_max(values %perm_nb);
    print "; Number of permutations\n";
    foreach my $seq_type (@seq_types) {
	print join("\t", $seq_type, $perm_nb{$seq_type} || 0, $seqfile{$seq_type}), "\n";
    }
    &PermuteMatrixColumns() if ($tasks{permute} && $perm_nb_max);

    ## Calcualte theoretical distribution of probabilities
    &PrintTheorScoreDistribution($matrix) if ($tasks{theor});

    ## Calculate score distributions in the different input sequence files

    ## Calculate the Leave-one-out score distribution for the matrix sites
    if ($tasks{loo}) {
      &LOO_scores($matrix, @matrix_scan_options);
      push @distrib_files, &ScoreDistrib('matrix_sites_loo', $Wmin, $Wmax);
    }


    ## Other sequence files
    foreach my $seq_type (@seq_types) {
      &RSAT::message::TimeWarn("Analyzing sequence type", $seq_type, $seqfile{$seq_type});
#      &ScanSequences($seqfile{$seq_type}, $matrix_file, $matrix_format, $seq_type,   @matrix_scan_options) ;
#      push @distrib_files, &ScoreDistrib($seq_type, $Wmin, $Wmax); $file_nb{$seq_type} = scalar(@distrib_files);
      &CalcSequenceDistrib($seqfile{$seq_type}, $matrix_file, $matrix_format, $seq_type,   @matrix_scan_options) ;

      ## Score sequences with the permuted matrices
      if (($seqfile{$seq_type}) && ($perm_nb{$seq_type} > 0)) {
	  ## Calculate the merged distribution for permuted matrices
	  my $perm_suffix = $seq_type."_perm_col_1-".$perm_nb{$seq_type};
	  if (defined($scanopt{$seq_type})) {
	      $scanopt{$perm_suffix} = $scanopt{$seq_type};
	      $scanopt{$perm_suffix} .= " -top_matrices ".$perm_nb{$seq_type}; ## Select the type-specific number of permutations
	  }
#	  &ScanSequences($seqfile{$seq_type}, $outfile{$seq_type.'_matrix_perm_col_all'}, "tab", $perm_suffix, @matrix_scan_options); 
#	  push @distrib_files, &ScoreDistrib($perm_suffix, $Wmin, $Wmax);
	  &CalcSequenceDistrib($seqfile{$seq_type}, $outfile{$seq_type.'_matrix_perm_col_all'}, "tab", $perm_suffix,   @matrix_scan_options) ;
	  
	  ## Calculate the separate distributions for each permuted matrix
	  ## (this highlights the variability but the graph is noisy)
	  if ($perm_separate_distrib) {
	      for my $i (1..$perm_nb{$seq_type}) {
		  $perm_suffix = $seq_type."_perm_col_".$i;
		  if (defined($scanopt{$seq_type})) {
		      $scanopt{$perm_suffix} = $scanopt{$seq_type};
		      $scanopt{$perm_suffix} .= " -top_matrices 1"; ## Select a single matrix
		  }
#		  &ScanSequences($seqfile{$seq_type}, $outfile{'matrix_perm_col_'.$i}, "tab", $perm_suffix, @matrix_scan_options); 
#		  push @distrib_files, &ScoreDistrib($perm_suffix, $Wmin, $Wmax);
		  &CalcSequenceDistrib($seqfile{$seq_type}, $outfile{'matrix_perm_col_'.$i}, "tab", $perm_suffix,   @matrix_scan_options) ;
	      }
	  }
      }
  }

    ## Compare the distributions
    &CompareDistrib(9, @distrib_files) if ($tasks{compare}); # the column of interest is rel_ic (inv_cum_freq)


    #### print verbosity
    &Verbose() if ($main::verbose);

    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::out "; Job started $start_time\n";
	print $main::out "; Job done    $done_time\n";
    }

    ################################################################
    ###### close output stream
    close $main::out if ($main::outfile{prefix});

    ################################################################
    ###### Clean some matrix files

    ## Remove the single permuted matrix files (all matrices are stored in another file)
    for my $i (1..$perm_nb_max) {
      my $perm_file = $outfile{'matrix_perm_col_'.$i};
      if ($perm_file) {
	my $clean_cmd = "rm -f ".$perm_file;
	&doit($clean_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
      }
    }

    ## Remove the partial matrices
    if (scalar(@partial_matrix_files) > 0) {
      my $clean_partial_cmd = "rm -f ";
      $clean_partial_cmd .= join (" ", @partial_matrix_files);
      &doit($clean_partial_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
    }
    
    ################################################################
    ###### Clean some temporary files
    
    ## Remove the temporary distribution files    
    if (scalar(@temporary_distrib_files) > 0) {
    	my $clean_partial_cmd = "rm -f ";
    	$clean_partial_cmd .= join (" ", @temporary_distrib_files);
    	&doit($clean_partial_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
      }

    ## Give the warning about the output prefix
    if ($main::verbose >= 1) {
      &RSAT::message::Info("Output directory", $dir{output});
      &RSAT::message::Info("Log file", $outfile{log});
    }

    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {

    my $arg;

    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()


    while (scalar(@arguments)) {
      $arg = shift (@arguments);
#      &RSAT::message::Debug("argument", $arg) if ($main::verbose >= 10);

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## Dry run
=pod

=item B<-dry>

Dry run: print the commands but do not execute them. 

=cut
	} elsif ($arg eq "-dry") {
	    $main::dry = 1;;
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    ## Matrix file
=pod

=item B<-m matrix_file>

Matrix file.

=cut
	} elsif ($arg eq "-m") {
 	  &RSAT::error::FatalError("Options -ms and -m are mutually incompatible.") 
	    if ($main::infile{matrix_sites});
	  &RSAT::error::FatalError("You are not allowed to specify several matrices.") 
	    if ($main::infile{matrix});
	  $main::infile{matrix} = shift(@arguments);


	    ## File containing both the matrix and its sites
=pod

=item B<-ms matrix_sites>

File containing both a matrix and its sites. The sites are then used
as positive sequence set, and labelled as "matrix_sites" in the
distribution tables and graphs.

The option -ms is only valid with the file formats which contain both
the matrix and its sites (e.g. consensus, MotifSampler, meme). The
format of the matrix+site file can be specified with the
option '-matrix_format'.

If the matrix and its sites are only available in separate files, an
equivalent effect can be obtained by combining the options "-m
my_matrix.tab" and "-seq matrix_sites site_sequences.fasta".

=cut
	} elsif ($arg eq "-ms") {
 	  &RSAT::error::FatalError("Options -ms and -m are mutually incompatible.") 
	    if ($main::infile{matrix});
 	  &RSAT::error::FatalError("Options -ms and -m are mutually incompatible.") 
	    if ($main::infile{matrix});
	  &RSAT::error::FatalError("You are not allowed to specify several matrices.") 
	    if ($main::infile{matrix_sites});
	  $main::infile{matrix_sites} = shift(@arguments);

	    ## Matrix format
=pod

=item B<-matrix_format matrix_format>

Format of the matrix file.

=cut
	} elsif ($arg eq "-matrix_format") {
	    $matrix_format = shift(@arguments);

# 	    ## File containing the positive sequence set
# =pod

# =item B<-pos positive_seq_file>

# File containing the positive sequence set.

# =cut
# 	} elsif ($arg eq "-pos") {
# 	  &RSAT::error::FatalError("Options -pos and -ms are mutually incompatible.") 
# 	    if ($main::infile{matrix_sites});
# 	  $main::seqfile{positive} = shift(@arguments);
# 	  push @seq_types, "positive";

# 	    ## File containing the negative sequence set
# =pod

# =item B<-neg neg_seq_file>

# File containing the negative sequence set.

# =cut
# 	} elsif ($arg eq "-negative") {
# 	    $main::seqfile{negative} = shift(@arguments);
#          push @seq_types, "negative";

	    ## File containing a sequence set of a specific type
=pod

=item B<-seq seq_type seq_file>

File containing a sequence set of a given type.  The first next
argument indicates the type of the sequence (which will appear in the
leend of the plots), and the second next argument the file name.

=cut
       } elsif ($arg eq "-seq") { 
	 my $seq_type = shift(@arguments);
	 $main::seqfile{$seq_type} =
	   shift(@arguments);
         push @seq_types, $seq_type;

	    ## Sequence-specific scanning options
=pod

=item B<-scanopt seq_type "option1 option2 ...">

Sequence set-specific options for matrix-scan.  These options are added at the
end of the matrix-scan command for scanning the specified sequence set.

=cut
       } elsif ($arg eq "-scanopt") { 
	 my $seq_type = shift(@arguments);
	 $main::scanopt{$seq_type} =
	   " ".shift(@arguments);

	    ## Skip the Leave-one-out (LOO) test for the positive set
=pod

=item B<-noloo>

Do not apply the leave-one-out (LOO) test on the positive sequences. 

=cut
	} elsif ($arg eq "-noloo") {
	  $supported_tasks{loo} = 0;

# 	    ## Number of permutations for the positive set
# =pod
#
# =item B<-perm_pos #>
#
# Number of permutations for the positive set (default 100)
#
# =cut
# 	} elsif ($arg eq "-perm_pos") {
# 	    $main::perm_nb{positive} = shift(@arguments);
# 	    &RSAT::error::FatalError($perm_nb{positive}, "Invalid value for option -perm_pos. Should be a Natural number.") 
# 	      unless (&IsNatural($main::perm_nb{positive}));
#
# 	    ## Number of permutations for the negative set
# =pod
#
# =item B<-perm_neg #>
#
# Number of permutations for the negative set (default 1)
#
# =cut
# 	} elsif ($arg eq "-perm_neg") {
# 	    $main::perm_nb{negative} = shift(@arguments);
# 	    &RSAT::error::FatalError($perm_nb{negative}, "Invalid value for option -perm_pos. Should be a Natural number.") 
# 	      unless (&IsNatural($main::perm_nb{negative}));

	    ## Number of permutations for a specific set
=pod

=item B<-perm seq_type #>

Number of permutations for a specific set (default 0).

=cut
	} elsif ($arg eq "-perm") {
	  my $seq_type = shift(@arguments);
	  $main::perm_nb{$seq_type} = shift(@arguments);
	  &RSAT::error::FatalError($perm_nb{$seq_type}, "Invalid value for option -perm. Should be a Natural number.") 
	    unless (&IsNatural($main::perm_nb{$seq_type}));

	    ## perm_sep
=pod

=item B<-perm_sep>

Calculate the distributions for each permuted matrix separately. This
provides an estimate of the variability between permutations, but the
resulting graph is less readable, because of the multiplicity of
curves.

=cut
	} elsif ($arg eq "-perm_sep") {
	  $main::perm_separate_distrib = 1;

	    ## Sequence format
=pod

=item B<-seq_format sequence_format>

Sequence format. 

=cut
	} elsif ($arg eq "-seq_format") {
	    $seq_format = shift(@arguments);

	    ## Pseudo weight
=pod

=item B<-pseudo pseudo_counts>

Pseudo-weight.

=cut
	} elsif ($arg eq "-pseudo") {
	    $main::pseudo_counts = shift(@arguments);
	    &RSAT::error::FatalError(join("\t", $main::pseudo_counts, 
					  "Invalid value for a pseudo-weight. Must be a positive real number."))
		unless ((&RSAT::util::IsReal($main::pseudo_counts) )
			&& ($main::pseudo_counts >= 0));


	    ## Output file
=pod

=item	B<-o output_prefix>

Prefix of the output files. The program generates various files, and
automatically adds a specific suffix to each output file.

=over

=item I<pos_scores>

Scores of the positive sequence set. 

=back

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{prefix} = shift(@arguments);

	    ## Options for the distribution curves
=pod

=item B<-graph_option 'option1 options2 ...'>

Specify options that will be passed to the program XYgraph for
generating the distribution curves. Beware: if an option requires to
be followed by a value (ex -xsize 1000), you have to embrace the
option and its value in quotes.

  Example
   -graph_option '-size 800 -title "LexA matrix" -bg blue'

This option can be used iteratively on a command line.

  Example
   -graph_option '-xsize 1000' -graph_option '-title "LexA matrix"'

=cut
	} elsif ($arg eq "-graph_option") {
	  $graph_options .= " ".shift @arguments;

	  ## Reference distribution for the ROC curve
=pod

=item B<-roc_ref>

Reference distribution for the ROC curve.

=cut
	} elsif ($arg eq "-roc_ref") {
	  $main::roc_ref = shift(@arguments);



	    ## Options for the ROC curves
=pod

=item B<-roc_option 'option1 options2 ...'>

Specify options that will be passed to the program XYgraph for
generating the ROC curves. Beware: if an option requires to
be followed by a value (ex -xsize 1000), you have to embrace the
option and its value in quotes.

  Example
   -roc_option '-gstep1 0.1 -gstep2 0.02'

This option can be used iteratively on a command line.

  Example
   -roc_option '-gstep1 0.1' -roc_option '-gstep2 0.02'

=cut
	} elsif ($arg eq "-roc_option") {
	  $main::roc_options .= " ".shift @arguments;


	    ## Image format
=pod

=item	B<-img_format>

Image format for the plots (ROC curve, score profiels, ...).

=cut
	} elsif ($arg eq "-img_format") {
	    $main::image_format = shift(@arguments);

	    ## Tasks
=pod

=item B<-return tasks>

List of tasks to perform. If this option is not specified, all the
tasks are performed. 

Note that some tasks depend on other ones. This option should thus be
used with caution, by experimented users only.

Supported fields:

=over

=item B<scan>

Scan sequences with matrix-scan

=back

=cut
       } elsif ($arg eq "-task") {
	 $arg = shift (@arguments);
	 chomp($arg);
	 my @tasks = split ",", $arg;
	 foreach my $task (@tasks) {
	   $task = lc($task);
	   if ($supported_tasks{$task}) {
	     $tasks{$task} = 1;
	   } else {
	     &RSAT::error::FatalError(join("\t", $task, "Invalid tasks. Supported:", $supported_tasks));
	   }
	 }

	    ## Other options
=pod

=item B<Other options>

All the other options are automatically passed to matrix-scan, in
order to specify the scanning parameters (strands, background model,
...).

Note that the option '-return' of matrix-scan cannot be used here,
because matrix-quality specifies the return fields required for its
statistics.

=cut

	} else {
	  push @matrix_scan_options, $arg;
	}
    }

=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::out "; matrix-quality ";
    &PrintArguments($main::out);
    if (defined(%main::infile)) {
	print $main::out "; Input files\n";
	foreach my $key (sort(keys %infile)) {
	  my $value = $infile{$key};
#	while (my ($key,$value) = each %main::infile) {
	    printf $main::out ";\t%-29s\t%s\n", $key , $value;
	}
    }
    if (defined(%main::seqfile)) {
	print $main::out "; Sequence files\n";
	foreach my $key (sort(keys %seqfile)) {
	  my $value = $seqfile{$key};
	    printf $main::out ";\t%-29s\t%s\n", $key , $value;
	}
    }
    if (defined(%main::outfile)) {
	print $main::out "; Output files\n";
	foreach my $key (sort(keys %outfile)) {
	  my $value = $outfile{$key};
	  printf $main::out ";\t%-29s\t%s\n", $key , $value;
	}
    }
    if (defined(%main::dir)) {
	print $main::out "; Directories\n";
	foreach my $key (sort(keys %dir)) {
	  my $value = $dir{$key};
	  printf $main::out ";\t%-29s\t%s\n", $key , $value;
	}
    }

    if (scalar(@seq_types) > 0) {
	print $main::out "; Matrix permutations per sequence type\n";
	foreach my $seq_type (@seq_types) {
	    unless (defined($perm_nb{$seq_type})) {
		$perm_nb{$seq_type} = 0;
	    }
	    printf $main::out ";\t%-21s\t%d\n", $seq_type , $perm_nb{$seq_type};
	}
    }
}


################################################################
## Export the sites which were use to build the matrix in a fasta file.
sub ExportInputSites {
  my ($matrix, $matrix_file) = @_;

  $main::outfile{matrix_sites} = $outfile{prefix}."_matrix_sites.fasta";
  $main::seqfile{matrix_sites} = $main::outfile{matrix_sites} if ($infile{matrix_sites});
  push @seq_types, "matrix_sites";
  &RSAT::message::TimeWarn("Exporting matrix sites to file", $outfile{matrix_sites}) 
    if ($main::verbose >= 1);
  my $site_handler = &OpenOutputFile($outfile{matrix_sites});
  my $site_nb = 0; 
  foreach my $site ($matrix->get_attribute("sequences")) {
    $site_nb++;
    my $site_id = $matrix->get_attribute("name");
    $site_id .= "_site_".$site_nb;
    &PrintNextSequence($site_handler, "fasta", 0, $site, $site_id);
  }

  ## Specific options for scanning matrix sites
  $scanopt{matrix_sites} = " -1str"; ## the sites from the matrix itself should be scanned only in the orientation where they were used to build the matrix
  $scanopt{matrix_sites} .= " -uth rank_pm 1"; ## Only the top score has to be taken for the matrix sites

#  ## This is apparently not used anymore ?
#  my $matrix_scan_cmd = "matrix-scan -v 1 ";
#  $matrix_scan_cmd .= " -top_matrices 1";
#  $matrix_scan_cmd .= " -decimals ".$decimals;
#  $matrix_scan_cmd .= " -pseudo ".$pseudo_counts;
#  $matrix_scan_cmd .= " -m ".$matrix_file;
}

################################################################
## LOO scoring of the sites Discard one site (the "left out"
## site), build a partial matrix with the remaining ones, and
## score the left out site with the partial matrix. Iterate this
## procedure over all sites.
sub LOO_scores {
  my ($matrix, @args) = @_;

  if ($main::verbose >= 1) {
    print $main::out "; LOO partial matrices\n";
  }

  $main::outfile{matrix_sites_loo} = $outfile{prefix}."_matrix_sites_loo.tab";
#  push @distrib_files, $main::outfile{matrix_sites_loo};

  &RSAT::message::TimeWarn("LOO scoring of the matrix sites",  $outfile{matrix_sites_loo})
    if ($main::verbose >= 1);
  $loo_scores_handle = &OpenOutputFile($main::outfile{matrix_sites_loo});

  my @sites = $matrix->get_attribute("sequences");


  my @partial_matrices = ();

  for my $i (0..$#sites) {
    ## Select the left out site
    my $lo_site_nb = $i+1;
    my $lo_site = $sites[$i];
    my $lo_site_id = $matrix->get_attribute("name");
    $lo_site_id .= "_site_".$lo_site_nb;

    ## Build a partial matrix with the other sites
    my $partial_matrix_name = $matrix->get_attribute("name");
    $partial_matrix_name .= "_leftout_".$lo_site_nb;


    my $partial_matrix = new RSAT::matrix();
    $partial_matrix->init();
    $partial_matrix->set_attribute("name", $partial_matrix_name);
    $partial_matrix->set_attribute("number", $lo_site_nb);
    $partial_matrix->set_attribute("ncol", length($lo_site));
    $partial_matrix->setAlphabet_lc(@alphabet);
    $partial_matrix->force_attribute("nrow", scalar(@alphabet)); ## Specify the number of rows of the matrix
    push @partial_matrices, $partial_matrix;
    for my $j (0..$#sites) {
      next if ($j == $i) ; ## Leave out the ith site
 	  if ($loo_rm_twin) {
 	  	next if ($sites[$j] eq $sites[$i]); ## exclude "twin" site : exclude sites identical to the ith leftout site
 	  }
      $partial_matrix->add_site(lc($sites[$j]));
    }
    $partial_matrix->treat_null_values();

    ## Save the partial matrix in a file
    my $partial_matrix_file = $outfile{prefix}."_partial_matrix_".$lo_site_nb.".tab";
    push @partial_matrix_files,  $partial_matrix_file;
    if ($main::verbose >= 1) {
		my @partial_matrix_sites = $partial_matrix->get_attribute("sequences");
		printf $main::out (";\t%s\t%d sites\t%s\n", 
				   $partial_matrix_name, 
				   scalar(@partial_matrix_sites), 
				   $partial_matrix_file);
    }

    &RSAT::message::Info("Exporting partial matrix to file", $partial_matrix_file) if ($main::verbose >= 3);
    $partial_matrix_handle = &OpenOutputFile($partial_matrix_file);
    $tmp_verbose = $verbose;
    $verbose = 0;
    print $partial_matrix_handle $partial_matrix->toString(sep=>"\t",
							   type=>"counts",
							   format=>"tab",
							  );
    $verbose = $tmp_verbose;
    close $partial_matrix_handle;

    ## Score the left out site with the partial matrix
    my $matrix_scan_cmd = "echo $lo_site | matrix-scan -v 1";
    $matrix_scan_cmd .= " -top_matrices 1";
    $matrix_scan_cmd .= " -seq_format raw";
    $matrix_scan_cmd .= " -m ".$partial_matrix_file;
    $matrix_scan_cmd .= " -matrix_format tab";
    $matrix_scan_cmd .= " -return distrib -1str -uth rank 1";
    $matrix_scan_cmd .= join(" ", "", @args);
    if ($i > 0) {
      $matrix_scan_cmd .= " | grep -v '^;'";
      $matrix_scan_cmd .= " | grep -v '^#'";
    }
    &RSAT::message::Info("LOO command",  ($i+1)."/".scalar(@sites), $matrix_scan_cmd) if ($main::verbose >= 2);
    my $score_result = `$matrix_scan_cmd`;
    print $loo_scores_handle $score_result;

  }
  close $loo_scores_handle;
}


################################################################
## Compute the score distribution in one sequence set
sub CalcSequenceDistrib {
  my ($sequence_file, $matrix_file, $matrix_format, $seq_type, @args) = @_;

  ## Define the output file fpor the current sequence type
  $main::outfile{$seq_type} = $outfile{prefix}."_scan_".$seq_type."_score_distrib.tab";  

  ## Scan the sequences if requested
  return unless  ($tasks{scan});

  ## Prepare the matrix-scan command
  &RSAT::message::TimeWarn("Scoring sequences of type", $seq_type,  $outfile{$seq_type}) 
    if ($main::verbose >= 1);
  my $matrix_scan_cmd = "matrix-scan -v 1 ";
  $matrix_scan_cmd .= " -top_matrices 1";
  $matrix_scan_cmd .= " -i ".$sequence_file;
  $matrix_scan_cmd .= " -m ".$matrix_file;
  $matrix_scan_cmd .= " -matrix_format ".$matrix_format;
  $matrix_scan_cmd .= " -return sites";
  $matrix_scan_cmd .= join(" ", "", @args);
  if (defined($main::scanopt{$seq_type})) {
      $matrix_scan_cmd .= " ".$main::scanopt{$seq_type};
  }

  ## Prepare the classfreq command (to extract the distribution from the scores)
  my $classfreq_min = sprintf("%.${decimals}f", $main::Wmin);
  $matrix_scan_cmd .= " | grep -v '^;' | grep -v '^#'";
  $matrix_scan_cmd .= " | cut -f 8";
  $matrix_scan_cmd .= " | classfreq -v 1 -ci 0.01";
  $matrix_scan_cmd .= " -min ".$classfreq_min;
  $matrix_scan_cmd .= " -o ".$outfile{$seq_type};

  ## Print the complete command in the log file
  print $main::out "; Scanning parameters for sequence type\t", $seq_type, "\n";
  print $main::out "; matrix-scan command\n";
  printf $main::out ";\t%-22s\t%s\n", "Sequence type", $seq_type;
  printf $main::out ";\t%-22s\t%s\n", "Sequence file", $sequence_file;
  if (defined($main::scanopt{$seq_type})) {
      printf $main::out ";\t%-22s\t%s\n", "Type-specific options", $scanopt{$seq_type};
  }
  printf $main::out ";%-22s\n%s\n", "Command:", $matrix_scan_cmd;
  print $main::out ";\n";


  ## Execute the command
  &doit($matrix_scan_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);

  ## Add the file to the list for the comparison of distributions
  push @main::distrib_files, $outfile{$seq_type}; $file_nb{$seq_type} = scalar(@distrib_files);

}


################################################################
## Score the sites which were use to build the matrix.
sub ScanSequences {
  my ($sequence_file, $matrix_file, $matrix_format, $seq_type, @args) = @_;

  ## Define the output file fpor the current sequence type
  $main::outfile{$seq_type} = $outfile{prefix}."_scan_".$seq_type."_distrib_matrixscan.tab";  

  ## Scan the sequences if requested
  return unless  ($tasks{scan});
  &RSAT::message::TimeWarn("Scoring sequences of type", $seq_type,  $outfile{$seq_type}) 
    if ($main::verbose >= 1);
  my $matrix_scan_cmd = "matrix-scan -v 1 ";
  $matrix_scan_cmd .= " -top_matrices 1";
  $matrix_scan_cmd .= " -i ".$sequence_file;
  $matrix_scan_cmd .= " -m ".$matrix_file;
  $matrix_scan_cmd .= " -matrix_format ".$matrix_format;
  $matrix_scan_cmd .= " -o ".$outfile{$seq_type};
  $matrix_scan_cmd .=  " -return distrib";
  $matrix_scan_cmd .= join(" ", "", @args);
  if (defined($main::scanopt{$seq_type})) {
      $matrix_scan_cmd .= " ".$main::scanopt{$seq_type};
  }

  ## Print the complete command in the log file
  print $main::out ";\n;matrix-scan command\n";
  printf $main::out ";\t%-22s\t%s\n", "Sequence type", $seq_type;
  printf $main::out ";\t%-22s\t%s\n", "Sequence file", $sequence_file;
  if (defined($main::scanopt{$seq_type})) {
      printf $main::out ";\t%-22s\t%s\n", "Type-specific options", $scanopt{$seq_type};
  }
  printf $main::out ";\t%-22s\t%s\n", "Command", $matrix_scan_cmd;

  ## Execute the command
  &doit($matrix_scan_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
}

################################################################
## Calculate the distribution of scores from a given matrix-scan result file
sub ScoreDistrib {
  my ($seq_type, $Wmin, $Wmax) = @_;

  $main::outfile{$seq_type."_distrib_tmp"} = $outfile{prefix}."_scan_".$seq_type."_distrib_tmp.tab";
  my $classfreq_min = sprintf("%.${decimals}f", $Wmin);
  &RSAT::message::TimeWarn("Calculating score distribution for sequences of type", $seq_type,  $outfile{${seq_type}."_distrib_tmp"}, $Wmin, $classfreq_min)
    if ($main::verbose >= 1);
  return unless ($outfile{$seq_type});
  my $reformat_cmd = "grep -v '^;' $outfile{$seq_type} | grep -v '^#' | cut -f 2,3 | sort -n > ".$outfile{${seq_type}."_distrib_tmp"};

  ## Execute the command
  &doit($reformat_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);

  ## From matrix-scan distribution : get occurence of each score, 
  ## recalculate the original list of scores and send it to classfreq
  ## to calculate the final distribution. This step enables to have the distribution
  ## over the whole range of theorical weights (necessary for plot) and permits to merge
  ## the results in case of several matrices sent to matrix-scan (permuted matrices)

  ## put the temporary distrib file in memory in an array
  my ($in_matrix_scan_distrib) = &OpenInputFile($outfile{${seq_type}."_distrib_tmp"});
  my @matrix_distrib = <$in_matrix_scan_distrib> ;
  close $in_matrix_scan_distrib;
  ## prepare the temporary score output
  $main::outfile{$seq_type."_distrib_score_tmp"} = $outfile{prefix}."_scan_".$seq_type."_distrib_score_tmp.tab";
  $distrib_score_handle = &OpenOutputFile($main::outfile{$seq_type."_distrib_score_tmp"});

  my @matrix_scan_scores = ();
  my @matrix_scan_occ = ();

  foreach my $line (0..$#matrix_distrib) {
    chomp ($matrix_distrib[$line]);
    my ($thisScore,$occ)  = split(/\s+/,$matrix_distrib[$line]);
    push (@matrix_scan_scores, $thisScore );
    push (@matrix_scan_occ, $occ);
  }
  undef @matrix_distrib;

  foreach my $scoreNb (1..$#matrix_scan_scores) {		
    if ($matrix_scan_scores[$scoreNb] != $matrix_scan_scores[$scoreNb-1]) {		
      for ($count = 1; $count <= $matrix_scan_occ[$scoreNb-1]; $count++) {
	print $distrib_score_handle $matrix_scan_scores[$scoreNb -1]."\n";
      }
    } else {
      $matrix_scan_occ[$scoreNb] = $matrix_scan_occ[$scoreNb] + $matrix_scan_occ[$scoreNb-1];
    }
			
    # last entry
    if ($scoreNb == $#matrix_scan_scores) {	
      for ($count = 1; $count <= $matrix_scan_occ[$scoreNb]; $count++) {
	print $distrib_score_handle $matrix_scan_scores[$scoreNb]."\n";
      }
    }		
  }
  close $distrib_score_handle;
	
  ## store temporary files for final removal
  push (@temporary_distrib_files,  $main::outfile{$seq_type."_distrib_score_tmp"});
  push (@temporary_distrib_files,  $main::outfile{$seq_type."_distrib_tmp"});
	
  ## prepare the complete distribution output
  $main::outfile{$seq_type."_distrib"} = $outfile{prefix}."_scan_".$seq_type."_distrib.tab";	
	
  my $classfreq_cmd = "classfreq -v 1 ";
  $classfreq_cmd .= " -i ".$main::outfile{$seq_type."_distrib_score_tmp"};
  $classfreq_cmd .= " -min ".$classfreq_min;
  $classfreq_cmd .= " -ci 0.01 ";
  $classfreq_cmd .= " -max ".$Wmax;
  $classfreq_cmd .= " -o ".$outfile{$seq_type."_distrib"};

  ## Execute the command
  &doit($classfreq_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  return ($outfile{$seq_type."_distrib"});
}


################################################################
## Export the matrix in tab-delimited format. This will be used
## for permuting the matrix.
sub ExportTabMatrix {
  my ($matrix) = @_;

  $outfile{matrix_tab} = $outfile{prefix}."_matrix.tab";
  &RSAT::message::TimeWarn("Exporting matrix in tab-delimited format",  $outfile{matrix_tab}) 
    if ($main::verbose >= 1);

  my $verbose_bk = $verbose;
  $verbose = 0;
  $matrix_handle = &OpenOutputFile($main::outfile{matrix_tab});
  print $matrix_handle $matrix->toString(sep=>"\t",
					 type=>"counts",
					 format=>"tab",
					 pipe=>"", ## We suppress the pipe for permute-table
					);
  close $matrix_handle;
  $verbose = $verbose_bk;
}


################################################################
## Export the matrix in tab-delimited format. This will be used
## for permuting the matrix.
sub PermuteMatrixColumns {
    &RSAT::message::TimeWarn("Permuting matrix columns", $perm_nb_max, "permutations")
      if ($main::verbose >= 1);

#   ## Single file regrouping all the permuted matrices for the positive set
#   $outfile{'positive_matrix_perm_col_all'} = $outfile{prefix}."_positive_matrix_perm_col_all_".$perm_nb{positive}.".tab";
#   my $init_matrix_cmd = "rm -f ".$outfile{'positive_matrix_perm_col_all'};
#   &doit($init_matrix_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);

#   ## Single file regrouping all the permuted matrices for the negative set
#   ## (the number of permuted matrices is not always the same as for the positive set)
#   $outfile{'negative_matrix_perm_col_all'} = $outfile{prefix}."_negative_matrix_perm_col_all_".$perm_nb{negative}.".tab";
#   $init_matrix_cmd = "rm -f ".$outfile{'negative_matrix_perm_col_all'};
#   &doit($init_matrix_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);

  ## Single file regrouping all the permuted matrices for each sequence type 
  foreach my $seq_type (sort keys %seqfile) {
   $outfile{$seq_type.'_matrix_perm_col_all'} = $outfile{prefix}."_".$seq_type."_matrix_perm_col_all_".$perm_nb{$seq_type}.".tab";
    $init_matrix_cmd = "rm -f ".$outfile{$seq_type.'_matrix_perm_col_all'};
    &doit($init_matrix_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  }

  for my $i (1..$perm_nb_max) {
    $outfile{'matrix_perm_col_'.$i} = $outfile{prefix}."_matrix_perm_col_".$i.".tab";
    my $permute_matrix_cmd = "permute-table -rownames -entire_col";
    $permute_matrix_cmd .= " -i ".$outfile{matrix_tab};
    $permute_matrix_cmd .= " -o ".$outfile{'matrix_perm_col_'.$i};

    ## Add the matrix to the list of permuted matrices for the different sequence sets
    foreach my $seq_type (sort keys %seqfile) {
      if ($i <= $perm_nb{$seq_type}) {
	$permute_matrix_cmd .= "; cat ".$outfile{'matrix_perm_col_'.$i}." >> ".$outfile{$seq_type.'_matrix_perm_col_all'};
	$permute_matrix_cmd .= "; echo '\/\/' >> ".$outfile{$seq_type.'_matrix_perm_col_all'} if ($i < $perm_nb{$seq_type});
      }
    }

#     ## Add the matrix to the list of permuted matrices for the positive set
#     if ($i <= $perm_nb{positive}) {
#       $permute_matrix_cmd .= "; cat ".$outfile{'matrix_perm_col_'.$i}." >> ".$outfile{'positive_matrix_perm_col_all'};
#       $permute_matrix_cmd .= "; echo '\/\/' >> ".$outfile{'positive_matrix_perm_col_all'} if ($i < $perm_nb{positive});
#     }

#     ## Add the matrix to the list of permuted matrices for the negative set
#     if ($i <= $perm_nb{negative}) {
#       $permute_matrix_cmd .= "; cat ".$outfile{'matrix_perm_col_'.$i}." >> ".$outfile{'negative_matrix_perm_col_all'};
#       $permute_matrix_cmd .= "; echo '\/\/' >> ".$outfile{'negative_matrix_perm_col_all'} if ($i < $perm_nb{negative});
#     }

    ## Execute the command
    &doit($permute_matrix_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);
  }
}


################################################################
## Compare the score distribution files
sub CompareDistrib {
  my ($score_column, @distrib_files) = @_;

  $outfile{distrib_compa} = $outfile{prefix}."_score_distrib_compa";
  &RSAT::message::TimeWarn("Comparing score distributions",  $outfile{distrib_compa}) 
    if ($main::verbose >= 1);

  ################################################################
  ## Compare the distributions
  my $distrib_compa_cmd = "compare-scores ";
  $distrib_compa_cmd .= " -numeric";
  $distrib_compa_cmd .= " -sc1 2"; # score column for the theoretical distribution
  $distrib_compa_cmd .= " -sc ".$score_column; # score column for the observed distributions
  $distrib_compa_cmd .= " -suppress ".$outfile{prefix}."_scan_";
  $distrib_compa_cmd .= " -suppress ".$outfile{prefix}."_";
  $distrib_compa_cmd .= " -suppress _score_distrib.tab";
  $distrib_compa_cmd .= " -o ".$outfile{distrib_compa}.".tab";
  $distrib_compa_cmd .= " -files ";
  $distrib_compa_cmd .= join(" ", $main::outfile{'theoretical_distrib'}, @distrib_files);
  &doit($distrib_compa_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);

  ################################################################
  ## Draw a graph with all the inverse cumulative distributions
  my $XYgraph_cmd = "XYgraph -xsize 800 -ysize 400";
  my $ycols = join ",", 2..(scalar(@distrib_files)+2);
  $XYgraph_cmd .= " -i ".$outfile{distrib_compa}.".tab";
  $XYgraph_cmd .= " -format ".$image_format." -lines -pointsize 1 -legend";
  $XYgraph_cmd .= " -title1 'matrix-quality ".$infile{matrix}."'";
  $XYgraph_cmd .= " -title2 ".$outfile{prefix};
  $XYgraph_cmd .= " -xcol 1 -ycol ".$ycols;
  $XYgraph_cmd .= " -xleg1 'matrix score' ";
  $XYgraph_cmd .= " -yleg1 'Frequency (inverse cumulative) ' ";
  $XYgraph_cmd .= " -ymin 0  -ymax 1 ";
  $XYgraph_cmd .= " -gp 'set size ratio 0.5' ";
  $XYgraph_cmd .= " ".$graph_options;
  $XYgraph_cmd .= " -o ".$outfile{distrib_compa}.".".$image_format;
  &doit($XYgraph_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);

  ################################################################
  ## Draw a graph with all the inverse cumulative distributions
  ## and a logarithmic Y axis
  $XYgraph_cmd = "XYgraph -xsize 800 -ysize 400";
  $XYgraph_cmd .= " -i ".$outfile{distrib_compa}.".tab";
  $XYgraph_cmd .= " -format ".$image_format." -lines -pointsize 1 -legend";
  $XYgraph_cmd .= " -title1 'matrix-quality ".$infile{matrix}."'";
  $XYgraph_cmd .= " -title2 ".$outfile{prefix};
  $XYgraph_cmd .= " -xcol 1 -ycol ".$ycols;
  $XYgraph_cmd .= " -xleg1 'matrix score' ";
  $XYgraph_cmd .= " -yleg1 'Frequency (inverse cumulative) ' ";
  $XYgraph_cmd .= " -ymax 1 -ylog 10";
  $XYgraph_cmd .= " -gp 'set size ratio 0.5' ";
  $XYgraph_cmd .= " ".$graph_options;
  $XYgraph_cmd .= " -o ".$outfile{distrib_compa}."_logy.".$image_format;
  &doit($XYgraph_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);

  ################################################################
  ## Draw a ROC curve
  my $ref_column = 2;
  if ($roc_ref) {
    if (defined($file_nb{$roc_ref})) {
      $ref_column = 2 + $file_nb{$roc_ref};
    } else {
      &RSAT::message::Warning($roc_ref, "Invalid reference distribution for the ROC curve: should be one of the input sequence types, or 'theor'");
    }
  }
  $XYgraph_cmd = "XYgraph -xsize 400 -ysize 400";
  $ycols = join ",", 2..(scalar(@distrib_files)+2);
  $XYgraph_cmd .= " -i ".$outfile{distrib_compa}.".tab";
  $XYgraph_cmd .= " -format ".$image_format." -lines -pointsize 1 -legend";
  $XYgraph_cmd .= " -title1 'matrix-quality: ROC curve' ";
#  $XYgraph_cmd .= " -title2 ".$outfile{prefix};
  $XYgraph_cmd .= " -xcol ".$ref_column;
  $XYgraph_cmd .= " -ycol ".$ycols;
  $XYgraph_cmd .= " -xleg1 'Reference set : ".$roc_ref."' ";
  $XYgraph_cmd .= " -yleg1 'other distributions' ";
  $XYgraph_cmd .= " -ymin 0  -ymax 1 ";
  $XYgraph_cmd .= " -xmin 0  -xmax 1 ";
  $XYgraph_cmd .= " ".$roc_options;
  $XYgraph_cmd .= " -o ".$outfile{distrib_compa}."_roc.".$image_format;
  &doit($XYgraph_cmd, $dry, $die_on_error, $verbose, $batch, $job_prefix);

}


################################################################
## Calculate score distribution
sub PrintTheorScoreDistribution {
  my ($matrix) = @_;

  $main::outfile{'theoretical_distrib'} = $main::outfile{prefix}."_theor_score_distrib.tab";
  my $wd = &OpenOutputFile($main::outfile{'theoretical_distrib'});

#  my %weight_proba = $matrix->getTheorScoreDistrib("weights");
#  my %weight_proba_cum = $matrix->getTheorScoreDistrib("weights", "cum");
  my %weight_proba_inv_cum = $matrix->getTheorScoreDistrib("weights", "inv_cum");

  foreach my $weight (sort {$a <=> $b} keys (%weight_proba_inv_cum)) {
    print $wd join("\t", $weight, 
#		   $weight_proba{$weight},
#		   $weight_proba_cum{$weight},
		   $weight_proba_inv_cum{$weight},
		  ), "\n";
  }
  close $wd;

#  push @distrib_files, ;

}


__END__

=pod

=head1 SEE ALSO

=over

=item B<matrix-scan>

=item B<convert-matrix>

=back

=cut
