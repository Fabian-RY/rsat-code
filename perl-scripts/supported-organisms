#!/usr/bin/perl
if ($0 =~ /([^(\/)]+)$/) {
    push (@INC, "$`lib/");
}
require "RSA.lib";
#use strict;

$out_format = "text";

@formats = qw (html_list html_table array text keys names sizes full tree);
foreach $f (@formats) {
    $supported_format{$f} = 1;
}
$formats = join ",", @formats;

&ReadArguments();

if ($out_format eq "tree") {
    &SupportedOrganismTree();
} else {
    print &ListSupportedOrganisms($out_format);
}

exit(0);

################################################################
##################### SUBROUTINE DEFINITION ####################
################################################################

################################################################
##  Export the taxonomy of supported organisms in a tree (nexus)
##  format
sub SupportedOrganismTree {
    use Bio::TreeIO;

    my %nodes = (); # node index

    ## Create a tree with the taxonomy
    my $tree = new Bio::Tree::Tree();

    ## Initiate the root of the taxonomy
    my $root_node = new Bio::Tree::Node(-id=>"organism", -description=>"organism");
    $nodes{organism} = $root_node;
    $tree->set_root_node($root_node);

    ## Iterate over all supported organisms
    my $org_counter = 0;
    foreach my $org (keys %supported_organism) {
	$org_counter++;
#	last if ($org_counter > 2);

	my $org_node = new Bio::Tree::Node(-id=>$org, -description=>$org);
	$nodes{$org} = $org_node; # index the new node
	my $taxonomy = $supported_organism{$org}->{taxonomy};

	## Replace prolematic characters by _
	$taxonomy =~ s|/|_|g; ## / are reserved in phylip format
	$taxonomy =~ s| |_|g; ## 
	$taxonomy =~ s|\(|_|g; ## / are reserved in phylip format
	$taxonomy =~ s|\)|_|g; ## / are reserved in phylip format

	my @taxonomy = split /\s*;\s*/, $taxonomy;

	warn join ("\t", ";", $org_counter, $org, $taxonomy), "\n" if ($main::verbose >= 3);
	
	## Initiate child to the level of the organism
	my $child = $org;
	$child_node = $org_node; 
	
	## traverse the taxonomy bottom->up
	for my $tr (0..$#taxonomy) {
	    my $t = $#taxonomy -$tr;
	    my $parent = $taxonomy[$t];
	    if (defined $nodes{$parent}) {
		$nodes{$parent}->add_Descendent($child_node);
		warn join("\t", ";\t", "parent found", $t, $parent, $nodes{$parent}), "\n" if ($main::verbose >= 4);
		$child_node = $nodes{$parent};
		last;
	    } else {
		$parent_node = new Bio::Tree::Node(-id=>$parent, -description=>$parent);
		$nodes{$parent} = $parent_node;
		$nodes{$parent}->add_Descendent($child_node);
		warn join("\t", ";\t", 
			  "new parent", $t, $parent, 
#			  $nodes{$parent}, 
			  "child", $child_node->id(), 
#			  $child_node,
			 ), "\n" if ($main::verbose >= 4);

		$child_node = $nodes{$parent};


		## Attach the top node to the root
		if ($t == 0) {
		    $root_node->add_Descendent($child_node);
		}
	    }
	}
#	$tree->add_Descendent($org_node);
    }
    
    my $out_tree = new Bio::TreeIO(-format => 'newick');
    $out_tree->write_tree($tree)
}

################################################################
#### Display full help message
sub PrintHelp {
  open HELP, "| more";
  print HELP <<End_of_help;
NAME
	supported-organisms

        2002 by Jacques van Helden (jvanheld\@scmbb.ulb.ac.be)
	
USAGE
        supported-organisms [-i inputfile] [-o outputfile] [-v]

DESCRIPTION
	Returns the list of organisms supported on this site of
	rsa-tools.

CATEGORY
	genomics
	administration

OPTIONS
	-h	(must be first argument) display full help message
	-help	(must be first argument) display options
	-format	output format
		supported: $formats
End_of_help
  close HELP;
  exit;
}

################################################################
#### Display short help message #####
sub PrintOptions {
  open HELP, "| more";
  print HELP <<End_short_help;
template options
----------------
-h	(must be first argument) display full help message
-help	(must be first argument) display options
-i	input file
-o	output file
-v	verbose
-format	output format ($formats)
End_short_help
  close HELP;
  exit;
}


################################################################
#### Read arguments 
sub ReadArguments {
    foreach my $a (0..$#ARGV) {
	### verbose ###
	if ($ARGV[$a] eq "-v") {
	    if (&IsNatural($ARGV[$a+1])) {
		$verbose = $ARGV[$a+1];
	    } else {
		$verbose = 1;
	    }
	    
	    ### detailed help
	} elsif ($ARGV[$a] eq "-h") {
	    &PrintHelp;
	    
	    ### list of options
	} elsif ($ARGV[0] eq "-help") {
	    &PrintOptions;
	    
	    ### input file ###
	} elsif ($ARGV[$a] eq "-format") {
	    $out_format = $ARGV[$a+1];
	    unless ($supported_format{$out_format}) {
		&FatalError("Format $out_format is not supported\n");
	    }
	    
	}
    }
}

