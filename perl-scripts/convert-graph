#!/usr/bin/perl -w
############################################################
#
# $Id: convert-graph,v 1.20 2007/06/13 11:48:32 rsat Exp $
#
# Time-stamp: <2003-07-04 12:48:55 jvanheld>
#
############################################################

## CVS: implemented the option -seed_nodes

## use strict;

=pod

=head1 NAME

convert-graph

=head1 DESCRIPTION

Convert graphs between diffferent formats. 

In the current state, the only supported input format are 
tab-delimited file and gml file. Various output format are already supported (dot,
gml, tab).

In the future, there should be as many input as output formats (the
program should perform interconversions between any supported format).


=head1 AUTHORS

jvanheld@scmbb.ulb.ac.be
sylvain@scmbb.ulb.ac.be

=head1 CATEGORY

util



=head1 USAGE
    
convert-graph [-i inputfile] [-o outputfile] [-from tab|gml] [-to format tab|dot|gml]  [-arc_id] [-v #]

=head1 INPUT FORMAT

=head1 OUTPUT FORMAT

=cut


BEGIN {
    if ($0 =~ /([^(\/)]+)$/) {
	push (@INC, "$`lib/");
    }
}
require "RSA.lib";
require RSAT::Graph2;


################################################################
## Main package
package main;
{

    ################################################################
    #### initialise parameters
    my $start_time = &AlphaDate();

    %main::infile = ();
    %main::outfile = ();

    $main::verbose = 0;
#    $main::in = STDIN;
    $main::out  = STDOUT;
    
    ## arc_id_option
    $arc_id_option = 0;

    ## Input formats
    local $input_format = "tab";
    %supported_input_format =(
	tab=>1,
	gml=>1
    );
    $supported_input_formats = join (",", keys %supported_input_format);
    local $source_col = 1;
    local $target_col = 2;
    local $weight_col = 0;
    local $source_color_col = 0;
    local $target_color_col = 0;
    local $color_col = 0;

    ## Output formats
    local $output_format = "dot";
    %supported_output_format =(
			       dot=>1,
			       gml=>1,
			       tab=>1
			       
    );
    $supported_output_formats = join (",", keys %supported_output_format);

    
    &ReadArguments();

    ################################################################
    #### check argument values

    ################################################################
    ## Initialize the graph
    my $graph = new RSAT::Graph2();
    $graph->set_attribute("label", "graph");

    ################################################################
    ## Read the seed nodes
    if ($infile{seed_nodes}) {
      my @seed_nodes = ();
      &RSAT::message::TimeWarn("Loading seed nodes from file", $main::infile{seed_nodes}) if ($main::verbose >= 2);
      ($seed_handle) = &OpenInputFile($main::infile{seed_nodes});
      my $l = 0;
      while (<$seed_handle>) {
	$l++;
	next if (/^;/); ## Skip comment lines
	next if (/^#/); ## Skip header lines
	next unless (/\S/); ## Skip empty lines
	chomp();
	my ($id) = split /\s+/;
	if ($id) {
	  push @seed_nodes, $id;
	} else {
	  &RSAT::message::Warning("File", $infile{clusters}, "Line", $l, "starts with spaces. Skipped");
	}
      }
      close $seed_handle;
      &RSAT::message::TimeWarn("Seed nodes loaded", scalar(@seed_nodes)) if ($main::verbose >= 2);
      $graph->set_seed_nodes(@seed_nodes);
      &RSAT::message::Debug("SEED NODES", join " ", @seed_nodes) if ($main::verbose >= 4);
    }

    ################################################################
    ##### read input
    $graph->graph_from_text($input_format, $main::infile{input}, $source_col, $target_col, $weight_col, $source_color_col, $target_color_col,$color_col);

    ################################################################
    ###### print output
    ### open output streams
    $main::out = &OpenOutputFile($main::outfile{output});
    if ($output_format eq "tab") {
      $main::verbose_out = $main::out;
    } else {
      $main::verbose_out = STDOUT;
    }
    #### print verbose
    &Verbose() if ($main::verbose);
    print $out $graph->to_text($output_format, $arc_id_option);

    ################################################################
    ###### finish verbose
    if ($main::verbose >= 1) {
	my $done_time = &AlphaDate();
	print $main::verbose_out "; Job started $start_time\n";
	print $main::verbose_out "; Job done    $done_time\n";
    }

    ################################################################
    ###### close output stream
    close $main::out if ($main::outfile{output});

    exit(0);
}

################################################################
################### subroutine definition ######################
################################################################


################################################################
#### display full help message 
sub PrintHelp {
    system "pod2text -c $0";
    exit()
}

################################################################
#### display short help message
sub PrintOptions {
    &PrintHelp();
}

################################################################
#### Read arguments 
sub ReadArguments {
#    foreach my $a (0..$#ARGV) {
    my $arg = "";
    
    my @arguments = @ARGV; ## create a copy to shift, because we need ARGV to report command line in &Verbose()
    

    while ($arg = shift (@arguments)) {

	## Verbosity
=pod
	    

=head1 OPTIONS

=over 4

=item B<-v #>

Level of verbosity (detail in the warning messages during execution)

=cut
	if ($arg eq "-v") {
	    if (&IsNatural($arguments[0])) {
		$main::verbose = shift(@arguments);
	    } else {
		$main::verbose = 1;
	    }
	    
	    ## Help message
=pod

=item B<-h>

Display full help message

=cut
	} elsif ($arg eq "-h") {
	    &PrintHelp();
	    
	    ## List of options
=pod

=item B<-help>

Same as -h

=cut
	} elsif ($arg eq "-help") {
	    &PrintOptions();

	    
=pod
	    ## Input file
=pod

=item B<-i inputfile>

If no input file is specified, the standard input is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-i") {
	    $main::infile{input} = shift(@arguments);
	    
	    ## Output file
=pod

=item	B<-o outputfile>

If no output file is specified, the standard output is used.  This
allows to use the command within a pipe.

=cut
	} elsif ($arg eq "-o") {
	    $main::outfile{output} = shift(@arguments);
	    
	    ### Input format  
=pod

=item B<-from input_format>

Input format. Supported: tab, gml

=cut
	} elsif ($arg eq "-from") {
	    $input_format = shift(@arguments);
	    &RSAT::error::FatalError("$input_format\tInvalid input format. Supported: $supported_input_formats")
		unless ($supported_input_format{$input_format});


	    ### Output format  
=cut

=item B<-to output_format>

Output format. Supported: tab, dot, gml

=cut 
	} elsif ($arg eq "-to") {
	    $output_format = shift(@arguments);
	    &RSAT::error::FatalError("$output_format\tInvalid output format. Supported: $supported_output_formats")
		unless ($supported_output_format{$output_format});


	    ## Source column
=pod

=item B<-scol>

Source column. Column containing the source nodes. (default 1)

=cut
	} elsif ($arg eq "-scol") {
	    $source_col = shift (@arguments);
	    unless (&IsNatural($source_col) && ($source_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_col, "Invalid value for the source column. Must be a strictly positive natural number"));
	    }

	    ## Target column
=pod

=item B<-tcol>

Target column. Column containing the target nodes. (default 2)

=cut
	} elsif ($arg eq "-tcol") {
	    $target_col = shift (@arguments);
	    unless (&IsNatural($target_col) && ($target_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_col, "Invalid value for the target column. Must be a strictly positive natural number"));
	    }

	    ## Weight column
=pod

=item B<-wcol>

Weight column. Column containing the weight nodes. (no default)

=cut
	} elsif ($arg eq "-wcol") {
	    $weight_col = shift (@arguments);
	    unless (&IsNatural($weight_col) && ($weight_col > 0)) {
		&RSAT::error::FatalError(join("\t", $weight_col, "Invalid value for the weight column. Must be a strictly positive natural number"));
	    }
=pod

=item B<-eccol>

Edge color column. Column containing the color of the edges (RGB). (no default)

=cut
	} elsif ($arg eq "-eccol") {
	    $color_col = shift (@arguments);
	    unless (&IsNatural($color_col) && ($color_col > 0)) {
		&RSAT::error::FatalError(join("\t", $color_col, "Invalid value for the color column. Must be a strictly positive natural number"));
	    }
=pod

=item B<-sccol>

Source node color colum. Column containing the color of the node (RGB). (no default)

A node can only have one color. If in the file, the color of the node changes, only the first defined color 
will be taken into account.

=cut
	} elsif ($arg eq "-sccol") {
	    $source_color_col = shift (@arguments);
	    unless (&IsNatural($source_color_col) && ($source_color_col > 0)) {
		&RSAT::error::FatalError(join("\t", $source_color_col, "Invalid value for the color column. Must be a strictly positive natural number"));
	    }
=pod

=item B<-tccol>

Target node color colum. Column containing the color of the node (RGB). (no default)

A node can only have one color. If in the file, the color of the node changes, only the first defined color 
will be taken into account.

=cut
	} elsif ($arg eq "-tccol") {
	    $target_color_col = shift (@arguments);
	    unless (&IsNatural($target_color_col) && ($target_color_col > 0)) {
		&RSAT::error::FatalError(join("\t", $target_color_col, "Invalid value for the color column. Must be a strictly positive natural number"));
	    }	    

=pod

=item B<-arc_id>

Add a unique ID for each arc when using the tab-delimited output.

=cut
	} elsif ($arg eq "-arc_id") {
	    $arc_id_option = 1;

=pod

=item B<-seed_nodes seed_node_file>

This option is currently implemented only for input format "tab".

Select a subgraph induced by a set of seed nodes. When this option is
used, the program only reads arcs whose ends (source and target) are
both members of the seed node set.

Seed nodes are specified in a text file. The first word of each row is
considered as an identifier for a seed node.

=cut

	} elsif ($arg eq "-seed_nodes") {
	    $main::infile{seed_nodes} = shift(@arguments);


	} else {
	    &FatalError(join("\t", "Invalid option", $arg));

	}
    }


=pod

=back

=cut

}

################################################################
#### verbose message
sub Verbose {
    print $main::verbose_out "; convert-graph ";
    &PrintArguments($main::verbose_out);
    if (defined(%main::infile)) {
	print $main::verbose_out "; Input files\n";
	while (my ($key,$value) = each %main::infile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
    if (defined(%main::outfile)) {
	print $main::verbose_out "; Output files\n";
	while (my ($key,$value) = each %main::outfile) {
	    print $main::verbose_out ";\t$key\t$value\n";
	}
    }
}


__END__

=pod

=head1 SEE ALSO

=item I<compare-graphs>

=item I<compare-graph-clusters>

=item I<convert-graph>

=item I<graph-get-clusters>

=item I<graph-neighbours>

=item I<graph-node-degree>

=item I<graph-set-attributes>

=cut
